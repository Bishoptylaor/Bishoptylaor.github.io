<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leet121</title>
      <link href="/uncategorized/leet121/"/>
      <url>/uncategorized/leet121/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leet217</title>
      <link href="/uncategorized/leet217/"/>
      <url>/uncategorized/leet217/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leet238</title>
      <link href="/uncategorized/leet238/"/>
      <url>/uncategorized/leet238/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leet53</title>
      <link href="/uncategorized/leet53/"/>
      <url>/uncategorized/leet53/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leet152</title>
      <link href="/uncategorized/leet152/"/>
      <url>/uncategorized/leet152/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leet153</title>
      <link href="/uncategorized/leet153/"/>
      <url>/uncategorized/leet153/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leet33</title>
      <link href="/uncategorized/leet33/"/>
      <url>/uncategorized/leet33/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.15 三数之和</title>
      <link href="/uncategorized/leet15/"/>
      <url>/uncategorized/leet15/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/3sum/description/">Leetcode.15 三数之和</a></p><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。</code></pre><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><p>流程可以参考 <a href="https://leetcode.cn/problems/two-sum/">两数之和</a> 和 <a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/">两数之和 II</a></p><p>设置 a，b，c 三个指针，首先固定 a 指针，可以确定当前目标求和为 - nums[a]<br>在 a 指针后续的位置设置 b 指针，通过 c 指针遍历 b 后面的位置，确定符合的三元组<br>c 指针遍历一轮之后，可以将 b 指针向后移动，直到当前从 a 指针出发的所有三元组都被找到<br>然后再移动 a 指针</p><p>比较关键的点是，结果中的三元组不能重复，那么我们可以通过先排序的方法，在求解过程中提前将重复结果过滤掉</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123; </span><br><span class="line">n := <span class="built_in">len</span>(nums) </span><br><span class="line">sort.Ints(nums) </span><br><span class="line">ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举 a </span></span><br><span class="line"><span class="keyword">for</span> first := <span class="number">0</span>; first &lt; n; first++ &#123; </span><br><span class="line"><span class="comment">// 需要和上一次枚举的数不相同 </span></span><br><span class="line"><span class="keyword">if</span> first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>] &#123; </span><br><span class="line"><span class="keyword">continue</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// c 对应的指针初始指向数组的最右端 </span></span><br><span class="line">third := n - <span class="number">1</span> </span><br><span class="line">target := <span class="number">-1</span> * nums[first] </span><br><span class="line"><span class="comment">// 枚举 b </span></span><br><span class="line"><span class="keyword">for</span> second := first + <span class="number">1</span>; second &lt; n; second++ &#123; </span><br><span class="line"><span class="comment">// 需要和上一次枚举的数不相同 </span></span><br><span class="line"><span class="keyword">if</span> second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>] &#123; </span><br><span class="line"><span class="keyword">continue</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 需要保证 b 的指针在 c 的指针的左侧 </span></span><br><span class="line"><span class="keyword">for</span> second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target &#123; </span><br><span class="line">third-- </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果指针重合，随着 b 后续的增加 </span></span><br><span class="line"><span class="comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环 </span></span><br><span class="line"><span class="keyword">if</span> second == third &#123; </span><br><span class="line"><span class="keyword">break</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> nums[second] + nums[third] == target &#123; </span><br><span class="line">ans = <span class="built_in">append</span>(ans, []<span class="type">int</span>&#123;nums[first], nums[second], nums[third]&#125;) </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> ans </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leet11</title>
      <link href="/uncategorized/leet11/"/>
      <url>/uncategorized/leet11/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.1 两数之和</title>
      <link href="/uncategorized/leet1/"/>
      <url>/uncategorized/leet1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/two-sum/description/">Leetcode.1 两数之和</a></p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [3,2,4], target = 6输出：[1,2]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [3,3], target = 6输出：[0,1]</code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go 八股</title>
      <link href="/uncategorized/go-EightPartFrame/"/>
      <url>/uncategorized/go-EightPartFrame/</url>
      
        <content type="html"><![CDATA[<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h5 id="golang-中原生的-map-本身是线程不安全的，主要表现在以下方面："><a href="#golang-中原生的-map-本身是线程不安全的，主要表现在以下方面：" class="headerlink" title="golang 中原生的 map 本身是线程不安全的，主要表现在以下方面："></a>golang 中原生的 map 本身是线程不安全的，主要表现在以下方面：</h5><ol><li>对于 map 结构的并发访问，会报错 panic。</li><li>即使通过某种方式不同时写一个 key，在 map 扩容的时候也会有问题，因为 map 的扩容是线程不安全的</li></ol><h5 id="sync-Map-相对-map-的优势："><a href="#sync-Map-相对-map-的优势：" class="headerlink" title="sync.Map 相对 map 的优势："></a>sync.Map 相对 map 的优势：</h5><ol><li>一写多读</li><li>空间换时间 &#x3D; read 和 dirty</li><li>double-checking</li><li>缓存思路</li><li>延时删除</li></ol><h5 id="关于-dirty-的提升"><a href="#关于-dirty-的提升" class="headerlink" title="关于 dirty 的提升"></a>关于 dirty 的提升</h5><p>Map 中维持了一个 int 类型的 <code>misses</code> 每当 Map 未命中 read 时，会将该值自增 1， 当该值大于 dirty 的长度后，dirty 就会被提升为 read，提升之后，dirty 和 misses 会被重置，等下一次插入新值时，会将 read 中未删除的数据复制到 dirty 中。<br>除此之外，执行 <code>Range</code> 时，也会先进行一次提升。</p><h5 id="关于延迟删除"><a href="#关于延迟删除" class="headerlink" title="关于延迟删除"></a>关于延迟删除</h5><p>当执行 <code>Delete</code> 时，如果 read 没有击中， 就会直接从 dirty 中删除，否则如果键值在 read 中，会先将其 Value 的指针（enter.p）标记为 nil, 等下一次执行复制时，这些被标记为 nil 的键值会被重新标记为 expunged，即 enter.p 有三种可能的值：</p><ol><li>nil: 表示 键值已经被删除，但这一版的 read 还没有被复制到 dirty 中，所以 dirty 此时为 nil, 遇到要重新插入这个key时，可以直接修改 read，之后进行复制时，这个最新的值会被同步回 dirty。</li><li>expunged: 表示该键值已经被删除并且经历了复制， dirty 不为 nil， 这时需要同时修改 read 和 dirty， 避免 read 的数据比 dirty 中的数据新，导致下一次提升时丢失新数据。</li><li><code>!= nil</code>: 表示存储的是具体的 value 的指针。</li></ol><p>sync.Map 具有以下结构和方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123; </span><br><span class="line">mu sync.Mutex <span class="comment">// 互斥锁</span></span><br><span class="line">read atomic.Value <span class="comment">// 原子化只读操作</span></span><br><span class="line">dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry <span class="comment">// 新增的 kv 会存储到这里</span></span><br><span class="line">misses <span class="type">int</span> <span class="comment">// 当 read 中查询失败时，misses+=1，当 miss 的数量超过 dirty 时，会触发将 dirty 转化到 read</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 Map 中取出一个 value </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Load(key <span class="keyword">interface</span>&#123;&#125;) (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>) &#123; </span><br><span class="line">read, _ := m.read.Load().(readOnly) </span><br><span class="line"><span class="comment">// 优先从 read 中读取</span></span><br><span class="line">e, ok := read.m[key] </span><br><span class="line"><span class="comment">// 当读不到且 amended = true 时，再互斥的从 dirty 中查找</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; </span><br><span class="line">m.mu.Lock() </span><br><span class="line"><span class="comment">// double-checking， 避免在加锁过程中有其他 goroutine 将 dirty 提升为 read 的情况</span></span><br><span class="line">read, _ = m.read.Load().(readOnly) e, ok = read.m[key] </span><br><span class="line"><span class="comment">// 双重查找后还找不到，再去 dirty 中查找，同时 misses += 1</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; </span><br><span class="line">e, ok = m.dirty[key] <span class="comment">// 修改 misses，尝试提升 dirty </span></span><br><span class="line">m.missLocked() </span><br><span class="line">&#125; </span><br><span class="line">m.mu.Unlock()</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span> !ok &#123; <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span> &#125; </span><br><span class="line"><span class="comment">// 需要注意这里取到的是指向真实 value 的指针，还需要读取出真正的 value</span></span><br><span class="line"><span class="keyword">return</span> e.load() </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> missLocked() &#123; </span><br><span class="line">m.misses++ </span><br><span class="line"><span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 将 dirty 提升为 read </span></span><br><span class="line">m.read.Store(readOnly&#123;m: m.dirty&#125;) </span><br><span class="line"><span class="comment">// 重置相关字段 </span></span><br><span class="line">m.dirty = <span class="literal">nil</span> </span><br><span class="line">m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 Map 中 存入一个 KV 对 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line"><span class="comment">// 优先从 read 中读取</span></span><br><span class="line"><span class="comment">// 如果 read 中找到了，利用 entry 的 tryStore 方法更新 value</span></span><br><span class="line">read, _ := m.read.Load().(readOnly) </span><br><span class="line"><span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁， 二次检查</span></span><br><span class="line">m.mu.Lock() </span><br><span class="line">read, _ = m.read.Load().(readOnly) </span><br><span class="line"><span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line"><span class="comment">// 当对已经存在于 `read` 中的键值对执行删除操作时，而是会把其暂时标记为 `nil`,</span></span><br><span class="line"><span class="comment">// 等 dirty 升级为 read 后再插入新值时会把 read 中标记为 `nil` 的值标记为 `expunged`, </span></span><br><span class="line"><span class="comment">// 而其他的值会被重新复制到 dirty 中，当这时插入刚被删除的键后，就会直接把之前标记为 `expunged` 的键的值赋为新值</span></span><br><span class="line"><span class="keyword">if</span> e.unexpungeLocked() &#123; </span><br><span class="line">m.dirty[key] = e </span><br><span class="line">&#125; </span><br><span class="line">e.storeLocked(&amp;value) </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line"><span class="comment">// 如果 dirty 中找到了，通过 storeLocked 修改 dirty 中的 entry</span></span><br><span class="line">e.storeLocked(&amp;value) </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="comment">// dirty 中也没有，那么就直接插入到 dirty 中</span></span><br><span class="line"><span class="keyword">if</span> !read.amended &#123; </span><br><span class="line"><span class="comment">// 此时如果 amended == false，对应两种情况</span></span><br><span class="line"><span class="comment">// 1. 第一次插入数据，read 和 dirty 都为空，此时需要对 read 进行初始化</span></span><br><span class="line"><span class="comment">// 2. 之前的 dirty 刚刚升级成为 read，此时 dirty 为空，需要将之前有可能存在的已标记删除的进行惰性删除</span></span><br><span class="line">m.dirtyLocked() </span><br><span class="line">m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;) </span><br><span class="line">&#125; </span><br><span class="line">m.dirty[key] = newEntry(value) </span><br><span class="line">&#125; </span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 Map 中存在 key,覆盖并返回 (旧值, true), 否则返回 (新值, false) </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadOrStore(key, value <span class="keyword">interface</span>&#123;&#125;) (actual <span class="keyword">interface</span>&#123;&#125;, loaded <span class="type">bool</span>) </span><br><span class="line"><span class="comment">// 从 Map 中删除一个 KV 对 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line"><span class="comment">// 二次检查 read</span></span><br><span class="line">read, _ := m.read.Load().(readOnly) </span><br><span class="line">e, ok := read.m[key] </span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; </span><br><span class="line">m.mu.Lock() </span><br><span class="line">read, _ = m.read.Load().(readOnly) </span><br><span class="line">e, ok = read.m[key] </span><br><span class="line"><span class="comment">// 不存在，就从 dirty 中删除</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; </span><br><span class="line"><span class="built_in">delete</span>(m.dirty, key) </span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock() </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 存在的话就调用 entry 的 delete() 从 read 中删除</span></span><br><span class="line"><span class="keyword">if</span> ok &#123; e.<span class="built_in">delete</span>() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 Map 中的所有 KV 执行 f, 直到 f 返回 false </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>) &#123; </span><br><span class="line">read, _ := m.read.Load().(readOnly) </span><br><span class="line"><span class="keyword">if</span> read.amended &#123; </span><br><span class="line"><span class="comment">// double-checking</span></span><br><span class="line">m.mu.Lock() </span><br><span class="line">read, _ = m.read.Load().(readOnly) </span><br><span class="line"><span class="keyword">if</span> read.amended &#123; </span><br><span class="line"><span class="comment">// 提升 dirty</span></span><br><span class="line">read = readOnly&#123;m: m.dirty&#125; </span><br><span class="line">m.read.Store(read) </span><br><span class="line">m.dirty = <span class="literal">nil</span> </span><br><span class="line">m.misses = <span class="number">0</span> </span><br><span class="line">&#125; </span><br><span class="line">m.mu.Unlock() </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123; </span><br><span class="line">v, ok := e.load() </span><br><span class="line"><span class="keyword">if</span> !ok &#123; </span><br><span class="line"><span class="keyword">continue</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> !f(k, v) &#123; </span><br><span class="line"><span class="keyword">break</span> </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> dirtyLocked() &#123; </span><br><span class="line"><span class="comment">// 对应情况 1 </span></span><br><span class="line"><span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123; <span class="keyword">return</span> &#125; </span><br><span class="line"><span class="comment">// 情况 2 </span></span><br><span class="line">read, _ := m.read.Load().(readOnly) </span><br><span class="line">m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry, <span class="built_in">len</span>(read.m)) </span><br><span class="line"><span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line"><span class="comment">// 没有被删除，复制到 dirty 中 </span></span><br><span class="line"><span class="keyword">if</span> !e.tryExpungeLocked() &#123; m.dirty[k] = e &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123; </span><br><span class="line"><span class="comment">// m 和 dirty 中的 value 是同一块内存 </span></span><br><span class="line">m <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry </span><br><span class="line"><span class="comment">// 如果 dirty 和 read 中的数据不一致时，amended 为 true。若此时 read 中读不到，就要去 dirty 中查询</span></span><br><span class="line">amended <span class="type">bool</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read 和 dirty 中的 entry 指向的是同一地址，修改会同时生效；减少空间浪费</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">p unsafe.Pointer <span class="comment">// *interface&#123;&#125; </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> load() (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>) &#123; </span><br><span class="line">p := atomic.LoadPointer(&amp;e.p) </span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123; <span class="comment">// 由于 Map 的延时删除策略，出现这两种情况均代表 kv 已经不存在了</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> *(*<span class="keyword">interface</span>&#123;&#125;)(p), <span class="literal">true</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> <span class="built_in">delete</span>() (hadValue <span class="type">bool</span>) &#123; </span><br><span class="line"><span class="comment">// 这里不是真的删除嗷，只是将对应 value 的 p 指向了 nil。直到下一次 dirty 升级时才会真正的删除，aka Map 的延时删除策略</span></span><br><span class="line"><span class="keyword">for</span> &#123; p := atomic.LoadPointer(&amp;e.p) </span><br><span class="line"><span class="comment">// 不存在或被删除</span></span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125; </span><br><span class="line"><span class="comment">// CAS 将 enter.p 指向 nil </span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryStore(i *<span class="keyword">interface</span>&#123;&#125;) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123; </span><br><span class="line">p := atomic.LoadPointer(&amp;e.p) <span class="comment">// 被删除 </span></span><br><span class="line"><span class="keyword">if</span> p == expunged &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125; <span class="comment">// 比较 e.p 与 p, 相等赋新值，否则自旋比较 </span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> storeLocked(i *<span class="keyword">interface</span>&#123;&#125;) &#123; </span><br><span class="line">atomic.StorePointer(&amp;e.p, unsafe.Pointer(i)) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用来判断 `entry` 是否被删除，当 `entry.p == nil` 时，说明这个 value 被标记为删除，这时会把它重新标记为 `expunged` 返回 true， 否则返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryExpungeLocked() (isExpunged <span class="type">bool</span>) &#123; </span><br><span class="line">p := atomic.LoadPointer(&amp;e.p) </span><br><span class="line"><span class="keyword">for</span> p == <span class="literal">nil</span> &#123; </span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, <span class="literal">nil</span>, expunged) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">&#125; </span><br><span class="line">p = atomic.LoadPointer(&amp;e.p) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> p == expunged </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>比较常见的问题是 slice 和普通 array 的区别：array 是值类型；slice 是引用类型，指向底层的数组地址<br>子切片：引用的底层数组是一致的，但是 slice 本身对应的内存地址不一致；当子切片长度超过原切片的时候，会产生扩容，替换掉原来的底层数组</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><ol><li>Channel本质上是由三个FIFO（First In FirstOut，先进先出）队列组成的用于协程之间传输数据的协程安全的通道；FIFO的设计是为了保障公平，让事情变得简单，原则是让等待时间最长的协程最有资格先从channel发送或接收数据；</li><li>三个FIFO队列依次是buf循环队列，sendq待发送者队列，recvq待接收者队列。buf循环队列是大小固定的用来存放channel接收的数据的队列；sendq待发送者队列，用来存放等待发送数据到channel的goroutine的双向链表，recvq待接收者队列，用来存放等待从channel读取数据的goroutine的双向链表；sendq和recvq可以认为不限大小；</li><li>跟函数调用传参本质都是传值一样，channel传递数据的本质就是值拷贝，引用类型数据的传递也是地址拷贝；有从缓冲区buf地址拷贝数据到接收者receiver栈内存地址，也有从发送者sender栈内存地址拷贝数据到缓冲区buf；</li><li>Channel里面参数的修改不是并发安全的，包括对三个队列及其他参数的访问，因此需要加锁，本质上，channel就是一个有锁队列；</li><li>Channel 的性能跟 sync.Mutex 差不多，没有谁比谁强。Go官方之所以推荐使用Channel进行并发协程的数据交互，是因为channel的设计理念能让程序变得简单，在大型程序、高并发复杂的运行状况中也是如此。</li></ol><p>关注下方代码 <code>makechan</code> 中 <code>switch-case</code> 相关语句，可以发现当存储在 buf 中的元素不包含指针时，hchan 中也不包含 GC 关心的指针。buf 指向一段相同元素类型的内存，elemtype 固定不变。受到垃圾回收器的限制，指针类型的缓冲 buf 需要单独分配内存。<br>channel 本身是引用类型，其创建全部调用的是 mallocgc()，在<em>堆</em>上开辟的内存空间，说明 channel 本身会被 GC 自动回收。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123; </span><br><span class="line">qcount <span class="type">uint</span> <span class="comment">// 队列中所有数据总数 </span></span><br><span class="line">dataqsiz <span class="type">uint</span> <span class="comment">// 循环队列大小 </span></span><br><span class="line">buf unsafe.Pointer <span class="comment">// 指向循环队列的指针 </span></span><br><span class="line">elemsize <span class="type">uint16</span> <span class="comment">// 循环队列中元素的大小 </span></span><br><span class="line">closed <span class="type">uint32</span> <span class="comment">// chan是否关闭的标识 </span></span><br><span class="line">elemtype *_type <span class="comment">// 循环队列中元素的类型 </span></span><br><span class="line">sendx <span class="type">uint</span> <span class="comment">// 已发送元素在循环队列中的位置 </span></span><br><span class="line">recvx <span class="type">uint</span> <span class="comment">// 已接收元素在循环队列中的位置 </span></span><br><span class="line">recvq waitq <span class="comment">// 等待接收的goroutine的等待队列 </span></span><br><span class="line">sendq waitq <span class="comment">// 等待发送的goroutine的等待队列 </span></span><br><span class="line">lock mutex <span class="comment">// 控制chan并发访问的互斥锁 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123; </span><br><span class="line">elem := t.elem </span><br><span class="line"><span class="comment">// 检查数据项大小不能超过 64KB </span></span><br><span class="line"><span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123; throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>) &#125; <span class="comment">// 检查内存对齐是否正确 </span></span><br><span class="line"><span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123; </span><br><span class="line">throw(<span class="string">&quot;makechan: bad alignment&quot;</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 缓冲区大小检查，判断是否溢出 </span></span><br><span class="line">mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size)) </span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123; </span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>)) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> c *hchan </span><br><span class="line"><span class="keyword">switch</span> &#123; </span><br><span class="line"><span class="comment">// 当队列或者元素大小为 0 时，调用 mallocgc() 在堆上为 channel 开辟一段大小为 hchanSize 的内存空间；</span></span><br><span class="line"><span class="keyword">case</span> mem == <span class="number">0</span>: </span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>)) </span><br><span class="line"><span class="comment">// 竞态检查，利用这个地址进行同步操作. </span></span><br><span class="line">c.buf = c.raceaddr() </span><br><span class="line"><span class="comment">// 当元素类型不是指针类型时，调用 mallocgc() 在堆上为 channel 和底层 buf 缓冲区数组开辟一段大小为 hchanSize + mem 连续的内存空间；</span></span><br><span class="line"><span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>: </span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>)) </span><br><span class="line"><span class="comment">// 表示hchan后面在内存里紧跟着就是buf环形队列 </span></span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize) </span><br><span class="line"><span class="comment">// 默认情况元素类型中有指针类型，调用 mallocgc() 在堆上分别为 channel 和 buf 缓冲区分配内存。</span></span><br><span class="line"><span class="keyword">default</span>:  </span><br><span class="line">c = <span class="built_in">new</span>(hchan) c.buf = mallocgc(mem, elem, <span class="literal">true</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 设置元素个数、元素类型给创建的chan </span></span><br><span class="line">c.elemsize = <span class="type">uint16</span>(elem.size) </span><br><span class="line">c.elemtype = elem </span><br><span class="line">c.dataqsiz = <span class="type">uint</span>(size) </span><br><span class="line">lockInit(&amp;c.lock, lockRankHchan) </span><br><span class="line"><span class="keyword">if</span> debugChan &#123; </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.size, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> c </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h5><ol><li>首先 select 非阻塞的发送，需要判断两种情况；</li><li>一般的阻塞调用，先判断 recvq 等待接收队列是否为空，如果不为空，那么说明缓冲区为空 or 无缓冲 Channel；</li><li>如果 recvq 有接收者，则属于缓冲区空，从 recvq 中取出一个 goroutine，然后写入数据，接着唤醒 goroutine，结束发送过程；</li><li>如果缓冲区有空位，写入数据到缓冲区，完成发送；</li><li>如果缓冲区满，将发送数据的 goroutine 放到 sendq 中，进入睡眠，等待唤醒。<h5 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h5></li><li>也是先判断select这种非阻塞接收的两种情况（block为false）；然后是加锁进行阻塞调用的逻辑；</li><li>同步接收：如果发送者队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出一个 goroutine，读取消息，唤醒该 goroutine，结束读取；</li><li>同步接收：如果发送者队列 sendq 不为空，有缓冲区，说明缓冲区已经满了，移动 recvx 指针的位置，取出一个数据，同时从 sendq 中取出一个 goroutine，拷贝里面的数据到 buf 中，结束读取；</li><li>异步接收：如果发送者队列 sendq 为空，且缓冲区有数据（有缓冲 channel），直接从缓冲区取出数据，结束读取；</li><li>阻塞接收：如果发送者队列 sendq 为空，且缓冲区无数据（无缓冲 channel），就将当前的 goroutine 加入 recvq，进入睡眠等待唤醒。</li></ol><h5 id="关闭-Chan"><a href="#关闭-Chan" class="headerlink" title="关闭 Chan"></a>关闭 Chan</h5><ol><li>判断 channel 当前状态，如果 channel &#x3D;&#x3D; nil || channel 已经关闭，会直接 panic；</li><li>关闭的主要工作是释放所有的接收者和发送者：先回收接收者，因为从一个关闭的 channel 中读数据，不会发生 panic，顶多读到一个默认零值。再回收发送者。注意这里可能会产生 panic，因为往一个关闭的 channel 中发送数据，会产生 panic。</li></ol><h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><h5 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h5><p>当一个 goroutine 持有锁时，后续的 goroutine 会以先进先出的方式排队等待，当锁被释放时，队列中第一个 goroutine 会被唤醒。但是它需要和新到来的 goroutine 争夺锁，由于新来的 goroutine 已经在 CPU 中，刚刚唤醒的大概率会竞争失败，重新被放到队首。这种情况有可能导致 goroutine 迟迟不能被执行而被“饿死”</p><h5 id="饥饿模式"><a href="#饥饿模式" class="headerlink" title="饥饿模式"></a>饥饿模式</h5><p>为了解决“饿死”的问题，如果一个等待的 goroutine 超过 1 ms (starvationThresholdNs) 没有得到锁，这个锁就会被转换为饥饿模式。饥饿模式下，锁会直接交给队列中的第一个 goroutine，而新来的 goroutine 会放到队尾等待。正常状态下的性能是高于饥饿模式的，所以在大部分情况下，还是应该回到正常模式去的。<br>当队列中最后一个 goroutine 被执行或者它的等待时间低于 1 ms 时，会将该锁的状态切换回正常模式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123; </span><br><span class="line"><span class="comment">// +---------------------------------+-----------+</span></span><br><span class="line"><span class="comment">// |        WaitersCount             |  status   | </span></span><br><span class="line"><span class="comment">// +---------------------------------+-----------+ </span></span><br><span class="line"><span class="comment">// &lt;-----------+ 29 +---------------&gt; &lt;--+ 3 +---&gt;</span></span><br><span class="line">state <span class="type">int32</span> <span class="comment">// 锁状态，其中低三位用来表示锁状态，高 29 位用来记录等待当前互斥锁的 goroutine 个数</span></span><br><span class="line">sema <span class="type">uint32</span> <span class="comment">// 控制锁状态的信号量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ( </span><br><span class="line">mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 0001 表示互斥锁处于锁定状态 </span></span><br><span class="line">mutexWoken <span class="comment">// 0010 表示从正常模式被唤醒 </span></span><br><span class="line">mutexStarving <span class="comment">// 0100 饥饿模式 </span></span><br><span class="line">mutexWaiterShift = <span class="literal">iota</span> <span class="comment">// 3 表示除 WaitersCount 外，状态占用了三个 bite </span></span><br><span class="line">starvationThresholdNs = <span class="number">1e6</span> <span class="comment">// 饥饿的阈值， 1ms </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h5><p>通过 CAS 判断 <code>m.state == 0</code> 时，意味着当前锁处于正常的解锁状态，只需要将锁设置为 <code>mutexLocked</code> 即可，否则就需要进入 <code>lockSlow</code> 通过自旋等方式等待锁释放。<code>lockslow</code> 大致分为以下几个部分：</p><ol><li>判断是否可以自旋：自旋需要满足两个条件：<ul><li>处于正常模式，且锁已经被锁定</li><li><code>runtime_canSpin</code> 返回 true:<ul><li>运行在多 CPU 的机器上；</li><li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li><li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li></ul></li></ul></li><li>一旦进入自旋，会通过 <code>runtime_doSpin</code> ,去执行 30 次的 <code>PAUSE</code> 指令，该指令只会占用 CPU 并消耗 CPU 时间，一旦不满足上面的两个条件了，就会去计算当前锁的最新状态，导致其不满足的原因有很多，如：<ul><li>其他 goroutine 已经释放锁</li><li>其他 goroutine 导致该锁进入饥饿模式</li><li>自旋次数超过 4 次</li></ul></li><li>计算和更新状态其实就是去更新 <code>state</code> 中的四个值；一旦计算完毕后，通过 CAS 尝试更新<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123; </span><br><span class="line"><span class="comment">// Fast path: grab unlocked mutex. </span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123; </span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123; </span><br><span class="line">race.Acquire(unsafe.Pointer(m)) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// Slow path (outlined so that the fast path can be inlined) </span></span><br><span class="line">m.lockSlow() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123; </span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123; </span><br><span class="line">_ = m.state race.Release(unsafe.Pointer(m)) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果 m.state - mutexLocked == 0 说明没人等待该锁，同时该锁处于正常状态 </span></span><br><span class="line"><span class="comment">// 这时可以快速解锁，即锁状态会直接赋成 0 </span></span><br><span class="line"><span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked) </span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123; </span><br><span class="line"><span class="comment">// 否则则需要慢速解锁 </span></span><br><span class="line">m.unlockSlow(<span class="built_in">new</span>) </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) &#123; </span><br><span class="line"><span class="comment">// 如果锁没锁定，直接抛出异常 </span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123; </span><br><span class="line">throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 正常模式下 </span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123; </span><br><span class="line">old := <span class="built_in">new</span> </span><br><span class="line"><span class="keyword">for</span> &#123; </span><br><span class="line"><span class="comment">// 如果没有其他等待者或者锁不处于空闲状态，直接返回，不需要唤醒其他等待着 </span></span><br><span class="line"><span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123; </span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 唤醒新的等待者 </span></span><br><span class="line"><span class="comment">// 等待者减一，设置唤醒标志 woken </span></span><br><span class="line"><span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken </span><br><span class="line"><span class="comment">// 设置 state, 唤醒一个阻塞着的 goroutine </span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123; </span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>) </span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 设置失败，重新获取状态设置 </span></span><br><span class="line">old = m.state </span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 饥饿模式下，直接唤醒队首的 goroutine，这时 mutexLocked 位依然是 0 </span></span><br><span class="line"><span class="comment">// 但由于处在饥饿状态下，锁不会被其他新来的 goroutine 抢占 </span></span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>) </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><h5 id="1、浅拷贝"><a href="#1、浅拷贝" class="headerlink" title="1、浅拷贝"></a>1、浅拷贝</h5><p>浅拷贝是指对地址的拷贝<br>浅拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化，释放内存地址时，同时释放内存地址<br>引用类型的都是浅拷贝：<code>slice</code>、<code>map</code>、<code>function</code><br>浅拷贝的特点：</p><ul><li>拷贝的时候仅仅拷贝地址，地址指向的都是同一个值</li><li>在<code>a</code>中修改，则<code>b</code>中也跟着变化</li><li>内存销毁是一致的</li></ul><h5 id="2、深拷贝"><a href="#2、深拷贝" class="headerlink" title="2、深拷贝"></a>2、深拷贝</h5><p>深拷贝是指将地址指向的值进行拷贝<br>深拷贝的是数据本身，创造一个一样的新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值。既然内存地址不同，释放内存地址时，可分别释放<br>值类似的都是深拷贝：<code>int</code>、<code>float</code>、<code>bool</code>、<code>array</code>、<code>struct</code><br>深拷贝的特点：</p><ul><li>复制的时候会新创建一个对象</li><li>指向完全不同的内存地址</li><li>修改是互不影响的<br>通过指针求值，将值拷贝实现，修改拷贝的值不影响原来的值<h5 id="3、结构体的深拷贝"><a href="#3、结构体的深拷贝" class="headerlink" title="3、结构体的深拷贝"></a>3、结构体的深拷贝</h5>默认情况下，结构体类型中的字段是值类型，拷贝时都是深拷贝<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Per <span class="keyword">struct</span> &#123; </span><br><span class="line">Name <span class="type">string</span> </span><br><span class="line">Age <span class="type">int</span> </span><br><span class="line">HouseIds [<span class="number">2</span>]<span class="type">int</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">p1 := Per&#123; Name: <span class="string">&quot;ssgeek&quot;</span>, Age: <span class="number">24</span>, HouseIds: [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">22</span>, <span class="number">33</span>&#125;, &#125; </span><br><span class="line">p2 := p1 </span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p1, &amp;p1) <span class="comment">// &#123;ssgeek 24 [22 33]&#125; 0xc000180030 </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p2, &amp;p2) <span class="comment">// &#123;ssgeek 24 [22 33]&#125; 0xc000180060 </span></span><br><span class="line">p2.Age = <span class="number">19</span> </span><br><span class="line">p2.Name = <span class="string">&quot;likui&quot;</span> </span><br><span class="line">p2.HouseIds[<span class="number">1</span>] = <span class="number">44</span> </span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p1, &amp;p1) <span class="comment">// &#123;ssgeek 24 [22 33]&#125; 0xc000098180 </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p2, &amp;p2) <span class="comment">// &#123;likui 19 [22 44]&#125; 0xc0000981b0 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、结构体的浅拷贝"><a href="#4、结构体的浅拷贝" class="headerlink" title="4、结构体的浅拷贝"></a>4、结构体的浅拷贝</h5>使用指针进行浅拷贝，浅拷贝中，可以看到<code>p1</code>和<code>p2</code>的内存地址是相同的，修改其中一个对象的属性时，另一个也会产生变化<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span> </span><br><span class="line"><span class="keyword">type</span> Per <span class="keyword">struct</span> &#123; </span><br><span class="line">Name <span class="type">string</span> </span><br><span class="line">Age <span class="type">int</span> </span><br><span class="line">HouseIds [<span class="number">2</span>]<span class="type">int</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">p1 := Per&#123; Name: <span class="string">&quot;ssgeek&quot;</span>, Age: <span class="number">24</span>, HouseIds: [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">22</span>, <span class="number">33</span>&#125;, &#125; </span><br><span class="line">p2 := &amp;p1 </span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p1, &amp;p1) <span class="comment">// &#123;ssgeek 24 [22 33]&#125; 0xc000076180 </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p2, p2) <span class="comment">// &amp;&#123;ssgeek 24 [22 33]&#125; 0xc000076180 </span></span><br><span class="line">p2.Age = <span class="number">19</span> </span><br><span class="line">p2.Name = <span class="string">&quot;likui&quot;</span> </span><br><span class="line">p2.HouseIds[<span class="number">1</span>] = <span class="number">44</span> </span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p1, &amp;p1) <span class="comment">// &#123;likui 19 [22 44]&#125; 0xc000076180 </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p2, p2) <span class="comment">// &amp;&#123;likui 19 [22 44]&#125; 0xc000076180 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="5、结构体值类型的浅拷贝"><a href="#5、结构体值类型的浅拷贝" class="headerlink" title="5、结构体值类型的浅拷贝"></a>5、结构体值类型的浅拷贝</h5><p>使用<code>new</code>函数实现值类型的浅拷贝<br>值类型的默认是深拷贝，想要实现值类型的浅拷贝，一般是两种方法</p><ul><li>使用指针</li><li>使用new函数（new函数返回的是指针）</li></ul><h5 id="6、结构体引用类型的浅拷贝"><a href="#6、结构体引用类型的浅拷贝" class="headerlink" title="6、结构体引用类型的浅拷贝"></a>6、结构体引用类型的浅拷贝</h5><p>结构体默认是深拷贝，但如果结构体中包含map、slice等这些引用类型，默认也还是浅拷贝<br>map是引用类型，引用类型浅拷贝是默认的情况</p><h5 id="7、结构体引用类型的深拷贝"><a href="#7、结构体引用类型的深拷贝" class="headerlink" title="7、结构体引用类型的深拷贝"></a>7、结构体引用类型的深拷贝</h5><p>结构体中含有引用类型的字段，那么这个字段就是浅拷贝，但是往往希望的是深拷贝，解决方案如下</p><ul><li>方法一：挨个把可导致浅拷贝的引用类型字段自行赋值。赋值后，修改值就相互不影响了</li><li>方法二：使用<code>json</code>或反射。简单来说：<code>json</code>将引用类型的数据进行<code>dump</code>，<code>dump</code>后就和原来的引用类型没有关系了</li></ul><h2 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h2><h5 id="Go-协程为什么快？"><a href="#Go-协程为什么快？" class="headerlink" title="Go 协程为什么快？"></a>Go 协程为什么快？</h5><p>这就要从进程，线程，协程三者的关系讲起。<br>最早的进程时代，是单 CPU 单进程，一切皆是串行执行；到了多进程&#x2F;线程时代，当一个进程阻塞时，切换到另外等候的进程，时间片轮转法保证了等待的进程都能够被运行，但是进程间的调度会占用CPU大部分时间；而到了高并发的场景下，为每个任务都去创建一个线程显然是不合理的，那么，golang 将原来的线程分为了两部分，一个是用户级别的线程（轻量级的线程，运行在用户态，即 goroutine），一个是内核级的线程（即一般意义上的线程，运行在内核态），这样，对于协程的切换和调度都是在用户态进行，不涉及内核级别的调度，因此这是 goroutine 能够很好地支持高并发的场景的基础。</p><ul><li>进程: 进程是具有一定独立功能的程序，进程是系统资源分配和调度的最小单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</li><li>线程: 线程是进程的一个实体,线程是内核态,而且是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</li><li>程: 协程是一种用户态的轻量级线程，协程的调度完全是由用户来控制的。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</li></ul><h5 id="调度器的三个基本对象："><a href="#调度器的三个基本对象：" class="headerlink" title="调度器的三个基本对象："></a>调度器的三个基本对象：</h5><ul><li><p>G（Goroutine），代表协程，go关键字创建的对象</p></li><li><p>M（Work Thread），工作线程，一个 M 关联一个内核级线程</p></li><li><p>P（Processor），代表一个 处理器，又称上下文</p><h5 id="G-M-P三者的关系与特点："><a href="#G-M-P三者的关系与特点：" class="headerlink" title="G-M-P三者的关系与特点："></a>G-M-P三者的关系与特点：</h5></li><li><p>每一个运行的 M 必须绑定一个 P，线程 M 创建后会检查并执行G（goroutine）对象。</p></li><li><p>每一个 P 保存着一个协程 G 的队列。</p></li><li><p>除了每个 P 自身保存的G的队列外，调度器还有一个全局的G队列</p></li><li><p>M 从队列中提取 G，并执行</p></li><li><p>P 的个数就是 GOMAXPROCS（最大256），启动时固定，一般不修改</p></li><li><p>M 的个数和 P 的个数不一定一样多（会有sleep的M或者P不绑定M）(最大10000)</p></li><li><p>P 是用一个全局数组(255)来保存的，并维护一个全局的 P 的空闲链表</p></li></ul><h5 id="局部G队列与全局G队列的关系"><a href="#局部G队列与全局G队列的关系" class="headerlink" title="局部G队列与全局G队列的关系"></a>局部G队列与全局G队列的关系</h5><ul><li>全局G任务队列会和本地G任务队列按照一定策略互相交换。</li><li>G的执行顺序，先从本地队列找，本地没有则从全局队列找</li><li>转移    局部与全局，全局G个数&#x2F;P个数   局部与局部，一次性转移一半</li></ul><h5 id="Gorutine-从入队到执行"><a href="#Gorutine-从入队到执行" class="headerlink" title="Gorutine 从入队到执行"></a>Gorutine 从入队到执行</h5><ol><li>当我们创建一个G对象，就是 gorutine，它会加入到本地队列或者全局队列</li><li>如果还有空闲的P，则创建一个M 绑定该 P ，注意！这里，P 此前必须还没绑定过M 的，否则不满足空闲的条件<ol><li>先找到一个空闲的P，如果没有则直接返回</li><li>P 个数不会占用超过自己设定的cpu个数</li><li>P 在被 M 绑定后，就会初始化自己的 G 队列，此时是一个空队列</li></ol></li><li>M 会启动一个底层线程，循环执行能找到的 G 任务。这里的寻找的 G 从下面几方面找：<ol><li>当前 M 所绑的 P 队列中找</li><li>去别的 P 的队列中找</li><li>去全局 G 队列中找</li></ol></li><li>G任务的执行顺序是，先从本地队列找，本地没有则从全局队列找</li><li>程序启动的时候，首先跑的是主线程，然后这个主线程会绑定第一个 P</li><li>入口 main 函数，其实是作为一个 goroutine 来执行</li></ol><p>1、runtime创建第一个线程M0：M0是启动进程后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G，在之后M0就和其他的M一样了。<br>2、runtime创建第一个Go协程G0：G0是每次启动一个M都会第一个创建的goroutine，G0仅用于负责调度G，G0不指向任何可执行函数，每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间，全局变量的G0是M0的G0。一般的G0放在本地队列中。<br>3、关联M0和G0。<br>4、调度初始化初始化M0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。<br>5、创建main()中的goroutine，即runtime.main创建goroutine。<br>6、启动M0，此时M0已经绑定了P，从P的本地队列中获取G，获取到main goroutine。<br>7、M绑定P。<br>8、循环判断M通过P是否能够获取到G。<br>9、获取不到则M进入休眠队列，等待被唤醒后再重新与P绑定。<br>10、能够获取到G，则M根据G中的栈信息和调度信息设置运行环境。<br>11、M执行G。<br>12、G退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。</p><h5 id="中断挂起与恢复"><a href="#中断挂起与恢复" class="headerlink" title="中断挂起与恢复"></a>中断挂起与恢复</h5><p>goroutine协程的中断挂起与恢复 ：协程的切换时间片是10ms，也就是说 goroutine 最多执行10ms就会被 M 切换到下一个 G。这个过程，又被称为 中断，挂起<br>go程序启动时会首先创建一个特殊的内核线程 sysmon，用来监控和管理，其内部是一个循环：</p><ol><li>记录所有 P 的 G 任务的计数 schedtick，schedtick会在每执行一个G任务后递增</li><li>如果检查到 schedtick 一直没有递增，说明这个 P 一直在执行同一个 G 任务，如果超过10ms，就在这个G任务的栈信息里面加一个 tag 标记</li><li>然后这个 G 任务在执行的时候，如果遇到非内联函数调用，就会检查一次这个标记，然后中断自己，把自己加到队列末尾，执行下一个G</li><li>如果没有遇到非内联函数 调用（有时候正常的小函数会被优化成内联函数）的话，那就会一直执行这个G任务，直到它自己结束；如果是个死循环，并且 GOMAXPROCS&#x3D;1 的话。那么一直只会只有一个 P 与一个 M，且队列中的其他 G 不会被执行！</li></ol><p>中断后的恢复</p><ol><li>中断的时候将寄存器里的栈信息，保存到自己的 G 对象里面</li><li>当再次轮到自己执行时，将自己保存的栈信息复制到寄存器里面，这样就接着上次之后运行</li></ol><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><h2 id="一些细碎知识点"><a href="#一些细碎知识点" class="headerlink" title="一些细碎知识点"></a>一些细碎知识点</h2><h5 id="Golang-传参"><a href="#Golang-传参" class="headerlink" title="Golang 传参"></a>Golang 传参</h5><ol><li>理论上来说，Golang 只有值传递，所有协程的入参都是值拷贝，协程内部的修改，无法影响原参数</li><li>对于指针类型的参数，是对其指向地址的拷贝，因此可以使用地址来修改原参数</li><li>Slice 底层是引用数组，因此对于 Slice 的修改可以反映到原数组；注意 扩容相关内容</li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>todo</title>
      <link href="/uncategorized/todo/"/>
      <url>/uncategorized/todo/</url>
      
        <content type="html"><![CDATA[<p>raft<br><a href="https://cloud.tencent.com/developer/article/2168468">https://cloud.tencent.com/developer/article/2168468</a></p><p>sync.map<br><a href="https://cloud.tencent.com/developer/article/2140224">https://cloud.tencent.com/developer/article/2140224</a><br><a href="https://cloud.tencent.com/developer/article/2140226">https://cloud.tencent.com/developer/article/2140226</a><br>go.map<br><a href="https://blog.csdn.net/lp15929801907/article/details/130229409?utm_source=miniapp_weixin">https://blog.csdn.net/lp15929801907/article/details/130229409?utm_source=miniapp_weixin</a></p><p>sync.Mutex<br><a href="https://cloud.tencent.com/developer/article/2140227">https://cloud.tencent.com/developer/article/2140227</a></p><p>defer<br><a href="https://cloud.tencent.com/developer/article/1410243">https://cloud.tencent.com/developer/article/1410243</a></p><p>gmp<br><a href="https://cloud.tencent.com/developer/article/2191347">https://cloud.tencent.com/developer/article/2191347</a><br><a href="https://cloud.tencent.com/developer/article/1680164">https://cloud.tencent.com/developer/article/1680164</a></p><p>redis<br><a href="https://blog.csdn.net/qq1515312832/article/details/113880849">https://blog.csdn.net/qq1515312832/article/details/113880849</a></p><p>channel<br><a href="https://cloud.tencent.com/developer/article/1651356">https://cloud.tencent.com/developer/article/1651356</a></p><p>拷贝<br><a href="https://cloud.tencent.com/developer/article/1870553">https://cloud.tencent.com/developer/article/1870553</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/uncategorized/%E8%AF%9D%E6%9C%AF/"/>
      <url>/uncategorized/%E8%AF%9D%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="自我介绍："><a href="#自我介绍：" class="headerlink" title="自我介绍："></a>自我介绍：</h3><p>您好，我是王鑫宇，非常感谢给我的这次面试机会，拥有几年k12教育公司负责增长业务相关的系统和模型设计，其中主要包括活动营销平台的开发，以及相关系统的重构与升级，有过多次大型系统研发经验，有过多次跨部门系统研发经验。有过5人小组的管理经验。</p><h3 id="您在前一家公司的离职原因是什么？"><a href="#您在前一家公司的离职原因是什么？" class="headerlink" title="您在前一家公司的离职原因是什么？"></a>您在前一家公司的离职原因是什么？</h3><p>政策限制后，公司尝试了多种方向，比如海外业务、多学科等探索，初步是有一些成果的。我自身来说还是想要和公司一同发展的，但是随着时间的推移，各方向业务收缩，研发工作以维护为主，对于系统层面的迭代实际上是在不断地做减法。并且家人生病，需要人手照顾，综合考虑下就出来了</p><p>使用 etcd 来完成微服务注册和发现，使用 thrift 和 grpc 作为微服务的框架。<br>rpc访问量、耗时，sql耗时等关键指标暴露给 Prometheus，并通过 Grafana 展示，便于监控服务质量，以及出现问题时可以帮助快速定位异常接口</p><p>context多数用来进行上下文信息传递，在实际开发中，会记录整条调用链路。一般来说，需要注意的是超时机制；context只能自顶向下传值；context一定不能为nil，在不确定的情况下可以使用 context.TODO() 或者 context.Background()</p><p>etcd中的分布式锁一般用来在集群系统启动时确定由哪一个系统来全局单例业务操作，比如数据刷新、业务数据清洗等<br>依据当前接口的唯一标识数据来实现幂等<br>不同系统间调用顺序可以用消息队列保证<br>分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p><p>分布式系统一般使用 redis 来做分布式锁（缺点：redis主从切换时可能丢失数据）<br>redis分布式锁，我们使用的业务场景，加锁时间一般为1s-3s，根据场景浮动，其中3s是我们设定的最长响应时间。</p><p>如果加锁后，过期时间内业务由于某种原因还没执行完，下一次请求再次加锁后打进来，而此时上一次的请求还未执行完毕，这时候需要对锁进行延期。可以采用协程的方法来设置一个ticker，在执行完毕的channel中如果没有收到通知，那么就需要对这个锁进行有限次的续期，来保证不会出现超卖这类情况。</p><p>另一种情况是如果当前锁是全局的，那么可能会出现锁被其他集群的进程解锁的情况，这种一般针对加锁的key进行处理即可</p><p>广告系统，主要是针对公司内部各个app的多种展示为进行统一投放和数据收集。为了保证访问质量和稳定性，使用了内存-redis-tidb三层缓存结构，系统启动时，会优先将活跃状态的广告内容加载到各个实例的内存中。然后根据实际访问的过程，会在redis中添加第二层缓存，类似于维护了一层热点数据。最后一层是tidb也就是所有的广告配置信息。内存数据会定时刷新，对于配置变化的感知在刷新周期之外；对于配置变化敏感的其他系统，在配置发生变化时，也会有消息队列进行通知。</p><p>最终达到的效果是能够支持静默期、按次投放、按周期投放、轮播等多样化可组合的投放策略。这里的轮播是由后端来实现的，用户有一个可见广告的集合，每次操作到某个页面会在这个集合里面给用户返回广告内容，可以达到的效果是每次访问到的内容都是不相同的，可以一定程度上增加曝光。但是需要注意的一点是，这样的曝光方式对于用户的使用流程是侵入比较严重的，因此不太推荐业务方将这种配置加载到用户使用流程中。</p><p>轮播的实现方式是利用了redis中zset的结构，为轮播条件下 用户-广告位形成一个桶，访问次数作为分数加入zset中，这样就可以用zscore来进行可访问性判断；访问一轮之后整个清除zset中的数据（实际使用的话是前100名，用户-广告位下常规配置不可能达到这个量）。同时也会为这个桶增加过期时间，防止无效占用。</p><p>当然这里可以用ZRevRange来支持乱序返回但这样就不是轮播的概念了，我仍然保留了这一功能。</p><p>数据收集的话，是结合了公司内部的打点系统，直接上报到日志，然后由大数据的同学消费日志队列进行收集整理。同时每个广告都有一个唯一标识，会从展示到访问到落地页再到可能产生的售卖来生成数据漏斗，来评估投放效率、物料等，也有用来优化用户流失的问题。这部分具体细节我就不太了解了，我研发后推进到各方使用后，由于我本身负责的是一对一业务线的，但是我们本身的售卖模型是比较长线的，中间可能还会有销售等人为因素影响承担，于是由另一个更大的流量池app绘本业务来进行后续的维护和更新了。</p><p>对于活动呢，由于运营提出的活动形式有很多，且对于上线时间有强要求，所以一般初次出现的活动形式，会采取敏捷开发的方式，以达到最快且稳定上线的目的</p><p>任务系统，初期设计呢是很死板的，根据运营设计的任务动作从涉及到的多个方向拉取或者等待信息推送，但是这个方案对于其他业务的侵入性太高，风险极高。针对这一点，我将所有的业务动作全部转移到消息队列来获取，这样对于其他业务线或者系统来说，大部分是已经支持的</p><p>抽奖系统，可以讲讲分布式锁相关，</p><p>slice底层实现方法，map底层实现方法</p><p>redis 跳表</p><p>golang 语言的优势：静态语言，编译阶段可以发现一些问题；并发支持好，耗时随并发数线性增加；垃圾回收处理好</p><p>golang 文件操作使用比较少，了解不多</p><p>golang channel 利用协程通信来共享内存</p><p>常见排序：快排，堆排，归并</p><p>内核线程才是并行的基本单位</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/elementary-sort/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/elementary-sort/</url>
      
        <content type="html"><![CDATA[<p>![[source&#x2F;images&#x2F;elementary-sort.png]]</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 必看必会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/elementary-time-complixty/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/elementary-time-complixty/</url>
      
        <content type="html"><![CDATA[<h2 id="时间复杂度-大-O"><a href="#时间复杂度-大-O" class="headerlink" title="时间复杂度 (大 O)"></a>时间复杂度 (大 O)</h2><p>![[Pasted image 20240429194251.png]]</p><p>![[Pasted image 20240429194302.png]]</p><p>首先，我们来谈谈常用操作的时间复杂度，按数据结构&#x2F;算法划分。然后，我们将讨论给定输入大小的合理复杂性。</p><h4 id="数组（动态数组-x2F-列表）"><a href="#数组（动态数组-x2F-列表）" class="headerlink" title="数组（动态数组&#x2F;列表）"></a>数组（动态数组&#x2F;列表）</h4><p>规定 <em>n &#x3D; arr.length</em>,</p><ul><li>结尾添加或删除元素: 𝑂(1)</li><li>从任意索引中添加或删除元素: 𝑂(𝑛)</li><li>访问或修改任意索引处的元素: 𝑂(1)</li><li>检查元素是否存在: 𝑂(𝑛)</li><li>双指针: 𝑂(𝑛⋅𝑘), 𝑘 是每次迭代所做的工作，包括滑动窗口</li><li>构建前缀和: 𝑂(𝑛)</li><li>求给定前缀和的子数组的和：𝑂(1)</li></ul><h4 id="字符串-不可变"><a href="#字符串-不可变" class="headerlink" title="字符串 (不可变)"></a>字符串 (不可变)</h4><p>规定 <em>n &#x3D; s.length</em>,</p><ul><li>添加或删除字符: 𝑂(𝑛)</li><li>任意索引处的访问元素: 𝑂(1)</li><li>两个字符串之间的连接: 𝑂(𝑛+𝑚), 𝑚 是另一个字符串的长度</li><li>创建子字符串: 𝑂(𝑚), 𝑚 是子字符串的长度</li><li>双指针: 𝑂(𝑛⋅𝑘), 𝑘 是每次迭代所做的工作，包括滑动窗口</li><li>通过连接数组、stringbuilder 等构建字符串：𝑂(𝑛)</li></ul><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>给定 𝑛n 作为链表中的节点数，</p><ul><li>给定指针位置的后面添加或删除元素: 𝑂(1)</li><li>如果是双向链表，给定指针位置添加或删除元素: 𝑂(1)</li><li>在没有指针的任意位置添加或删除元素: 𝑂(𝑛)</li><li>无指针任意位置的访问元素: 𝑂(𝑛)</li><li>检查元素是否存在: 𝑂(𝑛)</li><li>在位置 i 和 j 之间反转: 𝑂(𝑗−𝑖)</li><li>使用快慢指针或哈希映射完成一次遍历: 𝑂(𝑛)</li></ul><h4 id="哈希表-x2F-字典"><a href="#哈希表-x2F-字典" class="headerlink" title="哈希表&#x2F;字典"></a>哈希表&#x2F;字典</h4><p>给定 <em>n &#x3D; dic.length</em>,</p><ul><li>添加或删除键值对: 𝑂(1)</li><li>检查 key 是否存在: 𝑂(1)</li><li>检查值是否存在: 𝑂(𝑛)</li><li>访问或修改与 key 相关的值: 𝑂(1)</li><li>遍历所有键值: 𝑂(𝑛)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意: 𝑂(1)O(1) 操作相对于 n 是常数.实际上，哈希算法可能代价很高。例如，如果你的键是字符串，那么它将花费 𝑂(𝑚)O(m)，其中 𝑚m 是字符串的长度。 这些操作只需要相对于哈希映射大小的常数时间。</span><br></pre></td></tr></table></figure></li></ul><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>给定 <em>n &#x3D; set.length</em>,</p><ul><li>添加或删除元素: 𝑂(1)</li><li>检测元素是否存在: 𝑂(1)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面的说明也适用于这里。</span><br></pre></td></tr></table></figure></li></ul><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈操作依赖于它们的实现。栈只需要支持弹出和推入。如果使用动态数组实现:给定 <em>n &#x3D; stack.length</em>,</p><ul><li>推入元素: 𝑂(1)</li><li>弹出元素: 𝑂(1)</li><li>查看 (查看栈顶元素): 𝑂(1)</li><li>访问或修改任意索引处的元素: 𝑂(1)</li><li>检测元素是否存在: 𝑂(𝑛)</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列操作依赖于它们的实现。队列只需要支持出队列和入队列。如果使用双链表实现:给定 <em>n &#x3D; queue.length</em>,</p><ul><li>入队的元素: 𝑂(1)</li><li>出队的元素: 𝑂(1)</li><li>查看 (查看队列前面的元素): 𝑂(1)</li><li>访问或修改任意索引处的元素: 𝑂(𝑛)</li><li>检查元素是否存在: 𝑂(𝑛)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意:大多数编程语言实现队列的方式比简单的双链表更复杂。根据实现的不同，通过索引访问元素可能比 𝑂(𝑛)O(n) 快，但有一个重要的常量除数。</span><br></pre></td></tr></table></figure></li></ul><h4 id="二叉树问题-DFS-x2F-BFS"><a href="#二叉树问题-DFS-x2F-BFS" class="headerlink" title="二叉树问题 (DFS&#x2F;BFS)"></a>二叉树问题 (DFS&#x2F;BFS)</h4><p>给定  𝑛 作为树的节点数，大多数算法的时间复杂度为 𝑂(𝑛⋅𝑘), 𝑘 是在每个节点上做的操作数, 通常是 𝑂(1)。这只是一个普遍规律，并非总是如此。我们在这里假设 BFS 是用高效队列实现的。</p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>给定 𝑛 作为树中的节点数，</p><ul><li>添加或删除元素：最坏的情况下 𝑂(𝑛),平均情况 𝑂(log⁡𝑛)</li><li>检查元素是否存在：最坏的情况下 𝑂(𝑛), 平均情况 𝑂(log⁡𝑛)<br>平均情况是当树很平衡时 —— 每个深度都接近满。最坏的情况是树只是一条直线。</li></ul><h4 id="堆-x2F-优先队列"><a href="#堆-x2F-优先队列" class="headerlink" title="堆&#x2F;优先队列"></a>堆&#x2F;优先队列</h4><p>给定 <em>n &#x3D; heap.length</em> 并讨论最小堆,</p><ul><li>添加一个元素: 𝑂(log⁡𝑛)</li><li>删除最小的元素: 𝑂(log⁡𝑛)</li><li>找到最小的元素: 𝑂(1)</li><li>查看元素是否存在: 𝑂(𝑛)</li></ul><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>在最坏的情况下，二分查找的时间复杂度为 𝑂(log⁡𝑛)，其中 𝑛 是初始搜索空间的大小。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>排序: 𝑂(𝑛⋅log⁡𝑛), 其中 𝑛 是要排序的数据的大小</li><li>图上的 DFS 和 BFS：𝑂(𝑛⋅𝑘+𝑒)，其中 𝑛 是节点数，𝑒 是边数，前提是每个节点处理花费都是 𝑂(1)，不需要重复遍历。</li><li>DFS 和 BFS 空间复杂度：通常为 𝑂(𝑛)，但如果它在图形中，则可能为 𝑂(𝑛+𝑒) 来存储图形</li><li>动态规划时间复杂度：𝑂(𝑛⋅𝑘)，其中 𝑛 是状态数，𝑘 是每个状态所需要的操作数</li><li>动态规划空间复杂度：𝑂(𝑛)，其中 𝑛 是状态数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 必看必会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raft 面试必备</title>
      <link href="/interview/distribution/raft/"/>
      <url>/interview/distribution/raft/</url>
      
        <content type="html"><![CDATA[<p>Raft<br>Raft协议呢，一般包括这三种节点：Follower、Candidate、Leader；其中，候选人是只有在选举期间才存在的节点，一旦选举结束，那么集群中就只有 Leader，Follower</p><p>节点之间使用 rpc 来通信，包括 投票rpc，复制日志心跳rpc，快照rpc</p><p>选举过程如下：<br>选举时机：当网络刚刚启动或者集群节点变更，或者上一任期结束后。所有节点进入选举阶段，每个人持有一个随机的选举时钟，时钟结束后，节点优先给自己投票，然后广播投票rpc。会有三种结果：赢得多数选票成为 Leader； 其他人当选，自己成为 follower；没有人当选，开启下一轮投票。<br>由于raft的机制，可以认为能够成为 Leader 的节点，一定是包含所有日志的节点<br>leader选举的过程是：1、增加term号；2、给自己投票；3、重置选举超时计时器；4、发送请求投票的RPC给其它节点</p><p>Leader 被选举出来以后，就开始接收客户端的消息。Leader 会将这一条消息作为日志记录下来，并将其通过心跳包同步给集群中的 follower，当大部分节点都同步这条日志以后，Leader 将这个请求应用到自身的状态机并回复客户端。follower 如果发生宕机或者丢包，Leader 会不断尝试直到所有节点都同步了这条日志。<br>日志由有序编号（log index）的日志条目组成。每个日志条目包含它被创建时的任期号（term）和用于状态机执行的命令。</p><p>日志复制的过程有两条保证：</p><ol><li>如果不同节点的两条日志有相同的索引和任期，那么他们存储的命令是一致的（由于主从同步的特性，Leader 节点上的日志和命令落库后就不会更改）</li><li>如果不同节点的两条日志有相同的索引和任期，那么他们之前存储的日志也是一致的（由于日志的一致性检查，当 follower 收到来自 Leader 的心跳包以后，会与本地的日志索引和任期做匹配，如果有不一致，那么会拒绝掉这个心跳包）</li></ol><p>日志复制的异常情况包括：<br>Leader 宕机或者崩溃，旧 Leader 没有复制完所有的日志。可能多，可能少，可能不一致</p><p>日志复制的过程，需要通过与 Leader 保证强一致性来保证安全复制。当日志产生不一致时，Leader 会从后往前尝试同步日志心跳包给其他节点，直到找到一个双方都符合的日志，然后 Leader 会把从这条日志以后的所有内容同步给该节点，将不一致的部分覆盖掉，直到与 Leader 保持完全一致<br><strong>当 leader 和 follower 日志冲突的时候</strong>，leader 将<strong>校验 follower 最后一条日志是否和 leader 匹配</strong>，如果不匹配，<strong>将递减查询，直到匹配，匹配后，删除冲突的日志</strong></p><p>那么像之前提到 Leader 中的日志可能也不是最新的，会不会同步出去的日志本身就是异常的呢？<br>这个就是 raft 通过两条限制来保证了日志复制的安全性：</p><ol><li>只有log索引和任期是最新的节点才有可能成为 Leader，这个在选举投票期间是可以判断的，非最新的就不给他投票</li><li>Leader 只能推进日志的索引进行提交，以前任期的要在检查一致性的过程中同步过去。</li></ol><p>那么在实际使用过程中，为了保证日志不会无限增长，每隔一段时间，每个节点独立的进行快照，将某个时间点以前的日志落库后丢弃。<br>当 Leader 在同步日志的过程中发现某个节点的日志特别老，那么这时候，Leader 会发送快照rpc来将日志打包复制。<br>当然实际使用中，需要控制间隔的时间，和快照的频率（防止发生 io 阻塞），一般达到固定大小发生一次。<br>同时可以使用 copy-on-write 技术来保证正常的日志同步</p><p>脑裂问题是说一次性在集群中增加了太多的节点，比如超过了原来节点数量的一半，那么就有可能产生双主的现象，即一个集群中有两个 Leader，彼此成员之间没有交集。解决办法是一次变更一个节点，少量多次的来完成。<br>另外还有一个情况是，如果发生了网络分区故障或者异常，导致老 Leader 失联了，剩下的节点会重新选举出一个新 Leader，并与客户端继续交流。当老 Leader 恢复连接以后，他上面的 commit 都会被视作失效，本身会转化为 follower 接收从新 Leader 来的日志。</p><p>另外一种还有一个 <strong>Prevote</strong> 机制<br>当有一个 follower 与集群隔离后，他会自己进入候选阶段，并由于无法获得投票成为 Leader 而一直刷新任期，导致该节点任期非常大。当该节点重进集群以后，会由于任期导致选举混乱，因此 raft 采用 prevote 机制，是一个类似于两阶段提交的协议，第一阶段先征求其他节点是否同意选举，如果同意选举则发起真正的选举操作，否则降为Follower角色。这样就避免了网络分区节点重新加入集群，触发不必要的选举操作</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>simulation02</title>
      <link href="/interview/log/simulation02/"/>
      <url>/interview/log/simulation02/</url>
      
        <content type="html"><![CDATA[<p>深维：<br>一面：</p><h4 id="1-用过哪些分布式锁-redis-key用什么类型-用string有什么坏处-？没抢到的都在干等着，浪费cpu？如何规避。-etcd如何分布式锁"><a href="#1-用过哪些分布式锁-redis-key用什么类型-用string有什么坏处-？没抢到的都在干等着，浪费cpu？如何规避。-etcd如何分布式锁" class="headerlink" title="1.用过哪些分布式锁 redis key用什么类型 用string有什么坏处 ？没抢到的都在干等着，浪费cpu？如何规避。 etcd如何分布式锁"></a>1.用过哪些分布式锁 redis key用什么类型 用string有什么坏处 ？没抢到的都在干等着，浪费cpu？如何规避。 etcd如何分布式锁</h4><p>redis 锁 可能存在的问题：</p><ul><li>业务超时，导致锁失效，造成多实例持有锁：延长过期时间（不推荐）；类似 java 的看门狗机制，另外启用一个协程对锁续约。</li><li>redis 主从切换时可能造成多实例持有锁，这个是用的 redlock 来解决的，不过具体的方案我就没有看过了<br>用过redis锁， setnx属于原子操作，上锁失败一般认为是锁已经存在了。一般使用string类型作为key，string类型有一个缺点是会占用比较大的空间，<br>可以根据业务具体情况使用 hset ，但是需要保证单个集合中的 kv 数量，如果超过某个界限，redis 就不会用 ziplist 来存储这个集合了</li></ul><p>etcd<br>prefix<br>etcd支持前缀查找，所以可以用一个前缀表示锁资源，前缀 + 唯一id的方式表示锁资源的持有者。</p><p>lease机制<br>租约机制可以保证锁的活性，持有锁的客户端宕机，key自动过期，避免宕机。etcd客户端提供的lease续租机制解决客户端长时间阻塞导致锁失效问题。</p><p>watch机制<br>redis采用忙轮询的方式来获取锁，etcd可以使用watch机制监听锁的删除事件，更加高效。</p><h4 id="2-数据库-隔离级别-没有解决什么问题-幻读是什么"><a href="#2-数据库-隔离级别-没有解决什么问题-幻读是什么" class="headerlink" title="2.数据库 隔离级别 没有解决什么问题 幻读是什么"></a>2.数据库 隔离级别 没有解决什么问题 幻读是什么</h4><p>一共有五种：<br>不使用事务<br>read uncommitted 允许脏读<br>read committed 防止脏读 最常用<br>repeatable read 防止脏读，不可重复读 mysql 默认<br>serilized 串行事务，防止幻读，脏读，不可重复读<br>级别越高，安全性越好，并发性能约低</p><p>幻读就是在一个事务过程中用相同条件查询时，获取的结果不一致<br>事务A获取的结果集，事务B对其中的数据进行了修改并提交，事务A在重新执行查询时，可能会发现原本不存在的数据行（幻影），或者原本存在的数据行消失了</p><h4 id="3-布隆过滤器的原理"><a href="#3-布隆过滤器的原理" class="headerlink" title="3.布隆过滤器的原理"></a>3.布隆过滤器的原理</h4><p>利用位数组和哈希函数来判断一个元素是否存在于集合中<br>布隆过滤器基于一个位数组和若干个哈希函数，其中位数组是一个由0和1组成的数组，初始值全部为0。当一个元素加入到布隆过滤器中时，会通过多个哈希函数生成多个哈希值，然后将这些哈希值对应的位数组位置设置为1。当一个元素要查询是否存在于布隆过滤器中时，也会通过多个哈希函数生成多个哈希值，然后查询这些哈希值对应的位数组位置是否都为1。如果任何一个位数组位置不为1，那么该元素肯定不存在于布隆过滤器中。如果所有位数组位置都为1，那么该元素可能存在于布隆过滤器中。因为多个元素可能会被哈希到同一个位数组位置上，所以存在误判的情况，但是不会漏掉任何一个元素。<br>哈希函数数量与位数组长度无关，位数组存储的是元素哈希以后的结果</p><p>优点是查询快，不需要真正查询数据；位数组扩展性强；占用内存小<br>缺点是无法删除，且有一定程度误判的概率</p><p>redis中提供了布隆过滤器的功能，但是我没有实际使用过</p><h4 id="4-channel相关-1-有缓存-没有缓存-send什么情况下会阻塞2-已经关闭的channel取数据-返回什么3-往没有初始化的channel里send会返回什么"><a href="#4-channel相关-1-有缓存-没有缓存-send什么情况下会阻塞2-已经关闭的channel取数据-返回什么3-往没有初始化的channel里send会返回什么" class="headerlink" title="4.channel相关 1.有缓存 没有缓存 send什么情况下会阻塞2.已经关闭的channel取数据 返回什么3.往没有初始化的channel里send会返回什么"></a>4.channel相关 1.有缓存 没有缓存 send什么情况下会阻塞2.已经关闭的channel取数据 返回什么3.往没有初始化的channel里send会返回什么</h4><h4 id="5-slice和数组的区别-各自的好处-地址引用和值引用的好处"><a href="#5-slice和数组的区别-各自的好处-地址引用和值引用的好处" class="headerlink" title="5.slice和数组的区别 各自的好处 地址引用和值引用的好处"></a>5.slice和数组的区别 各自的好处 地址引用和值引用的好处</h4><p>区别仅在于数据在声明时定长，切片可拓展长度<br>值引用是对原数据进行了一份拷贝后传入函数，一般用于函数改值不影响原数据的场景；地址引用是对原数据地址指针的引用，一般函数中对于这个引用的改动会反映到原数据上</p><h4 id="6-mysql的索引如何实现的，二级索引如何实现的"><a href="#6-mysql的索引如何实现的，二级索引如何实现的" class="headerlink" title="6.mysql的索引如何实现的，二级索引如何实现的"></a>6.mysql的索引如何实现的，二级索引如何实现的</h4><p>由于聚集索引是利用表的主键构建的，所以每张表只能拥有一个聚集索引。</p><p>聚集索引的叶子节点就是数据页。换句话说，数据页上存放的是完整的每行记录。因此聚集索引的一个优点就是：通过过聚集索引能获取完整的整行数据。另一个优点是：对于主键的排序查找和范围查找速度非常快。<br>使用B+树作为索引结构，其中聚集索引（Primary Index）的叶子节点包含行数据，而非聚集索引（Secondary Index）的叶子节点包含主键值。<br>二级索引（也称为辅助索引）实现方式与主索引类似，只是它不是主键。在InnoDB中，二级索引的叶子节点包含指向主键的指针，这个指针用于回表查询获取完整的数据行。</p><h4 id="7-map的底层如何实现的-什么类型不能用做map的key"><a href="#7-map的底层如何实现的-什么类型不能用做map的key" class="headerlink" title="7.map的底层如何实现的 什么类型不能用做map的key"></a>7.map的底层如何实现的 什么类型不能用做map的key</h4><h4 id="8-golang源码看过吗？"><a href="#8-golang源码看过吗？" class="headerlink" title="8.golang源码看过吗？"></a>8.golang源码看过吗？</h4><p>没有详细看过，对于可能用到的 map 和 slice 有看过大致的原理</p><h4 id="9-如何实现LRU"><a href="#9-如何实现LRU" class="headerlink" title="9.如何实现LRU"></a>9.如何实现LRU</h4><p>双向链表 + 哈希表<br>双向链表存储节点，哈希表存储节点值到节点地址的映射</p><h4 id="10-索引（a-b-c-a-x3D-b-x3D-c-x3D-c-x3D-b-x3D-a-x3D-a-x3D-b-gt-c-x3D-命中索引的哪一段"><a href="#10-索引（a-b-c-a-x3D-b-x3D-c-x3D-c-x3D-b-x3D-a-x3D-a-x3D-b-gt-c-x3D-命中索引的哪一段" class="headerlink" title="10.索引（a,b,c) a&#x3D; b&#x3D; c&#x3D;, c&#x3D; b&#x3D; a&#x3D;, a&#x3D; b&gt; c&#x3D;命中索引的哪一段"></a>10.索引（a,b,c) a&#x3D; b&#x3D; c&#x3D;, c&#x3D; b&#x3D; a&#x3D;, a&#x3D; b&gt; c&#x3D;命中索引的哪一段</h4><h4 id="11-数据库间隙锁是什么"><a href="#11-数据库间隙锁是什么" class="headerlink" title="11.数据库间隙锁是什么"></a>11.数据库间隙锁是什么</h4><p>MySQL InnoDB支持三种行锁定方式：</p><p>行锁（Record Lock）：锁直接加在索引记录上面。<br>间隙锁（Gap Lock）：锁加在不存在的空闲空间，可以是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。<br>Next-Key Lock：行锁与间隙锁组合起来用就叫做Next-Key Lock。</p><p>在一般范围区间查询数据时，会对命中的行加行锁，但是对于条件范围内但是还不存在的行也会加间隙锁。如果上一次区间查询没有执行完毕，那么针对该表区间内的insert操作会因为间隙锁而阻塞，直到查询执行完毕才会继续执行<br>可以解决幻读问题</p><p>可以防止数据误删改</p><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>T0</td><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>T1</td><td>delete from t_student where id &lt; 4;</td><td></td></tr><tr><td>T2</td><td></td><td>insert into t_student VALUES(2,‘戏子111’,1,“杭州”);</td></tr><tr><td>T3</td><td></td><td>commit;</td></tr><tr><td>T4</td><td>commit;</td><td></td></tr><tr><td>会对插入性能有一定影响</td><td></td><td></td></tr></tbody></table><h4 id="12-分布式事务了解过哪些-如何实现"><a href="#12-分布式事务了解过哪些-如何实现" class="headerlink" title="12.分布式事务了解过哪些 如何实现"></a>12.分布式事务了解过哪些 如何实现</h4><h4 id="13-电商系统如何防止超买超卖"><a href="#13-电商系统如何防止超买超卖" class="headerlink" title="13.电商系统如何防止超买超卖"></a>13.电商系统如何防止超买超卖</h4><p>一般来说，超买超卖发生在高并发的情况下。那么针对高并发的情况，可以通过加并发锁控制并发；采用队列方式改为顺序执行；利用数据库的原子语句（不推荐）<br>一般减库存区分 下单、付款、预扣（例如下单后保留10分钟）这几个节点</p><h4 id="14-悲观锁和乐观锁分别适合什么样的场景"><a href="#14-悲观锁和乐观锁分别适合什么样的场景" class="headerlink" title="14.悲观锁和乐观锁分别适合什么样的场景"></a>14.悲观锁和乐观锁分别适合什么样的场景</h4><p>悲观锁：担心数据被他人修改，因此每次修改都期望加锁，适合写大于读的情况。主要利用数据库中的读锁，行锁，写锁<br>乐观锁因为不担心数据修改问题，更多适合读大于写的场景，使用版本号或者时间戳（updatetime）</p><h4 id="15-负载均衡-etcd如何做-NGINX如何做-k8s如何做"><a href="#15-负载均衡-etcd如何做-NGINX如何做-k8s如何做" class="headerlink" title="15.负载均衡 etcd如何做 NGINX如何做 k8s如何做"></a>15.负载均衡 etcd如何做 NGINX如何做 k8s如何做</h4><p>轮询和加权轮询；权重可以根据节点的状态来动态调整。要注意权重的上下限<br>一致性哈希： 哈希环，服务端节点在环上，距离哈希结果最近的下一个节点<br>最少连接数<br>最快响应等</p><h4 id="16-普罗米修斯"><a href="#16-普罗米修斯" class="headerlink" title="16.普罗米修斯"></a>16.普罗米修斯</h4><h4 id="17-traceid系统怎么做的-如何从前端传到后端各个服务"><a href="#17-traceid系统怎么做的-如何从前端传到后端各个服务" class="headerlink" title="17.traceid系统怎么做的 如何从前端传到后端各个服务"></a>17.traceid系统怎么做的 如何从前端传到后端各个服务</h4><p>伴鱼使用的是jager，最初的采集方式是每隔一段时间采集一次。主要用来排查异常，解决业务问题，但是有间隔的采样命中相关异常的概率很小，经常是遇到了问题但是采集不到。后期结合社区内的一些组件，更新了采集方式，</p><p>二面：<br>1.挑一个项目能代表你的架构设计或者解决问题的能力（需要偏技术而不是业务）</p><p>2.如何做服务治理</p><p>3.etcd是ap系统还是cp系统<br>&#x3D;&#x3D;<strong>etcd是CP实现</strong>&#x3D;&#x3D;,它保证一致性与分区容错性,一定程度上牺牲了可用性。</p><p>4.etcd如何做负载均衡</p><p>5.K8S+docker A服务调用B服务是怎么知道B服务的地址的 </p><p>6.降级限流熔断怎么做的 熔断的原理是什么</p><ol><li>降级（Degradation）<br>概念：降级是指在系统遇到异常或高负载等情况下，暂时关闭或者切换到一些功能简化的模式，以保证核心流程的可用性和稳定性。<br>作用：通过舍弃一些非核心或不重要的功能，保护核心功能的正常运行。<br>示例：在高负载情况下，关闭一些消耗较大的查询功能，只提供基本的读写操作。</li><li>熔断（Circuit Breaker）<br>概念：熔断是指在服务调用过程中，当某个服务出现故障或不可用时，暂时停止调用该服务，直到服务恢复正常。<br>作用：通过熔断机制，保护系统免受故障服务的影响，避免雪崩效应。<br>示例：监控服务调用的失败率或错误率，当达到一定阈值时，打开熔断器，停止对该服务的调用。一段时间后，再进行尝试，如果调用成功，则关闭熔断器，继续正常调用。</li><li>限流（Rate Limiting）<br>概念：限流是指在系统的请求流量过大时，对请求进行控制和限制，使得系统在可接受的范围内进行处理，避免系统超出处理能力而崩溃。<br>作用：通过限制请求的数量或速度，保护系统免受过载的影响。<br>示例：设置每秒最大请求数或最大并发数，当请求数或并发数达到阈值时，拒绝额外的请求或者将其放入等待队列，直到系统能够处理。</li></ol><p>7.post报文由什么组成</p><p>8.tcp如何定位双方 三次握手</p><p>9.如果有M个东西，每8个为一组，每两组之间有两个重叠，会分成多少组</p><p>10.人才管理</p><p>11.逃逸分析</p><p>12.设计模式</p><p>一面<br>epoll、select、poll 区别<br>epoll 的水平触发和边缘触发的区别<br>TCP 的流量控制<br>为什么有了流量控制还要有拥塞控制?<br>TCP 不是可靠传输吗？为什么会丢包呢？<br>那你介绍一下拥塞控制的算法？<br>进程、线程的区别<br>Go里面GMP模型是怎么样的？<br>算法：旋转矩阵，牛客上写过，easy，秒<br>二面<br>如何用栈实现队列<br>如何判断一个链表有没有环？<br>那为什么快慢指针一定能够相遇？<br>你用的是 mysql 是吧，那 B树 和 B+树 的区别是？<br>介绍一下死锁产生的必要条件<br>如何实现互斥锁？<br>如何实现自旋锁？<br>算法：三数之和。秒<br>三面<br>kafka 和 其他消息队列，比如 rocketmq，rabbitmq ，有什么优势？<br>kafka如何保证消息不丢失？<br>https为什么是安全的？<br>ssl&#x2F;tls 是怎么保证安全的？经过几次握手？<br>事务的四大特性？<br>用过哪些排序？<br>快排一定最快吗？<br>场景题：如果我有100G文件，但是只有 500 M 的内存，这些文件存着一行行的数字，如何获取最小的10个？<br>算法：最长有序括号，常见题，秒</p><h4 id="grpc-和-http-的区别"><a href="#grpc-和-http-的区别" class="headerlink" title="grpc 和 http 的区别"></a>grpc 和 http 的区别</h4><p>grpc的话是使用 http&#x2F;2 协议进行通信，传输内容为二进制内容，因此grpc的关键算法是 payload 的序列化和反序列化，一般使用 protocol buffer 序列化库。服务之间使用 rpc 调用</p><h5 id="数据序列化："><a href="#数据序列化：" class="headerlink" title="数据序列化："></a>数据序列化：</h5><p>gRPC使用Protocol Buffers对数据进行序列化和反序列化，实现跨语言、跨平台的数据交换。Protocol Buffers的序列化和反序列化过程可以通过以下公式表示：</p><ul><li>序列化(M)&#x3D;Encode(M)</li><li>反序列化(M)&#x3D;Decode(M)<br>其中，$M$ 是数据结构，$Encode$ 和 $Decode$ 分别表示序列化和反序列化操作。</li></ul><h5 id="RPC调用："><a href="#RPC调用：" class="headerlink" title="RPC调用："></a>RPC调用：</h5><p>gRPC的RPC调用过程可以分为以下步骤：</p><ul><li>客户端通过Protocol Buffers序列化请求数据，并使用HTTP&#x2F;2发送请求。</li><li>服务器接收请求，使用Protocol Buffers反序列化请求数据。</li><li>服务器执行RPC方法，并将结果序列化为Protocol Buffers格式。</li><li>服务器使用HTTP&#x2F;2发送响应给客户端。</li><li>客户端使用Protocol Buffers反序列化响应数据，并处理结果。</li></ul><ol><li>通信方式</li></ol><ul><li>RPC:远程过程调用,是一种进程间通信方式。双方建立链接后,一个进程可以直接调用另一个进程的函数。</li><li>HTTP:超文本传输协议,是一种客户端和服务器之间的请求-响应模式。客户端发送请求,服务器返回响应,两者连接后立即断开。</li></ul><ol start="2"><li>传输协议</li></ol><ul><li>RPC:可以使用TCP或UDP作为传输协议。</li><li>HTTP:使用TCP作为传输协议。</li></ul><ol start="3"><li>数据格式</li></ol><ul><li>RPC:通常使用自定义的数据格式,比如XML、JSON等。</li><li>HTTP:使用标准的MIME类型,如HTML、XML、JSON、图片等多种格式。</li></ul><ol start="4"><li>连接方式</li></ol><ul><li>RPC:双方在通信期间会持续连接。</li><li>HTTP:采用无连接的传输协议,每次连接后立即断开,下次通信需要重新建立连接。</li></ul><ol start="5"><li>应用场景</li></ol><ul><li>RPC:适用于内部系统集成,提供服务的调用和响应。</li><li>HTTP:适用于Web应用,网页访问和文件传输。</li></ul><p>总结一下</p><ul><li>RPC是一种进程内通信机制,HTTP是一种网络应用协议。</li><li>RPC使用TCP或UDP,HTTP只使用TCP。 </li><li>RPC使用自定义的数据格式,HTTP使用标准MIME类型。</li><li>RPC是持续连接,HTTP是短连接。</li><li>RPC用于内部集成,HTTP用于Web应用。</li></ul><p>伊对</p><ol><li>项目，活动营销平台，感觉没有什么技术难点。。。</li><li>slice 底层实现是什么，源代码里面有哪些结构，是否是线程安全的</li><li>sync.map 怎么实现的？为什么他是线程安全的，做了哪些处理</li><li>redis zset，是什么数据结构，redis怎么存的</li><li>redis 大key问题？</li><li>mysql 慢查询怎么解决？除了索引（创建合适的索引和修改语句）+数据量 还有哪些方法？</li><li>go 内存泄漏？ 哪些情况会产生内存泄漏<ol><li>内存泄漏可能是因为长期运行的后台服务，或者是因为对象没有被适当地清理。</li><li>比如写入超过channel缓冲区间的 goroutine，但是没有人消费，后续写入全部阻塞</li><li>比如读取channel数据时，由于写入端已经执行完毕，造成饥饿阻塞</li><li>多个协程由于通信问题造成死锁</li><li>某些链接句柄采用了无限循环的方式来保证链接成功<br> 解决方法：</li><li>检查代码中是否有全局变量或长生命周期对象持有小对象的引用，导致小对象不能被垃圾回收。  </li><li>确保使用了智能指针（如<code>sync.Pool</code>）来管理共享资源的生命周期。</li><li>使用工具如<code>go tool pprof</code>分析内存使用情况，找出内存泄漏的位置。</li><li>定期重启服务以清理内存中的无用数据。</li><li>如果使用了第三方库，确保它们在使用后释放所有资源。</li><li>在代码中使用<code>defer</code>语句释放资源，如文件句柄、数据库连接等。</li><li>如果可能，使用上下文（Context）管理和取消长时间运行的操作，以便在操作完成前取消，释放资源。</li></ol></li></ol><p>题：283 移动0 改为 移动target；移动至末尾改为移动至前面</p><p>给定一个字符串str，返回字符串中字母顺序最大的而且同时在字符串中出现大写和小写的字母。 如果不存在这样的字母，返回‘~‘。<br>请返回大写字母<br>|str|&lt;&#x3D;1000<br>‘aAbBcD’ 返回 B</p><p>leetcode 931</p><p>需要自己写输入输出</p><h3 id="昆仑万维"><a href="#昆仑万维" class="headerlink" title="昆仑万维"></a>昆仑万维</h3><ol><li>gc流程？gc触发时机？</li><li>channel底层实现？</li><li>mutex底层实现？ 自旋？</li><li>mysql 多主多从？</li><li>raft协议，怎么同步日志？脑裂？怎么解决？</li><li>Kafka 为什么不支持读写分离？</li></ol><p>leet 71<br>leet 三数之和</p><p>Go channel mutex map slice 源码解析 check<br>Go gc gmp check<br>mysql B+树<br>redis raft<br>kafka<br>elasticsearch<br>etcd<br>grpc<br>zookeeper</p><p>微服务拆分。服务治理（服务发现，管理配置？流量控制，日志监控？容错容灾？）<br>网络协议：tcp&#x2F;ip，http，</p><p>区块链<br>1.接口加密怎么做<br>2.https是安全的么？<br>3.map为什么是线程不安全的，添加kv的流程是怎么样的？<br>4.channel区满，剩下阻塞状态的 routine 是怎么调度的？<br>5.redis 大key<br>6.go内存对齐<br>7.mysql B+树<br>8.雪崩，穿透（互斥锁 + 空缓存；布隆，但是怎么给所有接口加？）是什么？怎么解决？<br>9.kafka为什么读取比较快？<br>10.10个G的手机号，内存1G，怎么排序？</p><p>newstart 做企业erp的，说是tob但是有点像外包了<br>1.go for 和 for range 有什么区别？哪个好？<br>2.go context 过期、复制<br>3.go slice底层有哪些结构？ 扩容怎么扩的<br>4.做工资报表，有一批人员，有一批第三方考勤数据，有一批历史工资数据。你会怎么设计数据库？</p><p>区块链<br>接口怎么加密？可以用类似 sign ，对接口参数前后端同时加密对比<br>https 安全么？抓包？<br>k8s 崩溃了 有什么恢复手段？自动重启靠什么？<br>map 为什么线程不安全？ 扩容不是原子性<br>channel 10缓冲区，100 协程，写满了以后，阻塞的协程会被调度到哪里？归谁管？<br>redis 大key 问题。kv 中的 v 大，主因还是在于 redis 中 string 类型是用 sds 结构存储，最大一块内存区是 128k，更大的 value 会造成不连续的磁盘存储，影响取值速度；另一个会影响io，但相对不是主要原因<br>kafka 为什么会快呢？因为他的存储是在一段连续的区域<br>go 内存对齐<br>tidb 用的底层是啥？<br>mysql b+树，叶子节点存在哪里<br>缓存雪崩？<br>击穿怎么解决？<br>10个G的手机号文件，内存1个G，怎么排序？：拆文件，然后可以根据手机号特性，排序第一位第二位，分别放到不同的文件内</p><p>阿里：<br>1.服务拆分 原则 为什么要拆 方法论  颗粒度的粗细 数据一致性 上线之后遇到的问题<br>2.mongo mysql tidb 有什么优劣<br>3.kafka pulsuar 有什么优劣<br>4.数据库迁移遇到过哪些问题 怎么解决的<br>5.幂等 如何设计<br>6.给一个视频评论页面，数据库如何设计 索引 缓存<br>7.二分查找一个小于X的最大数<br>8.ES的原理</p><p>conviva:<br>1.网址敲了之后会发生什么<br>2.为什么用tidb<br>3.数据统计怎么做的<br>4.算法题 有向无环图求经过三个点的路径总数</p><p>旷视：<br>1.写一个结构体的快排<br>2.append的第二个参数是什么<br>3.append了之后会发生什么<br>3.用var 初始化一个slice 容量有多大 占多少字节<br>4.随机写一个leetcode中等难度的题</p><p>作业帮<br>1.讲项目，问了问活动数据<br>2.压力测试怎么做的<br>3.怎么避免高并发的请求到数据库（我讲了缓存）<br>4.数据迁移怎么做的？<br>5.算法题：不重叠的区间<br>6.go interface 能不能比较？<br>7.go 协程为什么快？</p><p>海纳AI<br>1.打开文件 应该是打开了才关，没打开不用关<br>2.for range 是复制出来的<br>3.协程传参<br>4.你写代码的层级架构是什么样<br>5.update where 如果没有索引会发生什么 跟隔离级别有关系吗<br>6.如何保证数据库和缓存的一致性：<br>    读缓存失败读sql的时候同时更新缓存<br>    对于更新频繁且一致性要求高的场景：更新时先更新缓存，再同步更新sql<br>    更新频繁但是一致性要求低：优先更新缓存，异步更新sql<br>    事务方式双写<br>    使用乐观锁 + 版本控制<br>7.缓存雪崩的解决办法<br>8.限流是怎么做的 令牌桶算法 有什么特点<br>    控制请求速率<br>    定时生成令牌，请求需要拿取令牌来执行<br>    漏桶算法：未满入桶，定速漏出来执行<br>9.假设有一场几十万人的在线考试，如何做到数据持久化数据一致性和高可用<br>10.什么是k8s的hpa<br>11.这种场景下redis和数据库的一致性<br>12.假如有一个表有几百个字段 这时候怎么办</p><p>进程，线程，协程的区别<br>进程间怎么通信<br>http，socket，rpc 概念和区别？优缺点<br>微服务怎么分的</p><p>n个数，任取 0-k 个求和，求有多少种可能的结果</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 实录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ETCD 面试必备</title>
      <link href="/interview/distribution/etcd/"/>
      <url>/interview/distribution/etcd/</url>
      
        <content type="html"><![CDATA[<p>etcd分布式锁的实现流程</p><ol><li><p>建立连接<br>客户端连接 etcd，以 &#x2F;etcd&#x2F;lock 为前缀创建全局唯一的 key， 假设第一个客户端对应的 key&#x3D;“&#x2F;etcd&#x2F;lock&#x2F;UUID1”，第二个为 key&#x3D;“&#x2F;etcd&#x2F;lock&#x2F;UUID2”； 客户端分别为自己的 key 创建租约 - Lease，租约的长度根据业务耗时确定；</p></li><li><p>创建定时任务作为租约的“心跳”<br>当一个客户端持有锁期间，其它客户端只能等待，为了避免等待期间租约失效， 客户端需创建一个定时任务作为“心跳”进行续约。此外，如果持有锁期间客户端崩溃， 心跳停止，key 将因租约到期而被删除，从而锁释放，避免死锁；</p></li><li><p>客户端将自己全局唯一的 key 写入 etcd<br>执行 put 操作，将步骤 1 中创建的 key 绑定租约写入 Etcd，根据 Etcd 的 Revision 机制， 假设两个客户端 put 操作返回的 Revision 分别为 1、2，客户端需记录 Revision 用以 接下来判断自己是否获得锁；</p></li><li><p>客户端判断是否获得锁<br>客户端以前缀 &#x2F;etcd&#x2F;lock&#x2F; 读取 key-Value 列表，判断自己 key 的 Revision 是否为当前列表中 最小的，如果是则认为获得锁；否则监听列表中前一个 Revision 比自己小的 key 的删除事件，一旦监听到删除事件或者因租约失效而删除的事件，则自己获得锁；</p></li><li><p>执行业务<br>获得锁后，操作共享资源，执行业务代码</p></li><li><p>释放锁<br>完成业务流程后，删除对应的key释放锁</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 必看必会 </tag>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 面试必备</title>
      <link href="/interview/distribution/kafka/"/>
      <url>/interview/distribution/kafka/</url>
      
        <content type="html"><![CDATA[<h5 id="Kafka-线上消息积压怎么解决"><a href="#Kafka-线上消息积压怎么解决" class="headerlink" title="Kafka 线上消息积压怎么解决"></a>Kafka 线上消息积压怎么解决</h5><ol><li>消费端拿到的消息并发消耗掉</li><li>转发到一个新的队列</li></ol><h5 id="kafka-消息重复消费？怎么解决？"><a href="#kafka-消息重复消费？怎么解决？" class="headerlink" title="kafka 消息重复消费？怎么解决？"></a>kafka 消息重复消费？怎么解决？</h5><ol><li>如果发送端使用了重试机制，由于网络原因没有收到发送成功的 ACK</li><li>消费者手动提交 offset，拉取一批数据，没有执行完但是服务宕机，这部分会再次拉出来执行<br>解决方法：幂等处理，自动提交</li></ol><h5 id="Kafka-消息丢失？怎么解决？"><a href="#Kafka-消息丢失？怎么解决？" class="headerlink" title="Kafka 消息丢失？怎么解决？"></a>Kafka 消息丢失？怎么解决？</h5><p>学习 kafka 呢需要明确几个概念<br>生产者发送消息到 broker 中某一个 topic 的具体分区里，消费者从一个或多个分区中拉取数据进行消费</p><p>这里整理了 Kafka 的一些关键术语：</p><ul><li>Producer：生产者，消息产生和发送端。</li><li>Broker：Kafka 实例，多个 broker 组成一个 Kafka 集群，通常一台机器部署一个 Kafka 实例，一个实例挂了不影响其他实例。</li><li>Consumer：消费者，拉取消息进行消费。 一个 topic 可以让若干个消费者进行消费，若干个消费者组成一个 Consumer Group 即消费组，一条消息只能被消费组中一个 Consumer 消费。</li><li>Topic：主题，服务端消息的逻辑存储单元。一个 topic 通常包含若干个 Partition 分区。</li><li>Partition：topic 的分区，分布式存储在各个 broker 中， 实现发布与订阅的负载均衡。若干个分区可以被若干个 Consumer 同时消费，达到消费者高吞吐量。一个分区拥有多个副本（Replica），这是Kafka在可靠性和可用性方面的设计，后面会重点介绍。</li><li>message：消息，或称日志消息，是 Kafka 服务端实际存储的数据，每一条消息都由一个 key、一个 value 以及消息时间戳 timestamp 组成。</li><li>offset：偏移量，分区中的消息位置，由 Kafka 自身维护，Consumer 消费时也要保存一份 offset 以维护消费过的消息位置。</li></ul><p>消费队列呢一般用来实现 同步到异步的转换，削峰，解耦 等目标</p><h5 id="kafka-设计特性"><a href="#kafka-设计特性" class="headerlink" title="kafka 设计特性"></a>kafka 设计特性</h5><ul><li>高吞吐、低延迟：kakfa 最大的特点就是收发消息非常快，kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒。</li><li>高伸缩性： 每个主题(topic) 包含多个分区(partition)，主题中的分区可以分布在不同的主机(broker)中。</li><li>持久性、可靠性： Kafka 能够允许数据的持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，Kafka 底层的数据存储是基于 Zookeeper 存储的，Zookeeper 我们知道它的数据能够持久存储。</li><li>容错性： 允许集群中的节点失败，某个节点宕机，Kafka 集群能够正常工作</li><li>高并发： 支持数千个客户端同时读写</li></ul><h2 id="Kafka-方案及其痛点"><a href="#Kafka-方案及其痛点" class="headerlink" title="Kafka 方案及其痛点"></a>Kafka 方案及其痛点</h2><p>之前，我们采用 Apache Kafka 作为消息平台， 为了让业务在高峰期（晚上八点到十点）不受影响，我们根据消息业务量的大小， 分别搭建了不同的集群。对于一些业务场景的需求， 比如需要重置 offset 来消费过去几天的消息，使用 Kafka 需要停掉消费者才可以进行， 这种方式对大量在线业务非常不利，只能采用重写消息或者一些不太灵活的方式来实现， 极大降低了使用体验。</p><p>我们在使用 Kafka 集群过程中，主要遇到以下问题：  </p><ol><li>Kafka 没有租户概念，需要手动维护多个集群，不方便运维。</li><li>Kafka 集群扩容后需要做 Reassign Partitions，IO 消耗大。</li><li>Kafka 监控体系不完善，排查问题较为繁琐。</li><li>在线业务消息重置不方便，实现起来较为麻烦，需要停掉消费组。</li><li>Kafka 不支持死信队列和延迟队列。</li><li>Kafka 没有官方维护和支持的 Go 语言客户端。</li><li>在 Kafka 中支持 schema，需要引入额外组件，不方便维护。</li></ol><h2 id="为什么选择-Pulsar"><a href="#为什么选择-Pulsar" class="headerlink" title="为什么选择 Pulsar"></a>为什么选择 Pulsar</h2><ul><li>Pulsar 采用云原生的架构，存储和计算分离。</li><li>Pulsar 支持多租户，我们可以按照不同的业务线、业务小组和对应的服务级别来管理消息保存时间、持久化、堆积清除策略等，统一维护一套 Pulsar 集群。</li><li>Pulsar 支持灵活的水平扩容。当存储不够时，直接增加 bookie 进行扩容，不会对用户产生任何影响。</li><li>Pulsar 自带监控体系，broker，bookie 相关指标清晰，方便快速定位问题，给出解决方案。</li><li>Pulsar cursor 方便重置消息，给业务带来很好的体验。</li><li>Pulsar 支持死信队列和延迟队列。</li><li>Pulsar schema 集成在 broker 中，不需要引入单独的组件。Golang client 支持 schema，减少了维护成本。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 必看必会 </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang语言面试题 - Grpc</title>
      <link href="/interview/go/go-grpc/"/>
      <url>/interview/go/go-grpc/</url>
      
        <content type="html"><![CDATA[<h3 id="grpc和http区别"><a href="#grpc和http区别" class="headerlink" title="grpc和http区别"></a>grpc和http区别</h3><p>gRPC和HTTP的主要区别在于它们的传输协议、序列化和反序列化方法、性能特性以及使用场景。具体如下：</p><ul><li>传输协议不同。gRPC使用基于二进制的HTTP&#x2F;2作为传输协议，支持多路复用、头部压缩和服务器推送等功能，提高了性能和效率，而HTTP通常使用文本协议，基于HTTP&#x2F;1.1或HTTP&#x2F;2，HTTP&#x2F;1.1是基于请求-响应模式的协议，每次请求都需要建立新的连接，HTTP&#x2F;2引入了多路复用和头部压缩等功能。</li><li>序列化和反序列化方法不同。gRPC使用Protocol Buffers（protobuf）作为默认的接口定义语言（IDL），用于描述数据结构和服务接口，protobuf是一种高效的二进制序列化格式，可以提供更小的数据包大小和更快的序列化&#x2F;反序列化速度，而HTTP使用普通文本格式进行数据交换，通常使用JSON或XML作为数据的表示格式。</li><li>性能特性不同。gRPC在性能方面优于HTTP，由于使用了二进制格式，因此传输速度更快、更稳定，而且gRPC通过使用连接池，实现客户端与服务端的长连接机制，使得延迟较低，在高网络带宽时表现更好，而HTTP设计目标是作为一种通用的、可扩展的协议，用于在客户端和服务器之间传输超文本数据，广泛用于Web应用程序和浏览器之间的通信。</li><li>使用场景不同。gRPC通常用于服务之间的通信，特别是分布式系统中，例如微服务框架等，具有高性能、低延迟、易扩展等特点，是一个理想的分布式系统通信协议，而HTTP主要用于Web中浏览器和服务器之间的交互，在Web应用程序中非常常见。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> go </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go语言 Slice 结构的底层实现</title>
      <link href="/golang/advanced-tutorial/go-slice/"/>
      <url>/golang/advanced-tutorial/go-slice/</url>
      
        <content type="html"><![CDATA[<h4 id="append-性能损耗"><a href="#append-性能损耗" class="headerlink" title="append 性能损耗"></a>append 性能损耗</h4><p>未指定长度或者长度不足时，双倍扩容（cap &lt; 1024）; 1.25倍扩容(cap &gt; 1024)。把元内存空间的数据拷贝过来，然后在新的内存空间继续append数据</p><p>在 Go 1.18 以后，扩容使用threshold为临界点（源码中设置为256）<br>当slice容量 &lt; 256时， 每次扩容为原来的两倍。当slice容量 &gt; 256时， 每次增加(oldcap + 3*threshold) 3&#x2F;4</p><h4 id="母子切片共享内存问题"><a href="#母子切片共享内存问题" class="headerlink" title="母子切片共享内存问题"></a>母子切片共享内存问题</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slicem := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>) <span class="comment">// len = 3, cap = 5 分配了5个空间，置入了3个数据</span></span><br><span class="line">slices := slicem[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">// len = 2, cap = 4</span></span><br></pre></td></tr></table></figure><p>最开始时，子切片和母切片共享母切片的内存空间，对子切片的修改会反映到母切片上，对子切片的 append 操作，会将数据添加到母切片预留的内存空间内。<br>如持续进行 append 操作，直到将母切片预留的内存空间完全消耗完毕后，二者就会发生内存分离，从此再无关系</p><h4 id="切片导致内存泄漏"><a href="#切片导致内存泄漏" class="headerlink" title="切片导致内存泄漏"></a>切片导致内存泄漏</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Leak</span><span class="params">()</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">parent := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">son := parent[<span class="number">10</span>:<span class="number">20</span>]</span><br><span class="line"><span class="keyword">return</span> son</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>func 返回子切片，只要这个子切片没有被 GC 回收，子切片持有的母切片的内存空间就得不到释放，导致泄漏</p><h4 id="函数参数需要用切片指针么"><a href="#函数参数需要用切片指针么" class="headerlink" title="函数参数需要用切片指针么"></a>函数参数需要用切片指针么</h4><p>如果函数内部需要对切片的 len 和 cap 进行修改，且修改要反映在函数外部，那么需要传入切片的指针</p><h4 id="一边遍历一边修改切片"><a href="#一边遍历一边修改切片" class="headerlink" title="一边遍历一边修改切片"></a>一边遍历一边修改切片</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// go 中 for-range 遍历的是原集合的拷贝</span></span><br><span class="line"><span class="keyword">for</span> i, m := <span class="keyword">range</span> arr &#123;</span><br><span class="line">m += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下方这种才能修改成功</span></span><br><span class="line"><span class="keyword">for</span> i, m := <span class="keyword">range</span> arr &#123;</span><br><span class="line">arr[i] = m + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 进阶教程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> go </tag>
            
            <tag> 必看必会 </tag>
            
            <tag> Slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式23-中介模式</title>
      <link href="/golang/go-design-pattern/gda-act/23-mediator/"/>
      <url>/golang/go-design-pattern/gda-act/23-mediator/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式22-解释器模式</title>
      <link href="/golang/go-design-pattern/gda-act/22-interpreter/"/>
      <url>/golang/go-design-pattern/gda-act/22-interpreter/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式21-命令模式</title>
      <link href="/golang/go-design-pattern/gda-act/21-command/"/>
      <url>/golang/go-design-pattern/gda-act/21-command/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式20-备忘录模式</title>
      <link href="/golang/go-design-pattern/gda-act/20-memento/"/>
      <url>/golang/go-design-pattern/gda-act/20-memento/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式19-访问者模式</title>
      <link href="/golang/go-design-pattern/gda-act/19-visitor/"/>
      <url>/golang/go-design-pattern/gda-act/19-visitor/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式18-迭代器模式</title>
      <link href="/golang/go-design-pattern/gda-act/18-iterator/"/>
      <url>/golang/go-design-pattern/gda-act/18-iterator/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式17-状态模式</title>
      <link href="/golang/go-design-pattern/gda-act/17-state/"/>
      <url>/golang/go-design-pattern/gda-act/17-state/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言 Map 结构的底层实现</title>
      <link href="/golang/advanced-tutorial/go-map/"/>
      <url>/golang/advanced-tutorial/go-map/</url>
      
        <content type="html"><![CDATA[<h2 id="Golang-中的-map-详解"><a href="#Golang-中的-map-详解" class="headerlink" title="Golang 中的 map 详解"></a>Golang 中的 map 详解</h2><h3 id="一、什么是-map？"><a href="#一、什么是-map？" class="headerlink" title="一、什么是 map？"></a>一、什么是 map？</h3><h4 id="1、map-的定义"><a href="#1、map-的定义" class="headerlink" title="1、map 的定义"></a>1、map 的定义</h4><p>  在计算机科学里，被称为相关数组、map、符号表或者字典，是由一组 &lt;key, value&gt; 对组成的抽象数据结构，并且同一个 key 只会出现一次。<br>  两个关键点：map 是由 key-value 对组成的；key 只会出现一次。<br>  map 的设计也被称为 “The dictionary problem（字典问题）”，它的任务是设计一种数据结构用来维护一个集合的数据，并且可以同时对集合进行增删查改的操作。</p><h4 id="2、map-的数据结构"><a href="#2、map-的数据结构" class="headerlink" title="2、map 的数据结构"></a>2、map 的数据结构</h4><p>  最主要的数据结构有两种：哈希查找表（Hash table）、搜索树（Search tree）。</p><p>哈希查找表（Hash table）<br>  哈希查找表使用哈希函数将 key 分配到不同的桶（bucket，也就是数组的不同 index），开销主要在哈希函数的计算以及数组的常数访问时间，在很多场景下，哈希查找表的性能很高。</p><p>搜索树（Search tree）<br>  搜索树一般采用自平衡搜索树，包括：AVL 树，红黑树。<br>  哈希查找表的平均查找效率是 O(1)，最差是 O(N)，如果哈希函数设计的很好，最坏的情况基本不会出现。自平衡搜索树法的最差搜索效率是 O(logN)。遍历自平衡搜索树，返回的 key 序列，一般会按照从小到大的顺序；而哈希查找表则是乱序的。</p><h3 id="二、Golang-中-map-的类型"><a href="#二、Golang-中-map-的类型" class="headerlink" title="二、Golang 中 map 的类型"></a>二、Golang 中 map 的类型</h3><p>  Golang 中 map 是一个指针，占用 8 个字节。当使用 make 创建 map 时，底层调用的是 makemap() 函数，makemap() 函数返回的是一个指针，因为返回的是指针，所以 map 作为参数的时候，函数内部能修改map。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="三、map-的底层实现"><a href="#三、map-的底层实现" class="headerlink" title="三、map 的底层实现"></a>三、map 的底层实现</h3><p>   源码位于 src\runtime\map.go 中。</p><p>  golang 中 map 底层使用的是哈希查找表，用链表来解决哈希冲突。每个 map 的底层结构是 hmap，是由若干个结构为 bmap 的 bucket 组成的数组，每个 bucket 底层都采用链表结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.  </span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;  </span><br><span class="line"><span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.   </span></span><br><span class="line"><span class="comment">// Make sure this stays in sync with the compiler&#x27;s definition.   </span></span><br><span class="line">count     <span class="type">int</span>    <span class="comment">// map中元素的数量，调用len()直接返回此值  </span></span><br><span class="line">flags     <span class="type">uint8</span>  <span class="comment">// 状态标识符，key和value是否包指针、是否正在扩容、是否已经被迭代</span></span><br><span class="line">B         <span class="type">uint8</span>  <span class="comment">// map中桶数组的数量，桶数组的长度的对数，len(buckets) == 2^B，可以最多容纳 6.5 * 2 ^ B 个元素，6.5为装载因子  </span></span><br><span class="line">noverflow <span class="type">uint16</span> <span class="comment">// 溢出桶的大概数量，当B小于16时是准确值，大于等于16时是大概的值</span></span><br><span class="line">hash0     <span class="type">uint32</span> <span class="comment">// 哈希种子，用于计算哈希值，为哈希函数的结果引入一定的随机性</span></span><br><span class="line"></span><br><span class="line">buckets    unsafe.Pointer <span class="comment">// 指向桶数组的指针，长度为 2^B ，如果元素个数为0，就为 nil  </span></span><br><span class="line">oldbuckets unsafe.Pointer <span class="comment">// 指向一个旧桶数组，用于扩容，它的长度是当前桶数组的一半, 扩容时非空  </span></span><br><span class="line">nevacuate  <span class="type">uintptr</span>        <span class="comment">// 搬迁进度，小于此地址的桶数组迁移完成  </span></span><br><span class="line"></span><br><span class="line">extra *mapextra <span class="comment">// 可选字段，用于gc，指向所有的溢出桶，避免gc时扫描整个map，仅扫描所有溢出桶就足够了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mapextra holds fields that are not present on all maps.type </span></span><br><span class="line">mapextra <span class="keyword">struct</span> &#123;  </span><br><span class="line">   <span class="comment">// If both key and elem do not contain pointers and are inline, then we mark bucket  </span></span><br><span class="line">   <span class="comment">// type as containing no pointers. This avoids scanning such maps.  </span></span><br><span class="line">   <span class="comment">// However, bmap.overflow is a pointer. In order to keep overflow buckets   </span></span><br><span class="line">   <span class="comment">// alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow.   </span></span><br><span class="line">   <span class="comment">// overflow and oldoverflow are only used if key and elem do not contain pointers.   </span></span><br><span class="line">   <span class="comment">// overflow contains overflow buckets for hmap.buckets.  </span></span><br><span class="line">   <span class="comment">// oldoverflow contains overflow buckets for hmap.oldbuckets.  </span></span><br><span class="line">   <span class="comment">// The indirection allows to store a pointer to the slice in hiter.  </span></span><br><span class="line">   overflow    *[]*bmap  <span class="comment">// 指针数组，指向所有溢出桶</span></span><br><span class="line">   oldoverflow *[]*bmap  <span class="comment">// 指针数组，发生扩容时，指向所有旧的溢出桶</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// nextOverflow holds a pointer to a free overflow bucket.  </span></span><br><span class="line">   nextOverflow *bmap  <span class="comment">// 指向所有溢出桶中下一个可以使用的溢出桶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bmap的结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [bucketCnt]<span class="type">uint8</span>    <span class="comment">// bucketCnt=8，// 存放key哈希值的高8位，用于决定kv键值对放在桶内的哪个位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上编辑期间会动态生成一个新的结构体</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">topbits  [<span class="number">8</span>]<span class="type">uint8</span>     <span class="comment">// 存放key哈希值的高8位，用于决定kv键值对放在桶内的哪个位置</span></span><br><span class="line">keys     [<span class="number">8</span>]keytype   <span class="comment">// 存放key的数组</span></span><br><span class="line">values   [<span class="number">8</span>]valuetype <span class="comment">// 存放value的数组</span></span><br><span class="line">pad      <span class="type">uintptr</span>      <span class="comment">// 用于对齐内存</span></span><br><span class="line">overflow <span class="type">uintptr</span>      <span class="comment">// 指向下一个桶，即溢出桶，拉链法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  buckets是一个bmap数组，数组的长度就是 2^B。每个bucket固定包含8个key和value，实现上面是一个固定的大小连续内存块，分成四部分：tophash 值，8个key值，8个value值，指向下个bucket的指针。</p><p>  tophash 值用于快速查找key是否在该bucket中，当插入和查询运行时都会使用哈希哈数对key做哈希运算，获取一个hashcode，取高8位存放在bmap tophash字段中。</p><p>  桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置）。</p><p>  如图，B&#x3D;5 表示hmap的有2^5&#x3D;32个bmap，buckets是一个bmap数组，其长度为32，每个bmap有8个key。</p><p>  桶结构的很多字段得在编译时才会动态生成，比如 key 和 values 等</p><p>  桶结构中，之所以所有的 key 放一起，所有的 value 放一起，而不是 key&#x2F;value 一对对的一起存放，目的便是在某些情况下可以省去pad字段，节省内存空间。由于内存对齐的原因，key0&#x2F;value0&#x2F;key1&#x2F;value1… 这样的形式可能需要更多的补齐空间，比如 map[int64]int8 ，1字节的value后面需要补齐7个字节才能保证下一个key是 int64 对齐的。</p><p>  golang中的map使用的内存是不会收缩的，只会越用越多。</p><p>  每个 bucket 设计成最多只能放 8 个 key-value 对，如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个溢出桶 bucket ，通过 overflow 指针连接起来。</p><h3 id="四、map-的扩容"><a href="#四、map-的扩容" class="headerlink" title="四、map 的扩容"></a>四、map 的扩容</h3><h4 id="1、装载因子（平均每个桶存储的元素个数）"><a href="#1、装载因子（平均每个桶存储的元素个数）" class="headerlink" title="1、装载因子（平均每个桶存储的元素个数）"></a>1、装载因子（平均每个桶存储的元素个数）</h4><p>  Go的装载因子阈值常量：6.5，map 最多可容纳 6.5*2^B 个元素。</p><p>  装载因子等于 map中元素的个数 &#x2F; map的容量，即len(map) &#x2F; 2^B。装载因子用来表示空闲位置的情况，装载因子越大，表明空闲位置越少，冲突也越多。随着装载因子的增大，哈希表线性探测的平均用时就会增加，这会影响哈希表的性能，当装载因子大于70%，哈希表的性能就会急剧下降，当装载因子达到100%，整个哈希表就会完全失效，这个时候，查找和插入任意元素的复杂度都是O(N),因为需要遍历所有元素。</p><p>  另外装载因子与扩容、迁移等重新散列(rehash) 行为有直接关系：</p><p>在程序运行时，会不断地进行插入、删除等，会导致 bucket 不均，内存利用率低，需要迁移。<br>在程序运行时，出现装载因子过大，需要做扩容，解决 bucket 过大的问题。<br>为什么装载因子是6.5？不是8？不是1？<br>  装载因子是哈希表中的一个重要指标，主要目的是为了平衡 buckets 的存储空间大小和查找元素时的性能高低。实际上这是 Go 官方的经过认真的测试得出的数字，一起来看看官方的这份测试报告。包含四个指标：</p><p>loadFactor：负载因子，也叫装载因子；<br>%overflow：溢出率，有溢出 bukcet 的百分比；<br>bytes&#x2F;entry：平均每对 key&#x2F;alue 的开销字节数；<br>hitprobe：查找一个存在的 key 时，要查找的平均个数；<br>missprobe：查找一个不存在的 key 时，要查找的平均个数。</p><p>  Go 官方发现：装载因子越大，填入的元素越多，空间利用率就越高，但发生冲突的几率就变大；反之，装数因子越小，填入的元素越少，冲突发生的几率减小，但空间利用率低，而且还会提高扩容操作的次数。</p><p>  根据这份测试结果和讨论，Go 官方取了一个相对适中的值，把 Go 中的 map 的负数因子硬编码为 6.5，这就是 6.5 的选择缘由。这意味着在 Go 语言中，当 map存储的元素个数大于或等于 6.5*桶个数 时，就会发扩容行为。</p><h4 id="2、触发-map-扩容的时机（插入、删除key）"><a href="#2、触发-map-扩容的时机（插入、删除key）" class="headerlink" title="2、触发 map 扩容的时机（插入、删除key）"></a>2、触发 map 扩容的时机（插入、删除key）</h4><p>当装载因子超过6.5时，扩容一倍，属于增量扩容；<br>当使用的溢出桶过多时，重新分配一样大的内存空间，属于等量扩容；<br>（实际上没有扩容，主要是为了回收空闲的溢出桶，节省空间，提高 map 的查找和插入效率）<br>为什么会出现这种情况？<br>  这种情况可能是因为map删除的特性导致的。当我们不断向哈希表中插入数据，并且将他们又全部删除时，其内存占用并不会减少，因为删除只是将桶对应位置的tophash置nil而已。<br>  这种情况下，就会不断的积累溢出桶造成内存泄露，为了解决这种情况，采用了等量扩容的机制，一旦哈希表中出现了过多的溢出桶，会创建新桶保存数据，gc会清理掉老的溢出桶，从而避免内存泄露。</p><p>如何定义溢出桶是否太多需要等量扩容呢？两种情况：</p><p>当B小于15时，溢出桶的数量超过2^B，属于溢出桶数量太多，需要等量扩容；<br>当B大于等于15时，溢出桶数量超过2^15，属于溢出桶数量太多，需要等量扩容。</p><h4 id="3、扩容策略（怎么扩容？）"><a href="#3、扩容策略（怎么扩容？）" class="headerlink" title="3、扩容策略（怎么扩容？）"></a>3、扩容策略（怎么扩容？）</h4><p>  Go 会创建一个新的 buckets 数组，新的 buckets 数组的容量是旧buckets数组的两倍（或者和旧桶容量相同），将原始桶数组中的所有元素重新散列到新的桶数组中。这样做的目的是为了使每个桶中的元素数量尽可能平均分布，以提高查询效率。旧的buckets数组不会被直接删除，而是会把原来对旧数组的引用去掉，让GC来清除内存。</p><p>  在map进行扩容迁移的期间，不会触发第二次扩容。只有在前一个扩容迁移工作完成后，map才能进行下一次扩容操作。</p><h4 id="4、搬迁策略"><a href="#4、搬迁策略" class="headerlink" title="4、搬迁策略"></a>4、搬迁策略</h4><p>  由于map扩容需要将原有的kv键值对搬迁到新的内存地址，如果一下子全部搬完，会非常的影响性能。go 中 map 的扩容采用渐进式的搬迁策略，原有的 key 并不会一次性搬迁完毕，一次性搬迁会造成比较大的延时，每次最多只会搬迁 2 个 bucket，将搬迁的O(N)开销均摊到O(1)的赋值和删除操作上。</p><p>  上面说的 hashGrow() 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets 挂到了 oldbuckets 字段上。真正搬迁 buckets 的动作在 growWork() 函数中，而调用 growWork() 函数的动作是在 mapassign 和 mapdelete 函数中。也就是插入或修改、删除 key 的时候，都会尝试进行搬迁 buckets 的工作。先检查 oldbuckets 是否搬迁完毕，具体来说就是检查 oldbuckets 是否为 nil。</p><h3 id="五、解决哈希冲突"><a href="#五、解决哈希冲突" class="headerlink" title="五、解决哈希冲突"></a>五、解决哈希冲突</h3><h4 id="1、开放寻址法"><a href="#1、开放寻址法" class="headerlink" title="1、开放寻址法"></a>1、开放寻址法</h4><p>  如果发生哈希冲突，从发生冲突的那个单元起，按一定的次序，不断重复，从哈希表中寻找一个空闲的单元，将该键值对存储在该单元中。具体的实现方式包括线性探测法、平方探测法、随机探测法和双重哈希法等。开放寻址法需要的表长度要大于等于所需要存放的元素数量。</p><h4 id="2、链地址法"><a href="#2、链地址法" class="headerlink" title="2、链地址法"></a>2、链地址法</h4><p>  基于数组 + 链表 实现哈希表，数组中每个元素都是一个链表，将每个桶都指向一个链表，当哈希冲突发生时，新的键值对会按顺序添加到该桶对应的链表的尾部。在查找特定键值对时，可以遍历该链表以查找与之匹配的键值对。</p><h4 id="3、两种方案的比较"><a href="#3、两种方案的比较" class="headerlink" title="3、两种方案的比较"></a>3、两种方案的比较</h4><p>内存利用率<br>  对于链地址法，基于 数组 + 链表 进行存储，链表节点可以在需要时再创建，开放寻址法需要事先申请好足够内存，因此链地址法对内存的利用率高。<br>适用场景<br>  链地址法对装载因子的容忍度会更高，适合存储大对象、大数据量的哈希表，而且相较于开放寻址法，它更加灵活，支持更多的优化策略，比如可采用红黑树代替链表。但是链地址法需要额外的空间来存储指针。<br>  对于开放寻址法，它只有数组一种数据结构就可完成存储，继承了数组的优点，对CPU缓存友好，易于序列化操作，但是它对内存的利用率不高，且发生冲突时代价更高。当数据量明确、装载因子小，适合采用开放寻址法。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 进阶教程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> go </tag>
            
            <tag> 必看必会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式16-职责链模式</title>
      <link href="/golang/go-design-pattern/gda-act/16-chain/"/>
      <url>/golang/go-design-pattern/gda-act/16-chain/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式15-策略模式</title>
      <link href="/golang/go-design-pattern/gda-act/15-strategy/"/>
      <url>/golang/go-design-pattern/gda-act/15-strategy/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式14-模板模式</title>
      <link href="/golang/go-design-pattern/gda-act/14-template/"/>
      <url>/golang/go-design-pattern/gda-act/14-template/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式13-观察者模式</title>
      <link href="/golang/go-design-pattern/gda-act/13-observer/"/>
      <url>/golang/go-design-pattern/gda-act/13-observer/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式12-享元模式</title>
      <link href="/golang/go-design-pattern/gda-struct/12-flyweight/"/>
      <url>/golang/go-design-pattern/gda-struct/12-flyweight/</url>
      
        <content type="html"><![CDATA[<p>按照课程中的例子来理解，就是象棋棋子作为享元，可以被所有的对局共享，以达到减少内存的目的</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式11-组合模式</title>
      <link href="/golang/go-design-pattern/gda-struct/11-composite/"/>
      <url>/golang/go-design-pattern/gda-struct/11-composite/</url>
      
        <content type="html"><![CDATA[<p>比较简单的例子是 人员架构中 部门和人员的关系，二者可以形成简单的树形接口，部门中规定了一些功能；而人员又有自己的基本属性功能</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式10-门面模式</title>
      <link href="/golang/go-design-pattern/gda-struct/10-facade/"/>
      <url>/golang/go-design-pattern/gda-struct/10-facade/</url>
      
        <content type="html"><![CDATA[<p>简单来理解就是 有登录和注册两个基础功能，对外统一封装成 登录&amp;注册，上层调用无需知道具体调用的逻辑，只通过一个接口获取登录状态即可</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式09-适配器模式</title>
      <link href="/golang/go-design-pattern/gda-struct/09-adapter/"/>
      <url>/golang/go-design-pattern/gda-struct/09-adapter/</url>
      
        <content type="html"><![CDATA[<p>简单理解是有两个不同的业务系统，需要同时完成同一种业务动作，可以封装后统一提供给上层调用</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式08-装饰器模式</title>
      <link href="/golang/go-design-pattern/gda-struct/08-decorator/"/>
      <url>/golang/go-design-pattern/gda-struct/08-decorator/</url>
      
        <content type="html"><![CDATA[<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>下面是一个简单的画画的例子，默认的 <code>Line</code>  只有基础的画画功能， <code>ColorLine</code>  为他加上了颜色，本质上是对现有功能类进行包装，增加新功能点</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> decorator  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// IDraw IDraw  </span></span><br><span class="line"><span class="keyword">type</span> IDraw <span class="keyword">interface</span> &#123;  </span><br><span class="line">   Draw() <span class="type">string</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Line 划线  </span></span><br><span class="line"><span class="keyword">type</span> Line <span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Draw Draw  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Line)</span></span> Draw() <span class="type">string</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;Drawing a line here&quot;</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ColorLine 有颜色的线  </span></span><br><span class="line"><span class="keyword">type</span> ColorLine <span class="keyword">struct</span> &#123;  </span><br><span class="line">   line IDraw  </span><br><span class="line">   color  <span class="type">string</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// NewColorLine NewColorLine  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewColorLine</span><span class="params">(line IDraw, color <span class="type">string</span>)</span></span> ColorLine &#123;  </span><br><span class="line">   <span class="keyword">return</span> ColorLine&#123;color: color, line: line&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Draw Draw  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ColorLine)</span></span> Draw() <span class="type">string</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> c.line.Draw() + <span class="string">&quot;, color is &quot;</span> + c.color  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestColorLine_Draw</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">   l := Line&#123;&#125;  </span><br><span class="line">   ncl := NewColorLine(sq, <span class="string">&quot;red&quot;</span>)  </span><br><span class="line">   got := ncl.Draw()  </span><br><span class="line">   assert.Equal(t, <span class="string">&quot;Drawing a line here, color is red&quot;</span>, got)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式07-桥接模式</title>
      <link href="/golang/go-design-pattern/gda-struct/07-bridge/"/>
      <url>/golang/go-design-pattern/gda-struct/07-bridge/</url>
      
        <content type="html"><![CDATA[<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bridge  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// IMsgSender IMsgSender  </span></span><br><span class="line"><span class="keyword">type</span> IMsgSender <span class="keyword">interface</span> &#123;  </span><br><span class="line">   Send(msg <span class="type">string</span>) <span class="type">error</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// EmailMsgSender 发送邮件  </span></span><br><span class="line"><span class="comment">// 可能还有 电话、短信等各种实现  </span></span><br><span class="line"><span class="keyword">type</span> EmailMsgSender <span class="keyword">struct</span> &#123;  </span><br><span class="line">   emails []<span class="type">string</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// NewEmailMsgSender NewEmailMsgSender  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEmailMsgSender</span><span class="params">(emails []<span class="type">string</span>)</span></span> *EmailMsgSender &#123;  </span><br><span class="line">   <span class="keyword">return</span> &amp;EmailMsgSender&#123;emails: emails&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Send Send  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmailMsgSender)</span></span> Send(msg <span class="type">string</span>) <span class="type">error</span> &#123;  </span><br><span class="line">   <span class="comment">// 这里去发送消息  </span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// INotification 通知接口  </span></span><br><span class="line"><span class="keyword">type</span> INotification <span class="keyword">interface</span> &#123;  </span><br><span class="line">   Notify(msg <span class="type">string</span>) <span class="type">error</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ErrorNotification 错误通知  </span></span><br><span class="line"><span class="comment">// 后面可能还有 warning 各种级别  </span></span><br><span class="line"><span class="keyword">type</span> ErrorNotification <span class="keyword">struct</span> &#123;  </span><br><span class="line">   sender IMsgSender  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// NewErrorNotification NewErrorNotification  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewErrorNotification</span><span class="params">(sender IMsgSender)</span></span> *ErrorNotification &#123;  </span><br><span class="line">   <span class="keyword">return</span> &amp;ErrorNotification&#123;sender: sender&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Notify 发送通知  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *ErrorNotification)</span></span> Notify(msg <span class="type">string</span>) <span class="type">error</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> n.sender.Send(msg)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestErrorNotification_Notify</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">   sender := NewEmailMsgSender([]<span class="type">string</span>&#123;<span class="string">&quot;test@test.com&quot;</span>&#125;)  </span><br><span class="line">   n := NewErrorNotification(sender)  </span><br><span class="line">   err := n.Notify(<span class="string">&quot;test msg&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">   assert.Nil(t, err)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式06-代理模式</title>
      <link href="/golang/go-design-pattern/gda-struct/06-proxy/"/>
      <url>/golang/go-design-pattern/gda-struct/06-proxy/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式05-创造者模式总结</title>
      <link href="/golang/go-design-pattern/gda-create/05-create-summarize/"/>
      <url>/golang/go-design-pattern/gda-create/05-create-summarize/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 创建型模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式04-原型模式</title>
      <link href="/golang/go-design-pattern/gda-create/04-prototype/"/>
      <url>/golang/go-design-pattern/gda-create/04-prototype/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 创建型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式03-构造模式</title>
      <link href="/golang/go-design-pattern/gda-create/03-builder/"/>
      <url>/golang/go-design-pattern/gda-create/03-builder/</url>
      
        <content type="html"><![CDATA[<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>其实在 Golang 中对于创建类参数比较多的对象的时候，我们常见的做法是必填参数直接传递，可选参数通过传递可变的方法进行创建。<br>本文会先实现课程中的建造者模式，然后再实现我们常用的方式。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>通过下面可以看到，使用 Go 编写建造者模式的代码其实会很长，这些是它的一个缺点，所以如果不是参数的校验逻辑很复杂的情况下一般我们在 Go 中不会采用这种方式，而会采用后面的另外一种方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> (  </span><br><span class="line">   defaultMaxTotal = <span class="number">10</span>  </span><br><span class="line">   defaultMaxIdle  = <span class="number">9</span>  </span><br><span class="line">   defaultMinIdle  = <span class="number">1</span>  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ResourcePoolConfig resource pooltype ResourcePoolConfig struct &#123;  </span></span><br><span class="line">   name     <span class="type">string</span>  </span><br><span class="line">   maxTotal <span class="type">int</span>  </span><br><span class="line">   maxIdle  <span class="type">int</span>  </span><br><span class="line">   minIdle  <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ResourcePoolConfigBuilder 用于构建 ResourcePoolConfig  </span></span><br><span class="line"><span class="keyword">type</span> ResourcePoolConfigBuilder <span class="keyword">struct</span> &#123;  </span><br><span class="line">   name     <span class="type">string</span>  </span><br><span class="line">   maxTotal <span class="type">int</span>  </span><br><span class="line">   maxIdle  <span class="type">int</span>  </span><br><span class="line">   minIdle  <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// SetName SetName  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span></span> SetName(name <span class="type">string</span>) <span class="type">error</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;name can not be empty&quot;</span>)  </span><br><span class="line">   &#125;  </span><br><span class="line">   b.name = name  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// SetMinIdle SetMinIdle  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span></span> SetMinIdle(minIdle <span class="type">int</span>) <span class="type">error</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> minIdle &lt; <span class="number">0</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;max tatal cannot &lt; 0, input: %d&quot;</span>, minIdle)  </span><br><span class="line">   &#125;  </span><br><span class="line">   b.minIdle = minIdle  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// SetMaxIdle SetMaxIdle  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span></span> SetMaxIdle(maxIdle <span class="type">int</span>) <span class="type">error</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> maxIdle &lt; <span class="number">0</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;max tatal cannot &lt; 0, input: %d&quot;</span>, maxIdle)  </span><br><span class="line">   &#125;  </span><br><span class="line">   b.maxIdle = maxIdle  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// SetMaxTotal SetMaxTotal  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span></span> SetMaxTotal(maxTotal <span class="type">int</span>) <span class="type">error</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> maxTotal &lt;= <span class="number">0</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;max tatal cannot &lt;= 0, input: %d&quot;</span>, maxTotal)  </span><br><span class="line">   &#125;  </span><br><span class="line">   b.maxTotal = maxTotal  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Build Build  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span></span> Build() (*ResourcePoolConfig, <span class="type">error</span>) &#123;  </span><br><span class="line">   <span class="keyword">if</span> b.name == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;name can not be empty&quot;</span>)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 设置默认值  </span></span><br><span class="line">   <span class="keyword">if</span> b.minIdle == <span class="number">0</span> &#123;  </span><br><span class="line">      b.minIdle = defaultMinIdle  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> b.maxIdle == <span class="number">0</span> &#123;  </span><br><span class="line">      b.maxIdle = defaultMaxIdle  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> b.maxTotal == <span class="number">0</span> &#123;  </span><br><span class="line">      b.maxTotal = defaultMaxTotal  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> b.maxTotal &lt; b.maxIdle &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;max total(%d) cannot &lt; max idle(%d)&quot;</span>, b.maxTotal, b.maxIdle)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> b.minIdle &gt; b.maxIdle &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;max idle(%d) cannot &lt; min idle(%d)&quot;</span>, b.maxIdle, b.minIdle)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> &amp;ResourcePoolConfig&#123;  </span><br><span class="line">      name:     b.name,  </span><br><span class="line">      maxTotal: b.maxTotal,  </span><br><span class="line">      maxIdle:  b.maxIdle,  </span><br><span class="line">      minIdle:  b.minIdle,  </span><br><span class="line">   &#125;, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;testing&quot;</span>  </span><br><span class="line">   <span class="string">&quot;github.com/stretchr/testify/assert&quot;</span>   </span><br><span class="line">   <span class="string">&quot;github.com/stretchr/testify/require&quot;</span></span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestResourcePoolConfigBuilder_Build</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">   tests := []<span class="keyword">struct</span> &#123;  </span><br><span class="line">      name    <span class="type">string</span>  </span><br><span class="line">      builder *ResourcePoolConfigBuilder  </span><br><span class="line">      want    *ResourcePoolConfig  </span><br><span class="line">      wantErr <span class="type">bool</span>  </span><br><span class="line">   &#125;&#123;  </span><br><span class="line">      &#123;  </span><br><span class="line">         name: <span class="string">&quot;name empty&quot;</span>,  </span><br><span class="line">         builder: &amp;ResourcePoolConfigBuilder&#123;  </span><br><span class="line">            name:     <span class="string">&quot;&quot;</span>,  </span><br><span class="line">            maxTotal: <span class="number">0</span>,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         want:    <span class="literal">nil</span>,  </span><br><span class="line">         wantErr: <span class="literal">true</span>,  </span><br><span class="line">      &#125;,  </span><br><span class="line">      &#123;  </span><br><span class="line">         name: <span class="string">&quot;maxIdle &lt; minIdle&quot;</span>,  </span><br><span class="line">         builder: &amp;ResourcePoolConfigBuilder&#123;  </span><br><span class="line">            name:     <span class="string">&quot;test&quot;</span>,  </span><br><span class="line">            maxTotal: <span class="number">0</span>,  </span><br><span class="line">            maxIdle:  <span class="number">10</span>,  </span><br><span class="line">            minIdle:  <span class="number">20</span>,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         want:    <span class="literal">nil</span>,  </span><br><span class="line">         wantErr: <span class="literal">true</span>,  </span><br><span class="line">      &#125;,  </span><br><span class="line">      &#123;  </span><br><span class="line">         name: <span class="string">&quot;success&quot;</span>,  </span><br><span class="line">         builder: &amp;ResourcePoolConfigBuilder&#123;  </span><br><span class="line">            name: <span class="string">&quot;test&quot;</span>,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         want: &amp;ResourcePoolConfig&#123;  </span><br><span class="line">            name:     <span class="string">&quot;test&quot;</span>,  </span><br><span class="line">            maxTotal: defaultMaxTotal,  </span><br><span class="line">            maxIdle:  defaultMaxIdle,  </span><br><span class="line">            minIdle:  defaultMinIdle,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         wantErr: <span class="literal">false</span>,  </span><br><span class="line">      &#125;,  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;  </span><br><span class="line">      t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">         got, err := tt.builder.Build()  </span><br><span class="line">         require.Equalf(t, tt.wantErr, err != <span class="literal">nil</span>, <span class="string">&quot;Build() error = %v, wantErr %v&quot;</span>, err, tt.wantErr)  </span><br><span class="line">         assert.Equal(t, tt.want, got)  </span><br><span class="line">      &#125;)  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go-常用的参数传递方法"><a href="#Go-常用的参数传递方法" class="headerlink" title="Go 常用的参数传递方法"></a>Go 常用的参数传递方法</h3><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ResourcePoolConfigOption option</span></span><br><span class="line"><span class="keyword">type</span> ResourcePoolConfigOption <span class="keyword">struct</span> &#123;  </span><br><span class="line">   maxTotal <span class="type">int</span>  </span><br><span class="line">   maxIdle  <span class="type">int</span>  </span><br><span class="line">   minIdle  <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ResourcePoolConfigOptFunc to set option</span></span><br><span class="line"><span class="keyword">type</span> ResourcePoolConfigOptFunc <span class="function"><span class="keyword">func</span><span class="params">(option *ResourcePoolConfigOption)</span></span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// NewResourcePoolConfig NewResourcePoolConfig  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewResourcePoolConfig</span><span class="params">(name <span class="type">string</span>, opts ...ResourcePoolConfigOptFunc)</span></span> (*ResourcePoolConfig, <span class="type">error</span>) &#123;  </span><br><span class="line">   <span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;name can not be empty&quot;</span>)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   option := &amp;ResourcePoolConfigOption&#123;  </span><br><span class="line">      maxTotal: <span class="number">10</span>,  </span><br><span class="line">      maxIdle:  <span class="number">9</span>,  </span><br><span class="line">      minIdle:  <span class="number">1</span>,  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;  </span><br><span class="line">      opt(option)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> option.maxTotal &lt; <span class="number">0</span> || option.maxIdle &lt; <span class="number">0</span> || option.minIdle &lt; <span class="number">0</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;args err, option: %v&quot;</span>, option)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> option.maxTotal &lt; option.maxIdle || option.minIdle &gt; option.maxIdle &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;args err, option: %v&quot;</span>, option)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> &amp;ResourcePoolConfig&#123;  </span><br><span class="line">      name:     name,  </span><br><span class="line">      maxTotal: option.maxTotal,  </span><br><span class="line">      maxIdle:  option.maxIdle,  </span><br><span class="line">      minIdle:  option.minIdle,  </span><br><span class="line">   &#125;, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;testing&quot;</span>  </span><br><span class="line">   <span class="string">&quot;github.com/stretchr/testify/assert&quot;</span>   </span><br><span class="line">   <span class="string">&quot;github.com/stretchr/testify/require&quot;</span></span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNewResourcePoolConfig</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">type</span> args <span class="keyword">struct</span> &#123;  </span><br><span class="line">      name <span class="type">string</span>  </span><br><span class="line">      opts []ResourcePoolConfigOptFunc  </span><br><span class="line">   &#125;  </span><br><span class="line">   tests := []<span class="keyword">struct</span> &#123;  </span><br><span class="line">      name    <span class="type">string</span>  </span><br><span class="line">      args    args  </span><br><span class="line">      want    *ResourcePoolConfig  </span><br><span class="line">      wantErr <span class="type">bool</span>  </span><br><span class="line">   &#125;&#123;  </span><br><span class="line">      &#123;  </span><br><span class="line">         name: <span class="string">&quot;name empty&quot;</span>,  </span><br><span class="line">         args: args&#123;  </span><br><span class="line">            name: <span class="string">&quot;&quot;</span>,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         want:    <span class="literal">nil</span>,  </span><br><span class="line">         wantErr: <span class="literal">true</span>,  </span><br><span class="line">      &#125;,  </span><br><span class="line">      &#123;  </span><br><span class="line">         name: <span class="string">&quot;success&quot;</span>,  </span><br><span class="line">         args: args&#123;  </span><br><span class="line">            name: <span class="string">&quot;test&quot;</span>,  </span><br><span class="line">            opts: []ResourcePoolConfigOptFunc&#123;  </span><br><span class="line">               <span class="function"><span class="keyword">func</span><span class="params">(option *ResourcePoolConfigOption)</span></span> &#123;  </span><br><span class="line">                  option.minIdle = <span class="number">2</span>  </span><br><span class="line">               &#125;,  </span><br><span class="line">            &#125;,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         want: &amp;ResourcePoolConfig&#123;  </span><br><span class="line">            name:     <span class="string">&quot;test&quot;</span>,  </span><br><span class="line">            maxTotal: <span class="number">10</span>,  </span><br><span class="line">            maxIdle:  <span class="number">9</span>,  </span><br><span class="line">            minIdle:  <span class="number">2</span>,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         wantErr: <span class="literal">false</span>,  </span><br><span class="line">      &#125;,  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;  </span><br><span class="line">      t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">         got, err := NewResourcePoolConfig(tt.args.name, tt.args.opts...)  </span><br><span class="line">         require.Equalf(t, tt.wantErr, err != <span class="literal">nil</span>, <span class="string">&quot;error = %v, wantErr %v&quot;</span>, err, tt.wantErr)  </span><br><span class="line">         assert.Equal(t, tt.want, got)  </span><br><span class="line">      &#125;)  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发一些公共库的时候，对于入口参数的传递推荐后面一种方法，可以一定程度上避免参数变化破坏式更新的情况</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 创建型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试官101</title>
      <link href="/interview/%E9%9D%A2%E8%AF%95%E5%AE%98/interviewer101/"/>
      <url>/interview/%E9%9D%A2%E8%AF%95%E5%AE%98/interviewer101/</url>
      
        <content type="html"><![CDATA[<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a><strong>面试</strong></h3><h4 id="算法能力-一题5-10min"><a href="#算法能力-一题5-10min" class="headerlink" title="算法能力 一题5-10min :"></a>算法能力 一题5-10min :</h4><ol><li>题目：仅出现一次的数</li><li>题目：连续固定区间最大值<br>给你一个数组 nums 和一个大小为 k的区间。这个区间可以从数组的最左侧不断移动到数组的最右侧。每个移动区间固定有 k 个数字。这个区间每次只向右移动一位。<br>让你返回移动过程中，这些固定区间中的最大值。</li></ol><p>样例输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br></pre></td></tr></table></figure><p>样例输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,3,5,5,6,7]</span><br></pre></td></tr></table></figure><p>样例解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">移动情况 最大值</span><br><span class="line"></span><br><span class="line">[1 3 -1] -3 5 3 6 7 3</span><br><span class="line"></span><br><span class="line">1 [3 -1 -3] 5 3 6 7 3</span><br><span class="line"></span><br><span class="line">1 3 [-1 -3 5] 3 6 7 5</span><br><span class="line"></span><br><span class="line">1 3 -1 [-3 5 3] 6 7 5</span><br><span class="line"></span><br><span class="line">1 3 -1 -3 [5 3 6] 7 6</span><br><span class="line"></span><br><span class="line">1 3 -1 -3 5 [3 6 7] 7</span><br></pre></td></tr></table></figure><ol start="3"><li>拓展</li></ol><p>样例输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,5,3,6,7], t = 5</span><br><span class="line">k = 2</span><br><span class="line">k = 3</span><br><span class="line">k = 4</span><br><span class="line">k = 5</span><br><span class="line">k = 6</span><br></pre></td></tr></table></figure><p>样例输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 3 -1 5 5 6 7</span><br><span class="line">3 3 5 5 6 7</span><br><span class="line">3 5 5 6 7</span><br><span class="line">5 5 6 7</span><br><span class="line">5 6 7</span><br></pre></td></tr></table></figure><h4 id="基础能力"><a href="#基础能力" class="headerlink" title="基础能力"></a>基础能力</h4><h6 id="Go八股"><a href="#Go八股" class="headerlink" title="Go八股"></a>Go八股</h6><p><a href="https://www.topgoer.cn/docs/gomianshiti/gomianshiti-1dd225t6esqld">https://www.topgoer.cn/docs/gomianshiti/gomianshiti-1dd225t6esqld</a></p><h6 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h6><ol><li><p>Redis是单线程的，但Redis为什么这么快？</p><ul><li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</li><li>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li><li>使用多路I&#x2F;O复用模型，非阻塞IO；这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程</li><li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</li></ul></li><li><p>缓存穿透和雪崩的解决方案</p></li><li><p>请简述Reids的删除策略</p><ul><li>定时删除：在设置键的过期时间的同时，创建一个定时任务，当键达到过期时间时，立即执行对键的删除操作</li><li>惰性删除：放任键过期不管，但在每次从键空间获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，如果没有过期，就返回该键</li><li>定期删除：每隔一点时间，程序就对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li></ul><ol start="3"><li>索引的构建流程？</li><li>b树，b+树区别，MongoDB为什么选用b树</li></ol></li></ol><h6 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h6><ol><li>CPU三级缓存</li><li>进程与线程<ul><li>进程: 进程是具有一定独立功能的程序，进程是系统资源分配和调度的最小单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</li><li>线程: 线程是进程的一个实体,线程是内核态,而且是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</li><li>协程: 协程是一种用户态的轻量级线程，协程的调度完全是由用户来控制的。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</li></ul></li></ol><h6 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h6><ol><li><p>创建索引的规则：最左匹配，区分度等</p></li><li><p>索引失效的情况</p><ul><li>未遵循最佳左前缀规则导致索引失效</li><li>计算、函数、类型转换(自动或手动)导致索引失效</li><li>范围条件右边列索引失效</li><li>不等于(!&#x3D;)会导致索引失效</li><li>is null可以用到索引，is not null不能用到索引</li><li>like以通配符%开头索引失效</li><li>or 前的列建立了索引 or后面的列没有建立索引 会导致索引失效</li><li>不同字符集进行比较前需要进行转换，会导致索引失效</li></ul></li><li><p>数据的存储方式： B+树</p><ul><li>非叶子节点不存储数据，只存索引（冗余），这样可以保证存放更多的索引</li><li>叶子节点存储所有索引字段</li><li>叶子节点用指针连接，提高区间访问性能<br> ![[Pasted image 20221201183525.png]]</li></ul></li><li><p>大数据量级的mysql，如何分库分表？解决方案？</p></li><li><p>网络这些可以挑一两个主题聊。</p></li><li><p>自我介绍，告知规则与流程：两个部分：算法题 &amp; 聊一聊基础问题</p></li><li><p>先介绍下自己；主要技能，常用语言，工作经历简单叙述</p></li><li><p>项目：支付相关，幂等？</p></li><li><p>发过去在线文档</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试官 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试官 </tag>
            
            <tag> 初学者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-连续固定区间最大值</title>
      <link href="/interview/%E9%9D%A2%E8%AF%95%E5%AE%98/maximum-of-segments/"/>
      <url>/interview/%E9%9D%A2%E8%AF%95%E5%AE%98/maximum-of-segments/</url>
      
        <content type="html"><![CDATA[<h1 id="连续固定区间最大值"><a href="#连续固定区间最大值" class="headerlink" title="连续固定区间最大值"></a>连续固定区间最大值</h1><ul><li>涉及知识点：堆，栈、双指针、滑动窗口，双向队列、线段树，树状数组, dp 等。</li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>nums</code> 和一个大小为 <code>k</code>的区间。这个区间可以从数组的最左侧不断移动到数组的最右侧。每个移动区间固定有 <code>k</code> 个数字。这个区间每次只向右移动一位。</p><p>让你返回移动过程中，这些固定区间中的最大值。</p><p>样例输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br></pre></td></tr></table></figure><p>样例输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,3,5,5,6,7]</span><br></pre></td></tr></table></figure><p>样例解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">          移动情况              最大值</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果候选人询问到数据范围，可提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.size() &lt;= 10^5</span><br><span class="line">-10^4 &lt;= nums[i] &lt;= 10^4</span><br><span class="line">1 &lt;= k &lt;= nums.size()</span><br></pre></td></tr></table></figure><h2 id="思路描述"><a href="#思路描述" class="headerlink" title="思路描述"></a>思路描述</h2><h3 id="思路-1：暴力滑动-O-n-2"><a href="#思路-1：暴力滑动-O-n-2" class="headerlink" title="思路 1：暴力滑动 O(n^2)"></a>思路 1：暴力滑动 O(n^2)</h3><p>暴力进行滑动窗口， 每次遍历当前窗口内的元素取最大值。</p><p>参考代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">find_maximum_of_sgements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + k &lt;= nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(*<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>() + i, nums.<span class="built_in">begin</span>() + i + k));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度 <code>O(n * k)～O(n^2)</code></li><li>空间复杂度 <code>O(n - k + 1)</code></li></ul><p><strong>这个是暴力解，非正确解，只能给 2 分，可提示次优解和最优解</strong></p><blockquote><p>优化提示 1：可以优化到低于 O(n^2) 的吗？比如 O(nlogn)，O(nlogk), 甚至是线性 O(n) 的做法。</p></blockquote><blockquote><p>优化提示 2：可以想到用一些可以维护极值的数据结构做吗？</p></blockquote><blockquote><p>优化提示 3：那如果拆分成子问题，快速求连续区间的最大值，你怎么做才会有带 log 的时间复杂度？</p></blockquote><p><strong>提示后，候选人还是不会。可换题。</strong></p><h3 id="思路-2：堆-O-nlogk"><a href="#思路-2：堆-O-nlogk" class="headerlink" title="思路 2：堆 O(nlogk)"></a>思路 2：堆 O(nlogk)</h3><p>维护一个大小为 <code>k</code> 的堆，向堆中插入一个元素(单个操作时间复杂度 <code>O(logk)</code>), 将数据不断 <code>push</code> 进堆，每次取结果都将 <code>top</code> 的数取出来就是序列答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">find_maximum_of_segments</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  priority_queue&lt; pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; pq;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">      pq.<span class="built_in">push</span>(&#123;nums[i],i&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = k;i &lt; nums.<span class="built_in">size</span>(); i++) &#123; </span><br><span class="line">      <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>() &amp;&amp; pq.<span class="built_in">top</span>().second &lt;= (i - k)) &#123;</span><br><span class="line">          pq.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      pq.<span class="built_in">push</span>(&#123;nums[i],i&#125;);</span><br><span class="line">      res.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().first);   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<code>O(nlogk)</code>, 候选人有可能写成<code>O(nlogn)</code>, 但问题不大。</li><li>空间复杂度：<code>O(k)</code>。</li></ul><p><strong>这个是正确解，但非最优解，可给 3 分，通过。</strong></p><h3 id="思路-3：双向队列-O-n"><a href="#思路-3：双向队列-O-n" class="headerlink" title="思路 3：双向队列 O(n)"></a>思路 3：双向队列 O(n)</h3><p>可以维护一个双向队列，这个队列是递减的。队列用来保存可能是最大值的数字的 <code>index</code>。<br>当前窗口最大值的 <code>index</code> 在队首，当窗口滑动时，会进入一个新值，出去一个旧值，不断更新给出当前窗口的最大值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">find_maximum_of_segments</span>(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> k) &#123;</span><br><span class="line">  deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">      <span class="comment">// 新元素入队时, 比队尾元素大的话则替代队尾元素</span></span><br><span class="line">      <span class="keyword">while</span>(!que.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[que.<span class="built_in">back</span>()])&#123;</span><br><span class="line">          que.<span class="built_in">pop_back</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 检查队首的 index 是否在窗口内，不在则出队</span></span><br><span class="line">      <span class="keyword">if</span>(!que.<span class="built_in">empty</span>() &amp;&amp; que.<span class="built_in">front</span>() &lt; i - k + <span class="number">1</span>) &#123;</span><br><span class="line">          que.<span class="built_in">pop_front</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      que.<span class="built_in">push_back</span>(i);</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= k <span class="number">-1</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(nums[que.<span class="built_in">front</span>()]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<code>O(n)</code>。</li><li>空间复杂度：<code>O(k)</code>。</li></ul><p><strong>这个是正确解，最优解，可给 4 分，通过。</strong></p><h3 id="思路-4：dynamic-programming"><a href="#思路-4：dynamic-programming" class="headerlink" title="思路 4：dynamic programming"></a>思路 4：dynamic programming</h3><p>先将数组分割成有 <code>k</code> 个元素的块。<br>建立数组 <code>left</code>,其中 <code>left[j]</code> 是从块的开始到下标 <code>j</code> 最大的元素，方向： <code>左-&gt;右</code>。<br>数组 <code>right</code>，其中 <code>right[j]</code> 是从块的结尾到下标 <code>j</code> 最大的元素，方向： <code>右-&gt;左</code>。</p><p>从左到右遍历数组，建立数组 <code>left</code>。</p><p>从右到左遍历数组，建立数组 <code>right</code>。</p><p>因为一个窗口 <code>[i, i + k - 1]</code> 最多跨越两个块，所以求窗口中的最大值就是求这个窗口跨越的块中的最大值，<br>可以知道，无论是跨越 1 个块也好，2 个块也好，计算处于边界的 <code>i</code> 和 <code>i + k - 1</code> 对应的值即可。</p><p><code>right[i]</code> 表示从块的结尾到下标 <code>j</code> 的最大的元素。</p><p><code>left[i + k - 1]</code> 表示从块的开始到下标 <code>i + k - 1</code> 的最大的元素。</p><p>这两个范围刚好是整个窗口。</p><p>所以窗口的最大值是 <code>max(right[i], left[i + k - 1])</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">find_maximum_of_segments</span>(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> k) &#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">right</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="type">int</span> max_num;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i % k == <span class="number">0</span>)&#123;</span><br><span class="line">          max_num = nums[i];</span><br><span class="line">      &#125;</span><br><span class="line">      max_num = <span class="built_in">max</span>(max_num, nums[i]);</span><br><span class="line">      left[i] = max_num;</span><br><span class="line">  &#125;</span><br><span class="line">  max_num = nums[n - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i % k == k - <span class="number">1</span>)&#123;</span><br><span class="line">          max_num = nums[i];</span><br><span class="line">      &#125;</span><br><span class="line">      max_num = <span class="built_in">max</span>(max_num, nums[i]);</span><br><span class="line">      right[i] = max_num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - k; i ++)&#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(<span class="built_in">max</span>(right[i], left[i + k - <span class="number">1</span>]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个是正确解，最优解，但比较难想到。可给 5 分，通过。</strong></p><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<code>O(n)</code>。</li><li>空间复杂度：<code>O(n)</code>。</li></ul><h2 id="其他思路参考"><a href="#其他思路参考" class="headerlink" title="其他思路参考"></a>其他思路参考</h2><p>以下解法比较特殊，而且编码比较复杂，如果真的有候选人在面试中写了，可以考虑给 5 分。</p><h3 id="思路-4-线段树-segment-tree"><a href="#思路-4-线段树-segment-tree" class="headerlink" title="思路 4: 线段树 (segment tree)"></a>思路 4: 线段树 (segment tree)</h3><p>比较裸的线段树维护极值的做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;tree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushUp</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">  tree[rt] = <span class="built_in">max</span>(tree[<span class="number">1</span> &lt;&lt; rt], tree[<span class="number">1</span> &lt;&lt; rt | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l,<span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">    tree[rt] = nums[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span> &lt;&lt; rt, l, mid, nums);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span> &lt;&lt; rt | <span class="number">1</span>, mid + <span class="number">1</span>, r, nums);</span><br><span class="line">  <span class="built_in">pushUp</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l &gt; r) &#123;</span><br><span class="line">    <span class="keyword">return</span> INT_MIN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(l &gt; qr || r &lt; ql) &#123;</span><br><span class="line">    <span class="keyword">return</span> INT_MIN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// [ql [l, r] qr]</span></span><br><span class="line">  <span class="keyword">if</span>(l &gt;= ql &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">      <span class="keyword">return</span> tree[rt];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> left_val = <span class="built_in">query</span>(<span class="number">1</span> &lt;&lt; rt, l, mid, ql, qr);</span><br><span class="line">  <span class="type">int</span> right_val = <span class="built_in">query</span>(<span class="number">1</span> &lt;&lt; rt | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(left_val, right_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">find_maximum_of_segments</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">0</span> || n &lt; k) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  tree.<span class="built_in">resize</span>(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, nums);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + k - <span class="number">1</span> &lt; n; i++) &#123;</span><br><span class="line">      <span class="type">int</span> val = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, i, i + k - <span class="number">1</span>);</span><br><span class="line">      res.<span class="built_in">push_back</span>(val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<ul><li>建树：<code>O(n)</code>。</li><li>查询：<code>O(logn)</code></li></ul></li><li>空间复杂度：<code>O(3 * n)</code>。</li></ul><h3 id="思路-5：树状数组-fenwick-tree"><a href="#思路-5：树状数组-fenwick-tree" class="headerlink" title="思路 5：树状数组 (fenwick tree)"></a>思路 5：树状数组 (fenwick tree)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;val;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;tmp;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_VAL = <span class="number">1e5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">    val[x] = v;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">    <span class="type">int</span> lx = <span class="built_in">lowbit</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; lx; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      val[x] = <span class="built_in">max</span>(val[x], val[x - i]);</span><br><span class="line">    &#125;</span><br><span class="line">    x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(r &gt;= l) &#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;r = &quot; &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">    ans = <span class="built_in">max</span>(tmp[r - <span class="number">1</span>], ans);</span><br><span class="line">    r--;</span><br><span class="line">    <span class="keyword">while</span>(r &gt;= l + <span class="built_in">lowbit</span>(r))&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(val[r], ans);</span><br><span class="line">        r -= <span class="built_in">lowbit</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">find_maximum_of_segments</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  n = nums.<span class="built_in">size</span>();</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">0</span> || n &lt; k) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  val.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> num = nums[i] + MAX_VAL;</span><br><span class="line">    tmp.<span class="built_in">push_back</span>(num);</span><br><span class="line">    <span class="built_in">update</span>(i + <span class="number">1</span>, num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + k - <span class="number">1</span> &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> max_val = <span class="built_in">query</span>(i + <span class="number">1</span>, i + k);</span><br><span class="line">    res.<span class="built_in">push_back</span>(max_val - MAX_VAL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<ul><li>建树：<code>O(n)</code>。</li><li>查询：<code>O(logn)</code></li></ul></li><li>空间复杂度：<code>O(3 * n)</code>。</li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>如果遇到水平比较高的候选人，比如具有 OI 或者 ACM 经历且实力比较强的候选人。</p><p>候选人只需要口述解法即可。</p><p>可将上面题目改编成：</p><p>题意不变，同样是给你一个数组 <code>nums = [1,3,-1,-3,5,3,6,7]</code> 和 一个 <code>t</code>, <code>t</code> 代表查询次数。<br>即存在多组查询，每次查询给你不一样的 <code>k</code>, 让你输出每个查询区间为 <code>k</code> 的区间的答案序列。</p><p>数据范围：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.size() &lt;= 10^5</span><br><span class="line">-10^4 &lt;= nums[i] &lt;= 10^4</span><br><span class="line">1 &lt;= k &lt;= nums.size()</span><br><span class="line">1 &lt;= t &lt;= 10^3</span><br></pre></td></tr></table></figure><p>样例输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,5,3,6,7], t = 5</span><br><span class="line">k = 2</span><br><span class="line">k = 3</span><br><span class="line">k = 4</span><br><span class="line">k = 5</span><br><span class="line">k = 6</span><br></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 3 -1 5 5 6 7</span><br><span class="line">3 3 5 5 6 7 </span><br><span class="line">3 5 5 6 7 </span><br><span class="line">5 5 6 7 </span><br><span class="line">5 6 7</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h3><p>这种属于比较经典的 RMQ (Range Minimum&#x2F;Maximum Query) 问题。</p><p>可以使用一种数据结构 <code>Sparse Tables</code> 来解决。</p><p>该数据结构可在 <code>O(nlogn)</code> 内完成数据预处理， 在 <code>O(1)</code> 内完成查询。</p><ul><li>时间复杂度：<ul><li>预处理：<code>O(nlogn)</code>。</li><li>查询：<code>O(1)</code></li></ul></li><li>空间复杂度：<code>O(nlogn)</code>。</li></ul><p>代码参考：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> M;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">(vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;&amp;dp, vector&lt;<span class="type">int</span>&gt;&amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">          dp[i][j] = <span class="built_in">max</span>(dp[i][j<span class="number">-1</span>], dp[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;&amp;dp, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> k = (<span class="type">int</span>) (<span class="built_in">log</span>(r - l + <span class="number">1</span>) / <span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(dp[l][k], dp[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_maximum_of_segments</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  M = (<span class="type">int</span>) (<span class="built_in">log</span>(n) / <span class="built_in">log</span>(<span class="number">2</span>)) + <span class="number">1</span>; </span><br><span class="line">  vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(M + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">  <span class="built_in">prepare</span>(dp, nums);</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + k - <span class="number">1</span> &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(<span class="built_in">query</span>(dp, i, i + k - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: res) &#123;</span><br><span class="line">      cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试官 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-仅出现一次的元素</title>
      <link href="/interview/%E9%9D%A2%E8%AF%95%E5%AE%98/single-numbers/"/>
      <url>/interview/%E9%9D%A2%E8%AF%95%E5%AE%98/single-numbers/</url>
      
        <content type="html"><![CDATA[<h1 id="仅出现一次的元素"><a href="#仅出现一次的元素" class="headerlink" title="仅出现一次的元素"></a>仅出现一次的元素</h1><ul><li>涉及知识点：散列表、位运算</li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>（英文）<br>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.  </p><p>For example:  </p><p>Given nums &#x3D; [1, 2, 1, 3, 2, 5], return [3, 5].  </p><p>Note:  </p><ol><li>The order of the result is not important. So in the above example, [5, 3] is also correct.</li></ol><p>（中文）<br>给定一个整数数组，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出仅出现一次的那两个元素。要求时间复杂度在O(N)内。  </p><p>示例输入:  </p><pre><code>[1, 2, 1, 3, 2, 5]  </code></pre><p>示例输出：  </p><pre><code>[3, 5]  </code></pre><h2 id="思路描述"><a href="#思路描述" class="headerlink" title="思路描述"></a>思路描述</h2><h3 id="思路1：排序-遍历"><a href="#思路1：排序-遍历" class="headerlink" title="思路1：排序+遍历"></a>思路1：排序+遍历</h3><p>对序列排序，后遍历所有元素，通过相邻元素是否有相同值来判断是否满足条件，输出。  </p><p>常规排序方案的时空复杂度如下：  </p><ul><li>时间复杂度 <code>O(N*log(N))</code>  </li><li>空间复杂度 <code>O(1)</code></li></ul><p>此时解法不满足要求，可给到2分，若能给出计数排序（时间复杂度O(N)）法，可给到3分。  </p><h3 id="思路2：散列表-遍历"><a href="#思路2：散列表-遍历" class="headerlink" title="思路2：散列表+遍历"></a>思路2：散列表+遍历</h3><p>遍历每个元素，使用散列表存储元素值到数量的映射关系，再遍历散列表找出其中value为1的key，输出。  </p><p>该方案的时空复杂度分析如下：  </p><ul><li>时间复杂度 <code>O(N)</code>  </li><li>空间复杂度 <code>O(N)</code></li></ul><p>此时为次优解，可延伸提问对散列表的理解（如遍历结果是否有序，两个元素输出顺序是否确定），回答正确可给到4分  </p><h3 id="思路3：位运算"><a href="#思路3：位运算" class="headerlink" title="思路3：位运算"></a>思路3：位运算</h3><p>遍历元素，使用异或运算可消除相同的元素，得到所求两个元素的异或结果，从中找出二进制为1的最低位数字，再遍历一次，求出其中一个元素，再与前面结果异或得到另一个元素，输出。  </p><p>该方案的时空复杂度分析如下：  </p><ul><li>时间复杂度 <code>O(N)</code>  </li><li>空间复杂度 <code>O(1)</code></li></ul><p>此为最优解，可给到5分  </p><h2 id="解法示例"><a href="#解法示例" class="headerlink" title="解法示例"></a>解法示例</h2><p><a href="./single-numbers/sortSolution.go">排序+遍历</a>  </p><p><a href="./single-numbers/hashSolution.go">hash+遍历</a>  </p><p><a href="./single-numbers/bitSolution.go">位运算</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试官 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-移掉K位数字</title>
      <link href="/interview/%E9%9D%A2%E8%AF%95%E5%AE%98/remove-the-k-digit/"/>
      <url>/interview/%E9%9D%A2%E8%AF%95%E5%AE%98/remove-the-k-digit/</url>
      
        <content type="html"><![CDATA[<h1 id="移掉K位数字-leetcode-402"><a href="#移掉K位数字-leetcode-402" class="headerlink" title="移掉K位数字-leetcode-402"></a>移掉K位数字-leetcode-402</h1><ul><li>涉及知识点：贪心,栈</li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。  </p><p>注意:  </p><ul><li>num 的长度小于 10002 且 ≥ k。  </li><li>num 不会包含任何前导零。</li></ul><p>输入&#x2F;输出示例：  </p><p>Example 1:  </p><p>Input:   </p><pre><code>num = &quot;1432219&quot;, k = 3  </code></pre><p>Output:   </p><pre><code>&quot;1219&quot;  </code></pre><p>Explanation: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。  </p><p>Example 2:  </p><p>Input:   </p><pre><code>num = &quot;10200&quot;, k = 1  </code></pre><p>Output:   </p><pre><code>&quot;200&quot;  </code></pre><p>Explanation: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。  </p><p>Example 3:  </p><p>Input:   </p><pre><code>num = &quot;10&quot;, k = 2  </code></pre><p>Output:   </p><pre><code>&quot;0&quot;  </code></pre><p>Explanation: 从原数字移除所有的数字，剩余为空就是0。  </p><h2 id="思路描述"><a href="#思路描述" class="headerlink" title="思路描述"></a>思路描述</h2><h2 id="思路-0"><a href="#思路-0" class="headerlink" title="思路 0"></a>思路 0</h2><p>详细描述：思路，从左到右，找第一个比后面大的字符，删除，清零，k次扫描。  </p><ul><li>时间复杂度：o(n*k)  </li><li>空间复杂度：o(1)</li></ul><p>代码：  </p><pre><code class="java">class Solution &#123;      public String removeKdigits(String num, int k) &#123;        if (num.length() == k) return &quot;0&quot;;        StringBuilder s = new StringBuilder(num);        for (int i = 0; i &lt; k; i++) &#123;            int idx = 0;            for (int j = 1; j &lt; s.length() &amp;&amp; s.charAt(j) &gt;= s.charAt(j - 1); j++) idx = j;            s.delete(idx, idx + 1);            while (s.length() &gt; 1 &amp;&amp; s.charAt(0) == &#39;0&#39;) s.delete(0, 1);        &#125;        return s.toString();    &#125;&#125;  </code></pre><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h3><p>详细描述：在一定的范围内逐步选取最小的数字。<br>  </p><ol><li>在第一次循环中，num &#x3D; 1432219, k&#x3D;3，此时我们要删去k&#x3D;3个数字，保留n-k&#x3D;7-3&#x3D;4个数字。  </li><li>最终要挑选4个字符，那么我们先来挑选 千位 的字符，，由于挑选完千位后还需要挑选百位，十位，个位这三个位置的字符，所以千位能选择的范围只能在1432之间,因为要留出末尾的219这三个字符供百位、十位、个位 去挑选。  </li><li>1432中最小的值是1，所以千位的值选好了，就是1，接下来就是从千位后面的432219中去挑选百位值，可以发现挑选每一位的值是一个递归的过程。  </li><li>start &#x3D; 0, end &#x3D; k。也就是要在[start,end]中选取一个最小的进行保留，返回最小数字的下标minIndex。而在下次循环中，start &#x3D; minIndex+1, end++ ，也就是在[start,end]中选择下一个最小的数字。以此类推，直至所有数字都选取完毕。</li></ol><p>注意：当返回的下标minIndex及后面的字符串的长度 &#x3D; 还需要保留的字符串的长度的时候，直接返回  </p><ul><li>时间复杂度：o(n*k)  </li><li>空间复杂度：o(1)</li></ul><p>代码：  </p><pre><code class="go">func removeKdigits(num string, k int) string &#123;      if 0 == k &#123;        return num    &#125;    if k == len(num) &#123;        return &quot;0&quot;    &#125;    result := &quot;&quot;    i := len(num)-k    for &#123;        if i == 0 &#123;            break        &#125;        minIndex := 0        for  j := 0; j &lt; len(num)-(i-1); j++ &#123;            if num[j] &lt; num[minIndex] &#123;                minIndex = j            &#125;        &#125;        // 优化        if len(num)- minIndex == i &#123;            result = result + num[minIndex:]            break        &#125;        result += num[minIndex:minIndex+1]        num = num[minIndex+1:]        i--    &#125;    // 前导0    ans := strings.TrimLeft(result, &quot;0&quot;)    if ans == &quot;&quot; &#123;        ans = &quot;0&quot;    &#125;    return ans&#125;    </code></pre><h3 id="思路2-贪心-单调栈（一般可用-栈、队列、双端队列、双指针-实现）"><a href="#思路2-贪心-单调栈（一般可用-栈、队列、双端队列、双指针-实现）" class="headerlink" title="思路2: 贪心 + 单调栈（一般可用 栈、队列、双端队列、双指针 实现）"></a>思路2: 贪心 + 单调栈（一般可用 栈、队列、双端队列、双指针 实现）</h3><p>详细描述：  </p><ul><li><p>遍历字符串，逐个入栈,若新来的比栈顶小，则栈顶出栈 ,出栈相当于移除动作，需次数并与 k 比较，别删多了  </p></li><li><p>移除头部零有 ‘0’,全空，return “0”,构建字符串，顺序返回整个单调栈元素.  </p></li><li><p>时间复杂度：o(n+k)  </p></li><li><p>空间复杂度：o(n)</p></li></ul><p>代码：  </p><pre><code class="go">func removeKdigits(num string, k int) string &#123;      stack := []byte&#123;&#125;        for i := range num &#123;        digit := num[i]        for k &gt; 0 &amp;&amp; len(stack) &gt; 0 &amp;&amp; digit &lt; stack[len(stack)-1] &#123;            stack = stack[:len(stack)-1]            k--                &#125;        stack = append(stack, digit)     &#125;    stack = stack[:len(stack)-k]    ans := strings.TrimLeft(string(stack), &quot;0&quot;)    if ans == &quot;&quot; &#123;        ans = &quot;0&quot;        &#125;    return ans&#125;  </code></pre><h4 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h4><ul><li>提出思路0，能正确分析时空复杂度(2分)  </li><li>提出思路1，能正确分析时空复杂度(3分)  </li><li>提出思路2，能正确分析时空复杂度(4分)  </li><li>bugfree且代码简洁(5分)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试官 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/%E8%BD%AF%E5%AE%9E%E5%8A%9B/1/"/>
      <url>/%E8%BD%AF%E5%AE%9E%E5%8A%9B/1/</url>
      
        <content type="html"><![CDATA[<h1 id="软实力"><a href="#软实力" class="headerlink" title="软实力"></a>软实力</h1><h2 id="主动性，责任心"><a href="#主动性，责任心" class="headerlink" title="主动性，责任心"></a>主动性，责任心</h2><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>主动推进自己参与的每一个项目，将自己看作是每一个项目的负责人，以项目负责人的角度去看待事情，一方面能够让自己更好的做事情，另一方面也能培养自己的项目推动能力</p><h3 id="个人事务"><a href="#个人事务" class="headerlink" title="个人事务"></a>个人事务</h3><p>转介绍相关链路很长，用户从看到第三方广告开始，到最终成为忠实用户</p><h2 id="抗压能力–》有所进步，还需加强"><a href="#抗压能力–》有所进步，还需加强" class="headerlink" title="抗压能力–》有所进步，还需加强"></a>抗压能力–》有所进步，还需加强</h2><p>这一点我最初做的不够好，现在相对而言已经做的不错，总体经验如下</p><p><strong>学会区分事情的轻重缓急，不那么紧急的事情就先放着，不去理会，集中精神解决掉紧急的事情，然后以平和的心态去解决那些不紧急的</strong></p><p>可能说起来简单，但是具体如何实施，还是要自己多经历</p><h2 id="沟通能力–》在沟通中的谦逊没有问题，一向是自己错了就是错了不找接口，但是有时候事情多了，语气会急躁，有所注意和改进，还需要继续努力"><a href="#沟通能力–》在沟通中的谦逊没有问题，一向是自己错了就是错了不找接口，但是有时候事情多了，语气会急躁，有所注意和改进，还需要继续努力" class="headerlink" title="沟通能力–》在沟通中的谦逊没有问题，一向是自己错了就是错了不找接口，但是有时候事情多了，语气会急躁，有所注意和改进，还需要继续努力"></a>沟通能力–》在沟通中的谦逊没有问题，一向是自己错了就是错了不找接口，但是有时候事情多了，语气会急躁，有所注意和改进，还需要继续努力</h2><h3 id="保证沟通的高效性"><a href="#保证沟通的高效性" class="headerlink" title="保证沟通的高效性"></a>保证沟通的高效性</h3><p>低效的沟通不仅会让你烦，也会让沟通对象感到烦，当发现打字已经说不清楚事情的时候可以考虑直接语音，或者直接当面对接。</p><h3 id="沟通过程保持谦逊和平和"><a href="#沟通过程保持谦逊和平和" class="headerlink" title="沟通过程保持谦逊和平和"></a>沟通过程保持谦逊和平和</h3><h4 id="方案沟通"><a href="#方案沟通" class="headerlink" title="方案沟通"></a>方案沟通</h4><p>与他人沟通过程中难免有所争执，要能明确的从对方的角度思考，对方说的一些解决方案你可能一开始不认可，但是别人既然这么说了就一定有他这么说的原因，可以先问清楚，是不是有什么历史遗留问题或者业务场景，导致他要采用你不认可的方案，如果发现确实是对方思考不周，然后可以提供自己的想法，互相沟通，总会达成一致。</p><h4 id="接受自己不足"><a href="#接受自己不足" class="headerlink" title="接受自己不足"></a>接受自己不足</h4><p>不要有自己绝对不能犯错的思想，有时候明明是你的问题或者就是你能力不足没有思考到一些东西，被同事当面指出，这时候要保持谦逊的心，不要硬抗，这没有任何意义，错了就是错了，没有想到就是没有想到，接受别人的指责，然后反省进步即可，硬抗对他人对自己都不是一个好的方式。</p><h1 id="一些好的工作习惯和建议"><a href="#一些好的工作习惯和建议" class="headerlink" title="一些好的工作习惯和建议"></a>一些好的工作习惯和建议</h1><p><strong>1.事事有回音</strong></p><p>这一点很多鸡汤文都有写，但是真的很重要，所以在此放在第一个强调。</p><p>交给你的任务，你做到哪一步，一定要让给你布置的人心里有数，或者说你打算什么时候做完，也一定要给一个deadline，若是长久没有回音，或者最后出了岔子，难免就会留下不靠谱的印象。</p><p><strong>2.跟事情要跟到底</strong></p><p>让你跟一件事情，就要跟到底，中间如果遇到阻碍发现事情没有进展，就要想办法去解决，如果实在解决不了，就要跟向你布置任务的人主动沟通，最起码我们组内达成共识得出一个结论。</p><p><strong>3.不只是完成任务</strong></p><p> 以高标准要求自己，在完成任务的同时能否做的更好，或者说给我的方案是这样，我能否想出更好的方案，在这样的思考中自己的能力也会有所提升。</p><p><strong>4.高效</strong></p><p>一个任务，他花费多少时间，大家心里一般都有数，如果这个任务一般只花费一天，结果你做了两天，三天还没有做好，那一定是你的问题，还有的情况是因为其他事情多，所以设置了deadline，但是出现一拖再拖，到了deadline还继续往下拖的情况，那最起码也是你对自己时间规划不清楚所造成的问题，哪怕自己加班也不能出现因为自己导致项目block的情况，这是我对我自己的要求。</p><p><strong>5.团队配合</strong></p><p>不要怕问问题，但是要问对的问题。</p><p>当出现了问题，一定要先判定问题的范畴，是技术问题，还是非技术问题。</p><p>技术问题当然要靠自己搜资料和想办法解决，但是可以分情况给自己一个时间限制，比如我手上还有很多事情，我已经花了一个小时，还是解决不了这个问题，但是我这边该做的都做了，实在找不到问题了，问了避免浪费时间可以考虑求助一下资深同事或者自己组内的leader。</p><p>非技术问题，可能是我们公司的组件，或者相关的技术规范导致，是一种你知道了就知道了，不知道就无法解决的问题，完全没有下手思路，这种问题可以给自己的时间限制少一些，比如10分钟，当然在提问之前也要确定自己把该做的排查都做了，然后去问一下知道的人。</p><p>于我们组而言，大家都是比较平和的人，所以不要怕问问题，但是也不要问浪费大家时间的低级问题。</p><p><strong>6.不当传话筒</strong></p><p>组内负责的服务很多，有的业务不了解每个人负责的范畴会出现问错人的情况，如果这个问题你恰好也知道可以协助做答，不过作答后也要跟业务明确负责这问题的人其实是谁，不让以后所有这些问题都可能会先问你，如果你不清楚，就不要做传话筒，可以直接拉群或者直接告诉业务方应该问谁，不要转发问题，这样业务方跟问题负责人的沟通中就多加了一层你，有时候业务方对服务了解不清楚，问的问题本身就不正确，你还协助传达，那就是在浪费所有人的时间。</p>]]></content>
      
      
      <categories>
          
          <category> 软实力 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>序</title>
      <link href="/golang/go-design-pattern/startup/"/>
      <url>/golang/go-design-pattern/startup/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含 23 种常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记</li><li>一些基础原则和思想</li></ul><h3 id="“好”代码的几个标准"><a href="#“好”代码的几个标准" class="headerlink" title="“好”代码的几个标准"></a>“好”代码的几个标准</h3><ol><li>如何评价代码质量的高低？<br>代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁等，这些词汇是从不同的维度去评价代码质量的。它们之间有互相作用，并不是独立的，比如，代码的可读性好、可扩展性好就意味着代码的可维护性好。代码质量高低是一个综合各种因素得到的结论。我们并不能通过单一的维度去评价一段代码的好坏。</li><li>最常用的评价标准有哪几个？<br>最常用到几个评判代码质量的标准是：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。</li><li>如何才能写出高质量的代码？<br>要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等等</li></ol>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper</title>
      <link href="/interview/distribution/zookeeper/"/>
      <url>/interview/distribution/zookeeper/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是-zookeeper-？"><a href="#1-什么是-zookeeper-？" class="headerlink" title="1. 什么是 zookeeper ？"></a>1. 什么是 zookeeper ？</h3><p>Zookeeper（CP）<br>作为一个分布式协同服务，ZooKeeper非常好，但是对于Service发现服务来说就不合适了，因为对于Service发现服务来说就算是返回了包含不实的信息的结果也比什么都不返回要好。所以当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。</p><p>但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。</p><p>所以说，作为注册中心，可用性的要求要高于一致性！</p><p>在 CAP 模型中，Zookeeper整体遵循一致性（CP）原则，即在任何时候对 Zookeeper 的访问请求能得到一致的数据结果，但是当机器下线或者宕机时，不能保证服务可用性。</p><p>那为什么Zookeeper不使用最终一致性（AP）模型呢？因为这个依赖Zookeeper的核心算法是ZAB，所有设计都是为了强一致性。这个对于分布式协调系统，完全没有毛病，但是你如果将Zookeeper为分布式协调服务所做的一致性保障，用在注册中心，或者说服务发现场景，这个其实就不合适。</p><h3 id="2-什么是强、弱、最终一致性"><a href="#2-什么是强、弱、最终一致性" class="headerlink" title="2. 什么是强、弱、最终一致性"></a>2. 什么是强、弱、最终一致性</h3><h3 id="3-ZooKeeper-快速领导选举是如何实现的？"><a href="#3-ZooKeeper-快速领导选举是如何实现的？" class="headerlink" title="3. ZooKeeper 快速领导选举是如何实现的？"></a>3. ZooKeeper 快速领导选举是如何实现的？</h3><h3 id="4-如何通过两阶段提交来保证一致性"><a href="#4-如何通过两阶段提交来保证一致性" class="headerlink" title="4. 如何通过两阶段提交来保证一致性"></a>4. 如何通过两阶段提交来保证一致性</h3><h3 id="5-观察者节点的作用"><a href="#5-观察者节点的作用" class="headerlink" title="5. 观察者节点的作用"></a>5. 观察者节点的作用</h3><h3 id="6-为什么建议使用奇数台机器来构建集群？"><a href="#6-为什么建议使用奇数台机器来构建集群？" class="headerlink" title="6. 为什么建议使用奇数台机器来构建集群？"></a>6. 为什么建议使用奇数台机器来构建集群？</h3><h3 id="7-为什么会出现脑裂问题？"><a href="#7-为什么会出现脑裂问题？" class="headerlink" title="7. 为什么会出现脑裂问题？"></a>7. 为什么会出现脑裂问题？</h3>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GMP 原理与调度</title>
      <link href="/golang/concurrency/gmp/"/>
      <url>/golang/concurrency/gmp/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>M(machine): 代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。<br>P(processor): 表示逻辑processor，是线程M的执行的上下文。<br>G(goroutine): 调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。</p><h1 id="1-GMP-原理与调度"><a href="#1-GMP-原理与调度" class="headerlink" title="1. GMP 原理与调度"></a>1. GMP 原理与调度</h1><h3 id="1-1-1-一、Golang-“调度器”-的由来？"><a href="#1-1-1-一、Golang-“调度器”-的由来？" class="headerlink" title="1.1.1 一、Golang “调度器” 的由来？"></a>1.1.1 一、Golang “调度器” 的由来？</h3><h4 id="1-单进程时代不需要调度器"><a href="#1-单进程时代不需要调度器" class="headerlink" title="(1) 单进程时代不需要调度器"></a>(1) 单进程时代不需要调度器</h4><p>我们知道，一切的软件都是跑在操作系统上，真正用来干活 (计算) 的是 CPU。早期的操作系统每个程序就是一个进程，知道一个程序运行完，才能进行下一个进程，就是 “单进程时代”<br>一切的程序只能串行发生。<br>早期的单进程操作系统，面临 2 个问题：</p><ol><li><p>单一的执行流程，计算机只能一个任务一个任务处理。</p></li><li><p>进程阻塞所带来的 CPU 时间浪费。</p></li></ol><p>那么能不能有多个进程来宏观一起来执行多个任务呢？</p><p>后来操作系统就具有了最早的并发能力：多进程并发，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把 CPU 利用起来，CPU 就不浪费了。</p><h4 id="2-多进程-x2F-线程时代有了调度器需求"><a href="#2-多进程-x2F-线程时代有了调度器需求" class="headerlink" title="(2) 多进程 &#x2F; 线程时代有了调度器需求"></a>(2) 多进程 &#x2F; 线程时代有了调度器需求</h4><p><img src="https://s3.bmp.ovh/imgs/2022/02/921c521bed752387.jpg" alt="image"><br>在多进程 &#x2F; 多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞 cpu 可以立刻切换到其他进程中去执行，而且调度 cpu 的算法可以保证在运行的进程都可以被分配到 cpu 的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。</p><p>但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU 虽然利用起来了，但如果进程过多，CPU 有很大的一部分都被用来进行进程调度了。</p><p>怎么才能提高 CPU 的利用率呢？</p><p>但是对于 Linux 操作系统来讲，cpu 对进程的态度和线程的态度是一样的。<br><img src="https://s3.bmp.ovh/imgs/2022/02/bad5998d362c5be9.jpg" alt="image"></p><p>所有应用程序都是运行在操作系统上，真正用来干活(计算)的是<code>CPU</code>。所以谈到<code>Go</code>语言调度器，我们也绕不开操作系统、进程与线程这些概念。线程是操作系统调度时的最基本单元，而 Linux 在调度器并不区分进程和线程的调度，它们在不同操作系统上也有不同的实现，但是在大多数的实现中线程都属于进程。</p><p>多个线程可以属于同一个进程并共享内存空间。因为多线程不需要创建新的虚拟内存空间，所以它们也不需要内存管理单元处理上下文的切换，线程之间的通信也正是基于共享的内存进行的，与重量级的进程相比，线程显得比较轻量。</p><p>虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1 兆以上的内存空间，在对线程进行切换时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁对应的资源。</p><p>大量的线程出现了新的问题</p><ul><li><p>高内存占用</p></li><li><p>调度的CPU高消耗</p></li></ul><p>然后工程师们就发现，其实一个线程分为”内核态”线程和”用户态”线程。</p><p>一个<code>用户态线程</code>必须要绑定一个<code>内核态线程</code>，但是CPU并不知道有<code>用户态线程</code>的存在，它只知道它运行的是一个<code>内核态线程</code>(Linux的PCB进程控制块)。这样，我们再去细化分类，内核线程依然叫线程(thread)，用户线程叫协程(co-routine)。既然一个协程可以绑定一个线程，那么也可以通过实现协程调度器把多个协程与一个或者多个线程进行绑定。</p><p><code>Go</code>语言的<code>goroutine</code>来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被<code>runtime</code>调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。</p><p><code>Go</code>中，协程被称为<code>goroutine</code>，它非常轻量，一个<code>goroutine</code>只占几KB，并且这几KB就足够<code>goroutine</code>运行完，这就能在有限的内存空间内支持大量<code>goroutine</code>，支持了更多的并发。虽然一个<code>goroutine</code>的栈只占几KB，但实际是可伸缩的，如果需要更多内存，<code>runtime</code>会自动为<code>goroutine</code>分配。</p><p>既然我们知道了<code>goroutine</code>和系统线程的关系，那么最关键的一点就是实现协程调度器了。</p><p><code>Go</code>目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了。重新设计的调度器使用<code>G-M-P</code>模型并一直沿用至今。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f68Yc2PzBpdRSf4iaE1bicpADBkw9ITic8G4yctoweOep4Yc0fQKlkHeWkUIsUatove0g7AFsIAw22tA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="调度器G-M-P模型"></p><p>调度器G-M-P模型</p><ul><li><p>G — 表示 goroutine，它是一个待执行的任务；</p></li><li><p>M — 表示操作系统的线程，它由操作系统的调度器调度和管理；</p></li><li><p>P — 表示处理器，它可以被看做运行在线程上的本地调度器；</p></li></ul><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p><code>gorotuine</code> 就是<code>Go</code>语言调度器中待执行的任务，它在运行时调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销。</p><p><code>goroutine</code>只存在于<code>Go</code>语言的运行时，它是<code>Go</code>语言在用户态提供的线程，作为一种粒度更细的资源调度单元，如果使用得当能够在高并发的场景下更高效地利用机器的<code>CPU</code>。</p><h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p><code>Go</code>语言并发模型中的<code>M</code>是操作系统线程。调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有 <code>GOMAXPROCS</code> 个活跃线程能够正常运行。</p><p>在默认情况下，运行时会将 <code>GOMAXPROCS</code> 设置成当前机器的核数，我们也可以使用 <code>runtime.GOMAXPROCS</code> 来改变程序中最大的线程数。一个四核机器上会创建四个活跃的操作系统线程，每一个线程都对应一个运行时中的 <code>runtime.m</code> 结构体。</p><p>在大多数情况下，我们都会使用<code>Go</code>的默认设置，也就是活跃线程数等于<code>CPU</code>个数，在这种情况下不会触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由<code>Go</code>语言调度器触发，能够减少非常多的额外开销。</p><p>操作系统线程在<code>Go</code>语言中会使用私有结构体 <code>runtime.m</code> 来表示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type m struct &#123;    g0   *g     curg *g    ...&#125;</span><br></pre></td></tr></table></figure><p>其中<code>g0</code>是持有调度栈的<code>goroutine</code>，<code>curg</code> 是在当前线程上运行的用户<code>goroutine</code>，用户<code>goroutine</code>执行完后，线程切换回<code>g0</code>上，<code>g0</code>会从线程<code>M</code>绑定的<code>P</code>上的等待队列中获取<code>goroutine</code>交给线程。</p><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>调度器中的处理器<code>P</code>是线程和<code>goroutine</code> 的中间层，它能提供线程需要的上下文环境，也会负责调度线程上的等待队列，通过处理器<code>P</code>的调度，每一个内核线程都能够执行多个 <code>goroutine</code>，它能在<code>goroutine</code> 进行一些 <code>I/O</code> 操作时及时切换，提高线程的利用率。因为调度器在启动时就会创建 <code>GOMAXPROCS</code> 个处理器，所以<code>Go</code>语言程序的处理器数量一定会等于 <code>GOMAXPROCS</code>，这些处理器会绑定到不同的内核线程上并利用线程的计算资源运行<code>goroutine</code>。</p><p>此外在调度器里还有一个全局等待队列，当所有P本地的等待队列被占满后，新创建的<code>goroutine</code>会进入全局等待队列。<code>P</code>的本地队列为空后，<code>M</code>也会从全局队列中拿一批待执行的<code>goroutine</code>放到<code>P</code>本地的等待队列中。</p><h3 id="GMP模型图示"><a href="#GMP模型图示" class="headerlink" title="GMP模型图示"></a>GMP模型图示</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f68Yc2PzBpdRSf4iaE1bicpADicd9ka0ILRcZEob1gRNjuXgu6ic2dBysv5VeibYUUTru76UmRiaFrOmdtg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="GMP模型图示"></p><p>GMP模型图示</p><ul><li><p>全局队列：存放等待运行的G。</p></li><li><p>P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G时，G优先加入到P的本地队列，如果队列已满，则会把本地队列中一半的G移动到全局队列。</p></li><li><p>P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。</p></li><li><p>M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</p></li><li><p><code>goroutine</code>调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU上执行。</p></li></ul><h3 id="调度器的策略"><a href="#调度器的策略" class="headerlink" title="调度器的策略"></a>调度器的策略</h3><p>调度器的一个策略是尽可能的复用现有的活跃线程，通过以下两个机制提高线程的复用：</p><ol><li><p>work stealing机制，当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。</p></li><li><p>hand off机制，当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</p></li></ol><p><code>Go</code>的运行时并不具备操作系统内核级的硬件中断能力，基于工作窃取的调度器实现，本质上属于先来先服务的协作式调度，为了解决响应时间可能较高的问题，目前运行时实现了协作式调度和抢占式调度两种不同的调度策略，保证在大部分情况下，不同的 G 能够获得均匀的<code>CPU</code>时间片。</p><p>协作式调度依靠被调度方主动弃权，系统监控到一个<code>goroutine</code>运行超过10ms会通过 <code>runtime.Gosched</code> 调用主动让出执行机会。抢占式调度则依靠调度器强制将被调度方被动中断。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 必看必会 </tag>
            
            <tag> 并发 </tag>
            
            <tag> GMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-mutex</title>
      <link href="/golang/concurrency/go-mutex/"/>
      <url>/golang/concurrency/go-mutex/</url>
      
        <content type="html"><![CDATA[<h3 id="lock逻辑："><a href="#lock逻辑：" class="headerlink" title="lock逻辑："></a>lock逻辑：</h3><ol><li>第一次上锁的时候，直接走第一步<strong>CAS</strong>上锁，成功返回</li><li><strong>Mutex</strong>已经被另一个<strong>g</strong>上锁，那么<strong>state</strong>的<strong>g</strong>等待数+1，更新当前的锁状态，然后就进入队列，等待被唤醒，等到另个<strong>g</strong>调用了<strong>Unlock</strong>方法之后，当前<strong>g</strong>被唤醒，然后设置<strong>awoken&#x3D;true</strong>，再执行一遍<strong>for</strong>循环，此时<strong>locked</strong>位就是未上锁状态（0），<strong>new</strong>就是代表上锁，然后清除<strong>woken</strong>位，然后再<strong>CAS</strong>更新<strong>new</strong>到<strong>state</strong>上，因为之前的锁是未上锁状态，那么就代表抢锁成功，<strong>break</strong>，返回</li><li>和第二种一样，只不过，在<strong>CAS</strong>更新<strong>new</strong>到<strong>state</strong>上时，有其他<strong>g</strong>先改掉了<strong>state</strong>的值，那么就继续for循环，然后重复到第二种情况。</li></ol><h3 id="自旋锁："><a href="#自旋锁：" class="headerlink" title="自旋锁："></a>自旋锁：</h3><p>简单概括一下，就是为了解决锁粒度非常小的时候，给系统带来的不必要的调度开销<br>不过自旋要先满足几个条件<br>首先程序要跑在多核的机器上，然后GOMAXPROCS要大于1，并且此时有至少一个P的local runq是空的，才能进入到自旋的状态</p><p>自旋是一种多线程同步机制，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真。在多核的 CPU 上，自旋可以避免 Goroutine 的切换，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 Goroutine 进入自旋的条件非常苛刻</p><p>当<strong>Mutex</strong>已经上锁的时候，当前<strong>G</strong>在满足自旋条件下，进入自旋状态，在自旋中，其他<strong>G</strong>解锁了<strong>Mutex</strong>，那么当前<strong>G</strong>就设置了<strong>woken</strong>标记位，这样其他<strong>G</strong>在<strong>Unlock</strong>的时候就不会去等待队列里面唤醒<strong>G</strong>了，然后当前<strong>G</strong>就顺理成章的抢到了锁</p><p>这样自旋锁在锁粒度非常小的场景下的能对其性能带来一定的优化。</p><p>引入自旋锁之后，又带来了一个问题。就是<strong>G</strong>等待队列的<strong>长尾问题</strong>。因为从等待队列里面被唤醒，然后再去抢锁，对本身就在执行的<strong>G</strong>来说，被唤醒的<strong>G</strong>其实是很难抢过当前执行的<strong>G</strong>的，这样的话，等待队列里面的<strong>G</strong>，就会被饿死(长时间获取不到锁)，这样对等待队列的<strong>G</strong>来说其实是不公平的。</p><h3 id="饥饿模式"><a href="#饥饿模式" class="headerlink" title="饥饿模式"></a>饥饿模式</h3><p>简单概括一下，就是解决了等待G队列的长尾问题<br>饥饿模式下，直接由unlock把锁交给等待队列中排在第一位的G，同时，饥饿模式下，新进来的G不会参与抢锁也不会进入自旋状态，会直接进入等待队列的尾部。<br>饥饿模式的触发条件，当一个G等待锁时间超过1毫秒时，Mutex切换到饥饿模式<br>饥饿模式的取消条件，当一个G获取到锁且在等待队列的末尾，或者这个G获取锁的等待时间在1ms内，那么Mutex切换回正常模式</p><p>带来的改变</p><p>Mutex.state的倒数第三位，变成了mutexStarving标记位，0表示正常模式，1表示饥饿模式，与此同时，支持的最大等待G数量从230个 变成了229个</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 必看必会 </tag>
            
            <tag> 并发 </tag>
            
            <tag> mutex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang模拟面试题01</title>
      <link href="/interview/log/simulation01/"/>
      <url>/interview/log/simulation01/</url>
      
        <content type="html"><![CDATA[<ol><li><p>channel实现原理</p></li><li><p>Mutex 是悲观还是乐观锁（什么是乐观锁）</p></li><li><p>Mutex 有几种模式（饥饿和互斥）</p></li><li><p>Mutex 自旋锁？</p></li><li><p>goroutine 模型 和抢占时机</p><p><a href="https://www.bilibili.com/video/BV19r4y1w7Nx/?spm_id_from=333.788.recommend_more_video.6">https://www.bilibili.com/video/BV19r4y1w7Nx/?spm_id_from&#x3D;333.788.recommend_more_video.6</a></p></li><li><p>GC 原理</p></li><li><p>go内存分配，哪些对象分配在堆上，哪些分配在栈上（大对象小对象）</p></li><li><p>OOM out of MEMERY 内存泄漏</p></li><li><p>signal信号（64种）</p></li><li><p>Go Micro</p></li><li><p>CPU三级缓存，加载固定长度到cache，连续的地址空间</p></li><li><p>多核CPU如何保持cache不冲突（MESI）</p></li><li><p>rune 和 uint 超出位数后计算</p></li></ol><p>小厂01</p><ol><li>mutex有几种锁？<ol><li>互斥锁mutex</li><li>读写互斥锁rwmutex</li></ol></li><li>协程和线程？见golang101-1 .4</li><li>channel的作用？用法？<ol><li>控制并发数，一般结合 waitgroup</li><li>控制协程退出等</li></ol></li><li>tidb基础</li><li>gc流程 原理 golang101-2.4</li><li>线程与进程</li><li>slice 和 map 线程安全否</li><li>使用go遇到的挑战？</li><li>postgre？分布式缓存？</li><li>框架grpc相关</li><li>统计协程数量<ol><li>runtime.NumGoroutine()</li></ol></li><li>为什么转go<ol><li>微服务，上云</li><li>k8s</li><li>大量，分布式</li></ol></li></ol><p>ihandy</p><ol><li>项目</li><li>gc</li><li>redis 持久化</li><li>channel，context</li><li>mutex使用</li><li>gmp</li><li>进程线程协程</li></ol><p>数獨科技：多业务或者多方数据不出库，怎样模型化使用这些数据 tob</p><ol><li>项目<ol><li>最拿手的哪个？</li><li>技术点不是特别突出</li><li>任务系统要讲明白对用户和运营的两套接口模式，以及相关的缓存实现方案和刷新机制</li><li>广告系统要讲明白具体提升了哪些效率</li><li>什么维度的缓存key，等</li></ol></li><li>管理<ol><li>时间分配</li><li>需求评审大概流程和内容</li></ol></li><li>字符串相加</li><li>kafka ：topic， partition和consumer的关系， replica<ol><li>consumer的负载分配等</li><li>组内每个消费者对应一个partition，partition多的话由consumer承接，其中一个或几个接受的量会多；消费者多的话，多出partition的会处于空闲状态</li></ol></li></ol><p>中物联讯</p><ol><li>项目</li></ol><p>字节国际支付</p><ol><li>项目</li><li>redis 持久化</li><li>求根号2<ol><li>卡算法题了你敢信，菜逼</li><li>去把课程中的题每个至少来两遍才够的！！！！！！</li></ol></li></ol><p>循环调度：银行 or 销售的提效工具，通话质量模型 tob</p><ol><li>http + 协程，怎么调度的？是否涉及用户态和核心态的切换？</li><li>索引的构建流程？</li><li>b树，b+树区别，MongoDB为什么选用b树</li><li>gmp调度流程</li><li>redis 哪些命令? 时间复杂度是 o(n)</li><li>kafka 持久化？</li><li>kafka partition数量根据哪些信息确定的？<ol><li>回答：consumer的数量</li><li>答案：？</li></ol></li></ol><p>umu</p><ol><li>mysql 聚合索引和XX索引</li><li>redis 各种数据类型的底层结构</li></ol><p>自己总结：<br>并发，缓存，高可用，grpc，gc，gmp，mutex，channel，context等<br>http，redis，mysql，zookeeper，raft<br>乐观锁悲观锁？<br>cas？</p><p>集度基础服务开发</p><ol><li>grpc通信问题</li><li>grpc限流，熔断相关</li><li>golang 底层，写了就会问，channel实现方式，slice实现方式</li><li>如何做限流，redis请求锁的过期时间为什么，如果有人一直持有锁怎么办？</li><li>延时队列的实现方案</li><li>golang的gc</li><li>redis 锁的实现方案？</li><li>算法：判断二叉树是否对称</li><li>逃逸分析</li></ol><p>刷题：<br>剑指offer<br>算法训练营<br>简单题*3<br>中等题*4</p><p>Tik Tok二面<br>1.介绍数据库索引？<br>    数据库索引是一种数据结构，用于提高数据库查询效率。它通过创建特定的数据结构（如B树、B+树）来存储数据的有序副本，以便更快地定位和检索数据。<br>2.为什么把二叉查找树变成多路平衡查找树就能减少磁盘IO？为什么树的高度决定了磁盘的IO次数？如果查找某一个数据，用二叉查找树和用B+树的时间复杂度分别是多少?<br>3.B+树的叶子结点的默认大小是多少？如果把B树的非叶子结点只存放指针,那B树是不是就和B+树一样了呢？<br>4.除了二叉树，B+树，B树这些索引，还有什么常见的存储数据结构适合做索引呢？<br>    哈希索引和全文索引也常用于数据库索引。<br>5.为什么InnoDB不用哈希做索引，用哈希和用B+树有什么区别？<br>    哈希索引适用于等值查询，而B+树索引支持范围查询和排序。InnoDB使用B+树索引，因为它支持更多的查询类型。<br>6.Redis里面有序集合用的索引？介绍一下跳跃表，与哈希的区别？<br>    跳跃表是一种有序数据结构，用于实现有序集合。与哈希表相比，跳跃表支持有序性和范围查询。<br>7.MySQL事务隔离级别有哪些，会产生哪些问题，MySQL默认的隔离级别是什么<br>    MySQL的事务隔离级别包括读未提交、读已提交、可重复读和串行化。不同的隔离级别可能导致脏读、不可重复读和幻读等问题。MySQL默认的隔离级别是可重复读。<br>8.MySQL如何实现可重复读？MVCC的底层原理？<br>9.看你用过palsuar，也用过Kafka，那你说一下这两者不一样的地方？或者设计上有哪些不一样？<br>    Pulsar和Kafka都是消息中间件，但它们的架构和设计有所不同。例如，Pulsar支持多租户、多数据中心复制和动态消息路由等特性，而Kafka则更加专注于高吞吐量和低延迟。<br>14.说说两者底层存储消息方式的区别？<br>15.为什么这两者要这么设计？<br>17.Redis如何实现高可用和高可靠的？<br>    Redis实现高可用通常通过主从复制和哨兵或集群模式。哨兵负责监控节点健康，并在主节点失败时自动切换到从节点。集群模式支持数据分片和节点自动发现，提高了可用性和可扩展性。<br>18.Redis的主从复制是同步的还是异步的？异步和同步的优缺点？<br>    Redis的主从复制是异步的。异步复制提高了性能，但可能导致数据不一致性和数据丢失。<br>19.了解go吗，说说协程，为什么要用协程？<br>    协程是一种轻量级的线程，由Go语言原生支持。协程的优点包括低开销、高并发和简单易用，使得编写并发程序变得更加简单和高效。<br>20.为什么多线程访问共享资源需要加锁处理？<br>    多线程并发访问共享资源可能导致数据竞态和不一致性。加锁能够保证数据的原子性和一致性，从而确保线程安全。<br>21.说说可见性，为什么一个线程看不到另外一个线程的修改？<br>    线程的可见性指的是一个线程对共享变量的修改能够被其他线程立即看到。在多线程编程中，由于CPU的优化、缓存以及编译器的优化，可能导致线程之间的数据不一致。为了确保线程安全和正确性，我们需要解决这个问题。多线程对同一共享变量做修改时，某个线程修改后的新值可能不会立即更新到主内存，其他线程可能仍旧读到该变量旧值。<br>    使用锁保证同一时刻只有一个线程访问共享变量；<br>    对变量访问使用原子操作<br>23.让你设计一个任务调度器的类，add一个task，指定这个task的执行时间，可以add很多任务，但每个task执行的时间又各不相同，你如何实现，用什么数据结构？<br>    可以使用优先队列（如最小堆）来存储任务，并按照执行时间进行排序。每次调度器检查时，都会选择最早的任务执行。<br>24.优先队列的实现原理？</p><h2 id="定义与概念"><a href="#定义与概念" class="headerlink" title="定义与概念"></a><strong>定义与概念</strong></h2><p>优先队列是一种数据结构，用于存储具有不同优先级的任务或元素</p><p>包括FIFO（先进先出）和LIFO（后进先出）两种基本类型</p><h2 id="实现技术"><a href="#实现技术" class="headerlink" title="实现技术"></a><strong>实现技术</strong></h2><p>数据结构</p><p>堆式队列：高效的数据组织结构</p><p>K叉树：基于K叉树的优先队列算法，运算效率高</p><p>双输入通道优先网络：用于通信网络设计</p><p>算法设计</p><p>PQDSA算法：基于DAG任务集的入口节点数量确定优先队列数</p><p>MP-SAQM算法：基于优先级区分的调度及主动队列管理</p><p>硬件支持</p><p>SP-PIFO: 使用严格优先级队列逼近PIFO行为</p><p>光学优先队列：通过反馈系统实现，提高了缓冲容量的利用率</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h2><p>操作系统</p><p>调度算法优化：提高处理器调度效率</p><p>网络传输</p><p>数据包调度：实现可编程的数据包调度</p><p>人工智能</p><p>异构计算环境下的任务调度问题解决</p><p>中间件技术</p><p>处理多个任务时按轻重顺序执行，缩短用户平均等待时间</p><h2 id="性能分析与优化"><a href="#性能分析与优化" class="headerlink" title="性能分析与优化"></a><strong>性能分析与优化</strong></h2><p>并行操作性能</p><p>并行插入和删除方法：保证并行度和串行存取算法的优先顺序一致</p><p>高效合并优先队列的技术：减少存储开销，提高操作效率</p><p>实验验证与比较</p><p>实验结果验证了不同算法的有效性，如SP-PIFO、PQDSA等</p><p>对比经典堆算法和新颖堆变体在不同输入下的表现</p><h2 id="挑战与未来方向"><a href="#挑战与未来方向" class="headerlink" title="挑战与未来方向"></a><strong>挑战与未来方向</strong></h2><p>技术挑战</p><p>实现大规模并行操作的存储空间自适应性</p><p>提高硬件支持下的实时性和准确性</p><p>发展趋势</p><p>探索新的数据结构和算法以适应更复杂的应用场景</p><p>加强对异构计算环境下的优化和支持能力</p><p>25.算法题：二叉树的完全性检验？</p><h2 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h2><p>1.介绍一下业务表的字段</p><p>2.定时任务刷新字段, 是怎么实现的?</p><p>3.分布式锁? 分布式死锁如何解决? 看门狗机制? 如何避免当前线程加的锁, 被其它线程解锁?</p><p>4.乐观锁和悲观锁的区别? 写多读少的情况, 应该使用乐观锁还是悲观锁?</p><p>5.分布式场景下, 如何实现乐观锁?</p><p>6.kafka的幂等性? 如何避免消息被重复消费?</p><p>7.两个线程, 同时向mysql中插入一条数据?</p><p>8.kafka如何保证消息不丢失</p><p>9.sql优化场景:</p><p>select id,name,balance from account where update_time &gt; ‘2020-09-19’ limit 100000, 10</p><p>该语句为什么查询慢? 有什么优化思路?</p><ol start="10"><li>算法题: 子集</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 实录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式01-单例模式</title>
      <link href="/golang/go-design-pattern/gda-create/01-singleton/"/>
      <url>/golang/go-design-pattern/gda-create/01-singleton/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>单例模式采用了 饿汉式 和 懒汉式 两种实现，个人其实更倾向于饿汉式的实现，简单，并且可以将问题及早暴露，懒汉式虽然支持延迟加载，但是这只是把冷启动时间放到了第一次使用的时候，并没有本质上解决问题，并且为了实现懒汉式还不可避免的需要加锁。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><strong>代码实现:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="comment">// Singleton 饿汉式单例</span></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> singleton *Singletonfunc init() &#123;</span><br><span class="line">singleton = &amp;Singleton&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetInstance 获取实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line"><span class="keyword">return</span> singleton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单元测试:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton_test</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">singleton </span><br><span class="line"><span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetInstance</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">assert.Equal(t, singleton.GetInstance(), singleton.GetInstance())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkGetInstanceParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line"><span class="keyword">if</span> singleton.GetInstance() != singleton.GetInstance() &#123;</span><br><span class="line">b.Errorf(<span class="string">&quot;test fail&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式（双重检测）"><a href="#懒汉式（双重检测）" class="headerlink" title="懒汉式（双重检测）"></a>懒汉式（双重检测）</h3><p><strong>代码实现:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">lazySingleton *Singleton</span><br><span class="line">once          = &amp;sync.Once&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetLazyInstance 懒汉式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetLazyInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line"><span class="keyword">if</span> lazySingleton == <span class="literal">nil</span> &#123;</span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">lazySingleton = &amp;Singleton&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lazySingleton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单元测试:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton_test</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">singleton </span><br><span class="line"><span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetInstance</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">assert.Equal(t, singleton.GetInstance(), singleton.GetInstance())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkGetInstanceParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line"><span class="keyword">if</span> singleton.GetInstance() != singleton.GetInstance() &#123;</span><br><span class="line">b.Errorf(<span class="string">&quot;test fail&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 创建型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang201</title>
      <link href="/golang/advanced-tutorial/golang201/"/>
      <url>/golang/advanced-tutorial/golang201/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 进阶教程笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>channel</title>
      <link href="/golang/concurrency/go-channel/"/>
      <url>/golang/concurrency/go-channel/</url>
      
        <content type="html"><![CDATA[<h2 id="channel-101"><a href="#channel-101" class="headerlink" title="channel 101"></a>channel 101</h2><h3 id="1-引子"><a href="#1-引子" class="headerlink" title="1. 引子"></a>1. 引子</h3><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。</p><p>如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h4><h2 id="channel-底层原理"><a href="#channel-底层原理" class="headerlink" title="channel 底层原理"></a>channel 底层原理</h2><ul><li><code>buf</code>是有缓冲的channel所特有的结构，用来存储缓存数据。是个循环链表 （为啥是循环链表？普通数组不行吗，普通数组地址和容量固定更适合指定的空间。需要pop 掉元素，普通数组需要全部都前移）</li><li><code>sendx</code>和<code>recvx</code>用于记录<code>buf</code>这个循环链表中的<del>发送或者接收的</del>index</li><li><code>lock</code>是个互斥锁。</li><li><code>recvq</code>和<code>sendq</code>分别是接收(&lt;-channel)或者发送(channel &lt;- xxx)的goroutine抽象出来的结构体(sudog)的队列。是个双向链表</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="type">uint</span>  <span class="comment">// 队列中的总元素个数 </span></span><br><span class="line">dataqsiz <span class="type">uint</span>  <span class="comment">// 环形队列大小，即可存放元素的个数 </span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// 环形队列指针 </span></span><br><span class="line">elemsize <span class="type">uint16</span>  <span class="comment">//每个元素的大小 </span></span><br><span class="line">closed   <span class="type">uint32</span>  <span class="comment">//标识关闭状态 </span></span><br><span class="line">elemtype *_type <span class="comment">// 元素类型 </span></span><br><span class="line">sendx    <span class="type">uint</span>   <span class="comment">// 发送索引，元素写入时存放到队列中的位置</span></span><br><span class="line">recvx    <span class="type">uint</span>   <span class="comment">// 接收索引，元素从队列的该位置读出</span></span><br><span class="line">recvq    waitq  <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">sendq    waitq <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex <span class="comment">//互斥锁，chan不允许并发读写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-读写流程"><a href="#1-读写流程" class="headerlink" title="1. 读写流程"></a>1. 读写流程</h4><blockquote><p>向 channel 写数据:</p><ol><li><p>若等待接收队列 recvq 不为空，则缓冲区中无数据或无缓冲区，将直接从 recvq 取出 G ，并把数据写入，最后把该 G 唤醒，结束发送过程。</p></li><li><p>若缓冲区中有空余位置，则将数据写入缓冲区，结束发送过程。</p></li><li><p>若缓冲区中没有空余位置，则将发送数据写入 G，将当前 G 加入 sendq ，进入睡眠，等待被读 goroutine 唤醒。</p></li></ol></blockquote><blockquote><p>从 channel 读数据</p><ol><li><p>若等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G ，把 G 中数据读出，最后把 G 唤醒，结束读取过程。</p></li><li><p>如果等待发送队列 sendq 不为空，说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程。</p></li><li><p>如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程。</p></li><li><p>将当前 goroutine 加入 recvq ，进入睡眠，等待被写 goroutine 唤醒。</p></li></ol></blockquote><blockquote><p>关闭 channel</p><p>1.关闭 channel 时会将 recvq 中的 G 全部唤醒，本该写入 G 的数据位置为 nil。将 sendq 中的 G 全部唤醒，但是这些 G 会 panic。</p><p>panic 出现的场景还有：</p><ul><li>关闭值为 nil 的 channel</li><li>关闭已经关闭的 channel</li><li>向已经关闭的 channel 中写数据</li></ul></blockquote><h4 id="2-创建channel"><a href="#2-创建channel" class="headerlink" title="2. 创建channel"></a>2. 创建channel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无缓冲的channel由于没有缓冲发送和接收需要同步</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)   </span><br><span class="line"><span class="comment">//有缓冲channel不要求发送和接收操作同步</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>实例化了 chan 的结构体，返回ch指针</p><h4 id="channel中发送send-ch-lt-xxx-和recv-lt-ch-接收"><a href="#channel中发送send-ch-lt-xxx-和recv-lt-ch-接收" class="headerlink" title="channel中发送send(ch &lt;- xxx)和recv(&lt;- ch)接收"></a>channel中发送send(ch &lt;- xxx)和recv(&lt;- ch)接收</h4><p>使用 mutex 加锁操作，新进先出的队列</p><h4 id="当channel缓存满后"><a href="#当channel缓存满后" class="headerlink" title="当channel缓存满后"></a>当channel缓存满后</h4><h5 id="发送满的时候"><a href="#发送满的时候" class="headerlink" title="发送满的时候"></a>发送满的时候</h5><p>当队列已满的时候，G1正在运行，当再次send操作时，会主动调用GO的调度器，让G1等待，并让出M，同时G1也会被抽象成含有G1指针和send元素的sudog结构体保存到hchan的<code>sendq</code>中等待被唤醒。</p><p>当G2 recv操作的时候，G2从缓存队列中取出数据，channel会将等待队列中的G1推出，将G1当时send的数据推到缓存中，然后调用Go的scheduler，唤醒G1，并把G1放到可运行的Goroutine队列中。</p><h5 id="接收满的时候"><a href="#接收满的时候" class="headerlink" title="接收满的时候"></a>接收满的时候</h5><p>这个时候G2会主动调用Go的调度器,让G2等待，并从让出M，让其他G去使用。 G2还会被抽象成含有G2指针和recv空元素的<code>sudog</code>结构体保存到hchan的<code>recvq</code>中等待被唤醒。此时恰好有个goroutine G1开始向channel中推送数据 <code>ch &lt;- 1</code>。 此时，非常有意思的事情发生了：G1并没有锁住channel，然后将数据放到缓存中，而是直接把数据从G1直接copy到了G2的栈中。 这种方式非常的赞！在唤醒过程中，G2无需再获得channel的锁，然后从缓存中取数据。减少了内存的copy，提高了效率。</p><h4 id="4-channel-的状态和操作方式"><a href="#4-channel-的状态和操作方式" class="headerlink" title="4. channel 的状态和操作方式"></a>4. channel 的状态和操作方式</h4><p>如下：</p><table><thead><tr><th align="left">操作</th><th align="left">nil 的 channel</th><th align="left">已关闭的 channel</th><th align="left">正常 channel</th></tr></thead><tbody><tr><td align="left">close 关闭</td><td align="left">panic</td><td align="left">panic</td><td align="left">成功</td></tr><tr><td align="left">ch &lt;- 写</td><td align="left">死锁</td><td align="left">panic</td><td align="left">阻塞或成功</td></tr><tr><td align="left">&lt;-ch 读</td><td align="left">死锁</td><td align="left">零值</td><td align="left">阻塞或成功</td></tr></tbody></table><p>channel一个类型管道，通过它可以在goroutine之间发送和接收消息。它是Golang在语言层面提供的goroutine间的通信方式。</p><p>众所周知，Go依赖于称为CSP（Communicating Sequential Processes）的并发模型，通过Channel实现这种同步模式。Go并发的核心哲学是不要通过共享内存进行通信; 相反，通过沟通分享记忆。</p><h2 id="channel-常见用法"><a href="#channel-常见用法" class="headerlink" title="channel 常见用法"></a>channel 常见用法</h2><h4 id="循环读取"><a href="#循环读取" class="headerlink" title="循环读取"></a>循环读取</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x := <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 必看必会 </tag>
            
            <tag> channel </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http 网络面试必备</title>
      <link href="/interview/http/"/>
      <url>/interview/http/</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP-协议和-HTTPS"><a href="#HTTP-协议和-HTTPS" class="headerlink" title="HTTP 协议和 HTTPS"></a>HTTP 协议和 HTTPS</h3><ul><li>HTTPS是加密传输协议，HTTP是名文传输协议</li><li>HTTPS需要用到SSL证书，而HTTP不用</li><li>HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO【参考：（1）为保护用户隐私安全,谷歌优先索引HTTPS网页、（2）百度开放收录https站点，https全网化势不可挡】</li><li>HTTPS标准端口443，HTTP标准端口80</li><li>HTTPS基于传输层，HTTP基于应用层</li><li>HTTPS在浏览器显示绿色安全锁，HTTP没有显示</li></ul><h3 id="TLS-x2F-SSL工作原理"><a href="#TLS-x2F-SSL工作原理" class="headerlink" title="TLS&#x2F;SSL工作原理"></a>TLS&#x2F;SSL工作原理</h3><p>对称加密：</p><ul><li>算法是公开的</li><li>通过秘钥来加密，使用相同的秘钥加密解密</li><li>des, 3des, aes</li><li>缺点：<ul><li>秘钥容易泄露</li><li>一个用户需要对应一个秘钥，服务器管理秘钥比较麻烦</li></ul></li></ul><p>非对称加密：</p><ul><li>算法公开</li><li>公钥加密，私钥解密</li><li>私钥加密，公钥解密</li><li>黑客拿到公钥和公钥加密的内容也解不了密</li><li>rsa, ecc, dh</li><li>优点：<ul><li>加密和解密使用不同的钥匙，可以传输公钥是安全的</li></ul></li><li>缺点<ul><li>加密和解密的速度比较慢</li></ul></li></ul><p>散列函数Hash：</p><ul><li>MD5，SHA1，SHA256</li><li>函数单向不可逆、对输入非常敏感、输出长度固定</li><li>散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密</li></ul><h4 id="HTTPS的握手过程"><a href="#HTTPS的握手过程" class="headerlink" title="HTTPS的握手过程"></a>HTTPS的握手过程</h4><p><img src="https://static.studygolang.com/200511/4bf1766991151c30854781c4b4455eb2.png" alt="image"><br>HTTPS的握手过程</p><ol><li>“client hello”消息：客户端通过发送”client hello”消息向服务器发起握手请求，该消息包含了客户端所支持的 TLS 版本和密码组合以供服务器进行选择，还有一个”client random”随机字符串。</li><li>“server hello”消息：服务器发送”server hello”消息对客户端进行回应，该消息包含了数字证书，服务器选择的密码组合和”server random”随机字符串。</li><li>验证：客户端对服务器发来的证书进行验证，确保对方的合法身份，验证过程可以细化为以下几个步骤：<ol><li>检查数字签名</li><li>验证证书链</li><li>检查证书的有效期</li><li>检查证书的撤回状态 (撤回代表证书已失效)</li></ol></li><li>premaster secret 字符串：客户端向服务器发送另一个随机字符串”premaster secret （预主密钥）”，这个字符串是经过服务器的公钥加密过的，只有对应的私钥才能解密。</li><li>使用私钥：服务器使用私钥解密”premaster secret”。</li><li>生成共享密钥：客户端和服务器均使用 client random，server random 和 premaster secret，并通过相同的算法生成相同的共享密钥 KEY。</li><li>客户端就绪：客户端发送经过共享密钥 KEY加密过的”finished”信号。</li><li>服务器就绪：服务器发送经过共享密钥 KEY加密过的”finished”信号。</li><li>达成安全通信：握手完成，双方使用对称加密进行安全通信。</li></ol><h4 id="HTTPS接入优化"><a href="#HTTPS接入优化" class="headerlink" title="HTTPS接入优化"></a>HTTPS接入优化</h4><ol><li>CDN接入<br>HTTPS 增加的延时主要是传输延时 RTT，RTT 的特点是节点越近延时越小，CDN 天然离用户最近，因此选择使用 CDN 作为 HTTPS 接入的入口，将能够极大减少接入延时。CDN 节点通过和业务服务器维持长连接、会话复用和链路质量优化等可控方法，极大减少 HTTPS 带来的延时。</li><li>会话缓存<br>虽然前文提到 HTTPS 即使采用会话缓存也要至少1*RTT的延时，但是至少延时已经减少为原来的一半，明显的延时优化;同时，基于会话缓存建立的 HTTPS 连接不需要服务器使用RSA私钥解密获取 Pre-master 信息，可以省去CPU 的消耗。如果业务访问连接集中，缓存命中率高，则HTTPS的接入能力讲明显提升。当前TRP平台的缓存命中率高峰时期大于30%，10k&#x2F;s的接入资源实际可以承载13k&#x2F;的接入，收效非常可观。</li><li>硬件加速<br>为接入服务器安装专用的SSL硬件加速卡，作用类似 GPU，释放 CPU，能够具有更高的 HTTPS 接入能力且不影响业务程序的。测试某硬件加速卡单卡可以提供35k的解密能力，相当于175核 CPU，至少相当于7台24核的服务器，考虑到接入服务器其它程序的开销，一张硬件卡可以实现接近10台服务器的接入能力。</li><li>远程解密<br>本地接入消耗过多的 CPU 资源，浪费了网卡和硬盘等资源，考虑将最消耗 CPU 资源的RSA解密计算任务转移到其它服务器，如此则可以充分发挥服务器的接入能力，充分利用带宽与网卡资源。远程解密服务器可以选择 CPU 负载较低的机器充当，实现机器资源复用，也可以是专门优化的高计算性能的服务器。当前也是 CDN 用于大规模HTTPS接入的解决方案之一。</li><li>SPDY&#x2F;HTTP2<br>前面的方法分别从减少传输延时和单机负载的方法提高 HTTPS 接入性能，但是方法都基于不改变 HTTP 协议的基础上提出的优化方法，SPDY&#x2F;HTTP2 利用 TLS&#x2F;SSL 带来的优势，通过修改协议的方法来提升 HTTPS 的性能，提高下载速度等。</li></ol><h4 id="https加密、解密及验证过程"><a href="#https加密、解密及验证过程" class="headerlink" title="https加密、解密及验证过程"></a>https加密、解密及验证过程</h4><ul><li>浏览器发送请求443端口（自身支持的非对称加密算法，协商）</li><li>ssl层放入公钥和服务器身份认证进行签名，保留私钥</li><li>浏览器校验公钥，和服务器身份</li><li>产生随机码，用公钥加密（此时黑客就算得到公钥也没办法对其解密出随机码）</li><li>服务器用会话密钥来对称加密传输</li></ul><h4 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别?"></a>tcp和udp的区别?</h4><ol><li>连接: tcp需要建立连接 udp不需建立连接</li><li>服务对象: tcp是一对一, udp可一对一, 一对多</li><li>可靠性: tcp可靠, 有序, udp不可靠, 无序</li><li>拥塞控制,流量控制: tcp拥有拥塞控制和流量控制, 保证数据传输的安全性, udp即使网络非常拥堵, 也不影响udp的发送速率</li><li>传输方式: tcp为流式传输, 没有边界, 但保证顺序和可靠, udp是一个包一个包发送, 有边界, 但是可能丢包或乱序</li><li>首部开销: tcp的首部开销大, udp的首部只有固定的8字节,开销小</li></ol><h4 id="面试常问问题——浏览器访问网址发生了什么？"><a href="#面试常问问题——浏览器访问网址发生了什么？" class="headerlink" title="面试常问问题——浏览器访问网址发生了什么？"></a>面试常问问题——浏览器访问网址发生了什么？</h4><p>总体来说分为以下几个过程：</p><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
            <tag> 必看必会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>channel - goroutine</title>
      <link href="/golang/concurrency/channel-gorourine/"/>
      <url>/golang/concurrency/channel-gorourine/</url>
      
        <content type="html"><![CDATA[<h3 id="goroutine超时处理"><a href="#goroutine超时处理" class="headerlink" title="goroutine超时处理"></a>goroutine超时处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        c1 &lt;- <span class="string">&quot;result 1&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c1:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout 1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        c2 &lt;- <span class="string">&quot;result 2&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c2:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无阻塞"><a href="#无阻塞" class="headerlink" title="无阻塞"></a>无阻塞</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c2:</span><br><span class="line">    fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">    fmt.Println(<span class="string">&quot;timeout 2&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通道关闭"><a href="#通道关闭" class="headerlink" title="通道关闭"></a>通道关闭</h3><ol><li>close(channel) 关闭通道</li><li>j，more :&#x3D; &lt;- channel 如果已关闭，则more为 false</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            j, more := &lt;-jobs</span><br><span class="line">            <span class="keyword">if</span> more &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;received job&quot;</span>, j)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;received all jobs&quot;</span>)</span><br><span class="line">                done &lt;- <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++ &#123;</span><br><span class="line">        jobs &lt;- j</span><br><span class="line">        fmt.Println(<span class="string">&quot;sent job&quot;</span>, j)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(jobs)</span><br><span class="line">    fmt.Println(<span class="string">&quot;sent all jobs&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管道遍历"><a href="#管道遍历" class="headerlink" title="管道遍历"></a>管道遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    queue := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    queue &lt;- <span class="string">&quot;one&quot;</span></span><br><span class="line">    queue &lt;- <span class="string">&quot;two&quot;</span></span><br><span class="line">    <span class="built_in">close</span>(queue)</span><br><span class="line">    <span class="keyword">for</span> elem := <span class="keyword">range</span> queue &#123;</span><br><span class="line">        fmt.Println(elem)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="只读和只写管道"><a href="#只读和只写管道" class="headerlink" title="只读和只写管道"></a>只读和只写管道</h3><ul><li><code>&lt;-chan string</code> 只读</li><li><code>chan&lt;- string</code> 只写</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(jobs <span class="keyword">chan</span> <span class="type">int</span>, done <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">j, more := &lt;-jobs</span><br><span class="line"><span class="keyword">if</span> more &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;received job&quot;</span>, j)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;received all jobs&quot;</span>)</span><br><span class="line">done &lt;- <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMsg</span><span class="params">(jobs <span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++ &#123;</span><br><span class="line">jobs &lt;- j</span><br><span class="line">fmt.Println(<span class="string">&quot;sent job&quot;</span>, j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(jobs)</span><br><span class="line">fmt.Println(<span class="string">&quot;sent all jobs&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> test(jobs, done)</span><br><span class="line"><span class="keyword">go</span> sendMsg(jobs)</span><br><span class="line"></span><br><span class="line">&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制并发数"><a href="#控制并发数" class="headerlink" title="控制并发数"></a>控制并发数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">choice1()</span><br><span class="line">choice2()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">choice1</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span> ,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">time.Sleep( time.Second)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&lt;- ch</span><br><span class="line">&#125;(ch)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">choice2</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span> ,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">time.Sleep( time.Second)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&lt;- ch</span><br><span class="line">&#125;(ch)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 必看必会 </tag>
            
            <tag> channel </tag>
            
            <tag> goroutine </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 反射</title>
      <link href="/golang/reflect/"/>
      <url>/golang/reflect/</url>
      
        <content type="html"><![CDATA[<h3 id="Name-and-Kind"><a href="#Name-and-Kind" class="headerlink" title="Name and Kind"></a>Name and Kind</h3><p>可调用函数和含义，以及结果一览</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typeOfCat := reflect.TypeOf(cat&#123;&#125;)</span><br><span class="line">typeOfCat.Name() <span class="comment">// cat</span></span><br><span class="line">typeOfCat.Kind()  <span class="comment">// struct</span></span><br><span class="line">typeOfCat.NumField() <span class="comment">// 2 几个字段</span></span><br><span class="line">typeOfCat.Field(i) <span class="comment">//第几个字段</span></span><br><span class="line">typeOfCat.FieldByName(<span class="string">&quot;Type&quot;</span>) <span class="comment">// 找名为Type的字段</span></span><br><span class="line">typeOfCat.MethodByName(<span class="string">&quot;Start&quot;</span>) <span class="comment">// 找名为Start的方法</span></span><br><span class="line"><span class="keyword">if</span> typeofCat.Kind() == <span class="string">&quot;ptr&quot;</span>&#123;</span><br><span class="line">  res := typeOfCat.Elem()  <span class="comment">// 等价于*ptr</span></span><br><span class="line">  res.Name()</span><br><span class="line">  res.Kind()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reflect-ValueOf-和reflect-Value"><a href="#reflect-ValueOf-和reflect-Value" class="headerlink" title="reflect.ValueOf()和reflect.Value"></a>reflect.ValueOf()和reflect.Value</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">valueOfA := reflect.ValueOf(a)</span><br><span class="line"><span class="keyword">var</span> getA <span class="type">int</span> = valueOfA.Interface().(<span class="type">int</span>)</span><br><span class="line"><span class="keyword">var</span> getA2 <span class="type">int</span> = <span class="type">int</span>(valueOfA.Int())</span><br></pre></td></tr></table></figure><h3 id="通过反射获取值信息"><a href="#通过反射获取值信息" class="headerlink" title="通过反射获取值信息"></a>通过反射获取值信息</h3><h4 id="使用反射值对象包装任意值"><a href="#使用反射值对象包装任意值" class="headerlink" title="使用反射值对象包装任意值"></a>使用反射值对象包装任意值</h4><p>Go语言中，使用 reflect.ValueOf() 函数获得值的反射值对象（reflect.Value）。书写格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value := reflect.ValueOf(rawValue)</span><br></pre></td></tr></table></figure><p>reflect.ValueOf 返回 reflect.Value 类型，包含有 rawValue 的值信息。reflect.Value 与原值间可以通过值包装和值获取互相转化。reflect.Value 是一些反射操作的重要类型，如反射调用函数。</p><h4 id="从反射值对象获取被包装的值"><a href="#从反射值对象获取被包装的值" class="headerlink" title="从反射值对象获取被包装的值"></a>从反射值对象获取被包装的值</h4><p>Go语言中可以通过 reflect.Value 重新获得原始值。</p><h5 id="1-从反射值对象（reflect-Value）中获取值的方法"><a href="#1-从反射值对象（reflect-Value）中获取值的方法" class="headerlink" title="1) 从反射值对象（reflect.Value）中获取值的方法"></a>1) 从反射值对象（reflect.Value）中获取值的方法</h5><p>可以通过下面几种方法从反射值对象 reflect.Value 中获取原值，如下表所示。</p><table><thead><tr><th align="left">方法名</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="left">Interface() interface {}</td><td align="left">将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td></tr><tr><td align="left">Int() int64</td><td align="left">将值以 int 类型返回，所有有符号整型均可以此方式返回</td></tr><tr><td align="left">Uint() uint64</td><td align="left">将值以 uint 类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td align="left">Float() float64</td><td align="left">将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td align="left">Bool() bool</td><td align="left">将值以 bool 类型返回</td></tr><tr><td align="left">Bytes() []bytes</td><td align="left">将值以字节数组 []bytes 类型返回</td></tr><tr><td align="left">String() string</td><td align="left">将值以字符串类型返回</td></tr></tbody></table><h5 id="2-从反射值对象（reflect-Value）中获取值的例子"><a href="#2-从反射值对象（reflect-Value）中获取值的例子" class="headerlink" title="2) 从反射值对象（reflect.Value）中获取值的例子"></a>2) 从反射值对象（reflect.Value）中获取值的例子</h5><p>下面代码中，将整型变量中的值使用 reflect.Value 获取反射值对象（reflect.Value）。再通过 reflect.Value 的 Interface() 方法获得 interface{} 类型的原值，通过 int 类型对应的 reflect.Value 的 Int() 方法获得整型值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明整型变量a并赋初值</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">1024</span></span><br><span class="line">    <span class="comment">// 获取变量a的反射值对象</span></span><br><span class="line">    valueOfA := reflect.ValueOf(a)</span><br><span class="line">    <span class="comment">// 获取interface&#123;&#125;类型的值, 通过类型断言转换</span></span><br><span class="line">    <span class="keyword">var</span> getA <span class="type">int</span> = valueOfA.Interface().(<span class="type">int</span>)</span><br><span class="line">    <span class="comment">// 获取64位的值, 强制类型转换为int类型</span></span><br><span class="line">    <span class="keyword">var</span> getA2 <span class="type">int</span> = <span class="type">int</span>(valueOfA.Int())</span><br><span class="line">    fmt.Println(getA, getA2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代码输出如下：</span></span><br><span class="line"><span class="comment">// 1024 1024</span></span><br></pre></td></tr></table></figure><h3 id="通过reflect反射修改值"><a href="#通过reflect反射修改值" class="headerlink" title="通过reflect反射修改值"></a>通过reflect反射修改值</h3><p>判断反射值是否可以修改？CanSet()，是否能被取址CanAddr()</p><p>结构体成员中，如果字段没有被导出，即便不使用反射也可以被访问，但不能通过反射修改</p><ol><li><p>指针指向的具体元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">v := reflect.ValueOf(&amp;x)</span><br><span class="line">v = v.Elem()</span><br></pre></td></tr></table></figure></li><li><p>slice的元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">1</span>&#125;</span><br><span class="line">v := reflect.ValueOf(s)</span><br><span class="line">e := v.Index(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p>可寻址的结构体的字段(指向结构体的指针)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Orange <span class="keyword">struct</span>&#123;</span><br><span class="line">  Size <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line">a := Orange&#123;<span class="number">99</span>&#125;</span><br><span class="line">v := reflect.ValueOf(&amp;a)</span><br><span class="line">v = v.Elem()</span><br><span class="line">field = v.FieldByName(<span class="string">&quot;field&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>可寻址的数组的元素(指向数组的指针)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">1</span>&#125;</span><br><span class="line">v := reflect.ValueOf(&amp;a)</span><br><span class="line">v = v.Elem()</span><br><span class="line">vIndex = v.Index(<span class="number">0</span>)</span><br><span class="line">vIndex.SetInt(<span class="number">1</span>)</span><br><span class="line">vIndex.SetInt(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ol><table><thead><tr><th align="left">-</th><th align="left">-</th></tr></thead><tbody><tr><td align="left">Set(x Value)</td><td align="left">将值设置为传入的反射值对象的值</td></tr><tr><td align="left">Setlnt(x int64)</td><td align="left">使用 int64 设置值。当值的类型不是 int、int8、int16、 int32、int64 时会发生宕机</td></tr><tr><td align="left">SetUint(x uint64)</td><td align="left">使用 uint64 设置值。当值的类型不是 uint、uint8、uint16、uint32、uint64 时会发生宕机</td></tr><tr><td align="left">SetFloat(x float64)</td><td align="left">使用 float64 设置值。当值的类型不是 float32、float64 时会发生宕机</td></tr><tr><td align="left">SetBool(x bool)</td><td align="left">使用 bool 设置值。当值的类型不是 bod 时会发生宕机</td></tr><tr><td align="left">SetBytes(x []byte)</td><td align="left">设置字节数组 []bytes值。当值的类型不是 []byte 时会发生宕机</td></tr><tr><td align="left">SetString(x string)</td><td align="left">设置字符串值。当值的类型不是 string 时会发生宕机</td></tr></tbody></table><h3 id="通过类型信息创建实例"><a href="#通过类型信息创建实例" class="headerlink" title="通过类型信息创建实例"></a>通过类型信息创建实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">typeOfA := reflect.TypeOf(a)</span><br><span class="line">aIns := reflect.New(typeOfA) <span class="comment">// 等价于 new(int)</span></span><br><span class="line">fmt.Println(aIns.Type(), aIns.Kind())</span><br></pre></td></tr></table></figure><h3 id="Go语言结构体标签（Struct-Tag）"><a href="#Go语言结构体标签（Struct-Tag）" class="headerlink" title="Go语言结构体标签（Struct Tag）"></a>Go语言结构体标签（Struct Tag）</h3><h4 id="结构体标签的格式"><a href="#结构体标签的格式" class="headerlink" title="结构体标签的格式"></a>结构体标签的格式</h4><p>tag 格式：<code>json:&quot;type&quot; id:&quot;100&quot;</code></p><p>注意：</p><ol><li>key:“value” 冒号后没有空格</li><li>两个key之间，一个空格，多一个都不行</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Type <span class="type">int</span> <span class="string">`json:&quot;type&quot; id:&quot;100&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从结构体标签中获取值"><a href="#从结构体标签中获取值" class="headerlink" title="从结构体标签中获取值"></a>从结构体标签中获取值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeOfCat := reflect.TypeOf(cat&#123;&#125;)</span><br><span class="line">catType = typeOfCat.FieldByName(<span class="string">&quot;Type&quot;</span>)</span><br><span class="line">catType.Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><h4 id="动态调用函数（无参数）"><a href="#动态调用函数（无参数）" class="headerlink" title="动态调用函数（无参数）"></a>动态调用函数（无参数）</h4><ol><li>直接<code>reflect.Valueof</code></li><li><code>MethodByName</code></li><li>调用<code>Call</code>方法</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Do&quot;</span></span><br><span class="line">    t := &amp;T&#123;&#125;</span><br><span class="line">    reflect.ValueOf(t).MethodByName(name).Call(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Do() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态调用函数（有参数）"><a href="#动态调用函数（有参数）" class="headerlink" title="动态调用函数（有参数）"></a>动态调用函数（有参数）</h4><ol><li>创建<code>reflect.Value</code>切片</li><li><code>reflect.Valueof(t).MethodByName(string)</code> 调用Call方法传入参数</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Do&quot;</span></span><br><span class="line">    t := &amp;T&#123;&#125;</span><br><span class="line">    a := reflect.ValueOf(<span class="number">1111</span>)</span><br><span class="line">    b := reflect.ValueOf(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    in := []reflect.Value&#123;a, b&#125;</span><br><span class="line">    reflect.ValueOf(t).MethodByName(name).Call(in)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Do(a <span class="type">int</span>, b <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span> + b, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接收返回值"><a href="#接收返回值" class="headerlink" title="接收返回值"></a>接收返回值</h4><ol><li>返回<code>[]reflect.Value</code></li><li>调用<code>Interface()</code>方法，转为<code>interface&#123;&#125;</code>类型</li><li>断言类型</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Do&quot;</span></span><br><span class="line">    t := &amp;T&#123;&#125;</span><br><span class="line">    ret := reflect.ValueOf(t).MethodByName(name).Call(<span class="literal">nil</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;strValue: %[1]v\nerrValue: %[2]v\nstrType: %[1]T\nerrType: %[2]T&quot;</span>, ret[<span class="number">0</span>], ret[<span class="number">1</span>].Interface().(<span class="type">error</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Do() (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>, errors.New(<span class="string">&quot;new error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Tag解析"><a href="#Tag解析" class="headerlink" title="Tag解析"></a>Tag解析</h4><ol><li><code>reflect.Typeof</code>有<code>NumField</code>，Field根据序号索取，取其中的tag</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;</span><br><span class="line">Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Age <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := T&#123;&#125;</span><br><span class="line">tt := reflect.TypeOf(a)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;tt.NumField();i++&#123;</span><br><span class="line">fmt.Println(tt.Field(i).Name)</span><br><span class="line">fmt.Println(tt.Field(i).Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">fmt.Println(tt.Field(i).Tag.Lookup(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">fmt.Println(tt.Field(i).Type)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过kind（）处理不同分支"><a href="#通过kind（）处理不同分支" class="headerlink" title="通过kind（）处理不同分支"></a>通过kind（）处理不同分支</h4><ol><li><code>reflect.Typeof().Kind()</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := <span class="number">1</span></span><br><span class="line">a := reflect.TypeOf(t)</span><br><span class="line"><span class="keyword">switch</span> a.Kind() &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.String:</span><br><span class="line">fmt.Println(<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> reflect.Int:</span><br><span class="line">fmt.Println(<span class="string">&quot;int&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断结构体是否实现接口"><a href="#判断结构体是否实现接口" class="headerlink" title="判断结构体是否实现接口"></a>判断结构体是否实现接口</h4><ol><li>将<code>nil</code>强转为接口指针类型，通过<code>reflect.Typeof().Elem</code>获取其接口类型</li><li><code>reflect.Typeof</code>调用方法<code>Implements</code>来判断</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IT <span class="keyword">interface</span> &#123;</span><br><span class="line">test1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">A <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> test1() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := &amp;T&#123;&#125;</span><br><span class="line">elem := reflect.TypeOf((*IT)(<span class="literal">nil</span>)).Elem()</span><br><span class="line"><span class="keyword">if</span> reflect.TypeOf(t).Implements(elem) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接通过接口强转判断</p><ol><li>将类型转换为 <code>reflect.Value</code></li><li>将<code>reflect.Value</code>调用Interface()方法转为接口类型</li><li>类型断言</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ITester <span class="keyword">interface</span> &#123;</span><br><span class="line">test1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">A <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u := &amp;User&#123;&#125;</span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line">val, ok := v.Interface().(ITester)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Support Interface&quot;</span>, val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> reflect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础知识</title>
      <link href="/interview/elementary/"/>
      <url>/interview/elementary/</url>
      
        <content type="html"><![CDATA[<h3 id="多核-CPU-Cache-如何保持一致？"><a href="#多核-CPU-Cache-如何保持一致？" class="headerlink" title="多核 CPU Cache 如何保持一致？"></a>多核 CPU Cache 如何保持一致？</h3><p>MESI</p><h3 id="CAP-原理"><a href="#CAP-原理" class="headerlink" title="CAP 原理"></a>CAP 原理</h3><p><a href="https://cloud.tencent.com/developer/article/2053602">https://cloud.tencent.com/developer/article/2053602</a></p><h3 id="大表-Join-小表优化，如何处理数据倾斜"><a href="#大表-Join-小表优化，如何处理数据倾斜" class="headerlink" title="大表 Join 小表优化，如何处理数据倾斜"></a>大表 Join 小表优化，如何处理数据倾斜</h3><h3 id="讲一下最大堆和最小堆"><a href="#讲一下最大堆和最小堆" class="headerlink" title="讲一下最大堆和最小堆"></a>讲一下最大堆和最小堆</h3><h3 id="happen-before-的规则"><a href="#happen-before-的规则" class="headerlink" title="happen-before 的规则"></a>happen-before 的规则</h3>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试算法题总结</title>
      <link href="/interview/inter-alg101/"/>
      <url>/interview/inter-alg101/</url>
      
        <content type="html"><![CDATA[<h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><p>更多加分点： 加权等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> LoadBalancer <span class="keyword">struct</span> &#123;</span><br><span class="line">    client []*Client</span><br><span class="line">    size <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLB</span><span class="params">(size <span class="type">int32</span>)</span></span> *LoadBalalcer &#123;</span><br><span class="line">    lb := &amp;LoadBalancer&#123;client: <span class="built_in">make</span>([]*Client, size), size: size&#125;</span><br><span class="line">    lb.client = <span class="built_in">append</span>(lb.client, &amp;Client&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> lb</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LoadBalancer)</span></span> getClient() *Client &#123;</span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">    x := rand.Int31n(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">return</span> m.client[x &amp; m.size]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Client)</span></span> Do &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Do&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    lb := NewLB(<span class="number">4</span>)</span><br><span class="line">    lb.getClient().Do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用反射调用函数"><a href="#利用反射调用函数" class="headerlink" title="利用反射调用函数"></a>利用反射调用函数</h3><p>实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span></span> Drive &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Driving&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    car := Car&#123;&#125;</span><br><span class="line">    val := reflect.ValueOf(&amp;car)</span><br><span class="line">    f := value.MethodByName(<span class="string">&quot;Drive&quot;</span>)</span><br><span class="line">    f.Call([]reflect.Value&#123;&#125;)  <span class="comment">// Drive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给定三个函数-cat-dog-fish-，每个函数启动一个-goroutine-，要求按照顺序打印100次"><a href="#给定三个函数-cat-dog-fish-，每个函数启动一个-goroutine-，要求按照顺序打印100次" class="headerlink" title="给定三个函数 cat dog fish ，每个函数启动一个 goroutine ，要求按照顺序打印100次"></a>给定三个函数 cat dog fish ，每个函数启动一个 goroutine ，要求按照顺序打印100次</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintCat</span><span class="params">(fishCH,catCH <span class="keyword">chan</span> <span class="type">bool</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> waitgroup.Done()</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(catCH)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt;<span class="number">100</span>;i++&#123;</span><br><span class="line">&lt;-fishCH</span><br><span class="line">fmt.Println(<span class="string">&quot;cat ...&quot;</span>)</span><br><span class="line">catCH &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintDog</span><span class="params">(catCH,dogCH <span class="keyword">chan</span> <span class="type">bool</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> waitgroup.Done()</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(dogCH)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt;<span class="number">100</span>;i++&#123;</span><br><span class="line">&lt;-catCH</span><br><span class="line">fmt.Println(<span class="string">&quot;dog ...&quot;</span>)</span><br><span class="line">dogCH&lt;-<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintFish</span><span class="params">(dogCH,fishCH <span class="keyword">chan</span> <span class="type">bool</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> waitgroup.Done()</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(fishCH)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt;<span class="number">100</span>;i++&#123;</span><br><span class="line">&lt;-dogCH</span><br><span class="line">fmt.Println(<span class="string">&quot;fish ...&quot;</span>)</span><br><span class="line">fishCH&lt;-<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> waitgroup sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">catCH := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>,<span class="number">1</span>)</span><br><span class="line">dogCH := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>,<span class="number">1</span>)</span><br><span class="line">fishCH := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>,<span class="number">1</span>)</span><br><span class="line">fishCH &lt;- <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> PrintFish(dogCH,fishCH)</span><br><span class="line"><span class="keyword">go</span> PrintDog(catCH,dogCH)</span><br><span class="line"><span class="keyword">go</span> PrintCat(fishCH,catCH)</span><br><span class="line"></span><br><span class="line">waitgroup.Add(<span class="number">3</span>)</span><br><span class="line">waitgroup.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽奖问题"><a href="#抽奖问题" class="headerlink" title="抽奖问题"></a>抽奖问题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定如下结构</span></span><br><span class="line"><span class="comment">// map中，key代表名称，value代表成交单数</span></span><br><span class="line"><span class="keyword">var</span> users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span> = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>&#123;</span><br><span class="line">  <span class="string">&quot;a&quot;</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="string">&quot;b&quot;</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="string">&quot;c&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&quot;d&quot;</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="string">&quot;f&quot;</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-随机抽奖"><a href="#1-随机抽奖" class="headerlink" title="1. 随机抽奖"></a>1. 随机抽奖</h5><p>从 map 中随机选取用户中奖<br>思路：将用户理解为一个个格子，从中选取一个格子中奖</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAwardUserName</span><span class="params">(users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>)</span></span> (name <span class="type">string</span>) &#123;</span><br><span class="line">  sizeOfUsers := <span class="built_in">len</span>(users)</span><br><span class="line">  award_index := rand.Intn(sizeOfUsers)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> index <span class="type">int</span></span><br><span class="line">  <span class="keyword">for</span> u_name, _ := <span class="keyword">range</span> users &#123;</span><br><span class="line">    <span class="keyword">if</span> index == award_index &#123;</span><br><span class="line">      name = u_name</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span> = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>&#123;</span><br><span class="line">    <span class="string">&quot;a&quot;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="string">&quot;b&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">&quot;c&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;d&quot;</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="string">&quot;e&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&quot;f&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rand.Seed(time.Now().Unix())</span><br><span class="line">  <span class="comment">// 抽奖1次</span></span><br><span class="line">  name := GetAwardUserName(users)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;user: %s jack point&quot;</span>, name)</span><br><span class="line">  <span class="comment">// 抽奖1000次</span></span><br><span class="line">  award_stat := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i += <span class="number">1</span> &#123;</span><br><span class="line">    name := GetAwardUserName(users)</span><br><span class="line">    <span class="keyword">if</span> count, ok := award_stat[name]; ok &#123;</span><br><span class="line">      award_stat[name] = count + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      award_stat[name] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> name, count := <span class="keyword">range</span> award_stat &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;user: %s, award count: %d\n&quot;</span>, name, count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方抽奖代码复杂度为 O(n) ，可以结合二分查找优化为 O(logN)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAwardGenerator</span><span class="params">(users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>)</span></span> (generator <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sum_num <span class="type">int64</span></span><br><span class="line">  name_arr := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(users))</span><br><span class="line">  offset_arr := <span class="built_in">make</span>([]<span class="type">int64</span>, <span class="built_in">len</span>(users))</span><br><span class="line">  <span class="keyword">var</span> index <span class="type">int</span></span><br><span class="line">  <span class="keyword">for</span> u_name, num := <span class="keyword">range</span> users &#123;</span><br><span class="line">    name_arr[index] = u_name</span><br><span class="line">    offset_arr[index] = sum_num</span><br><span class="line">    sum_num += num</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  generator = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    award_num := rand.Int63n(sum_num)</span><br><span class="line">    <span class="keyword">return</span> name_arr[binary_search(offset_arr, award_num)]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binary_search</span><span class="params">(nums []<span class="type">int64</span>, target <span class="type">int64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  start, end := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">  <span class="keyword">for</span> start &lt;= end &#123;</span><br><span class="line">    mid := start + (end-start)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">      end = mid - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">      <span class="keyword">if</span> mid+<span class="number">1</span> == <span class="built_in">len</span>(nums) &#123; <span class="comment">// 最后一名中奖</span></span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> nums[mid+<span class="number">1</span>] &gt; target &#123;</span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line">      &#125;</span><br><span class="line">      start = mid + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mid</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-加权抽奖"><a href="#2-加权抽奖" class="headerlink" title="2. 加权抽奖"></a>2. 加权抽奖</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个也是我们常规概率抽奖的实现方案</span></span><br><span class="line"><span class="comment">// 前置逻辑需要做好并发相关的处理，包括异常状态处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAwardGenerator</span><span class="params">(users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> sum_num <span class="type">int64</span></span><br><span class="line">  name_arr := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(users))</span><br><span class="line">  <span class="keyword">for</span> u_name, num := <span class="keyword">range</span> users &#123;</span><br><span class="line">    sum_num += num</span><br><span class="line">    name_arr = <span class="built_in">append</span>(name_arr, u_name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> generator <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span></span><br><span class="line">  generator = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    award_num := rand.Int63n(sum_num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> offset_num <span class="type">int64</span></span><br><span class="line">    <span class="keyword">for</span> _, u_name := <span class="keyword">range</span> name_arr &#123;</span><br><span class="line">      offset_num += users[u_name]</span><br><span class="line">      <span class="keyword">if</span> award_num &lt; offset_num &#123;</span><br><span class="line">        <span class="keyword">return</span> u_name</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缺省返回，正常情况下，不会运行到此处</span></span><br><span class="line">    <span class="keyword">return</span> name_arr[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个消息队列"><a href="#实现一个消息队列" class="headerlink" title="实现一个消息队列"></a>实现一个消息队列</h3><p>核心：切片 + 锁</p><h3 id="字符串相加-https-leetcode-cn-com-problems-add-s"><a href="#字符串相加-https-leetcode-cn-com-problems-add-s" class="headerlink" title="[字符串相加](https://leetcode-cn.com/problems/add-s"></a>[字符串相加](<a href="https://leetcode-cn.com/problems/add-s">https://leetcode-cn.com/problems/add-s</a></h3><p>trings&#x2F;)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStrings</span><span class="params">(num1 <span class="type">string</span>, num2 <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">add := <span class="number">0</span></span><br><span class="line">ans := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i, j := <span class="built_in">len</span>(num1) - <span class="number">1</span>, <span class="built_in">len</span>(num2) - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>; i, j = i - <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">x = <span class="type">int</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> j &gt;= <span class="number">0</span> &#123;</span><br><span class="line">y = <span class="type">int</span>(num2[j] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">result := x + y + add</span><br><span class="line">ans = strconv.Itoa(result%<span class="number">10</span>) + ans</span><br><span class="line">add = result / <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求根号2的值"><a href="#求根号2的值" class="headerlink" title="求根号2的值"></a>求根号2的值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找法求近似值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;  </span><br><span class="line">    l, r := <span class="type">float64</span>(<span class="number">0</span>), <span class="type">float64</span>(x)  </span><br><span class="line">    <span class="keyword">for</span> r-l &gt; <span class="number">1e-7</span> &#123;  </span><br><span class="line">        mid := l + (r - l) / <span class="number">2</span>  </span><br><span class="line"><span class="keyword">if</span> mid * mid &lt;= <span class="type">float64</span>(x) &#123;  </span><br><span class="line">            l = mid  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            r = mid  </span><br><span class="line">&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> r  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 牛顿迭代</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">&#125;  </span><br><span class="line">    C, x0 := <span class="type">float64</span>(x), <span class="type">float64</span>(x)  </span><br><span class="line">    <span class="keyword">for</span> &#123;  </span><br><span class="line">        xi := <span class="number">0.5</span> * (x0 + C/x0)  </span><br><span class="line">        <span class="keyword">if</span> math.Abs(x0 - xi) &lt; <span class="number">1e-7</span> &#123;  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">&#125;  </span><br><span class="line">        x0 = xi  </span><br><span class="line">&#125;  </span><br><span class="line">    <span class="keyword">return</span> x0  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> check(root, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(p, q *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &amp;&amp; q == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> || q == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p.Val == q.Val &amp;&amp; check(p.Left, q.Right) &amp;&amp; check(p.Right, q.Left) </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 算法 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>raft</title>
      <link href="/research/distribution/raft101/"/>
      <url>/research/distribution/raft101/</url>
      
        <content type="html"><![CDATA[<p><a href="https://raft.github.io/">一个劲爆的链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 研究所 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 101 </tag>
            
            <tag> raft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>paxos 论文翻译</title>
      <link href="/research/distribution/paxos-original/"/>
      <url>/research/distribution/paxos-original/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 研究所 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mongodb 面试必备</title>
      <link href="/interview/db/mongodb101/"/>
      <url>/interview/db/mongodb101/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 必看必会 </tag>
            
            <tag> mongo </tag>
            
            <tag> nosql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql 面试必备</title>
      <link href="/interview/db/mysql101/"/>
      <url>/interview/db/mysql101/</url>
      
        <content type="html"><![CDATA[<h1 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h1><h2 id="ACID-特性"><a href="#ACID-特性" class="headerlink" title="ACID 特性"></a>ACID 特性</h2><ul><li><p>**原子性(Atomicity)**：事务是一个不可分割的单位，因此在一个事务里的所有操作要么全部生效，要么全部不生效。</p></li><li><p>**一致性(Consistency)**：也可以理解为是预期状态的正确性，即从一个正确的状态到另一个正确的状态，这里的状态往往是由业务来定义的。比如转账中的一个扣钱一个加钱，是我们规定的一个数据流转，那么执行前的账户余额和转账后的账户余额就得满足加减特性，这就是所谓的业务正确。题外话：银行家舍入 —— 四舍六入五考虑，五后非零则进一，五后皆零看奇偶，奇进偶舍不连续。</p></li><li><p>**隔离性(Isolation)**：事务并发执行时，各个事务之间相互影响的程度。</p></li><li><p>**持久化(Durability)**：通过日志等手段，只要我们的事务提交成功了，那么就意味着这次的数据操作是成功的。即使下次重启了程序，也不会丢失此处的操作结果。</p></li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul><li><p><strong>未提交读：</strong> 即所谓的脏读，事务读取的数据可能是另一个事务已修改但还没提交的，这部分数据有可能产生回滚。导致后续的操作依赖了无效的数据。<br>修改时加排它锁；读取时加共享锁，读完释放。 eg：select for update</p></li><li><p><strong>已提交读：</strong> 如果想防止脏读，就需要等待其他事务提交后再进行读取操作。</p></li><li><p><strong>可重复读：</strong> 已提交读的隔离级别考虑到了数据回滚的无效性，却无法阻止事务的多次提交。比如事务 A 不断的对表进行修改提交，那么事务 B 就会在不同的时间点读取到不同的数据。为了让事务 B 在执行期间读取的数据都是一致的，就有了可重复读的隔离级别，即事务 B 在执行期间，其他事务不得进行修改操作。</p></li><li><p><strong>可串行化：</strong> 上面的可重复读隔离级别保证了事务执行期间读取的一致性。然而这里并不包括插入、删除操作。即会出现读多读少数据的情况，这种现象叫做幻读。为了解决幻读，只得进行串行化执行事务，才能互不影响。而此时的事务并发性是最低的</p></li></ul><h1 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h1><h2 id="Mysql-的索引分类"><a href="#Mysql-的索引分类" class="headerlink" title="Mysql 的索引分类"></a>Mysql 的索引分类</h2><ul><li><p><strong>从数据结构划分：</strong> B+ 树、hash 索引、全文索引</p></li><li><p><strong>从物理结构划分：</strong> 聚集索引、非聚集索引</p></li><li><p><strong>从逻辑用户划分：</strong> 主键、唯一索引、复合索引、普通单列索引</p></li></ul><h2 id="聚集索引、非聚集索引、主建的区别"><a href="#聚集索引、非聚集索引、主建的区别" class="headerlink" title="聚集索引、非聚集索引、主建的区别"></a>聚集索引、非聚集索引、主建的区别</h2><ul><li><p>聚集索引：在索引的叶子节点直接存 data 数据, 使用的是物理排序，一个表只能有一个字段设置了聚集索引（因为物理排序规则只能有一个），允许有 null 的数据存在，数据也不一定是唯一的。实现方案是B+树</p></li><li><p>主建：唯一标识某行记录，不允许有 null 的数据，要求数据必须唯一。在设置某个字段为主建时，数据库一般会自动在这个主建上建立一个唯一索引，并且如果之前表没有创建过聚集索引，还会在这个主建上建立一个聚集索引。自增Id强制设定为主键索引，这是为了b+tree和分页。这棵树的非叶子结点上存的都是主键，那如果一个表没有主键会怎么样？在innodb中，如果一个表没有主键，那默认会找建了唯一索引的列，如果也没有，则会生成一个隐形的字段作为主键！</p></li><li><p>非聚集索引：索引的叶子节点存的是数据域的记录指针，需要跳转查找。排序规则是逻辑排序，因此可以有多个非聚集索引存在。非聚集索引的存储结构与聚集索引是一样的，不同的是在叶子结点的数据部分存的不再是具体的数据，而数据的聚集索引的key。所以通过非聚集索引查找的过程是先找到该索引key对应的聚集索引的key，然后再拿聚集索引的key到主键索引树上查找对应的数据，这个过程称为<strong>回表</strong>！</p></li></ul><h2 id="有哪些情况会让索引失效？"><a href="#有哪些情况会让索引失效？" class="headerlink" title="有哪些情况会让索引失效？"></a>有哪些情况会让索引失效？</h2><ul><li><p>在 where 字段 上使用了函数或其他隐式转换</p></li><li><p>Like 模糊查询，开头使用了 “%”，例如 like ‘%hello%’</p></li><li><p>where 条件里使用了 or</p></li><li><p>建立了复合索引，但 where 条件里使用的是第二个字段的搜索</p></li></ul><h2 id="最左匹配原则是指？"><a href="#最左匹配原则是指？" class="headerlink" title="最左匹配原则是指？"></a>最左匹配原则是指？</h2><p>mysql 建立联合索引后，是按最左匹配原则来筛选记录的，即检索数据是从联合索引的第一个字段来筛选的。如果 where 里的条件只有第二个字段，那么将无法应用到索引。</p><h2 id="索引的底层数据结构-B-树是怎么样的？"><a href="#索引的底层数据结构-B-树是怎么样的？" class="headerlink" title="索引的底层数据结构 B+ 树是怎么样的？"></a>索引的底层数据结构 B+ 树是怎么样的？</h2><p>B+ 树是二叉搜索树的一个扩充，是多路搜索树。它只在叶子节点存储具体的数据或者数据的指向指针，而非叶子节点存放索引数据。这样可以降低磁盘 IO，还能充分利用磁盘的预读功能，批量的加载索引数据。</p><p><img src="https://static001.geekbang.org/infoq/46/467603fbd92fdada63040ebad9b7f628.png"></p><h2 id="b-树-b-树-b-树的区别"><a href="#b-树-b-树-b-树的区别" class="headerlink" title="b 树 b+树 b-树的区别"></a>b 树 b+树 b-树的区别</h2><ul><li><p>b 树就是 b-树， 国外叫 b-tree, 也就是 b 树。</p></li><li><p>b-tree 是在非叶子节点存放了数据，在查询索引时，只要找到索引值也就可以找到数据了，这样可以提前终止搜索。但每个节点就得存储索引值+数据值，占用的页空间会比较大，需要的磁盘 io 次数也会变多，即使是不需要关心的数据也会被预加载出来，浪费性能。</p></li><li><p>b+树是将索引值存在非叶子节点，数据值存在叶子节点，这样可以压缩树的高度，减少磁盘 io。</p></li></ul><h2 id="为什么不能在重复率高，例如性别字段上建立索引？"><a href="#为什么不能在重复率高，例如性别字段上建立索引？" class="headerlink" title="为什么不能在重复率高，例如性别字段上建立索引？"></a>为什么不能在重复率高，例如<code>性别</code>字段上建立索引？</h2><p>对于性别这种索引， 由于重复率高，对于 B+树(多路搜索树)来讲，得遍历多条路径，搜索代价大。还不如全表扫描，这样不需要维护索引，降低开销。</p><h2 id="Mysql-的-hash-索引是怎么样，有什么优缺点？"><a href="#Mysql-的-hash-索引是怎么样，有什么优缺点？" class="headerlink" title="Mysql 的 hash 索引是怎么样，有什么优缺点？"></a>Mysql 的 hash 索引是怎么样，有什么优缺点？</h2><p>hash 索引将列通过 hash 运算得到 hash code，然后将 hash code 跟数据行的指针地址关联在一起，下次查找时只需查找对应 hash code 的数据行地址即可。</p><p>hash 索引非常的紧凑，查找速度很快，适用于内存存储引擎的应用。不过它只能精确查询，不支持范围查找，也不能直接进行排序。限制还是挺多的。</p><p><img src="https://static001.geekbang.org/infoq/12/12bc94c294080d240a165e97e0a5f75e.png"></p><h2 id="Mysql-的全文索引"><a href="#Mysql-的全文索引" class="headerlink" title="Mysql 的全文索引"></a>Mysql 的全文索引</h2><p>全文索引主要是用于文档查找，像我们可能会从多篇文章中查找包含某些词语的文章，这时就可以使用全文索引了。虽然 like 也可以使用，但是效率太低了。全文索引在接收到文档时，会对它进行分词处理，以获取到关键词。然后会将关键词和属于这个文档的 id 关联起来。下次查找，就会先到关键词列表里找到关联的文档 id ，最后利用文档 id 去查找到文档数据。</p><h1 id="3-日志"><a href="#3-日志" class="headerlink" title="3. 日志"></a>3. 日志</h1><h2 id="日志类别"><a href="#日志类别" class="headerlink" title="日志类别"></a>日志类别</h2><ul><li><p><strong>binlog：</strong> 二进制日志，记录了数据库对数据的修改记录，包括了 DDL：例如表的创建，数据更新等。但并不包括 select 这些查询语句。binlog 日志是属于逻辑语句的记录，可用于主从数据库的同步。</p></li><li><p><strong>relay log：</strong> 中继日志，用于主从备份恢复使用的。有主服务器的 binlog 逻辑操作语句，以及当前的恢复位置。</p></li><li><p><strong>慢查询日志：</strong> 记录在 mysql 里执行时间超过预期值的耗时语句</p></li><li><p><strong>redo log：</strong> redo log 是对加载到内存数据页的修改结果的记录，和 binlog 不同的是，binlog 记录的是逻辑操作语句，偏向于过程记录。而 redo log 是一个数据页的修改日志，偏向于结果的记录。</p></li><li><p><strong>undo log：</strong> 回滚日志主要用于回滚数据，和 redo log 不一样的是，undo log 是逻辑日志，是一种相反操作的记录，比如在回滚时，如果是 insert 操作时，则会逆向为 delete，delete 操作时，逆向为 insert 操作，更新则恢复到当时的版本数据。</p></li></ul><h2 id="redo-log-相关概念：writepos、checkpoint、prepare、commit"><a href="#redo-log-相关概念：writepos、checkpoint、prepare、commit" class="headerlink" title="redo log 相关概念：writepos、checkpoint、prepare、commit"></a>redo log 相关概念：writepos、checkpoint、prepare、commit</h2><p>redo log 是用来记录当前数据页的修改情况，由于性能问题，每次修改并不会实时同步到硬盘。而是先在内存中修改，然后将修改情况记录到 redo 里，再定时的去将 redo 刷新到硬盘里。因此，redo log 有 2 个位置，一个是 writepos，自己写日志的位置；另一个是 checkpoint，是定时的将数据页同步到硬盘的位置。</p><p>redo log 在写 binlog 日志前会先记录 redo log，记录完后标记为 prepare 状态。当 binlog 也写入完成后，才将 redo log 标记为 commit 状态。只有当 redo log 是 commit 状态时，事务才能真正的 commit。这样能防止主从节点根据 binlog 同步有可能事务不一致的情况。</p><h1 id="4-Mysql-里的锁"><a href="#4-Mysql-里的锁" class="headerlink" title="4. Mysql 里的锁"></a>4. Mysql 里的锁</h1><h2 id="Mysql-里的锁有哪些？"><a href="#Mysql-里的锁有哪些？" class="headerlink" title="Mysql 里的锁有哪些？"></a>Mysql 里的锁有哪些？</h2><h3 id="乐观-x2F-悲观锁"><a href="#乐观-x2F-悲观锁" class="headerlink" title="乐观&#x2F;悲观锁"></a>乐观&#x2F;悲观锁</h3><ul><li><p>乐观锁：在读取数据时会假设各个事务互不影响，它们会处理好属于自己的那部分数据。如果在更新数据时，发现有其他事务修改了属于自己的数据，则会回滚之前的一切操作。</p></li><li><p>悲观锁：采取了先获取锁再访问的保守策略，如果已经有其他事务获取了锁，则必须等待锁释放才能继续。</p></li></ul><h3 id="共享-x2F-排它锁"><a href="#共享-x2F-排它锁" class="headerlink" title="共享&#x2F;排它锁"></a>共享&#x2F;排它锁</h3><ul><li><p>共享锁：又称读锁，当前事务在读取时，允许其他事务并发读取，但不允许其他事务上排它锁，必须等自己释放了才能继续。</p></li><li><p>排它锁：又称写锁，在写锁占有时，如果其他事务想上读写锁，则得排队等待。</p></li></ul><h3 id="表锁-x2F-行锁"><a href="#表锁-x2F-行锁" class="headerlink" title="表锁&#x2F;行锁"></a>表锁&#x2F;行锁</h3><ul><li><p>表锁：在操作数据时，直接将整张表锁住，操作粒度很大，很容易让其他事务在等待，但不会产生死锁。</p></li><li><p>行锁：针对的是行记录的并发控制，锁粒度很细，能支持高并发，但是不排除会有死锁情况产生。在 mysql 里行锁依赖索引实现，如果没有索引存在，则会直接进行表锁！</p></li></ul><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><ul><li><p>记录锁：只锁住某一条记录。当对唯一索引(包括主键)进行精确查询时，会使用记录锁。</p></li><li><p>间隙锁：当使用范围查询时，会对符合条件的区间数据上锁。在涉及到普通索引（即不是唯一索引）的查询时，都会使用间隙锁。</p></li><li><p>Next-key 锁：临建锁，可以理解为 记录锁 + 间隙锁。当对唯一索引进行范围查找或对唯一索引进行查找但结果不存在时（可以理解为锁住不存在的记录），会使用临建锁。</p></li></ul><p>上面的间隙锁、临建锁有效的防止了事务幻读情况产生，避免了在查找期间有数据新增或删除。</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>表锁的一种，它仅仅表示一种操作意向。当我们使用粒度比较小的行锁时，在检测是否有锁时，需要一行一行的检查，效率较低。有了意向锁之后，则不需一行一行的排查，只需检测对应的意向锁即可。</p><h2 id="事务里锁的应用是怎么样的？"><a href="#事务里锁的应用是怎么样的？" class="headerlink" title="事务里锁的应用是怎么样的？"></a>事务里锁的应用是怎么样的？</h2><h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>可重复读使用的是 MVCC 快照，所以在读取数据时大多数时候不需要使用锁。</p><p>但使用了 <code>UPDATE</code>, <code>DELETE</code>，或 <code>SELECT with FOR UPDATE（排它锁） 或 FOR SHARE（共享锁）</code>，则会根据下面的情况来使用锁：</p><ul><li><p>在唯一索引上精确查找某条记录时，使用记录锁</p></li><li><p>对于其他的搜索，InnoDB 将会锁定扫描到的索引范围，使用间隙锁或临建锁来<strong>防止幻读</strong>的产生</p></li></ul><h3 id="读提交"><a href="#读提交" class="headerlink" title="读提交"></a>读提交</h3><p>也是使用 MVCC 机制来读取数据，不过在使用 <code>UPDATE</code>, <code>DELETE</code>，或 <code>SELECT with FOR UPDATE（排它锁） 或 FOR SHARE（共享锁）</code>时和上面的机制不一样，当存储引擎将筛选到的记录交给 mysql server 层后，会对不相干的数据进行解锁，所以不会涉及间隙锁或临建锁。它们只会在做外键约束检查和重复键检查时使用到。由于间隙锁的禁用，可能会<strong>出现幻读</strong>现象。</p><h3 id="未提交读"><a href="#未提交读" class="headerlink" title="未提交读"></a>未提交读</h3><p>在 mysql 的 innodb 存储引擎里做 <code>SELECT</code>操作不会做任何锁动作，如果是 myisam 存储引擎，则会上共享锁。如果使用<code>UPDATE</code>, <code>DELETE</code>，或 <code>SELECT with FOR UPDATE（排它锁） 或 FOR SHARE（共享锁）</code>则和读提交一样的原则。</p><h3 id="可序列化读"><a href="#可序列化读" class="headerlink" title="可序列化读"></a>可序列化读</h3><p>可序列化读在使用 select 时，一般会自动的转化为 SELECT … FOR SHARE（共享锁），以保证读写序列化。</p><h2 id="lock-in-share-mode-和-for-update-里间隙锁什么时候会应用？"><a href="#lock-in-share-mode-和-for-update-里间隙锁什么时候会应用？" class="headerlink" title="lock in share mode 和 for update 里间隙锁什么时候会应用？"></a>lock in share mode 和 for update 里间隙锁什么时候会应用？</h2><ul><li><p>lock in share mode, for update 如果 where 条件是非索引类的，则不会加间隙锁；</p></li><li><p>lock in share mode, for update 如果 where 条件是主键类的，并且找不到记录时会加间隙锁；如果找到记录了则会将间隙锁给释放了。比如 where 主键 &#x3D; 3 能找到记录时则不会加间隙锁，找不到时会在该数据的前后叶子节点间加间隙锁；此时假如记录里只有 1，8，9，则会在 1, 8 之间加间隙锁</p></li><li><p>lock in share mode, for update 如果 where 条件是非聚集索引类的，会加间隙锁，即使找不到记录。</p></li></ul><h2 id="锁超时的配置"><a href="#锁超时的配置" class="headerlink" title="锁超时的配置"></a>锁超时的配置</h2><p>当 mysql 获取锁超时时候，如果系统变量 innodb_rollback_on_timeout 为 off ,则当前事务只会回滚最后一条 sql, 所以建议设置 innodb_rollback_on_timeout 为 on, 这样在获取锁超时时可以回滚全部 sql。</p><h1 id="5-MVCC-是指什么？"><a href="#5-MVCC-是指什么？" class="headerlink" title="5. MVCC 是指什么？"></a>5. MVCC 是指什么？</h1><p>MVCC 即<strong>多版本并发控制</strong>，它利用了 undo log 会在数据修改时保留上一个修改记录指针的特点，使得每个事务对数据的修改能有自己的历史版本追溯，就像镜像备份一样。当进行读操作时，如果有其他写操作的事务并发进行，那么此时可以根据事务的隔离级别选择读取最新版本亦或自己之前版本的数据。MVCC 不需要加锁的，它能提高事务的并发处理能力。</p><h1 id="6-mysql-的复制技术"><a href="#6-mysql-的复制技术" class="headerlink" title="6. mysql 的复制技术"></a>6. mysql 的复制技术</h1><ul><li><p>全同步复制：只有等所有的 slave 节点将同步的日志写入 relay log，并且响应 ack 确认后，此次的事务才会提交。数据完整性高，但性能低</p></li><li><p>半同步复制：只要有一个 salve 节点响应 ack 后就可以认为同步成功，但细分为了两种，一种是 <code>AFTER_COMMIT</code>：先在主库提交事务, 然后同步从库, 等待从库的 ack 确认. 才告诉客户端是否 Ok。另一种是 <code>AFTER_SYNC</code>：主库先不提交事务, 只有从库 有 replay log ,回复了 ack 后才进行提交事务。后面一种数据一致性较高</p></li><li><p>异步复制：一旦有需要复制的就通知 slave, 但不会等待确认成功才进行后续操作。</p></li></ul><h1 id="7-存储引擎"><a href="#7-存储引擎" class="headerlink" title="7. 存储引擎"></a>7. 存储引擎</h1><h2 id="Mysql-存储引擎有哪些以及特点？"><a href="#Mysql-存储引擎有哪些以及特点？" class="headerlink" title="Mysql 存储引擎有哪些以及特点？"></a>Mysql 存储引擎有哪些以及特点？</h2><ul><li><p><strong>InnoDB：</strong> 它是 mysql 的默认存储引擎，能够实现 ACID 特性的事务，并且能提交、回滚、恢复数据，能很好的保障用户数据。同时支持了行级锁、聚集索引以及外键约束，是一个完善的存储引擎。</p></li><li><p><strong>MyISAM：</strong> 是 mysql 最开始的存储引擎，占用空间小，能快速存储，但不支持事务，提供了基于表级别的锁粒度，适用于配置或只读功能的应用程序。</p></li><li><p><strong>Memory：</strong> 数据都是存在内存里的，能提供快速访问，不过应该较少人使用，毕竟一旦断电数据也就丢失了。</p></li><li><p><strong>CSV：</strong> 带有逗号分隔值的文本文件，没有索引存在。但是兼容性很好，可以跟其他的程序交换数据。</p></li></ul><h2 id="myisam-存储引擎和-innodb-的区别"><a href="#myisam-存储引擎和-innodb-的区别" class="headerlink" title="myisam 存储引擎和 innodb 的区别"></a>myisam 存储引擎和 innodb 的区别</h2><ul><li><p>innoDB 支持事务，myisam 不支持</p></li><li><p>innoDB 支持行锁，myisam 不支持，只能到表锁</p></li><li><p>innoDB 支持外键，myisam 不支持</p></li><li><p>innoDB 不支持全文索引，myisam 支持</p></li><li><p>innoDB 支持聚集索引 和 非聚集索引；myISAM 只支持非聚集索引，该索引存的是数据域的记录指针，还得跳转查找。</p></li></ul><h1 id="8-Mysql-的三层架构"><a href="#8-Mysql-的三层架构" class="headerlink" title="8. Mysql 的三层架构"></a>8. Mysql 的三层架构</h1><ul><li><p><strong>连接层：</strong> 主要负责连接池、通信协议、认证授权等；</p></li><li><p><strong>SQL 层：</strong> 这一层是 mysql 的大脑，通过一系列组件得到数据操作的最优解。</p></li><li><p><strong>存储层：</strong> 负责数据的存储、检索。</p></li><li><p><img src="https://static001.geekbang.org/infoq/7b/7b8895802bcf0c023f64a3ed741c1e46.pngc_center"></p></li></ul><h1 id="9-执行计划是什么？怎么看？"><a href="#9-执行计划是什么？怎么看？" class="headerlink" title="9. 执行计划是什么？怎么看？"></a>9. 执行计划是什么？怎么看？</h1><p>执行计划是 mysql 根据我们的查询语句进行一系列的分析后得到的优化方案。我们可以通过执行计划来获取执行过程。</p><p>执行计划的获取：</p><p><code>explain select 语句</code>  </p><p><img src="https://static001.geekbang.org/infoq/da/da4a15afe4d3bf624e33a136db3eac93.png"></p><p>涉及的字段含义如下：</p><ul><li><p>id： 该 SELECT 标识符</p></li><li><p>select_type： 该 SELECT 类型</p></li><li><p>table： 输出行的表</p></li><li><p>partitions： 匹配的分区</p></li><li><p>type： 联接类型</p></li><li><p>possible_keys： 可供选择的可能索引</p></li><li><p>key： 实际选择的索引</p></li><li><p>key_len： 所选密钥的长度</p></li><li><p>ref： 与索引比较的列</p></li><li><p>rows： 估计要检查的行数</p></li><li><p>filtered： 按表条件过滤的行百分比</p></li><li><p>Extra： 附加信息</p></li></ul><p>其中，有个 type 字段，它的含义大概如下：</p><ul><li><p>eq_ref： 使用到了 UNIQUE 或 PRIMARY KEY 索引</p></li><li><p>ref： 显示索引的哪一列被使用了</p></li><li><p>ref_or_null： 对 Null 进行了索引优化</p></li><li><p>range： 索引范围检索</p></li><li><p>index： 索引扫描</p></li><li><p>unique_subquery： 使用了 in 子查询，里面涉及了主键字段</p></li><li><p>index_subquery： 使用了 in 子查询，里面涉及了非唯一索引</p></li><li><p>fulltext： 全文索引</p></li><li><p>all： 全表扫描数据</p></li></ul><p>从上面大概就能分析出索引的使用情况了，如果是 all，那就是没有用到索引了。</p><h1 id="10-SQL-注入的现象是？"><a href="#10-SQL-注入的现象是？" class="headerlink" title="10. SQL 注入的现象是？"></a>10. SQL 注入的现象是？</h1><p>在拼接 SQL 语句时，直接使用客户端传递过来的值拼接，如果客户端传来包含 <code>or 1=1</code> 类似的语句，那么就会筛选到非预期的结果，进而达到欺骗服务器的效果。</p><p>解决方案是使用现在数据库提供的预编译（prepare）和查询参数绑定功能，例如使用占位符 <code>?</code>，然后将带有占位符的 SQL 语句交给数据库编译，这样数据库就能知道要执行的是哪些语句，条件值又是哪些，而不会混杂在一起。</p><h1 id="11-UNION-和-UNION-ALL-的区别？"><a href="#11-UNION-和-UNION-ALL-的区别？" class="headerlink" title="11. UNION 和 UNION ALL 的区别？"></a>11. UNION 和 UNION ALL 的区别？</h1><ul><li><p>UNION ALL：将所有的数据联合起来，即使有重复数据</p></li><li><p>UNION：会合并重复数据</p></li></ul><h1 id="12-为什么尽量使用自增-ID，而不是-UUID？"><a href="#12-为什么尽量使用自增-ID，而不是-UUID？" class="headerlink" title="12. 为什么尽量使用自增 ID，而不是 UUID？"></a>12. 为什么尽量使用自增 ID，而不是 UUID？</h1><p>自增 ID 是由有序的，而 UUID 是无序的，如果该字段作为索引，那么就会很容易打破 B+ 树的平衡，进而不断的在进行磁盘数据页的调整，导致性能下降</p><h1 id="13-分库分表有哪些？有什么优缺点？"><a href="#13-分库分表有哪些？有什么优缺点？" class="headerlink" title="13. 分库分表有哪些？有什么优缺点？"></a>13. 分库分表有哪些？有什么优缺点？</h1><ul><li><p>分库：从业务角度进行切分</p></li><li><p>分表：将数据根据一定的规则落在多张表上。比如按时间范围来切分，或者通过对 ID 进行 Hash 来路由到对应的表上。</p></li></ul><p>分库分表后使得数据不再集中到一张表上，但也带来了维护以及其他处理问题。比如原来的事务变为分布式事务；原来的 join 操作将要变为在应用层序做过滤；还有数据的后续迁移、扩容规划等。</p><h1 id="14-内连接、外连接区别"><a href="#14-内连接、外连接区别" class="headerlink" title="14. 内连接、外连接区别"></a>14. 内连接、外连接区别</h1><ul><li><p>内连接：只有符合条件的记录才会出现在结果集里</p></li><li><p>外连接：其结果集中不仅包含符合连接条件的行，还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。</p></li></ul><h1 id="15-常见的数据库优化"><a href="#15-常见的数据库优化" class="headerlink" title="15. 常见的数据库优化"></a>15. 常见的数据库优化</h1><ul><li><p>对经常出现在 where 条件里，并且数据重复率不高的字段建立索引</p></li><li><p>使用 JOIN 来代替子查询；</p></li><li><p>能使用 in 就不使用 or，前者能命中索引，后者会让索引失效</p></li><li><p>避免在 where 字段上计算，例如 where a &#x2F; 3 &#x3D; 1，这样会让索引失效；避免在 where 字段上使用 NULL 值的判断</p></li><li><p>打开慢查询日志配置，有针对性的分析响应缓慢的语句。</p></li></ul><h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="sql的执行顺序"><a href="#sql的执行顺序" class="headerlink" title="sql的执行顺序"></a>sql的执行顺序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from on where group by having select distinct order by limit</span><br></pre></td></tr></table></figure><h3 id="一条SQL更新语句执行顺序"><a href="#一条SQL更新语句执行顺序" class="headerlink" title="一条SQL更新语句执行顺序"></a>一条SQL更新语句执行顺序</h3><p>通过分析器分析，执行和查询语句一样。然后写redo log(是个循环日志文件。写完redo log同步到内存中，适当时机更新到磁盘中) 和 binary log，与redo log 采取二阶段事务提交</p><h3 id="事务隔离级别，怎么选择，为什么"><a href="#事务隔离级别，怎么选择，为什么" class="headerlink" title="事务隔离级别，怎么选择，为什么"></a>事务隔离级别，怎么选择，为什么</h3><h4 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h4><p>会读到未提交的事务，脏读，不可重复读，幻读</p><p>幻读：指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的数据行。</p><h4 id="不可重复读（rc）"><a href="#不可重复读（rc）" class="headerlink" title="不可重复读（rc）"></a>不可重复读（rc）</h4><p>别的事务提交，而能直接读到别的事务提交的结果，和别的事务提交之前的不一样，所以不可重复读</p><h4 id="可重复读-rr"><a href="#可重复读-rr" class="headerlink" title="可重复读(rr)"></a>可重复读(rr)</h4><p>读取是从快照中读取，即使别的事务提交仍读的是旧的</p><h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><p>锁表，别人读的时候，你不能干任何事情</p><h4 id="使用RC为默认隔离级别"><a href="#使用RC为默认隔离级别" class="headerlink" title="使用RC为默认隔离级别"></a>使用RC为默认隔离级别</h4><p>innodb默认为RR隔离级别，是由于历史原因binary log同步的原因，默认使用的是statement记录操作语句（是以commit的顺序为记录）。就会出现主从不一致的情况。</p><ol><li>在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多！</li><li>在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行</li><li>在RC隔离级别下，半一致性读(semi-consistent)特性增加了update操作的并发性！</li></ol><p>在RC级别下，不可重复读问题需要解决么？<br>不用解决，这个问题是可以接受的！毕竟你数据都已经提交了，读出来本身就没有太大问题！Oracle的默认隔离级别就是RC，你们改过Oracle的默认隔离级别么？</p><p>在RC级别下，主从复制用什么binlog格式？<br>OK,在该隔离级别下，用的binlog为row格式，是基于行的复制！Innodb的创始人也是建议binlog使用该格式！</p><h3 id="说说你了解的索引"><a href="#说说你了解的索引" class="headerlink" title="说说你了解的索引"></a>说说你了解的索引</h3><p>聚簇索引，使用的是B+ 树类型。</p><p>主键索引，存放的是value和索引</p><p>其余的只存放索引，需要回表查询。因为叶子节点只存放索引。</p><p>索引类型：</p><ol><li>主键索引</li><li>唯一索引</li><li>普通索引</li><li>联合索引</li></ol><p>explain中的字段</p><ul><li><p>id</p><ul><li>id 相同的情况下，执行顺序由上而下</li><li>如果是子查询，id 越大，越先执行</li><li>小表驱动大表</li></ul></li><li><p>select_type</p><ul><li>simple 简单的查询不包含子查询或者union</li><li>primary 主查询，最后加载</li><li>subquery 子查询</li><li>derived 衍生的临时表</li><li>union<ul><li>若第二个select出现在union之后，则标记为union</li><li>若union包含在from子句的子查询中，则外层select标记为derived</li></ul></li><li>union result 从union表获取结果的select<ul><li>两个union合并的select</li></ul></li></ul></li><li><p>table 哪张表</p></li><li><p>type</p><ul><li>从最好到最差依次<ul><li>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all</li><li>system 只有一条记录的单表，系统表</li><li>const 相当于primary key 或 unique 等于一个数值 where id &#x3D;1</li><li>eq_ref 唯一索引 t1.id&#x3D;t2.id</li><li>ref 普通索引，非唯一值</li><li>range 只检索给定范围的行，使用一个索引来选择行</li><li>index 遍历所有索引</li><li>all 全表扫描，需要优化</li></ul></li></ul></li><li><p>possible_keys，key</p><ul><li>可能用到的索引和实际用到的索引</li><li>覆盖索引不会显示在possible_keys上，只会显示在key中</li></ul></li><li><p>key_len</p><ul><li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</li><li>同样的查询结果，长度越少越好</li></ul></li><li><p>ref</p><ul><li>显示索引的哪一列被使用,如果可能的话，是一个常量，哪些列或常量被用于查找索引列上的值</li><li>const 常量</li><li>test1.t1.id</li></ul></li><li><p>rows</p><ul><li>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数</li><li>理论上影响了多少行</li></ul></li><li><p>extra</p><ul><li>不适合在其他列中显示但是十分重要的额外信息</li><li>using filesort<ul><li>mysql 无法利用索引完成的排序，文件排序</li></ul></li><li>using temporary<ul><li>对查询结果，使用了临时表 order by ,group by</li><li>最好使用覆盖索引，不要产生临时表</li></ul></li><li>using index<ul><li>表示相应的select 操作中使用了覆盖索引</li><li>同时出现using where ，表明索引被用来执行索引键值的查找</li><li>没出现using where，表明索引用来读取数据而非执行查找动作</li></ul></li><li>using where<ul><li>使用了 where</li></ul></li><li>using join buffer<ul><li>join 多，而使用了缓冲区</li></ul></li><li>impossible where<ul><li>where子句的值是false</li></ul></li></ul></li><li><p>两表加索引</p><ul><li>左连接<ul><li>加子表上，主表的数据全部都要，加了索引也没用，子表不一定都要，可以加索引优化</li><li>sql执行的顺序为 from on join 其中 on就是可以用到索引的地方</li></ul></li><li>右连接相反</li><li>join 语句的优化<ul><li>尽可能减少join语句的Nestedloop的循环总次数，永远用小结果集驱动大结果集</li><li>优先优化NestedLoop的内层循环</li><li>保证Join语句中被驱动表上Join条件字段已经被索引</li><li>当无法保证被驱动表的Join条件字段被索引且内存资源充足的前提下，不要太吝啬JoinBuffer的设置</li></ul></li></ul></li><li><p>索引失效的情况：</p><ul><li>全值匹配我最爱</li><li>违背最左前缀原则</li><li>跳过索引中的列</li><li>某列属于联合索引，对该列进行范围查询，值使用部分索引，该列右边的列无法使用索引</li><li>!&#x3D;,is null,is not null</li><li>like以通配符开头<ul><li>解决%like% 索引时不能失效的方法</li><li>使用覆盖索引可以解决</li></ul></li><li>用or连接条件</li><li>不在索引列上做任何操作（计算，函数，自动or手动类型转换，会导致索引失效而转向全表扫描）</li><li>尽量使用覆盖索引</li><li>字符串不加单引号索引失效</li><li>索引列的数据长度能少则少</li><li>索引一定不是越多越好，越全越好，一定是建合适的</li><li>匹配列浅醉可用到索引，like %9999%、ike %9999%用不到索引，like 9999%在列离散度高的时候能用到索引，离散度低的时候用不到</li><li>where条件中not in和&lt;&gt;操作无法使用索引</li><li>匹配范围值，order by也可用到索引</li><li>多用指定列查询，只返回自己想要的数据列，少用select*;</li><li>联合索引中如果不是按照索引最左列开始查找，无法使用索引</li><li>联合索引中精确匹配最左前列并范围匹配另外一列可以用到索引</li><li>联合索引中如果查询中有某个列的范围查询，则其右边所有列都无法使用索引</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 必看必会 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis面试必备</title>
      <link href="/interview/db/redis101/"/>
      <url>/interview/db/redis101/</url>
      
        <content type="html"><![CDATA[<h2 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><h3 id="1-分布式系统中常用的缓存方案有哪些？"><a href="#1-分布式系统中常用的缓存方案有哪些？" class="headerlink" title="1. 分布式系统中常用的缓存方案有哪些？"></a>1. 分布式系统中常用的缓存方案有哪些？</h3><ul><li>客户端缓存：页面和浏览器缓存，app 缓存，h5 缓存，localStorage，sessionStorage</li><li>CDN：内容存储&#x3D;数据存储，内容分发&#x3D;负载均衡</li><li>Nginx 缓存： 静态资源</li><li>服务端缓存：本地缓存，外部缓存</li><li>数据库缓存：持久缓存（mybatis，hibernate 多级缓存），mysql 查询缓存</li><li>操作系统缓存：page cache，buffer cache</li></ul><h3 id="2-常见的缓存淘汰算法"><a href="#2-常见的缓存淘汰算法" class="headerlink" title="2. 常见的缓存淘汰算法"></a>2. 常见的缓存淘汰算法</h3><ul><li>FIFO - 先进先出</li><li>LRU - 最近最少使用</li><li>LFU - 最不经常使用</li></ul><h3 id="3-Redis-如何配置-Key-的过期时间？他的实现原理是什么？"><a href="#3-Redis-如何配置-Key-的过期时间？他的实现原理是什么？" class="headerlink" title="3. Redis 如何配置 Key 的过期时间？他的实现原理是什么？"></a>3. Redis 如何配置 Key 的过期时间？他的实现原理是什么？</h3><ul><li>Expire or SETNX</li><li>原理：<ul><li>定期删除：每隔一段时间，执行一次删除过期 Key 的操作（批量脚本）</li><li>懒汉式删除：每当使用 get，getset 等指令去获取数据时，判断 key 是否过期，过期的话就先删除再操作</li><li>redis 同时使用两者，平衡执行频率和执行时长</li></ul></li></ul><h3 id="4-Redis-线程模型，单线程为什么快？"><a href="#4-Redis-线程模型，单线程为什么快？" class="headerlink" title="4. Redis 线程模型，单线程为什么快？"></a>4. Redis 线程模型，单线程为什么快？</h3><ul><li>基于 Reactor 开发了网络时间处理器 - 文件事件处理器，采用 IO 多路复用监听多个 Socket</li><li>纯内存操作、核心基于非阻塞的 IO 多路复用机制、单线程避免了多线程反复上下文切换的性能问题</li></ul><h3 id="5-redis-的常见结构及应用场景"><a href="#5-redis-的常见结构及应用场景" class="headerlink" title="5. redis 的常见结构及应用场景"></a>5. redis 的常见结构及应用场景</h3><ul><li>string<ul><li>id&#x2F;id_info 缓存  </li><li>计数器  </li><li>setnx 分布式锁 </li><li>分布式ID </li><li>sds（动态简单字符串）<ul><li>读取时间复杂度为 O(1)</li><li>惰性删除，留待下次使用</li><li>一次分配最大为 128kb</li></ul></li><li></li></ul></li><li>list<ul><li>当队列用，最近100个购买用户信息  </li><li>当栈用  </li><li>非实时分页列表，比如小时榜，日榜，周榜</li><li>存储微博、微信公众号等消息流数据</li><li>等于链表，插入删除 O(1)，查找 O(n)</li></ul></li><li>hash<ul><li>相比string获取单个字段节省 序列化与反序列化操作</li><li>相当于 HashMap ，由数组加链表组合而成，当一维的 hash 数组碰撞时，用链表串起来</li></ul></li><li>set<ul><li>取交、并、差集  </li><li>点赞、收藏、关注等…  </li><li>kv 模式</li></ul></li><li>sorted set<ul><li>排行榜功能，实时分页列表，实时榜单等</li><li>set 基础上增加了分数</li><li>结构上是由一个 dict 和一个跳表组成，dict 保证 key 唯一性</li><li>插入删除都是 O(log n)，查找 O(logn)</li><li>一大优点是可以对分数进行范围查找</li><li>少量数据按照 ziplist 存储，大量数据按照跳表存储</li></ul></li></ul><h4 id="redis-大key-问题是什么？怎么查出来？一般怎么解决？"><a href="#redis-大key-问题是什么？怎么查出来？一般怎么解决？" class="headerlink" title="redis 大key 问题是什么？怎么查出来？一般怎么解决？"></a>redis 大key 问题是什么？怎么查出来？一般怎么解决？</h4><p>大key问题呢是说 redis 的 kv 存储中，value值过大，一般超过10kb，我们就会认为这是一个大 key 了。<br>有执行命令，但是没有专门准备这个内容<br>大 key 的危害主要是：在redis内存中分布不均；操作耗时；取结果的数据量大，容易造成网络io堵塞<br>解决方式呢：可以逻辑上对于大 key 的 value 进行拆分和重组。其中 string 类型的大 key 一般不建议存到redis。另外的可以采用 hash 将大 key 拆分</p><h3 id="6-redis-集群方案"><a href="#6-redis-集群方案" class="headerlink" title="6. redis 集群方案"></a>6. redis 集群方案</h3><ul><li>主从模式</li><li>哨兵模式<ul><li>概念<ul><li>集群监控：监控主从是否正常</li><li>消息通知：故障通知</li><li>故障转移：主挂了，移到从身上</li><li>配置中心：通知 client 新的 master 地址</li></ul></li><li>本身也是分布式的，具体方案：<ul><li>通常3个哨兵实例来保证健壮性</li><li>即使哨兵自己挂了，还是可以正常工作</li><li>不保证数据领丢失，可以说主从结构就不保证</li><li>判断故障需要用<code>分布式选举</code>获得大部分哨兵统一才行</li></ul></li></ul></li><li>Redis cluster：服务端 Sharding 计数。采用槽的概念，一共16384个槽，请求发送至任意节点<ul><li>方案说明<ul><li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽（哈希值）区间的数据</li><li>每份数据分片会存储在多个互为主从的多节点上</li><li>数据先写入主节点，再<code>阻塞</code>同步至从节点</li><li>同一分片之间不保证强一致性</li><li>扩容时需要把旧节点数据也迁移一部分至新节点</li></ul></li><li>gossip 协议，多主多从</li></ul></li></ul><h3 id="7-redis-持久化方案"><a href="#7-redis-持久化方案" class="headerlink" title="7. redis 持久化方案"></a>7. redis 持久化方案</h3><ol><li>RDB：Redis Database<br>指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作是 fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，使用二进制压缩存储。<br>优点：</li></ol><ul><li>整个 redis 只包含一个文件 dump.rdb，方便持久化</li><li>容灾性好，易于备份</li><li>性能最大化，使用子进程处理，保证主进程 IO 吞吐，保证了 redis 的高性能</li><li>相对于数据集大时，比 AOF 的启动效率更高<br>缺点：</li><li>数据安全性低，因为会有间隔时间，所以如果间隔期间出现故障，无法保证期间的数据正常备份</li><li>当数据集较大时，子进程长期占用 CPU，会导致服务中断时间延长至秒级</li></ul><ol start="2"><li>AOF：Append Only File<br>以日志的形式记录服务器处理的每个读写操作，以文本的方式详细记录，可以查看历史操作记录<br>优点：</li></ol><ul><li>数据安全：每秒同步、每修改同步、不同步3中策略。每秒同步可以理解为类似1s间隔的 RDB ，可能也会出现丢失的情况；每修改同步可以认为是同步持久化，不会丢失</li><li>通过 append 方式追加新的操作，不惧宕机，可以使用 redis-check-aof 工具来解决一致性的问题。</li><li>rewrite 模式可以定期对 AOF 文件重写，合并相关操作，以达到压缩存储的目的<br>缺点</li><li>AOF 文件较大，恢复速度慢</li><li>数据集大的情况下，启动比 RDB 慢</li><li>运行效率 AOF &lt; RDB</li></ul><p>4.x版本后，把重写方式变成 RDB 直接放到 AOF 文件的头部，比以前版本更快</p><ol start="3"><li>主从同步</li></ol><ul><li>全量复制：<ul><li>主节点通过 bgsave 命令 fork 子进程进行 rdb 持久化，过程非常消耗CPU，内存，硬盘io</li><li>主节点将rdb文件通过网络发给从节点，消耗带宽</li><li>从节点清空数据，使用rdb文件载入，整个过程阻塞，无法响应命令</li></ul></li><li>部分复制：<ul><li>复制偏移量，双方都要维护</li><li>复制积压缓冲区：定长FIFO的队列作为缓冲区</li></ul></li></ul><h3 id="8-Redis-的过期键的删除策略"><a href="#8-Redis-的过期键的删除策略" class="headerlink" title="8. Redis 的过期键的删除策略"></a>8. Redis 的过期键的删除策略</h3><ol><li>惰性过期：访问一个 key 的时候才判断这个 key 是否已经过期，该策略可以最大化的节省 CPU 资源，但是对内存不友好，会存在大量的过期 key 没有被再次访问，从而不会被清除，占用内存</li><li>定期过期：每隔一定的时间，扫描数据库中一定量的 expire 字典中的 key，并清除其中已经过期的 key。该策略是前两者的一个折中方案，通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使内存和 CPU 达到最优平衡</li><li>二种策略同时生效</li></ol><h3 id="9-描述下缓存穿透、击穿、雪崩，以及解决方案"><a href="#9-描述下缓存穿透、击穿、雪崩，以及解决方案" class="headerlink" title="9. 描述下缓存穿透、击穿、雪崩，以及解决方案"></a>9. 描述下缓存穿透、击穿、雪崩，以及解决方案</h3><p>数据库是架构的瓶颈，要尽量保证有效请求到达数据库，可以酌情放大链路上前置位置的复杂度和成本<br>c client；redis ； db&#x2F;mysql</p><p>穿透：缓存和db中都找不到该数据 &#x3D; db中无数据，redis无数据，大量并发，请求打到db层<br>原因：接口请求数据不是有效参数，因此根本查不到结果；有效参数但是确实没有数据<br>解法：接口层增加鉴权，业务层增加有效请求判断；返回空 &amp;&amp; 增加短效的空缓存；布隆过滤器（难道要加到每个接口上么？需要思考嗷）；业务加互斥锁；对于空值可以增加一个空缓存</p><p>击穿：热点key过期 or key从来没有被访问过 &#x3D; db中有数据，大量并发，redis无缓存，请求打到db层<br>解法：热点数据永不过期；互斥锁（挡住大量重复的并发请求）</p><p>雪崩：N个key的都过期了（没有被缓存到） &#x3D; db中有，大量并发，redis无缓存，请求打到db层<br>解法：缓存数据设置随机过期时间；增加缓存失效标记位；缓存预热；互斥锁</p><p>流程： 请求redis，查不到 –&gt; 大家抢锁 O（1） –&gt; 抢上的查db，并更新缓存 O（1） –&gt; 没抢上的重复请求Redis ，拿到数据<br>延伸问题：多个等待的请求，是blocking的轻量级进程，不参与cpu及内核调度，注意处理线程池即可</p><ul><li>sorted set  <ul><li>实时分页列表，如实时榜单</li></ul></li></ul><ul><li>一般就是当缓存用</li><li>单线程模型</li><li>目的是服务无状态：session，token等；分布式锁</li><li>无锁化？</li></ul><h3 id="2-单线程还是多线程？"><a href="#2-单线程还是多线程？" class="headerlink" title="2. 单线程还是多线程？"></a>2. 单线程还是多线程？</h3><ul><li>工作线程都是单线程：<ul><li>操作是原子的单指令 pipeline</li><li>事务 vs pipeline ：事务执行期间是原子的；执行失败就是失败，其他指令继续执行，没有回滚 –&gt; redis 少使用事务 &amp;&amp; 事务内的指令少 + 快</li></ul></li><li>6.x+版本出现了 io 多线程</li></ul><hr><ul><li>详细理解 io 多线程 ：内核，网络通信（懂了再说）</li><li>单线程，满足 redis 的串行原子；io 多线程以后，把输入&#x2F;输出放到线程中并行，好处是：执行时间快；更好的压榨系统及硬件的资源</li></ul><h3 id="3-redis-存在线程安全的问题么？为什么？"><a href="#3-redis-存在线程安全的问题么？为什么？" class="headerlink" title="3. redis 存在线程安全的问题么？为什么？"></a>3. redis 存在线程安全的问题么？为什么？</h3><ul><li>参考问题2，redis核心是单线程串行，业务使用的时候需要自行保障线程安全</li></ul><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><h3 id="6-缓存如何淘汰的？"><a href="#6-缓存如何淘汰的？" class="headerlink" title="6. 缓存如何淘汰的？"></a>6. 缓存如何淘汰的？</h3><p>内存空间不足<br>淘汰机制<br>lru，lfu，random，ttl<br>全空间<br>设置了过期时间的key的集合中</p><h3 id="7-如何进行缓存预热？"><a href="#7-如何进行缓存预热？" class="headerlink" title="7. 如何进行缓存预热？"></a>7. 如何进行缓存预热？</h3><p>提前加载数据（很难判断哪些是真正的热数据，常常会出现缓存失败的情况）<br>开发逻辑上要应对差集数据造成的 击穿，穿透，雪崩</p><h3 id="8-数据库和缓存不一致如何解决？"><a href="#8-数据库和缓存不一致如何解决？" class="headerlink" title="8. 数据库和缓存不一致如何解决？"></a>8. 数据库和缓存不一致如何解决？</h3><p>恶心点的使用事务，但是意义不大，场景多为读多写极少，仅仅在秀肌肉<br>业务写db，然后redis更新缓存<br>业务写到消息队列中，redis和db同时消费数据，同时更新<br>redis缓存，更倾向于允许稍微的时差<br>总思路是减少db操作</p><h3 id="9-redis-主从不一致如何解决？"><a href="#9-redis-主从不一致如何解决？" class="headerlink" title="9. redis 主从不一致如何解决？"></a>9. redis 主从不一致如何解决？</h3><p>redis 默认弱一致性，主从异步同步<br>分布式锁不能用主从，可以用单实例、分片集群、redlock –&gt; redisson<br>配置中可以配置同步因子，总趋向于强一致性</p><h3 id="10-redis-持久化原理"><a href="#10-redis-持久化原理" class="headerlink" title="10. redis 持久化原理"></a>10. redis 持久化原理</h3><p>当前线程阻塞服务<br>后台异步进程完成持久化</p><h3 id="11-并发超量，redis-崩溃后如何处理？"><a href="#11-并发超量，redis-崩溃后如何处理？" class="headerlink" title="11. 并发超量，redis 崩溃后如何处理？"></a>11. 并发超量，redis 崩溃后如何处理？</h3><p>雪崩击穿穿透处理方案</p><h3 id="12-为啥使用setnx"><a href="#12-为啥使用setnx" class="headerlink" title="12. 为啥使用setnx"></a>12. 为啥使用setnx</h3><p>原子，不存在即创建<br>分布式锁，用 set k v nx ex 不存在，过期时间，避免死锁</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 必看必会 </tag>
            
            <tag> 并发 </tag>
            
            <tag> nosql </tag>
            
            <tag> redis </tag>
            
            <tag> 哨兵 </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> raft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang并发编程</title>
      <link href="/golang/concurrency/go-sync/"/>
      <url>/golang/concurrency/go-sync/</url>
      
        <content type="html"><![CDATA[<h3 id="go-并发控制"><a href="#go-并发控制" class="headerlink" title="go 并发控制"></a>go 并发控制</h3><p>实际生产中，WaitGroup 和 Channel 是常见的 2 种并发控制的方式。<br>如果有一系列任务，需要这些任务全部完成以后才能继续执行，WaitGroup 非常适合于这类场景，例如下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doTask</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">  time.Sleep(time.Duration(n))  </span><br><span class="line">  fmt.Printf(<span class="string">&quot;Task %d Done\n&quot;</span>, n)  </span><br><span class="line">  wg.Done()  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;  </span><br><span class="line">    wg.Add(<span class="number">1</span>)  </span><br><span class="line">    <span class="keyword">go</span> doTask(i + <span class="number">1</span>)  </span><br><span class="line">  &#125;  </span><br><span class="line">  wg.Wait()  </span><br><span class="line">  fmt.Println(<span class="string">&quot;All Task Done&quot;</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Task 3 Done  </span></span><br><span class="line"><span class="comment">// Task 1 Done  </span></span><br><span class="line"><span class="comment">// Task 2 Done  </span></span><br><span class="line"><span class="comment">// All Task Done  </span></span><br></pre></td></tr></table></figure><p><code>wg.Wait()</code> 会等待所有的子任务全部完成，所有子协程结束后，才会执行 <code>wg.Wait()</code> 后面的代码。<br>WaitGroup 只能等待子任务全部完成才能执行下一步，那么如果我们想要在主进程中通知子协程退出呢？这种场景下，可以使用 <code>select + chan</code> 机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stop <span class="keyword">chan</span> <span class="type">bool</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reqTask</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;  </span><br><span class="line">  <span class="keyword">for</span> &#123;  </span><br><span class="line">    <span class="keyword">select</span> &#123;  </span><br><span class="line">      <span class="keyword">case</span> &lt;-stop:  </span><br><span class="line">      fmt.Println(<span class="string">&quot;stop&quot;</span>, name)  </span><br><span class="line">      <span class="keyword">return</span>  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">      fmt.Println(name, <span class="string">&quot;send request&quot;</span>)  </span><br><span class="line">      time.Sleep(<span class="number">1</span> * time.Second)  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  stop = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)  </span><br><span class="line">  <span class="keyword">go</span> reqTask(<span class="string">&quot;worker&quot;</span>)  </span><br><span class="line">  time.Sleep(<span class="number">3</span> * time.Second)  </span><br><span class="line">  stop &lt;- <span class="literal">true</span>  </span><br><span class="line">  time.Sleep(<span class="number">3</span> * time.Second)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// worker send request  </span></span><br><span class="line"><span class="comment">// worker send request  </span></span><br><span class="line"><span class="comment">// worker send request  </span></span><br><span class="line"><span class="comment">// stop worker  </span></span><br></pre></td></tr></table></figure><p>更复杂的场景如何做并发控制呢？Go 语言提供了 Context 标准库可以解决这类场景的问题，Context 的作用和它的名字很像，上下文，即子协程的下上文。Context 有两个主要的功能：</p><ul><li>通知子协程退出（正常退出，超时退出等）；</li><li>传递必要的参数。</li></ul><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p><code>context.WithCancel()</code> 创建可取消的 Context 对象，即可以主动通知子协程退出。</p><h3 id="2-1-控制单个协程"><a href="#2-1-控制单个协程" class="headerlink" title="2.1 控制单个协程"></a><a href="https://geektutu.com/post/quick-go-context.html#2-1-%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AA%E5%8D%8F%E7%A8%8B" title="2.1 控制单个协程"></a>2.1 控制单个协程</h3><p>使用 Context 改写上述的例子，效果与 <code>select+chan</code> 相同。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20  </p><p>func reqTask(ctx context.Context, name string) {<br> for {<br> select {<br> case &lt;-ctx.Done():<br> fmt.Println(“stop”, name)<br> return<br> default:<br> fmt.Println(name, “send request”)<br> time.Sleep(1 * time.Second)<br> }<br> }<br>}  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithCancel(context.Background())<br> go reqTask(ctx, “worker1”)<br> time.Sleep(3 * time.Second)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><ul><li><code>context.Backgroud()</code> 创建根 Context，通常在 main 函数、初始化和测试代码中创建，作为顶层 Context。</li><li><code>context.WithCancel(parent)</code> 创建可取消的子 Context，同时返回函数 <code>cancel</code>。</li><li>在子协程中，使用 select 调用 <code>&lt;-ctx.Done()</code> 判断是否需要退出。</li><li>主协程中，调用 <code>cancel()</code> 函数通知子协程退出。</li></ul><h3 id="2-2-控制多个协程"><a href="#2-2-控制多个协程" class="headerlink" title="2.2 控制多个协程"></a><a href="https://geektutu.com/post/quick-go-context.html#2-2-%E6%8E%A7%E5%88%B6%E5%A4%9A%E4%B8%AA%E5%8D%8F%E7%A8%8B" title="2.2 控制多个协程"></a>2.2 控制多个协程</h3><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithCancel(context.Background())  </p><p> go reqTask(ctx, “worker1”)<br> go reqTask(ctx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><p>为每个子协程传递相同的上下文 <code>ctx</code> 即可，调用 <code>cancel()</code> 函数后该 Context 控制的所有子协程都会退出。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8  </p><p>worker1 send request<br>worker2 send request<br>worker1 send request<br>worker2 send request<br>worker1 send request<br>worker2 send request<br>stop worker1<br>stop worker2  </p><h2 id="3-context-WithValue"><a href="#3-context-WithValue" class="headerlink" title="3 context.WithValue"></a><a href="https://geektutu.com/post/quick-go-context.html#3-context-WithValue" title="3 context.WithValue"></a>3 context.WithValue</h2><p>如果需要往子协程中传递参数，可以使用 <code>context.WithValue()</code>。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27  </p><p>type Options struct{ Interval time.Duration }  </p><p>func reqTask(ctx context.Context, name string) {<br> for {<br> select {<br> case &lt;-ctx.Done():<br> fmt.Println(“stop”, name)<br> return<br> default:<br> fmt.Println(name, “send request”)<br> op :&#x3D; ctx.Value(“options”).(*Options)<br> time.Sleep(op.Interval * time.Second)<br> }<br> }<br>}  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithCancel(context.Background())<br> vCtx :&#x3D; context.WithValue(ctx, “options”, &amp;Options{1})  </p><p> go reqTask(vCtx, “worker1”)<br> go reqTask(vCtx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><ul><li><code>context.WithValue()</code> 创建了一个基于 <code>ctx</code> 的子 Context，并携带了值 <code>options</code>。</li><li>在子协程中，使用 <code>ctx.Value(&quot;options&quot;)</code> 获取到传递的值，读取&#x2F;修改该值。</li></ul><h2 id="4-context-WithTimeout"><a href="#4-context-WithTimeout" class="headerlink" title="4 context.WithTimeout"></a><a href="https://geektutu.com/post/quick-go-context.html#4-context-WithTimeout" title="4 context.WithTimeout"></a>4 context.WithTimeout</h2><p>如果需要控制子协程的执行时间，可以使用 <code>context.WithTimeout</code> 创建具有超时通知机制的 Context 对象。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithTimeout(context.Background(), 2*time.Second)<br> go reqTask(ctx, “worker1”)<br> go reqTask(ctx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> fmt.Println(“before cancel”)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><p><code>WithTimeout()</code>的使用与 <code>WithCancel()</code> 类似，多了一个参数，用于设置超时时间。执行结果如下：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7  </p><p>worker2 send request<br>worker1 send request<br>worker1 send request<br>worker2 send request<br>stop worker2<br>stop worker1<br>before cancel  </p><p>因为超时时间设置为 2s，但是 main 函数中，3s 后才会调用 <code>cancel()</code>，因此，在调用 <code>cancel()</code> 函数前，子协程因为超时已经退出了。</p><h2 id="5-context-WithDeadline"><a href="#5-context-WithDeadline" class="headerlink" title="5 context.WithDeadline"></a><a href="https://geektutu.com/post/quick-go-context.html#5-context-WithDeadline" title="5 context.WithDeadline"></a>5 context.WithDeadline</h2><p>超时退出可以控制子协程的最长执行时间，那 <code>context.WithDeadline()</code> 则可以控制子协程的最迟退出时间。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23  </p><p>func reqTask(ctx context.Context, name string) {<br> for {<br> select {<br> case &lt;-ctx.Done():<br> fmt.Println(“stop”, name, ctx.Err())<br> return<br> default:<br> fmt.Println(name, “send request”)<br> time.Sleep(1 * time.Second)<br> }<br> }<br>}  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithDeadline(context.Background(), time.Now().Add(1*time.Second))<br> go reqTask(ctx, “worker1”)<br> go reqTask(ctx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> fmt.Println(“before cancel”)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><ul><li><code>WithDeadline</code> 用于设置截止时间。在这个例子中，将截止时间设置为1s后，<code>cancel()</code> 函数在 3s 后调用，因此子协程将在调用 <code>cancel()</code> 函数前结束。</li><li>在子协程中，可以通过 <code>ctx.Err()</code> 获取到子协程退出的错误原因。</li></ul><p>运行结果如下：</p><p>1<br>2<br>3<br>4<br>5  </p><p>worker2 send request<br>worker1 send request<br>stop worker2 context deadline exceeded<br>stop worker1 context deadline exceeded<br>before cancel  </p><p>可以看到，子协程 <code>worker1</code> 和 <code>worker2</code> 均是因为截止时间到了而退出。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 必看必会 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang语言面试题 - 基本原理</title>
      <link href="/interview/go/golang101-2/"/>
      <url>/interview/go/golang101-2/</url>
      
        <content type="html"><![CDATA[<h4 id="1-golang-文件初始化的顺序"><a href="#1-golang-文件初始化的顺序" class="headerlink" title="1. golang 文件初始化的顺序"></a>1. golang 文件初始化的顺序</h4><p>init() 函数是 Go 程序初始化的一部分。由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。<br>总结顺序如下：<br><strong>import –&gt; const –&gt; var –&gt; init() &#x2F; init2() –&gt; main()</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  &#123;  </span><br><span class="line"> fmt.Println(<span class="string">&quot;init1:&quot;</span>, a)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  &#123;  </span><br><span class="line"> fmt.Println(<span class="string">&quot;init2:&quot;</span>, a)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>  </span><br><span class="line"><span class="keyword">const</span> b = <span class="number">100</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"> fmt.Println(<span class="string">&quot;main:&quot;</span>, a)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 执行结果  </span></span><br><span class="line"><span class="comment">// init1: 10  </span></span><br><span class="line"><span class="comment">// init2: 10  </span></span><br><span class="line"><span class="comment">// main: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// init2: 10  </span></span><br><span class="line"><span class="comment">// init1: 10  </span></span><br><span class="line"><span class="comment">// main: 10</span></span><br></pre></td></tr></table></figure><h4 id="2-interface-如何比较"><a href="#2-interface-如何比较" class="headerlink" title="2. interface 如何比较"></a>2. interface 如何比较</h4><p>Golang 中， interface 内部包含了两个字段，类型 T 和值 V ，interface 之间可以用 &#x3D;&#x3D; 或 !&#x3D; 进行比较。两个 interface 之间可能包含以下两种情况：</p><ol><li>两个都是 nil （对应的 T 和 V 都为 unset 的状态）</li><li>T 相同，且 V 相同</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;  </span><br><span class="line">  UserName <span class="type">string</span>  <span class="string">`json:user_name`</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> UserFace <span class="keyword">interface</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="comment">// 实际比较的是两个结构体的地址</span></span><br><span class="line">  <span class="keyword">var</span> u1, u2 UserFace = &amp;User&#123;<span class="string">&quot;Tom&quot;</span>&#125;, &amp;User&#123;<span class="string">&quot;Tom&quot;</span>&#125;  </span><br><span class="line">  <span class="comment">// 比较两个结构体</span></span><br><span class="line">  <span class="keyword">var</span> u3, u4 UserFace = User&#123;<span class="string">&quot;Tom&quot;</span>&#125;, User&#123;<span class="string">&quot;Tom&quot;</span>&#125;  </span><br><span class="line">  fmt.Println(u1 == u2) <span class="comment">// false  </span></span><br><span class="line">  fmt.Println(u3 == u4) <span class="comment">// true  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-interface-和-nil"><a href="#3-interface-和-nil" class="headerlink" title="3. interface 和 nil"></a>3. interface 和 nil</h4><p>上边讲了 interface 包含两个字段，那么一个 nil 的空结构体和 nil 是否真的相等呢？可以看下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> p *<span class="type">int</span> = <span class="literal">nil</span>  </span><br><span class="line">  <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = p  </span><br><span class="line">  fmt.Println(i == p) <span class="comment">// true  </span></span><br><span class="line">  fmt.Println(p == <span class="literal">nil</span>) <span class="comment">// true  </span></span><br><span class="line">  fmt.Println(i == <span class="literal">nil</span>) <span class="comment">// false  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 nil 非 interface 的值 p 赋给 i 的时候，i 实际上是 (T&#x3D;*int, V&#x3D;nil)。当二者相比较时，Go 会将 p 先转换成 interface 类型的再去比较，此时二者等价。<br>p 与 nil 是直接比较的值，因此二者也等价。<br>i 与 nil  比较时，会将 nil 转换为接口 (T&#x3D;nil, V&#x3D;nil)，与 i (T&#x3D;*int, V&#x3D;nil) 不相等，因此  i !&#x3D; nil</p><h4 id="4-GC-初步理解"><a href="#4-GC-初步理解" class="headerlink" title="4. GC 初步理解"></a>4. GC 初步理解</h4><p>最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count)，Go 语言 采用的是标记清除算法。1.5 版本以后在此基础上使用了三色标记法和写屏障技术，提高了效率。</p><p>标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p><ul><li>标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；</li><li>清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。</li></ul><p>标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW，这也是 GC 算法优化的重点），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。</p><p>三色标记算法将程序中的对象分成白色、黑色和灰色三类。</p><ul><li>白色：不确定对象。</li><li>灰色：存活对象，子对象待处理。</li><li>黑色：存活对象。</li></ul><p>标记开始时，所有内存加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入待扫描队列（灰色集合）；使用并发的 goroutine 扫描队列，取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入队列。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。</p><p>三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。</p><p>三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A (黑) -&gt; B (灰) -&gt; C (白) -&gt; D (白)  </span><br></pre></td></tr></table></figure><p>正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A (黑) -&gt; B (灰) -&gt; C (白)   </span><br><span class="line"> ↓  </span><br><span class="line">D (白)  </span><br></pre></td></tr></table></figure><p>为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，这个计数会拦截将白色指针插入黑色对象的操作，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。</p><p>一次完整的 GC 分为四个阶段：</p><ul><li>标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)，开启辅助 GC （mutator assist），统计 root 对象的任务数量</li><li>使用三色标记法标记（Marking, 并发）</li><li>标记结束(Mark Termination，需 STW)，关闭写屏障。</li><li>清理(Sweeping, 并发)</li></ul><h4 id="5-GMP-模型，go-协程"><a href="#5-GMP-模型，go-协程" class="headerlink" title="5. GMP 模型，go 协程"></a>5. GMP 模型，go 协程</h4><h4 id="6-Gin-框架简介"><a href="#6-Gin-框架简介" class="headerlink" title="6. Gin 框架简介"></a>6. Gin 框架简介</h4><h4 id="7-反射的原理"><a href="#7-反射的原理" class="headerlink" title="7. 反射的原理"></a>7. 反射的原理</h4><h4 id="8-Go-mutex-锁机制"><a href="#8-Go-mutex-锁机制" class="headerlink" title="8. Go mutex 锁机制"></a>8. Go mutex 锁机制</h4><p>例如：map 协程不安全，需要读写锁<br>Mutex 几种状态<br><code>mutexLocked</code> — 表示互斥锁的锁定状态；<br><code>mutexWoken</code> — 表示从正常模式被从唤醒；<br><code>mutexStarving</code> — 当前的互斥锁进入饥饿状态；<br><code>waitersCount</code> — 当前互斥锁上等待的 Goroutine 个数；</p><h4 id="9-Channel-优点和相关的坑"><a href="#9-Channel-优点和相关的坑" class="headerlink" title="9. Channel 优点和相关的坑"></a>9. Channel 优点和相关的坑</h4><h4 id="10-oom-？"><a href="#10-oom-？" class="headerlink" title="10. oom ？"></a>10. oom ？</h4><h4 id="11-内存管理方式"><a href="#11-内存管理方式" class="headerlink" title="11. 内存管理方式"></a>11. 内存管理方式</h4><h4 id="12-GC-触发时机"><a href="#12-GC-触发时机" class="headerlink" title="12. GC 触发时机"></a>12. GC 触发时机</h4><p>使用系统监控，该触发条件由 <code>runtime.forcegcperiod</code> 变量控制，默认为 2 分 钟。当超过两分钟没有产生任何 GC 时，强制触发 GC。 使用步调（Pacing）算法，其核心思想是控制内存增长的比例。如 Go 的 GC 是一种比例 GC, 下一次 GC 结束时的堆大小和上一次 GC <code>存活</code>堆大小成比例。一般来说，当前申请的内存是上一次 GC 两倍时触发。</p><h4 id="13-GRPC-以及-protobuf-协议优化"><a href="#13-GRPC-以及-protobuf-协议优化" class="headerlink" title="13. GRPC 以及 protobuf 协议优化"></a>13. GRPC 以及 protobuf 协议优化</h4><p>gRPC的核心概念包括：</p><p>RPC(Remote Procedure Call，远程过程调用)：gRPC提供了一种简单的RPC机制，允许客户端和服务器之间无缝通信。客户端通过调用本地方法，实际上是在远程服务器上执行方法，并将结果返回给客户端。<br>Protocol Buffers：gRPC使用Protocol Buffers作为数据序列化和传输格式。Protocol Buffers是一种轻量级、高效的数据结构序列化库，可以在多种编程语言之间实现无缝通信。<br>HTTP&#x2F;2：gRPC使用HTTP&#x2F;2作为传输协议，利用HTTP&#x2F;2的多路复用、流控制、压缩等特性，实现低延迟、高吞吐量的通信。</p><p>RPC调用：gRPC的RPC调用过程可以分为以下步骤：</p><p>客户端通过Protocol Buffers序列化请求数据，并使用HTTP&#x2F;2发送请求。<br>服务器接收请求，使用Protocol Buffers反序列化请求数据。<br>服务器执行RPC方法，并将结果序列化为Protocol Buffers格式。<br>服务器使用HTTP&#x2F;2发送响应给客户端。<br>客户端使用Protocol Buffers反序列化响应数据，并处理结果。</p><h4 id="14-golang-压测-pprof，火焰图"><a href="#14-golang-压测-pprof，火焰图" class="headerlink" title="14. golang 压测 pprof，火焰图"></a>14. golang 压测 pprof，火焰图</h4>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang语言面试题 - 常见题</title>
      <link href="/interview/go/golang101-3/"/>
      <url>/interview/go/golang101-3/</url>
      
        <content type="html"><![CDATA[<p>下面会给出网上收集的字节系 Golang 语言常见的面试题，按照热度排序哦</p><h4 id="简述-slice-的底层原理，slice-和数组的区别是什么？"><a href="#简述-slice-的底层原理，slice-和数组的区别是什么？" class="headerlink" title="简述 slice 的底层原理，slice 和数组的区别是什么？"></a>简述 slice 的底层原理，slice 和数组的区别是什么？</h4><h4 id="简单介绍-GMP-模型以及该模型的优点-困难"><a href="#简单介绍-GMP-模型以及该模型的优点-困难" class="headerlink" title="简单介绍 GMP 模型以及该模型的优点  困难"></a>简单介绍 GMP 模型以及该模型的优点  困难</h4><h4 id="简述-Golang-垃圾回收的机制-中等"><a href="#简述-Golang-垃圾回收的机制-中等" class="headerlink" title="简述 Golang 垃圾回收的机制  中等"></a>简述 Golang 垃圾回收的机制  中等</h4><p>Golang 采用的垃圾回收机制是三色标记法，分为白色（未标记）、灰色（标记中）、黑色（已标记）。<br>回收流程为：<br>    1. STW，从根节点出发，将根节点标记为黑色，将能达到的所有节点标记为灰色，然后将所有能达到的子节点加入队列<br>    2. 并发遍历队列中的节点，标记为黑色，且继续寻找其子节点标记为灰色并加入队列<br>    3. 直到队列中所有可达节点均遍历完毕，那么剩下的白色节点就是不可达的节点，可以回收掉<br>在实际使用过程中，如果在标记过程中，节点指针被用户操作改变，可能会标记失败被错误的清除掉，因此 Go 又引入了写屏障</p><p>一次完整的 GC 分为四个阶段：</p><ul><li>标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)，开启辅助 GC （mutator assist），统计 root 对象的任务数量</li><li>使用三色标记法标记（Marking, 并发）</li><li>标记结束(Mark Termination，需 STW)，关闭写屏障。</li><li>清理(Sweeping, 并发)</li></ul><p>GC 调优</p><ol><li>减少使用string类型中的 ‘+’（此种方式每次拼接都会申请一段新的内存空间），推荐使用 strings.Builder （类似切片的扩容机制）</li><li>小对象复用，尽量减少声明局部变量，小对象可以加入结构体来复用，方便 GC 扫描</li></ol><h4 id="协程与进程，线程的区别是什么？协程有什么优势？"><a href="#协程与进程，线程的区别是什么？协程有什么优势？" class="headerlink" title="协程与进程，线程的区别是什么？协程有什么优势？"></a>协程与进程，线程的区别是什么？协程有什么优势？</h4><p>Goroutines是可以同时运行的函数与方法。Goroutines 可以被认为是轻量级的线程。 与线程相比，创建 Goroutine 的开销很小。 Go应用程序同时运行数千个 Goroutine 是非常常见的做法。</p><ul><li>进程: 进程是具有一定独立功能的程序，进程是系统资源分配和调度的最小单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</li><li>线程: 线程是进程的一个实体,线程是内核态,而且是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</li><li>协程: 协程是一种用户态的轻量级线程，协程的调度完全是由用户来控制的。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</li></ul><h4 id="简述-defer-的执行顺序-中等"><a href="#简述-defer-的执行顺序-中等" class="headerlink" title="简述 defer 的执行顺序  中等"></a>简述 defer 的执行顺序  中等</h4><ol><li>多个 defer 的执行顺序为“后进先出”；</li><li>所有函数在执行 RET 返回指令之前，都会先检查是否存在 defer 语句，若存在则先逆序调用 defer 语句进行收尾工作再退出返回；</li><li>匿名返回值是在 return 执行时被声明，有名返回值则是在函数声明的同时被声明，因此在 defer 语句中只能访问有名返回值，而不能直接访问匿名返回值；</li><li>return 其实应该包含前后两个步骤：第一步是给返回值赋值（若为有名返回值则直接赋值，若为匿名返回值则先声明再赋值）；第二步是调用 RET 返回指令并传入返回值，而 RET 则会检查 defer 是否存在，若存在就先逆序插播 defer 语句，最后 RET 携带返回值退出函数；</li><li>defer 声明时会先确定函数参数，推迟执行的仅仅是函数体</li></ol><h4 id="Golang-有哪些优缺点、错误处理有什么优缺点？"><a href="#Golang-有哪些优缺点、错误处理有什么优缺点？" class="headerlink" title="Golang 有哪些优缺点、错误处理有什么优缺点？"></a>Golang 有哪些优缺点、错误处理有什么优缺点？</h4><p>优点：</p><ol><li>简洁、高效、安全</li><li>并发处理能力强</li><li>静态类型和编译型</li><li>丰富的标准库</li><li>跨平台和可移植性</li><li>强大的性能</li><li>垃圾回收机制<br>劣势:</li><li>泛型编程支持不足</li><li>错误处理方式可能不同</li></ol><p>采用错误返回方式，错误是一种内置类型，可以使用 error 类型来定义。而异常（panic）也可以通过 recover() 函数转换为 error来处理。优点是简单直观，一般与主体程序分离。可能的缺点是，需要在调用链中做好收集和处理，如果漏处理可能会有问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">panic</span> := <span class="built_in">recover</span>(); <span class="built_in">panic</span> != <span class="literal">nil</span> &#123;  </span><br><span class="line">      err = DumpStack(<span class="built_in">panic</span>)  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>两次 GC 周期重叠会引发什么问题，GC 触发机制是什么样的？  简单</p><p>Golang 的协程通信方式有哪些？  中等</p><p>△ 4次</p><p>简述 Golang 的伪抢占式调度  中等</p><p>△ 4次</p><p>什么是 goroutine 泄漏  简单</p><p>△ 4次</p><p>groutinue 什么时候会被挂起？  简单</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang语言面试题 - 基础语法</title>
      <link href="/interview/go/golang101-1/"/>
      <url>/interview/go/golang101-1/</url>
      
        <content type="html"><![CDATA[<h4 id="1-和-的区别？"><a href="#1-和-的区别？" class="headerlink" title="1.  = 和 := 的区别？"></a>1.  <code>=</code> 和 <code>:=</code> 的区别？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo <span class="type">int</span>  </span><br><span class="line">foo = <span class="number">10</span> </span><br><span class="line"><span class="comment">// 等价于  </span></span><br><span class="line">foo := <span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="2-指针的作用"><a href="#2-指针的作用" class="headerlink" title="2. 指针的作用"></a>2. 指针的作用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x =  <span class="number">5</span>  </span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> = &amp;x  </span><br><span class="line">fmt.Printf(<span class="string">&quot;x = %d&quot;</span>,  *p) <span class="comment">// x 可以用 *p 访问</span></span><br><span class="line"><span class="comment">//  `*` 运算符，也称为解引用运算符，用于访问地址中的值。</span></span><br><span class="line"><span class="comment">//  `＆`运算符，也称为地址运算符，用于返回变量的地址。</span></span><br></pre></td></tr></table></figure><h4 id="3-Go-有异常类型么？"><a href="#3-Go-有异常类型么？" class="headerlink" title="3. Go 有异常类型么？"></a>3. Go 有异常类型么？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go 只有错误类型</span></span><br><span class="line">f, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">  log.Fatal(err)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-协程和线程和进程的区别？"><a href="#4-协程和线程和进程的区别？" class="headerlink" title="4. 协程和线程和进程的区别？"></a>4. 协程和线程和进程的区别？</h4><p>Goroutines是可以同时运行的函数与方法。Goroutines 可以被认为是轻量级的线程。 与线程相比，创建 Goroutine 的开销很小。 Go应用程序同时运行数千个 Goroutine 是非常常见的做法。<br>并发掌握，goroutine和channel声明与使用！</p><h4 id="5-拼接字符串"><a href="#5-拼接字符串" class="headerlink" title="5. 拼接字符串"></a>5. 拼接字符串</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串是只读的，也就意味着每次修改操作都会创建一个新的字符串</span></span><br><span class="line">a := <span class="string">&quot;a&quot;</span></span><br><span class="line">b := <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="keyword">var</span> str1 <span class="type">string</span></span><br><span class="line">str1 += a</span><br><span class="line">str1 += b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用 `strings.Builder`，最小化内存拷贝次数。</span></span><br><span class="line"><span class="keyword">var</span> str strings.Builder  </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;  </span><br><span class="line">  str.WriteString(<span class="string">&quot;a&quot;</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">fmt.Println(str.String())</span><br></pre></td></tr></table></figure><h4 id="6-什么是-rune-类型"><a href="#6-什么是-rune-类型" class="headerlink" title="6. 什么是 rune 类型"></a>6. 什么是 rune 类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Go 语言中，字符串的底层表示是 byte (8 bit) 序列，而非 rune (32 bit) 序列。例如下面的例子中 `语` 和 `言` 使用 UTF-8 编码后各占 3 个 byte，因此 `len(&quot;Go语言&quot;)` 等于 8，当然我们也可以将字符串转换为 rune 序列。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(<span class="string">&quot;Go语言&quot;</span>)) <span class="comment">// 8  </span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>([]<span class="type">rune</span>(<span class="string">&quot;Go语言&quot;</span>))) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h4 id="7-判断-map-结构中是否包含某个-key-的方法"><a href="#7-判断-map-结构中是否包含某个-key-的方法" class="headerlink" title="7. 判断 map 结构中是否包含某个 key 的方法"></a>7. 判断 map 结构中是否包含某个 key 的方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok 为 true 代表有这个 key，且 val 是这个 key 的值</span></span><br><span class="line"><span class="keyword">if</span> val, ok := map_[<span class="string">&quot;key&quot;</span>]; ok &#123;  </span><br><span class="line">  <span class="comment">//do something  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-defer-的执行顺序"><a href="#8-defer-的执行顺序" class="headerlink" title="8. defer 的执行顺序"></a>8. defer 的执行顺序</h4><p>多个 defer 语句，遵从后进先出(Last In First Out，LIFO)的原则，最后声明的 defer 语句，最先得到执行。<br>panic 需要等defer 结束后才会向上传递。出现panic恐慌时候，会先按照defer的后入先出的顺序执行，最后才会执行panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">  i := <span class="number">0</span>  </span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;defer1&quot;</span>)  </span><br><span class="line">  &#125;()  </span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    i += <span class="number">1</span>  </span><br><span class="line">    fmt.Println(<span class="string">&quot;defer2&quot;</span>)  </span><br><span class="line">  &#125;()  </span><br><span class="line">  <span class="keyword">return</span> i  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  fmt.Println(<span class="string">&quot;return&quot;</span>, test())  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// defer2  </span></span><br><span class="line"><span class="comment">// defer1  </span></span><br><span class="line"><span class="comment">// return 0</span></span><br></pre></td></tr></table></figure><p>defer 在 return 语句之后执行，但在函数真正退出之前，defer 可以修改返回值。我们可以注意到前一个例子的返回值并没有被修改（注意：只有被预先定义的返回值才能被 defer 语句修改）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> (i <span class="type">int</span>) &#123;  </span><br><span class="line">  i = <span class="number">0</span>  </span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    i += <span class="number">1</span>  </span><br><span class="line">    fmt.Println(<span class="string">&quot;defer2&quot;</span>)  </span><br><span class="line">  &#125;()  </span><br><span class="line">  <span class="keyword">return</span> i  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  fmt.Println(<span class="string">&quot;return&quot;</span>, test())  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// defer2  </span></span><br><span class="line"><span class="comment">// return 1</span></span><br></pre></td></tr></table></figure><h4 id="9-tag的用法？"><a href="#9-tag的用法？" class="headerlink" title="9. tag的用法？"></a>9. tag的用法？</h4><p>tag 是 struct 结构的注解，不同的框架或者工具可以通过反射获取到某个字段的属性，增加语义<br>例如下方例子定义了 struct 结构字段和 json 结构的映射关系</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;encoding/json&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;  </span><br><span class="line">  Name <span class="type">string</span> <span class="string">`json:&quot;user_name&quot;`</span>  </span><br><span class="line">  Id   <span class="type">string</span> <span class="string">`json:&quot;user_id&quot;`</span>  </span><br><span class="line">  Age  <span class="type">int</span>    <span class="string">`json:&quot;-&quot;`</span>  <span class="comment">// json 忽略</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  buf, _ := json.Marshal(Stu&#123;<span class="string">&quot;Bishop&quot;</span>, <span class="string">&quot;1001&quot;</span>, <span class="number">18</span>&#125;)  </span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, buf)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-Golang-如何判断两个列表（slice）结构等价"><a href="#10-Golang-如何判断两个列表（slice）结构等价" class="headerlink" title="10. Golang 如何判断两个列表（slice）结构等价"></a>10. Golang 如何判断两个列表（slice）结构等价</h4><p>可以使用反射 reflect.DeepEqual(a, b) 来判断，但是此种方法比较影响性能，我们这里还是通过基础遍历的方法来完成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceAEqurlSliceB</span><span class="params">(a, b []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">  <span class="comment">// 等长</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b) &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判空</span></span><br><span class="line">  <span class="keyword">if</span> (a == <span class="literal">nil</span>) != (b == <span class="literal">nil</span>) &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  b = b[:<span class="built_in">len</span>(a)]  </span><br><span class="line">  <span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;  </span><br><span class="line"><span class="keyword">if</span> v != b[i] &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-如何标识枚举值（enums）"><a href="#11-如何标识枚举值（enums）" class="headerlink" title="11. 如何标识枚举值（enums）"></a>11. 如何标识枚举值（enums）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Level <span class="type">int32</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> (  </span><br><span class="line">  Level1 Level = <span class="literal">iota</span>  </span><br><span class="line">  Level2  </span><br><span class="line">  Level3 </span><br><span class="line">  Level4 </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  fmt.Println(Level1, Level2, Level3, Level4) <span class="comment">// 0, 1, 2, 3  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-空-struct-结构的一些用法"><a href="#12-空-struct-结构的一些用法" class="headerlink" title="12. 空 struct{} 结构的一些用法"></a>12. 空 struct{} 结构的一些用法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本体是一个空结构体</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(<span class="keyword">struct</span>&#123;&#125;&#123;&#125;)) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用作占位符使用</span></span><br><span class="line"><span class="keyword">type</span> Set <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  set := <span class="built_in">make</span>(Set)  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, item := <span class="keyword">range</span> []<span class="type">string</span>&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125; &#123;  </span><br><span class="line">set[item] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  fmt.Println(<span class="built_in">len</span>(set)) <span class="comment">// 3  </span></span><br><span class="line">  <span class="keyword">if</span> _, ok := set[<span class="string">&quot;A&quot;</span>]; ok &#123;  </span><br><span class="line">fmt.Println(<span class="string">&quot;A exists&quot;</span>) <span class="comment">// A exists  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用作传递信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    &lt;-ch  </span><br><span class="line">    <span class="comment">// do something  </span></span><br><span class="line">  &#125;()  </span><br><span class="line">  ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  </span><br><span class="line">  <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="13-声明结构体方法"><a href="#13-声明结构体方法" class="headerlink" title="13. 声明结构体方法"></a>13. 声明结构体方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Lamp <span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Lamp)</span></span> On() &#123;  </span><br><span class="line"> <span class="built_in">println</span>(<span class="string">&quot;On&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Lamp)</span></span> Off() &#123;  </span><br><span class="line"> <span class="built_in">println</span>(<span class="string">&quot;Off&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-make-和-new"><a href="#14-make-和-new" class="headerlink" title="14. make 和 new"></a>14. make 和 new</h4><ol><li>make 仅用来分配及初始化类型为 slice、map、chan 的数据。new 可分配任意类型的数据.</li><li>new 分配返回的是指针，即类型 *Type。make 返回引用，即 Type.</li><li>new 分配的空间被清零, make 分配空间后，会进行初始化.<br>一个例子<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i *<span class="type">int</span></span><br><span class="line">i = <span class="built_in">new</span>(<span class="type">int</span>) <span class="comment">// 分配内存地址并返回指向改地址的指针，同时置为类型的0值</span></span><br><span class="line">*i = <span class="number">10</span></span><br><span class="line">fmt.Println(*i) <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="15-代码输出啥相关题"><a href="#15-代码输出啥相关题" class="headerlink" title="15. 代码输出啥相关题"></a>15. 代码输出啥相关题</h4><h5 id="1"><a href="#1" class="headerlink" title="(1)"></a>(1)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">uint</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">uint</span> = <span class="number">2</span></span><br><span class="line">    fmt.Println(a-b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2^32-1 or 2^64-1 根据操作系统位数有不同结果</span></span><br></pre></td></tr></table></figure><p>强类型语言，计算结果也是 uint 类型，1-2 可以转换为 0-1 ，计算机中按照 0 + -1 来计算，-1 通常表示为补码，即所有位数都是1的一个数，即当前系统可表示的最大数</p><h5 id="2"><a href="#2" class="headerlink" title="(2)"></a>(2)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;A: &quot;</span>, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;B: &quot;</span>, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考点：<strong>go执行的随机性和闭包</strong><br>解答：谁也不知道执行后打印的顺序是什么样的，所以只能说是随机数字。但是<code>A:</code>均为输出10，<code>B:</code>从0~9输出(顺序不定)。第一个go func中i是外部for的一个变量，地址不变化。遍历完成后，最终i&#x3D;10。故go func执行时，i的值始终是10。<br>第二个go func中i是函数参数，与外部for中的i完全是两个变量。尾部(i)将发生值拷贝，go func内部指向值拷贝地址。</p><h5 id="3"><a href="#3" class="headerlink" title="(3)"></a>(3)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span></span> ShowA() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;showA&quot;</span>)</span><br><span class="line">    p.ShowB()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span></span> ShowB() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;showB&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">    People</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Teacher)</span></span> ShowB() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;teacher showB&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := Teacher&#123;&#125;</span><br><span class="line">    t.ShowA()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shwoA</span></span><br><span class="line"><span class="comment">// showB</span></span><br></pre></td></tr></table></figure><p>考点：<strong>go的组合继承</strong><br>解答：这是Golang的组合模式，可以实现OOP的继承。被组合的类型People所包含的方法虽然升级成了外部类型Teacher这个组合类型的方法（一定要是匿名字段），但它们的方法(ShowA())调用时接受者并没有发生变化。此时People类型并不知道自己会被什么类型组合，当然也就无法调用方法时去使用未知的组合者Teacher类型的功能。</p><h5 id="4"><a href="#4" class="headerlink" title="(4)"></a>(4)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    int_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">    string_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">    int_chan &lt;- <span class="number">1</span></span><br><span class="line">    string_chan &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> value := &lt;-int_chan:</span><br><span class="line">        fmt.Println(value)</span><br><span class="line">    <span class="keyword">case</span> value := &lt;-string_chan:</span><br><span class="line">        <span class="built_in">panic</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考点：<strong>select随机性</strong><br>解答： select会随机选择一个可用通用做收发操作。所以代码是有肯触发异常，也有可能不会。单个chan如果无缓冲时，将会阻塞。但结合 select可以在多个chan间等待执行。有三点原则： </p><ul><li>select 中只要有一个case能return，则立刻执行。 </li><li>当如果同一时间有多个case均能return则伪随机方式抽取任意一个执行。</li><li>如果没有一个case能return则可以执行”default”块。<h5 id="5"><a href="#5" class="headerlink" title="(5)"></a>(5)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)  </span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  </span><br><span class="line">    fmt.Println(s) <span class="comment">// [0,0,0,0,0,1,2,3] </span></span><br><span class="line">  </span><br><span class="line">    s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)  </span><br><span class="line">    s2 = <span class="built_in">append</span>(s2, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  </span><br><span class="line">    fmt.Println(s2)  <span class="comment">// [1,2,3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意 make 会给定义的长度分配初值<h5 id="6"><a href="#6" class="headerlink" title="(6)"></a>(6)</h5>map线程安全</li></ul><h4 id="16-如何理解go语言中的interface"><a href="#16-如何理解go语言中的interface" class="headerlink" title="16. 如何理解go语言中的interface?"></a>16. 如何理解go语言中的interface?</h4><ol><li>interface是方法申明的集合</li><li>任何类型的对象实现了在interface接口中声明的全部方法，则表明该类型实现了该接口</li><li>interface可以作为一种数据类型，实现了该接口的任何对象都可以给对应的接口类型变量赋值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义一个数据写入器</span></span><br><span class="line"><span class="keyword">type</span> DataWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">WriteData(data <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义文件结构，用于实现DataWriter</span></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现DataWriter接口的WriteData方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *file)</span></span> WriteData(data <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// 模拟写入数据</span></span><br><span class="line">fmt.Println(<span class="string">&quot;WriteData:&quot;</span>, data)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口可以作为数据类型传递，体现2，3</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cprint</span><span class="params">(writer DataWriter)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Cprint&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 实例化file</span></span><br><span class="line">f := <span class="built_in">new</span>(file)</span><br><span class="line"><span class="comment">// 声明一个DataWriter的接口</span></span><br><span class="line"><span class="keyword">var</span> writer DataWriter</span><br><span class="line"><span class="comment">// 将接口赋值f，也就是*file类型</span></span><br><span class="line">writer = f</span><br><span class="line"><span class="comment">// 使用DataWriter接口进行数据写入</span></span><br><span class="line">err := writer.WriteData(<span class="string">&quot;data&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;writeData err!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">Cprint(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="17-Go-语言是如何实现切片扩容的？"><a href="#17-Go-语言是如何实现切片扩容的？" class="headerlink" title="17. Go 语言是如何实现切片扩容的？"></a>17. Go 语言是如何实现切片扩容的？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  arr := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>) </span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++ &#123; </span><br><span class="line">    fmt.Println(<span class="string">&quot;len为&quot;</span>, <span class="built_in">len</span>(arr), <span class="string">&quot;cap为&quot;</span>, <span class="built_in">cap</span>(arr)) </span><br><span class="line">    arr = <span class="built_in">append</span>(arr, i) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看下结果<br>依次是 0,1,2,4,8,16,32,64,128,256,512,1024<br>但到了1024之后,就变成了 1024,1280,1696,2304<br>每次都是扩容了四分之一左右</p><h4 id="18-数组和切片"><a href="#18-数组和切片" class="headerlink" title="18. 数组和切片"></a>18. 数组和切片</h4><p>golang 中存在两种函数传入方式：值类型和引用类型<br>值类型只改变当前作用域的值，在该作用域外部不会生效；引用类型改变当前地址对应的值，在作用域外部生效。可以参考下边的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组 值类型</span></span><br><span class="line"><span class="comment">// 切片 引用类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeArray</span><span class="params">(x [3]<span class="type">int</span>)</span></span> &#123;x[<span class="number">0</span>] = <span class="number">123</span>&#125; <span class="comment">// 定义为数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(x []<span class="type">int</span>)</span></span> &#123;x[<span class="number">0</span>] = <span class="number">123</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  x1 := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;x1 original-&gt;&quot;</span>, x1)</span><br><span class="line">  changeArray(x)</span><br><span class="line">  fmt.Println(<span class="string">&quot;x1 current-&gt;&quot;</span>. x1)</span><br><span class="line"></span><br><span class="line">  x := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;x2 -&gt;&quot;</span>, x)</span><br><span class="line">  changeSlice(x)</span><br><span class="line">  fmt.Println(<span class="string">&quot;x2 -&gt;&quot;</span>. x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x1 -&gt; [1,2,3]</span></span><br><span class="line"><span class="comment">// x2 -&gt; [1,2,3]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="19"><a href="#19" class="headerlink" title="19."></a>19.</h4>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo建站（三）GitHub</title>
      <link href="/blog/build-blog/hexo101-3/"/>
      <url>/blog/build-blog/hexo101-3/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到建站记录的第二部分：部署到 github page</p><h2 id="GitHub页面"><a href="#GitHub页面" class="headerlink" title="GitHub页面"></a>GitHub页面</h2><p>这里假设已经注册过了Github帐户，如果没有，可以去<a href="https://github.com/">Github</a>注册。</p><p>注册好了后，登录Github,创建仓库：点击右上角的+号，选择new repository:<br><img src="https://t2.picb.cc/2022/02/21/fpUdSF.jpg" alt="git"></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo建站（二）butterfly</title>
      <link href="/blog/build-blog/hexo101-2/"/>
      <url>/blog/build-blog/hexo101-2/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到建站记录的第二部分：butterfly 主题的安装与初始化</p><h2 id="主题安装与使用"><a href="#主题安装与使用" class="headerlink" title="主题安装与使用"></a>主题安装与使用</h2><p>下载主题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">git <span class="built_in">clone</span> -b master https://gitee.com/immyw/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>修改站点配置文件 _config.yml ,把主题修改为 Butterfly</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">Butterfly</span></span><br></pre></td></tr></table></figure><p>为了后续方便配置，需要在当前目录 blog&#x2F; 创建 _config.butterfly.yml 文件，并将根目录下的 _config.yml 文件内容复制进去。更多的主题配置信息可以等待之后的文章~</p><p>尝试执行以下指令,以查看应用主题后的效果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">#清除旧的内容</span></span><br><span class="line">hexo g <span class="comment">#生成发布用的静态页面</span></span><br></pre></td></tr></table></figure><p>本地查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s <span class="comment"># hexo server</span></span><br></pre></td></tr></table></figure><p>执行完该命令可以去 <a href="localhost:4000">localhost:4000</a> 查看效果</p><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><h4 id="case1-："><a href="#case1-：" class="headerlink" title="case1 ："></a>case1 ：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ERROR TypeError: /data/blog/themes/butterfly/layout/includes/head.pug:40  </span><br><span class="line">38|  </span><br><span class="line">39| !=favicon_tag(theme.favicon || config.favicon)</span><br><span class="line"></span><br><span class="line">&gt; 40| <span class="built_in">link</span>(rel=<span class="string">&quot;canonical&quot;</span> href=urlNoIndex())  </span><br><span class="line">&gt; 41|  </span><br><span class="line">&gt; 42| //- 預解析  </span><br><span class="line">&gt; 43| !=partial(<span class="string">&#x27;includes/head/preconnect&#x27;</span>, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span><br><span class="line"></span><br><span class="line">prettyUrls is not a <span class="keyword">function</span>  </span><br><span class="line">at Object. (/data/blog/themes/butterfly/scripts/helpers/page.js:58:10)  </span><br><span class="line">at <span class="built_in">eval</span> (<span class="built_in">eval</span> at wrap (/data/blog/node_modules/pug-runtime/wrap.js:6:10), :89:77)  </span><br><span class="line">at template (<span class="built_in">eval</span> at wrap (/data/blog/node_modules/pug-runtime/wrap.js:6:10), :4603:215)  </span><br><span class="line">at _View._compiled (/data/blog/node_modules/hexo/lib/theme/view.js:136:50)  </span><br><span class="line">at _View.render (/data/blog/node_modules/hexo/lib/theme/view.js:39:17)  </span><br><span class="line">at /data/blog/node_modules/hexo/lib/hexo/index.js:64:21  </span><br><span class="line">at tryCatcher (/data/blog/node_modules/bluebird/js/release/util.js:16:23)  </span><br><span class="line">at /data/blog/node_modules/bluebird/js/release/method.js:15:34  </span><br><span class="line">at RouteStream._read (/data/blog/node_modules/hexo/lib/hexo/router.js:47:5)  </span><br><span class="line">at RouteStream.Readable.read (_stream_readable.js:479:10)  </span><br><span class="line">at resume_ (_stream_readable.js:966:12)  </span><br><span class="line">at processTicksAndRejections (internal/process/task_queues.js:80:21) &#123;  </span><br><span class="line">path: <span class="string">&#x27;/data/blog/themes/butterfly/layout/includes/head.pug&#x27;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>解决方案</p><ol><li>优先确认 themes&#x2F;butterfly 中有相关的文件内容</li><li>尝试执行如下命令： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br><span class="line"><span class="built_in">rm</span> -rf node_modules</span><br><span class="line"><span class="built_in">rm</span> -rf package-lock.json</span><br><span class="line">npm install</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure></li></ol><h4 id="case2："><a href="#case2：" class="headerlink" title="case2："></a>case2：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TypeError: /Users/blog/themes/butterfly/layout/includes/widget/index.pug:33</span><br><span class="line">    31|       !=partial(<span class="string">&#x27;includes/widget/card_tags&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line">    32|       !=partial(<span class="string">&#x27;includes/widget/card_archives&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line">  &gt; 33|       !=partial(<span class="string">&#x27;includes/widget/card_webinfo&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line">    34|       !=partial(<span class="string">&#x27;includes/widget/card_bottom_self&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line">/Users/blog/themes/butterfly/layout/includes/widget/card_webinfo.pug:18</span><br><span class="line">    16|         .webinfo-item</span><br><span class="line">    17|           .item-name=_p(<span class="string">&#x27;aside.card_webinfo.site_wordcount&#x27;</span>) + <span class="string">&quot; :&quot;</span></span><br><span class="line">  &gt; 18|           .item-count=totalcount(site)</span><br><span class="line">    19|       <span class="keyword">if</span> theme.busuanzi.site_uv</span><br><span class="line">    20|         .webinfo-item</span><br><span class="line">    21|           .item-name= _p(<span class="string">&#x27;aside.card_webinfo.site_uv_name&#x27;</span>) + <span class="string">&quot; :&quot;</span></span><br><span class="line"></span><br><span class="line">totalcount is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p>请检查是否安裝了wordcount插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><h4 id="case3："><a href="#case3：" class="headerlink" title="case3："></a>case3：</h4><p>如果你沒有 pug 以及 stylus 的渲染器会报错</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extends includes/layout.pug block content include ./includes/mixins/post-ui</span><br><span class="line">.pug <span class="comment">#recent-posts.recent-posts +postUI include includes/pagination.pug</span></span><br></pre></td></tr></table></figure><p>解决方案</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h4 id="case4："><a href="#case4：" class="headerlink" title="case4："></a>case4：</h4><p>hexo本地测试运行重启后页面空白，且提示 : </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN No layout: index.html</span><br></pre></td></tr></table></figure><p>可以参考 case1 &amp; case2 ，即 hexo generate 没有成功</p><h4 id="case5："><a href="#case5：" class="headerlink" title="case5："></a>case5：</h4><p>尝试 hexo deploy 发布的时候失败，显示如下，没有反应</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INFO  Validating config</span><br><span class="line">INFO</span><br><span class="line">  ===================================================================</span><br><span class="line"></span><br><span class="line">      <span class="comment">#####  #    # ##### ##### ###### #####  ###### #      #   #</span></span><br><span class="line">      <span class="comment">#    # #    #   #     #   #      #    # #      #       # #</span></span><br><span class="line">      <span class="comment">#####  #    #   #     #   #####  #    # #####  #        #</span></span><br><span class="line">      <span class="comment">#    # #    #   #     #   #      #####  #      #        #</span></span><br><span class="line">      <span class="comment">#    # #    #   #     #   #      #   #  #      #        #</span></span><br><span class="line">      <span class="comment">#####   ####    #     #   ###### #    # #      ######   #</span></span><br><span class="line"></span><br><span class="line">                            4.1.0</span><br><span class="line">  ===================================================================</span><br></pre></td></tr></table></figure><p>解决方案：deploy 参数需要配置到 _config.yml 文件中。<br><strong>注意：冒号后面需要一个空格</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repo:</span> <span class="string">git@github.com:yourname/yourname.github.io.git</span></span><br><span class="line"><span class="comment"># 推荐使用Git链接，使用http模式还会存在需要填写 用户名和邮箱的情况</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>更多问题请参考 <a href="https://butterfly.js.org/posts/98d20436/">butterfly</a> 官方文档中的解答</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo建站（一）hexo</title>
      <link href="/blog/build-blog/hexo101-1/"/>
      <url>/blog/build-blog/hexo101-1/</url>
      
        <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>终于俺也有自己的 blog 了，下面就整个 hexo 建站和主题 butterfly 的配置分几个部分给大家做个小小的总结</p><p>欢迎来到建站记录的第一部分：hexo 的安装</p><h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><p>官网地址：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p><h4 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h4><p>1.node<br>    首先去 <a href="http://nodejs.cn/download/">node.js</a> 的官网下载最新的稳定版本，我这里选择的是 mac 版本的<br>2.npm<br>    包管理工具</p><h4 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo</span><br></pre></td></tr></table></figure><p>记得这里需要使用管理员权限安装</p><p>初始化 hexo 至某个文件夹</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>这个文件夹就是自己将来管理文章的地方</p><p>工程配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>进入刚才初始化的 blog 文件夹</p><p>浏览器调试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generage</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>也可以如下简写</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>必备插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save <span class="comment"># hexo 渲染必备</span></span><br><span class="line">npm install hexo-server --save <span class="comment"># hexo 本地启动</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install --save hexo-wordcount <span class="comment"># wordcount 插件</span></span><br><span class="line">npm install hexo-butterfly-artitalk --save <span class="comment"># artitalk 插件</span></span><br><span class="line">npm install hexo-generator-feed --save <span class="comment"># RSS 插件</span></span><br><span class="line">npm install hexo-auto-category --save <span class="comment"># 自动根据目录生成categories</span></span><br></pre></td></tr></table></figure><p>自动生成 categories 详情和配置方法具体可以参考 <a href="https://github.com/xu-song/hexo-auto-category">auto-category</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/uncategorized/hello-world/"/>
      <url>/uncategorized/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
