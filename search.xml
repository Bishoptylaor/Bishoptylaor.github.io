<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络</title>
      <link href="/uncategorized/network/"/>
      <url>/uncategorized/network/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/uncategorized/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/uncategorized/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p><strong>并发和并行</strong><br>并发是指<strong>一个处理器</strong>同时处理多个任务。<br>并行是指<strong>多个处理器</strong>或者是多核的处理器同时处理多个不同的任务。<br>并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。</p><p>**并行(parallel)**：指在同一时刻，有多条指令在多个处理器上同时执行。就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。所以无论从微观还是从宏观来看，二者都是一起执行的。</p><p>**并发(concurrency)**：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。这就好像两个人用同一把铁锨，轮流挖坑，一小时后，两个人各挖一个小一点的坑，要想挖两个大一点得坑，一定会用两个小时。</p><p>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。</p><p>操作系统的功能</p><ul><li>进程管理</li><li>内存管理：提高内存利用率和访问速度，从而提高计算机的运行效率</li><li>文件管理</li><li>IO设备管理：设备无关性，将设备抽象成逻辑设备</li></ul><p>分成外核与内核模式的原因：</p><ul><li>保证操作系统受其他系统异常故障的影响；内核模式只能运行操作系统的程序，用户程序运行在外核中；</li><li>确保可能引起系统崩溃的指令（特权指令）只能在内核模式下运行；</li><li>为了防止非法IO，将所有IO指令定义为特权指令</li><li>设置中断，一定时间后将控制权返回给操作系统</li></ul><h6 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a><strong>进程和线程的区别</strong></h6><p>进程，是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位</p><p>在执行一些细小任务时，本身无需分配单独资源时(多个任务共享同一组资源即可，比如所有子进程共享父进程的资源)，进程的实现机制依然会繁琐的将资源分割，这样造成浪费，而且还消耗时间。后来就有了专门的多任务技术被创造出来——线程。</p><p><strong>共同点</strong>：在多任务程序中，子进程(子线程)的调度一般与父进程(父线程)平等竞争。在早期的Linux内核中，线程的实现和管理方式就是<strong>完全按照进程方式实现的</strong>。在2.6版内核以后才有了单独的线程实现。</p><p><strong>实现方法的差异</strong>：进程的个体间是完全独立的，而线程间是彼此依存的。多进程环境中，任何一个进程的终止，不会影响到其他进程。而多线程环境中，父线程终止，全部子线程被迫终止(没有了资源)。而任何一个子线程终止一般不会影响其他线程，除非<strong>子线程执行了exit()系统调用</strong>。任何一个子线程执行exit()，全部线程同时灭亡。</p><ul><li>从系统实现角度讲，进程的实现是调用fork系统调用：pid_t fork(void)；线程的实现是调用clone系统调用</li><li>fork()是将父进程的<strong>全部资源复制给了子进程</strong>。而线程的<strong>clone只是复制了一小部分必要的资源</strong>。后来操作系统还进一步优化fork实现——<strong>写时复制技术</strong>。在子进程需要复制资源(比如子进程执行写入动作更改父进程内存空间)时才复制，否则创建子进程时先不复制。</li><li>个体间辈分关系的迥异；进程的备份关系森严，在父进程没有结束前，所有的子进程都尊从父子关系；多线程间的关系没有那么严格，不管是父线程还是子线程创建了新的线程，都是共享父线程的资源，所以，都可以说是父线程的子线程，也就是只存在一个父线程，其余线程都是父线程的子线程。</li></ul><p><strong>内核态线程、轻量级进程、用户态线程</strong></p><p>它的创建和撤消是由内核的内部需求来决定的，一个内核线程不需要</p><p><strong>内核态线程</strong>：和一个用户进程联系起来。它共享内核的正文段和全局数据，具有自己的内核堆栈。内核线程的调度由于不需要经过态的转换并进行地址空间的重新映射，因此在内核线程间做上下文切换比在进程间做上下文切换快得多。</p><p><strong>轻量级进程</strong>：轻量级进程是核心支持的用户线程，它在一个单独的进程中提供多线程控制。这些轻量级进程被单独的调度，可以在多个处理器上运行，<strong>每一个轻量级进程都被绑定在一个内核线程上</strong>，而且在它的<strong>生命周期</strong>这种绑定都是有效的。轻量级进程被独立调度并且共享地址空间和进程中的其它资源，但是每个LWP都应该有自己的程序计数器、寄存器集合、核心栈和用户栈。</p><p><strong>用户线程</strong>：用户线程是通过线程库实现的。它们可以在没有内核参与下创建、释放和管理。内核对它们一无所知，而只是调度用户线程下的进程或者轻量级进程，这些进程再通过线程库函数来调度它们的线程。当一个进程被抢占时，它的所有用户线程都被抢占，当一个用户线程被阻塞时，它会阻塞下面的轻量级进程，如果进程只有一个轻量级进程，则它的所有用户线程都会被阻塞。</p><p> <strong>注意</strong>：Linux中，每个线程都有一个task_struct，所以线程和进程可以使用同一调度器调度。如果一个task独占所有的资源，则是一个HWP，如果一个task和其它task共享部分资源，则是LWP。<strong>clone</strong>系统调用就是一个<strong>创建轻量级进程</strong>的系统调用，clone的用法和pthread_create有些相似，两者的最根本的差别在于clone是创建一个LWP，对核心是可见的，由核心调度，<strong>而pthread_create通常只是创建一个用户线程</strong>，对核心是不可见的，由线程库调度。</p><p><strong>PCB进程控制模块</strong></p><ul><li>记录进程信息：进程标识信息、处理机状态、进程调度信息、资源分配信息</li><li>操作系统是根据进程控制块PCB来对并发执行的进程进行控制和管理的。</li><li>PCB是进程存在的唯一标志</li><li>寄存器、堆栈指针、程序计数器、进程状态、优先级、调度的参数、父进程、cpu占用时间</li></ul><p><strong>进程和程序的区别</strong></p><p>Program 指令的集合、是静态的概念；是持久的</p><p>Process 描述的是执行，动态的概念、包含程序、数据以及PCB；是暂时的</p><h6 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a><strong>进程之间的通信</strong></h6><ul><li><p>共享内存</p><ul><li>最快的速度进行方便的通信；</li></ul></li><li><p>信息传递</p><ul><li>交换较少的数据；小号时间多</li></ul></li><li><p>间接通信</p><ul><li>每当一个信箱有一个唯一的id</li><li>仅当共享一个信箱时，才能通信</li></ul></li><li><p>共享存储</p><ul><li>两个进程对共享空间的存储是互斥的<ul><li>基于数据结构的：共享速度慢、限制多、是一种低级通信方法</li><li>基于存储区的共享，数据的形式、存放位置都是由进程控制的，是一种高级通信方式</li></ul></li></ul></li><li><p>管道通信</p><ul><li>某个时间只能单行通信，在内存中开辟一个固定大小的缓冲区，但是也是互斥的</li><li>需要将缓冲区写满，缓冲区读满的时候才可以</li><li>数据不可以重复读，所以读进程只能有一个</li></ul></li><li><p>消息传递</p><ul><li>直接通信：将消息挂到对应线程的缓冲队列上，每个进程都会有自己信息缓冲队列，需要设置一些头</li><li>间接通信方式：将信息挂载到中间实体，也被称为“信箱”</li></ul></li></ul><p><strong>线程</strong></p><p>引入的原因</p><ul><li>​    进程操作系统开销大；将进程的两个任务分开：<strong>分配资源</strong>以及<strong>调度</strong>；对于作为调度和分派的基本单位，不同时作为拥有资源的单位，以做到“轻装上阵”； 对于拥有资源的基本单位，又不对之进行频繁的切换。</li><li>因此线程为CPU调度的最小单位，进程为资源分配的最小单位</li></ul><p>线程<strong>不拥有系统资源</strong>，只有其运行所必需的一些数据结构：TCB, a program counter, a register set, and a stack. 它与该进程内其它线程<strong>共享</strong>该进程所拥有的<strong>全部资源</strong>。</p><p><strong>线程和进程的区别</strong></p><ol><li>进程是<strong>资源分配</strong>的基本单位，所有与该进程有关的资源分配情况，进程也是分配主存的基本单位，它拥有一个完整的虚拟地址空间。而线程与资源分配无关，它属于某一个进程，并与该进程内的其它线程一起共享进程的资源。 </li><li>不同的进程拥有不同的虚拟地址空间，而同一进程中的多个线程共享同一地址空间。</li><li>进程调度的切换将涉及到有关资源指针的保存及进程地址空间的转换等问题。而线程的切换将<strong>不涉及资源指针</strong>的保存和地址空间的变化。所以，线程切换的开销要比进程切换的开销小得多。</li><li>进程的调度与切换都是由操作系统内核完成，而线程则既可由操作系统内核完成，也可由用户程序进行。</li><li>进程可以动态创建进程。被进程创建的线程也可以创建其它线程。</li><li>进程有创建、执行、消亡的生命周期。线程也有类似的生命周期</li></ol><p><strong>线程模型</strong></p><ul><li>用户线程，一对多<ul><li>线程在用户态中运行，运行与调度在用户空间中运行，内核无法感知，出问题无法切换，多个线程不能并发执行在多个处理器上（内核中只看到一个进程）</li></ul></li><li>一对一模型<ul><li>可以并行在多个处理器上</li><li>内核开销大</li></ul></li><li>多个多模型</li></ul><p><strong>进程同步</strong>：对多个相关进程在执行次序上的协调，用于保证这种关系的相应机制称为进程同步。</p><p>进程间通信问题</p><ul><li>竞争：竞争共享资源，导致运行的结果和进程执行的顺序相关； 解决方法：互斥，某种方法来确保如果一个进程正在使用一个共享的变量或文件，将被其他进程占用不能做同样的事情</li></ul><p>四种必要情况去保证互斥</p><ol><li>不能有两个进程同时在临界区中</li><li>不能假设CPU的速度以及数量</li><li>任何运行在关键区域之外的进程都不能阻止另一个进程</li><li>没有进程必须永远等待才能进入关键区域</li></ol><p><strong>忙等待的互斥</strong></p><ol><li>屏蔽中断<ol><li>每个进程刚进去临界区便屏蔽所有终端</li><li>如果屏蔽中断后忘记打开中断会导致系统的崩溃</li><li>如果系统是多处理器，屏蔽中断只会对单个cpu有效</li></ol></li><li>锁变量<ol><li>可能会有多个进程同时进入到临界区中</li></ol></li><li>严格轮换法<ol><li>不断测试变量直到某一个值的出现为止，称为忙等待；</li><li>在认为等待时间<strong>非常短</strong>的情况下，用于忙等待的锁，称为<strong>自旋锁</strong></li></ol></li></ol><p><strong>睡眠与唤醒</strong>:生产者和消费者问题</p><p><strong>信号量</strong>：检测信号量的数值、修改变量数值都是不可分割的<strong>原子操作</strong>。在操作完成或者阻塞前，其他进程都是无法访问该信号量的。</p><p><strong>管程的引入</strong></p><p>信号量的缺点：用信号量可实现进程间的同步，但由于信号量的控制分布在整个序中，其正确性分析很困难</p><p>引入管程：把信号量及其操作原语封装在一个对象内部；管程是管理进程间同步的机制，它保证进程互斥地访问共享变量，并方便地阻塞和唤醒进程。</p><p>经典的进程通信问题</p><ul><li>生产者消费者；等待唤醒机制</li><li>哲学家就餐问题；通过增加信号量，保证有一位哲学家可以吃到</li><li>读写问题；对资源加锁；对读者之间用锁保证互斥</li></ul><p>CPU调度问题</p><p>首先是处理机调度算法的共同目标（就与OS的共同目标一样）：</p><ul><li>资源利用率高：系统中处理机和其他资源都应尽可能的保持忙碌状态，其中最重要的资源是<strong>处理机</strong>；</li><li>公平性：诸进程都获得合理的CPU时间，不会发生进程<strong>饥饿现象</strong>；</li><li>平衡性：调度算法应当尽可能的保证系统资源使用的平衡性；</li><li>策略强制执行：对于所制定的策略，只要需要，就必须执行，即使会造成某些工作的延迟也要执行。</li></ul><p> <strong>作业(Job)<strong>：作业是一个比程序更为广泛的概念，它不仅包含了通常的</strong>程序和数据</strong>，而且还应配有一份<strong>作业说明书</strong>，系统根据该说明书来对程序的运行进行控制。</p><p>作业从进入系统到运行，通常需要经历<strong>收容</strong>、<strong>运行</strong>、<strong>完成</strong>三个阶段，其对应的作业状态分别为：<strong>后备状态</strong>（后备队列中）、<strong>运行状态</strong>（创建进程，进程的生命周期）、<strong>完成状态</strong>（作业运行结束或提前中断）。</p><p><strong>进程调度方式</strong>：分为非抢占式和抢占式两种，主要的划分方式就是进程在正常执行的过程中（发生阻塞情况例外），处理机是否可以被抢占。</p><p><strong>非抢占式</strong>：分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生某事件而阻塞时，才把处理机分配给另一个进程；<br><strong>抢占式</strong>：当一个进程正在运行时，系统可以基于某种原则（优先权原则、短进程优先原则、时间片原则），剥夺已分配给它的处理机，将之分配给其它进程。</p><p>调度发生的情况</p><ul><li>在创建一个进程后，需要决定是运行父进程还是子进程</li><li>在一个进程退出时必须做调度决策</li><li>当一个进程阻塞在IO和信号量时，或者由于其他原因，必须选择另一个进程运行</li><li>在一个IO中断发生时，必须做出决策调度</li></ul><p>批处理中的调度</p><ul><li>先来先服务</li><li>最短作业优先</li><li>最短剩余作业优先（每当新的进程时间比当前的剩余时间段，则挂起当前的）；饥饿问题</li></ul><p>交互系统中的调度</p><ul><li>轮转调度：时间片划分；时间短效率低，时间长交互效果不好</li><li>优先级调度：在每个时钟都会降低当前进程的优先级；优先级可以<strong>动态（随时间递减）或者静态</strong>赋予，<ul><li>静态非抢占式</li><li>抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。就是在运行进程的过程中，放弃当前进行，去进行优先级高的进程。</li></ul></li><li>多级队列<ul><li><img src="C:\Users\huami\AppData\Roaming\Typora\typora-user-images\image-20210628202032099.png" alt="image-20210628202032099"></li></ul></li><li>保证调度：系统跟踪各个进程自创以来使用过多少CPU的时间</li><li>公平分享调度算法：对于上述的保证调度算法，是对诸进程而言体现的一定程度的公平性。但是对于<strong>用户</strong>来讲就不一定公平了。</li><li>彩票调度：权重高的进程拥有更多的票，然后随机</li></ul><h5 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h5><p>无内存抽象：编程时直接写死地址；这样不能同时在系统上运行两份一样程序</p><p><strong>地址空间</strong>：保护和重定位；是一个进程可用于寻址内存的一套地址集合。每个进程都有自己的地址空间，并且这个地址空间是独立于其他程度的地址空间；动态重定位：用基址寄存器和界限寄存器；</p><p><strong>交换技术</strong>：处理<strong>内存超载</strong>问题</p><ul><li>直接交换：把程序完整调入内存中，使用该进程一段时间后，把它存到磁盘中</li><li>虚拟内存：是程序只有一部分被调入内存的情况下运行</li><li>会导致空洞；用内存紧缩技术会耗时</li><li>所需空间动态增长问题</li></ul><p><strong>空闲内存管理</strong></p><ul><li>使用位图来管理；单元越小图越大，检索连续的指定长度的空闲空间是耗时的</li><li>使用链表的储存管理：进程结束或者换出链表时块；<ul><li>下次适配算法</li><li>最佳适配算法</li></ul></li></ul><p><strong>虚拟内存</strong></p><p><strong>虚拟存储器就是作为主存储器空间扩充的一种方式</strong>，存储器管理把进程的全部信息放到辅存中，执行时先将其中的一部分装入主存，以后根据执行行为<strong>随用随调入</strong>，并且当主存中没有足够的内存空间时，存储器管理依据某些算法（页面置换算法或者是分区淘汰算法）淘汰内存中的页或者是分区。</p><p>页面:虚拟地址分为多个单元。</p><p>页帧:物理内存中相应的单元。</p><p><strong>内存管理单元</strong>负责虚拟地址到物理地址的转换</p><p>逻辑地址：页号+偏移量；前面几位是页号后面几位是偏移量；用页号去页表（map）去查询得到物理地址+上偏移量就得到物理地址；</p><p>页表会保存在内存中，寄存器存页表指针</p><p>TLB寄存器：相当于给页表加个缓存，为了解决虚拟地址到物理地址的转换速度</p><p>页式管理：页号+偏移量</p><p>段式管理：段号+段长度+偏移量</p><p>段页式管理：段号+页表长度+页的偏移量（段表【页的长度+页表存放的位置】 需要三次访存：第一次是段表、第二次页表、第三次访目标单元）</p><p>​    可以引用块表，将【段号和页号】作为关键字，这样只要一次访存，依旧是直接访问目标数据</p><p><strong>分页的原理</strong></p><p>将内存划分成多个小的分区，让一个进程的代码分布在<strong>非连续的内存地址中</strong>，一个进程按页的大小划分后，不同片段可以分开存储，但是这样就不能使用了之前连续分配的动态重定位的方式，需要额外实现定位的方法；按页的大小划分的一个较大的好处就是减少了进程的内部碎片的问题</p><p><strong>局部性原理</strong></p><ol><li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li><li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li></ol><p>针对大内存的页表</p><ul><li>多级页表<ul><li>避免全部页表保存一直保存在内存中</li></ul></li><li>倒排页表<ul><li>将虚拟地址作hash，然后根据hash值去对应槽找节点，如果有对应的（虚拟页面，页框）则找到</li></ul></li></ul><p>页面置换算法</p><ul><li>最近未使用页面置换算法NRU<ul><li>定时将页面设置为没有被访问<ul><li>没有被访问，没有被修改</li><li>没有被访问，已经被修改</li><li>已经被访问，没有修改</li><li>已经被访问，已经修改</li></ul></li></ul></li><li>先进先出</li><li>第二次机会页面置换算法<ul><li>修改FIFO，如果已经被访问，则设置为没被访问，重新进队</li></ul></li><li>时钟置换算法<ul><li>循环队列，如果R（访问）为0，直接淘汰，如果为1设为0，继续向前走</li></ul></li><li>最近最少使用LRU<ul><li>可以用老化算法来模拟；</li><li>可以理解为每次都访问的放到队头</li></ul></li><li>最近最不常用LFU<ul><li>计算访问次数</li></ul></li></ul><p>页面小</p><ul><li>优点：更少的页框，更少没被使用的</li><li>缺点：页表大</li></ul><p><strong>分段</strong></p><p>采用分页内存管理有一个不可避免的问题：用户视角的内存和实际物理内存的分离。用户通常更愿意将内存看做是一组<strong>不同长度的段的集合，这些段之间并没有一定的顺序</strong>，因此<strong>用户通过两个量来指定地址：段号+偏移</strong></p><p><strong>分段和分页的差别</strong></p><ol><li>页式和段式管理策略都不会产生外部碎片，但都有可能产生内部碎片</li><li>页的大小是统一的，而段的大小是可变的</li><li>采用分页会导致用户视角的内存和实际内存的分离，即使用户视角的内存和实际物理内存不一样，而分段正好可以支持用户视角，使用户视角的内存和实际物理内存分布保持一致</li><li>分页对程序员来说是透明的，用户指定一个地址，该地址通过硬件分为页码和偏移，这些程序员是看不见的；而分段对程序员来说通常是可见的，用户通过两个量：段号和偏移来指定地址，这两个量作为组织程序和数据的一种方便手段提供给程序员，程序员可以通过这两个量把程序和数据指定到不同的段（程序员必须清楚段的最大长度）</li></ol><p><strong>文件管理</strong></p><p>提供文件和目录的抽象，隐藏硬件设施的复杂信息；提供文件保护</p><p>同样也有文件控制块的概念</p><p>文件名-255字符</p><p>目录：包含所有文件信息的节点集合，是根据文件名检索文件的桥梁</p><p>通过FCB再次索引，索引中只有文件名，只有真正需要采取读取FCB,再根据FCB来找出文件的存放位置</p><p><strong>文件跟踪</strong>：实现文件存储就是跟踪哪些磁盘块与哪些文件一起使用。</p><ul><li>连续分配<ul><li>容易实现；读取效率高；文件删除后会留下空洞；文件最大空间在创建时就要确定</li></ul></li><li>链表分配<ul><li>没有外部碎片；文件检索简单；可以做到增长；随机访问速率低，空间不一定会填满一个空</li></ul></li><li>索引分配<ul><li>只有在打开相应文件时，才需要将i-node加载到内存中。</li><li>支持直接访问；没有外部碎片；索引也会占用空间开销</li></ul></li></ul><p><strong>文件名字的管理</strong></p><ul><li>固定长度：浪费空间</li><li>线性：删除文件时会留下空洞</li><li>堆：需要额外的开销</li></ul><p><strong>文件共享</strong></p><ul><li>硬链接：都保存的i-node节点<ul><li>删除源文件时，文件并没有被删除，会导致文件一直存在（按理删了源全部都要删掉）</li></ul></li><li>软链接：只有一个节点是保存了i-node，其他是保存”路径“<ul><li>需要额外的开销</li></ul></li></ul><h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p>管理和控制IO操作和IO设备；主要管理IO设备和对应的控制器</p><p><strong>设备无关性</strong>：应用程序独立于具体使用的物理设备；在系统中引入<strong>逻辑设备</strong>和<strong>物理设备</strong>；在应用程序中使用逻辑设备名来请求使用某类设备，而系统在实际执行中使用物理设备名；</p><p>设备驱动程序层：为内核IO子系统隐藏设别控制器的不同细节</p><ul><li>将串行位流转换为字节块</li><li>执行必要的错误纠正</li><li>方便主存使用</li></ul><p><strong>内存映射</strong>：CPU如何与设备的控制器和数据缓冲区进行通信</p><ul><li>每个控制寄存器都被分配一个IO端口，所有的IO端口形成IO端口空间<ul><li>直接访问</li></ul></li><li>将所有控制器映射到内存空间中，每个寄存器都被分配唯一的内存空间<ul><li>不需要特殊的保护机制来保护控制寄存器不被用户直接访问</li><li>每一条引用内存的指令也可以引用控制寄存器</li><li>但是需要缓存</li><li>因为只有一个地址空间，所有主内存模块和所有I&#x2F;O设备控制器必须检查所有内存引用才能看到该回应哪一个呢</li></ul></li></ul><p><img src="C:\Users\huami\AppData\Roaming\Typora\typora-user-images\image-20210729213204890.png" alt="image-20210729213204890"></p><p><strong>DMA直接存储器存取</strong></p><p>在ＤＭＡ出现之前，CPU与外设之间的数据传送方式有程序传送方式、中断传送方式。CPU是通过系统总线与其他部件连接并进行数据传输。</p><p>DMA的出现就是为了解决批量数据的输入&#x2F;输出问题。DMA是指外部设备不通过CPU而直接与系统内存交换数据的接口技术。这样数据的传送速度就取决于存储器和外设的工作速度。</p><p><strong>死锁</strong>：一个进程集合中每个程序都在等待只能由该进程集合中其他进程才能引发的事件，那么说明该进程集合是死锁</p><p><strong>死锁的四个必要条件</strong></p><ul><li>互斥条件</li><li>占有和等待</li><li>不可抢占</li><li>环路等待</li></ul><p>处理死锁的四种策略</p><ul><li><p>鸵鸟算法；发生的概率是很低的</p></li><li><p>检测死锁并且恢复</p><ul><li>通过深搜+回溯来找环，如果所有节点都是可以则是安全的</li><li>每种类型多个资源的死锁检测（E+R+A矩阵）</li><li>恢复地方法<ul><li>抢占</li><li>利用回滚</li><li>杀死进程来恢复</li></ul></li></ul></li><li><p>死锁避免</p><ul><li>资源轨迹图：不安全不代表一定会死锁，只代表有可能死锁</li><li>银行家算法；分配然后回收看是否可以全部满足</li></ul></li><li><p>死锁预防：从四个条件去破坏</p><ul><li>破坏互斥条件：避免在非绝对必要时分配资源；申请资源的进程越少越好</li><li>破坏占有和等待条件：规定开始执行前必须获得所有资源；当它请求时先释放自己手上的资源</li><li>破坏不可抢占条件：如果遭到拒绝就释放自己的资源</li><li>破坏环形等待：给资源编号，申请后面的必须先获得前面的资源</li></ul></li></ul><p><strong>两阶段锁</strong></p><p>第一阶段：进程试图对所有所需资源的记录进行加锁。如果成功执行第二阶段，完成后释放锁，第一阶段并没有做实际工作</p><p>如果第一阶段所需的锁已经被加锁，则释放全部锁，从头再来</p><p><strong>通信死锁</strong></p><p>通过超时中断死锁</p><p><strong>活锁</strong></p><p>互相谦让，但是没有进展</p><p><strong>饥饿</strong></p><p>无限制推后，虽然没有被阻塞</p><h1 id="操作系统-1"><a href="#操作系统-1" class="headerlink" title="操作系统"></a>操作系统</h1><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>进程的创建</p><ul><li>系统启动</li><li>执行正在进行的进程调用进程的创建</li><li>用户申请创建</li><li>批处理的初始化</li></ul><p>进程的结束</p><ul><li>完成任务</li><li>发生了错误（自愿）</li><li>发生严重错误（非自愿）</li><li>被其他进程杀死</li></ul><p>三个状态</p><ul><li>运行</li><li>就绪</li><li>阻塞</li></ul><p>运行到就绪：调用程序选择另一个进程</p><p><strong>进程的内部结构</strong></p><p>代码块、数据、堆、栈、PCB进程控制块（用户内用、系统内用、寄存器信息）</p><p><strong>切换的步骤</strong></p><ul><li>保存PCB</li><li>加载PCB</li><li>刷新内存缓存</li><li>改变地址映射</li></ul><h6 id="父进程和子进程"><a href="#父进程和子进程" class="headerlink" title="父进程和子进程"></a>父进程和子进程</h6><p>新创建的子进程<strong>几乎</strong>和父进程完全一样，子进程会获得父进程用户级虚拟地址空间（但是独立）一份副本，包括<strong>代码和数据段、堆、共享库以及与用户栈</strong>，子进程获得父进程任何打开<strong>文件描述符相同的副本</strong>，也就是子进程可以读取父进程中打开的任何文件。最大区别是拥有不同的PID；只是在创建的时候是一样的，后续的改变是相互独立的。</p><p><strong>僵死进程</strong></p><p>发生在子进程回收过程中，当进程由于某种原因终止时，内核不会立刻从系统中删除，而是保持已终止状态，直到父进程回收。所以一个终止了但是还没被回收的进程时<strong>僵死进程</strong></p><p>如果父进程终止了，但是还没有回收子进程，会有一个init进程成为其养父进程，来回收子进程</p><h6 id="fork和execve"><a href="#fork和execve" class="headerlink" title="fork和execve"></a>fork和execve</h6><p>fork会创建一个子进程，并且返回两次（用来区别父进程和子进程）；execve是在原来的进程的<strong>上下文中加载运行另一个新程序</strong>，如果成功不会返回</p><ul><li>系统中的每个程序都是运行在某个进程的<strong>context</strong>中的。context是由程序正确运行所需的状态组成的，这个状态包括存放在存储器中的<strong>程序的代码和数据</strong>，它的<strong>栈</strong>、<strong>通用目的寄存器的内容</strong>、<strong>程序计数器</strong>（PC）、<strong>环境变量</strong>以及打开的<strong>文件描述符的集合</strong>。</li><li>每个<strong>线程</strong>都有它自己的线程context，包括一个唯一的整数线程ID、栈、栈指针、程序计数器（PC）、通用目的寄存器和条件码。</li><li>每个线程和运行在同一进程内的其他线程一起共享进程context的<strong>剩余部分</strong>。这包括整个用户虚拟地址空间，它是由<strong>只读文本（代码）</strong>、<strong>读&#x2F;写数据</strong>、<strong>堆以及所有的共享库代码和数据区域组成</strong>。线程也同样共享打开文件的集合。</li></ul><h6 id="线程的过程"><a href="#线程的过程" class="headerlink" title="线程的过程"></a>线程的过程</h6><p><strong>创建线程</strong></p><ul><li>pthread_create:创建一个新的线程，可以在参数中绑定返回的线程tid，传入函数用于让新创线程执行这个函数，设置可以传入参数改变线程的默认值</li></ul><p><strong>线程终止</strong></p><ul><li>当顶层的线程例程返回时，线程也就隐式终止</li><li>通过调用pthread_exit函数，线程会显示结束。主线程调用pthread_exit会让其他所有对等线程终止</li><li>其他对象线程调用exit，该函数会终止进程导致该进程相关的线程都终止</li><li>零杠一个对等线程通过以线程id传入<strong>pthread_cancel</strong>来终止其他线程</li></ul><p><strong>回收已终止线程的资源</strong></p><p>pthread_join函数可以等待一个函数终止</p><p><strong>分离线程</strong></p><p>线程是可结合的也可以是分离的，一个结合的线程能够被其他线程收回和杀死；分离的线程是不能被其他线程杀死或者回收，<strong>他的资源在它终止的时候由系统自动释放</strong>。</p><p>使用pthread_detach</p><h6 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h6><p>一个小消息，通知进程系统发生了某一种类型的事件。通知用户进程发生了异常；如通过kill9一个进程向另一个进程来强制终止它；ctrl+c内核向前台进程组发送信号，一般是挂起前台进程；</p><p>发送但是还没接受的信号称为待处理信号（pending singal）；任何时候，一个类型最多只有一个待处理信号。如果同一个类型的信号收到多个，就会被丢弃。</p><p><strong>线程</strong></p><ul><li>如何能使多个程序更好地并发执行，同时又尽量减少系统的开销，成为设计操作系统的重要目标。</li><li>将进程的两个基本属性分开，由操作系统分开处理：对于作为调度和分派的基本单位，不同时作为拥有资源的单位，可以做到“轻装上阵”； </li><li>对于拥有资源的基本单位，又不对之进行频繁的切换。‘’</li></ul><p>修改为进程作为资源分配的单位，线程作为调度的单位</p><p>线程不拥有系统的资源，但是拥有其运行时必须的数据结构（TCB，程序计数器，寄存器，栈）</p><p>当然也有自己独有的部分：程序计数器、寄存器、栈、状态</p><p><strong>线程的不同实现方案</strong></p><p>纯用户态：线程表放在用户态中，可以自己定制调度算法，阻塞会一起阻塞（某个线程去IO）；线程占有CPU，除非资源放弃，其他线程不能保证</p><p>内核态中实现：线程表放在内核中，用池化技术循环利用</p><p><strong>轻量级进程</strong></p><p>与普通进程相比，<em>LWP</em>与其它进程<strong>共享所有（或大部分）逻辑地址空间和系统资源</strong>，一个进程可以创建多个<em>LWP</em>，这样它们共享大部分资源；<em>LWP</em>有它自己的*<a href="http://zh.wikipedia.org/w/index.php?title=%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86%E7%AC%A6&action=edit&redlink=1"><strong>进程标识符</strong></a><em>，并和其他进程有着</em><a href="http://zh.wikipedia.org/w/index.php?title=%E7%88%B6%E8%BF%9B%E7%A8%8B&action=edit&redlink=1"><strong>父子关系</strong></a><em>；</em>LWP*与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息；</p><p><strong>用户线程与内核线程</strong></p><p>1）可移植性：因为ULT完全在用户态实现线程，因此也就和具体的内核没有什么关系，可移植性方面ULT略胜一筹；</p><p>2）可扩展性：ULT是由用户控制的，因此扩展也就容易；相反，KLT扩展就很不容易，基本上只能受制于具体的操作系统内核；</p><p>3）性能：由于ULT的线程是在用户态，对应的内核部分还是一个进程，因此ULT就没有办法利用多处理器的优势，而KLT就可以通过调度将线程分布在多个处理上运行，这样KLT的性能高得多；另外，一个ULT的线程阻塞，所有的线程都阻塞，而KLT一个线程阻塞不会影响其它线程。</p><p>4）编程复杂度：ULT的所有管理工作都要由用户来完成，而KLT仅仅需要调用API接口，因此ULT要比KLT复杂的多。</p><p><strong>Linux的进程</strong></p><p><em>Linux</em>采用的“一对一”的线程模型，即一个<em>LWP</em>对应一个线程。这个模型最大的好处是线程调度由内核完成了，而其他线程操作（同步、取消）等都是核外的线程库函数完成的。</p><p>在<em>LinuxThreads</em>中，专门为<strong>每一个进程构造了一个管理线程</strong>，负责处理线程相关的管理工作。</p><p><strong>进程VS线程</strong></p><ul><li>进程是资源分配的基本单位，所有与该进程有关的资源分配情况，进程也是分配主存的基本单位，它拥有一个完整的虚拟地址空间。而线程与资源分配无关，它属于某一个进程，并与该进程内的其它线程一起共享进程的资源。</li><li>不同的进程拥有<strong>不同的虚拟地址空间</strong>，而同一进程中的多个线程<strong>共享同一地址空间</strong>。</li><li>进程调度的切换将涉及到有关<strong>资源指针</strong>的保存及<strong>进程地址空间的转换等</strong>问题。而线程的切换将<strong>不涉及资源指针的保存和地址空间的变化</strong>。所以，线程切换的开销要比进程切换的开销小得多。</li><li>进程的调度与切换都是由操作系统内核完成，而线程则既可由操作系统内核完成，也可由用户程序进行。</li></ul><p><strong>进程间的通信</strong></p><p>关注点：</p><ul><li>进程如何把信息传递给另一个进程（共享同一片空间）</li><li>进程在关键点直接不会出现交叉</li><li>正确的顺序</li></ul><p>进程同步：在多个进程执行次序上的协调；相互合作的一组并发进程在一些<strong>关键点</strong>上可能需要相互等待与互通信息，保证这种关系的就叫进程同步</p><p><strong>竞争条件</strong>：多个进程对共享资源，导致最后的结果与操作的顺序有关</p><p><strong>互斥</strong>：保证进程在使用共享资源的时候，其他进程不能进行相同的操作</p><h5 id="保证互斥的四个条件"><a href="#保证互斥的四个条件" class="headerlink" title="保证互斥的四个条件"></a><strong>保证互斥的四个条件</strong></h5><ul><li>任何两个进程不能同时处于临济区</li><li>不应对cpu的速度和数量作任何假设</li><li>临界区域外进程不能阻塞其他进程</li><li>不能使进程无限期等待进入临界区</li></ul><h6 id="忙等待的互斥"><a href="#忙等待的互斥" class="headerlink" title="忙等待的互斥"></a><strong>忙等待的互斥</strong></h6><p><strong>信号屏蔽</strong></p><ul><li>信号屏蔽<ul><li>多核中不好用，是针对操作系统的，忘记开启有问题</li></ul></li><li>锁变量<ul><li>获取并将其变成1，但是会有问题，因为进程可能随时切换，还是会卡进去</li></ul></li><li>严格轮换法<ul><li>忙等待，属于自己的就进去，但是违反了条件3，阻塞了别的进程</li></ul></li></ul><p><strong>睡眠与唤醒</strong></p><ul><li>信号量：控制进去临界区域的进层数；如果失败就在该位置睡眠，然后等待信号量增加后，系统随机选取一个唤醒</li></ul><p>信号量可以实现进程间的通信，但是由于信号量的控制分布在整个程序中，正确性难分析</p><ul><li>管程：引入了条件变量，wait和signal，当发现无法继续运行时会在变量上wait，导致进程阻塞；它存在于内存中，进程可以对它进行读写，它提供流控制，保证进程的正确读写，即管道为空时读进程会阻塞，管道为满时写进程会阻塞，以此实现进程之间的通信。</li></ul><h5 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h5><p>要么是陷入内核，要么是涉及外设</p><ol><li>管道( pipe )：<br>管道是一种<strong>半双工</strong>的通信方式，数据<strong>只能单向流动</strong>，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。<strong>以内存文件的形式存在</strong></li><li>匿名管道：克服了亲缘的限制，<strong>以磁盘文件的形式存在</strong>，先进先出，可以任意进程间通信</li><li>信号量(semophore ) ：<br>信号量是一个计数器，可以用来控制<strong>多个进程对共享资源的访问</strong>。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li>消息队列( message queue ) ：<br>消息队列是由消息的链表，存放在<strong>内核中</strong>并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。存在内核中说明其内核重启或者显式删除的时候才被删除</li><li>信号 (sinal ) ：<br>信号是一种比较复杂的通信方式<strong>，用于通知接收进程某个事件已经发生。</strong></li><li>共享内存(shared memory ) ：<br>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。<strong>就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。需要某种同步操作来保证，例如<strong>信号量</strong></li><li>套接字(socket ) ：<br>套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</li></ol><p>理解：<strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，但是多进程竞争同个共享资源会造成<strong>数据的错乱</strong>；</p><h6 id="线程间通信方式"><a href="#线程间通信方式" class="headerlink" title="线程间通信方式"></a>线程间通信方式</h6><ol><li>锁机制：包括互斥锁、条件变量、读写锁：只有<strong>拥有互斥对象的线程才有访问公共资源的权限</strong><ul><li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。</li><li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</li><li>条件变量可以以原子的方式阻塞进程，<strong>直到某个特定条件为真为止</strong>。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li></ul></li><li>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</li><li>信号机制(Signal)：类似进程间的信号处理<br>线程间的通信目的主要是用于线程同步，<strong>所以线程没有像进程通信中的用于数据交换的通信机制</strong>。</li></ol><h4 id="用户态切换到内核态的方式"><a href="#用户态切换到内核态的方式" class="headerlink" title="用户态切换到内核态的方式"></a>用户态切换到内核态的方式</h4><ol><li><p>系统调用</p><p>这是用户态进程<strong>主动</strong>要求切换到内核态的一种方式，<strong>用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作</strong>，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p></li><li><p>异常</p><p>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到<strong>处理此异常</strong>的内核相关程序中，也就转到了内核态，比如<strong>缺页异常</strong>。</p></li><li><p>外围设备的中断</p><p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p></li></ol><h6 id="调度"><a href="#调度" class="headerlink" title="调度"></a><strong>调度</strong></h6><p><strong>发生调度的时间</strong></p><ul><li>新的进程被创建</li><li>进行的进程退出</li><li>进行的进程被阻塞</li><li>IO中断</li><li>时钟中断</li></ul><p>调度算法</p><ul><li>FIFO：队列、链表</li><li>最短作业优先：优先队列</li><li>最短剩余时间优先</li><li>优先级调度（优先级的静态和动态）</li><li>多级队列（不同队列的时间片不同，2幂增）</li><li>保证调度（跟踪已经使用的时间）</li><li>彩票调度（优先级高拥有的票多）</li></ul><h4 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h4><p><strong>地址的抽象</strong></p><p>多个应用程序处于内存中互补影响，要满足<strong>保护和重定位</strong>的问题</p><p><strong>交换技术和虚拟内存</strong></p><p><strong>空间的分配问题</strong>（交换中引起了空洞问题）</p><ul><li>位图<ul><li>但是内存很大时，位图也很大</li></ul></li><li>链表的方式<ul><li>算法<ul><li>首次适配</li><li>最佳适配（要遍历一遍）</li></ul></li></ul></li></ul><p><strong>虚拟空间</strong></p><p>将程序切割成片段，但是前期时由程序员完成，将这个工作交给系统过去完成；</p><p>讲程序中的逻辑地址通过<strong>内存管理单元</strong>MMU进行转换，</p><p>虚拟空间中的页面&#x3D;物理地址中的页框</p><p>虚拟地址&#x3D;虚拟地址页号+偏移量</p><p>页表项</p><p><img src="C:\Users\huami\AppData\Roaming\Typora\typora-user-images\image-20210717232227535.png" alt="image-20210717232227535"></p><p>通过虚拟地址页号去<strong>页表</strong>找对应的页框同时判断其在不在内存中</p><p><strong>TLB</strong></p><p>在页表也很大时时候；以及<strong>映射得不够快</strong></p><p>相当于给页表再做一个<strong>缓存</strong></p><p><strong>多级页表</strong></p><p>从页号去找二级页表号，从二级页表号根据第二段找到框号，再加上偏移量</p><p><strong>倒查页表</strong></p><p>根据物理地址页框数量作为哈希数组长度，然后进行哈希</p><p><strong>页表置换算法</strong></p><ul><li><p>最近未使用算法NRU:</p><ul><li>两位（是否被访问，是否被修改），定期抹除访问标志（变成0）</li></ul></li><li><p>FIFO</p></li><li><p>第二次机会置换算法</p><ul><li>FIFO的优化，如果被访问过就将其痕迹抹掉重新入队</li></ul></li><li><p>时钟置换算法</p><ul><li>相当于给第二次置换算法，用循环链表来实现</li></ul></li><li><p>最近最少使用算法LRU</p><ul><li>老化算法</li><li>双向链表和HashMap实现</li></ul></li><li><p>LFU最不经常使用</p><ul><li>计算频率</li></ul></li></ul><h6 id="分段技术"><a href="#分段技术" class="headerlink" title="分段技术"></a><strong>分段技术</strong></h6><p>按照类型把进程的地址空间分为多个，每一种功能对应一个地址空间，独立增长，这就是分段思想，分段使得我们不需要关心如何管理和分割地址空间。分段与分页的区别在于，分段存在于逻辑地址的概念上，是一种划分逻辑地址的思想，而分页是解决逻辑地址到物理地址的映射过程的。</p><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p><strong>文件命名</strong></p><ul><li>长度为255</li><li>windows大小写不敏感，linux是大小写敏感</li></ul><p><strong>文件结构</strong></p><ul><li>线性+定长</li><li>树状结构</li></ul><p><strong>目录结构</strong></p><ul><li>单层结构<ul><li>难以查找文件</li></ul></li><li>两层结构<ul><li>解决了命名冲突问题</li><li>提高了搜索效率</li><li>可以文件共享和保护</li></ul></li><li>多层次<ul><li>文件和目录</li></ul></li></ul><p><strong>空间分配问题</strong></p><ul><li>顺序存储<ul><li>容易实现、可以直接访问和顺序访问</li><li>外部碎片，文件的<strong>长度必须提前知道</strong></li></ul></li><li>链式存储<ul><li>没有外部碎片、文件变长</li><li><strong>随机访问</strong>性能差，存在结构性开销</li></ul></li><li>i-node<ul><li>所有的i-node统一存储</li><li>每个文件都有自己i-node结点，支持直接访问，不存在外部碎片</li><li>i-node节点的结构性开销</li></ul></li></ul><p><strong>共享文件</strong></p><ul><li>i-node<ul><li>硬链接，每个节点都会指向这个文件</li></ul></li><li>符号链接<ul><li>其他接待保存路径</li></ul></li></ul><h4 id="IO-1"><a href="#IO-1" class="headerlink" title="IO"></a>IO</h4><p>分类</p><ul><li>块设备：把信息存储在固定的大小中，每个块都有自己的地址，每个块都能独立于其他块而读写</li><li>字符设备：不能寻址，也没有任何寻道操作</li></ul><p><strong>轮询</strong></p><p>cpu的干预非常频繁</p><p><img src="C:\Users\huami\AppData\Roaming\Typora\typora-user-images\image-20210729214538130.png" alt="image-20210729214538130"></p><p><strong>中断驱动</strong></p><p>容控制器自己完成任务后向cpu发一个中断信号，处理中断过程就是从控制器中读<strong>一个字的数据</strong>到cpu寄存器中，再写入内存，接着恢复去执行别的，等待下一次中断信号；但是中断次数过多也不好</p><p><img src="C:\Users\huami\AppData\Roaming\Typora\typora-user-images\image-20210729215353822.png" alt="image-20210729215353822"></p><h6 id="IO多路复用技术"><a href="#IO多路复用技术" class="headerlink" title="IO多路复用技术"></a>IO多路复用技术</h6><p>IO多路复用的事件驱动服务器是运行在单一进程上下文中的，因此每个逻辑流都能访问该进程的全部空间，使得流之间共享数据非常容易；</p><p>但是并发粒度的缩小会让代码量上升，而且使得如果一个逻辑流在忙于读文本行，其他是无法进展的</p><p><strong>DMA</strong></p><p><img src="C:\Users\huami\AppData\Roaming\Typora\typora-user-images\image-20210729220610942.png" alt="image-20210729220610942"></p><p>5.<strong>主要缺点和主要优点</strong></p><p>优点:数据传输以“块”为单位，CPU介入频率进- -步降低。数据的传输不再需要先经过CPU再写入内存，数据传输效率进- -步增加。CPU和&#x2F;O设备的并行性得到提升。</p><p>缺点: CPU每发出一- 条I&#x2F;0指令，只能读&#x2F;写一个或多个连续的数据块。</p><p><strong>控制器的任务</strong></p><p>把串行的位流转换成字节块，并且进行有必要的<strong>错误校验</strong></p><p>CPU<strong>如何与设备控制器何数据缓冲区进行通信</strong>？</p><ul><li>每个控制存储器被分配一个IO端口；只能由操作系统能对其访问；使用特殊的指令去读写</li><li>讲IO映射到内存空间中；像访问内存空间一样去访问；不需要特殊的保护机制去组织用户进程执行IO操作</li></ul><h4 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h4><ol><li><p>同步阻塞IO</p><p><img src="https://pic3.zhimg.com/v2-abef476a75afe52193be9577dcbcb88a_r.jpg" alt="preview"></p></li><li><p>同步非阻塞IO</p><p>非阻塞IO是在应用调用recvfrom读取数据时，如果该缓冲区没有数据的话，就会直接返回一个EWOULDBLOCK错误，不会让应用一直等待中。在没有数据的时候会即刻返回错误标识，那也意味着如果应用要读取数据就需要<strong>不断的调用recvfrom请求</strong>，直到读取到它数据要的数据为止。</p></li><li><p>多路复用IO</p><p><img src="https://pic3.zhimg.com/v2-260e80cbec13cbcc677779690f6ab2fa_r.jpg" alt="preview"></p><ul><li><p>为什么会产生多路复用IO？</p><p>因为当有多个网络连接，连接到某个进程的时候，我们想要监听这些socket接口，并当这些接口有数据返回的时候，进行处理。一种解决方案就是，对于每一个socket接口，我们都开辟一个线程来侦听，处理。这样做的局限就是，当连接数变大的时候（成千上万），那么我们就要创建多个线程变量。创建线程变量开销很大，而且，线程切换的开销也会变大。所以我们就寻求一种，<strong>单线程的情况下监听多个socket接口的方式</strong>，所以就会有多路复用IO的诞生。</p><p>本质上还是同步非阻塞IO，但是将阻塞放在了select上</p></li></ul></li><li><p>信号驱动IO,继续改良复用IO,思想是发出请求后等你数据准备好了就通知我</p></li><li><p>异步IO</p><p><img src="https://pic4.zhimg.com/v2-5095ab1ffe868a2577bc15310d740293_r.jpg" alt="preview"></p><p>异步IO需要更强的操作系统支持；当用户线程收到通知时，数据已经被内核读取完毕，<strong>并放在了用户线程指定的缓冲区内</strong>，内核在IO完成后通知用户线程直接使用即可。</p></li></ol><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁的定义：如果一组进程中每个进程都在等待一个事件，而这个事件只有该集合中的另一个进程才能引起，那么该集合就是死锁的。（都占有资源，然后互相等待）</p><p><strong>引起死锁四个条件</strong></p><ul><li>互斥条件：资源要么分配给一个进程，要么可用</li><li>占有资源和等待</li><li>不可抢占</li><li>环路等待</li></ul><p><strong>死锁检测</strong></p><ol><li>建模之后寻找环路</li><li>多资源的死锁检测，矩阵，先给能满足的，然后释放</li></ol><p><strong>死锁恢复</strong></p><ul><li>抢占</li><li>回滚</li><li>杀死进程</li></ul><p><strong>死锁避免</strong></p><ul><li>资源轨迹图</li><li>安全状态和不安全状态</li><li>单个银行家算法</li><li>多个资源的银行家算法</li></ul><p><strong>死锁预防</strong></p><ul><li><p><strong>破坏互斥条件</strong>：有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。</p></li><li><p><strong>破环占有和等待条件</strong>：预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。<strong>会有“饥饿”</strong></p></li><li><p><strong>破环不可抢占资源</strong>：当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。</p></li><li><p>破坏循环等待条件：规定每个进程，必须按编号递增的顺序请求资源</p></li></ul><p>活锁：互相谦让，导致谁都没办法开始</p><p><strong>中断</strong></p><p>中断主要是一个cpu硬件产生的定时脉冲，为了能通知操作系统是时间片到了，将cpu的使用权限从用户态切换到内核态中，内核态去根据中断信号进行不同的处理；</p><p>中断可能来自cpu内部，也可能来自外部；来自内部就是用户申请使用特权指令、时间片到了；外部一般是外设导致，如键盘输入</p><p><strong>系统调用：</strong></p><p>用户态程序通过系统调用的方法来申请操作系统的服务，因为其可能涉及到一些特权指令才能完成</p><p>陷入指令：是唯一一个只能在用户态不能在内核态执行的指令</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库面试常见题</title>
      <link href="/uncategorized/sql/"/>
      <url>/uncategorized/sql/</url>
      
        <content type="html"><![CDATA[<p>△ 66次</p><p>MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？  中等 <a href="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Phyduck/database/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%BD%BF%E7%94%A8B%2BTree.pdf">参考1</a> <a href="https://www.vertabelo.com/blog/all-about-indexes-part-2-mysql-index-structure-and-performance/#:~:text=The%20B%2DTree%20is%20the,to%202d%2B1%20child%20nodes.">参考2</a></p><p>△ 42次</p><p>数据库的事务隔离级别有哪些？各有哪些优缺点？  中等 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html">参考1</a> <a href="https://zhuanlan.zhihu.com/p/117476959">参考2</a></p><p>△ 36次</p><p>简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点  困难 <a href="https://redis.io/topics/persistence">参考1</a> <a href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-persistence.html#aof-%E5%92%8C-rdb-%E7%9A%84%E7%9B%B8%E4%BA%92%E4%BD%9C%E7%94%A8">参考2</a></p><p>△ 36次</p><p>Redis 如何实现分布式锁？  困难 <a href="https://redis.io/topics/distlock">参考1</a> <a href="https://www.redis.com.cn/topics/distlock.html">参考2</a></p><p>△ 34次</p><p>Redis 序列化有哪些方式？  中等</p><p>△ 34次</p><p>简述 Redis 的哨兵机制  中等</p><p>△ 30次</p><p>简述 Redis 中如何防止缓存雪崩和缓存击穿  中等 <a href="https://www.pixelstech.net/article/1586522853-What-is-cache-penetration-cache-breakdown-and-cache-avalanche">参考1</a> <a href="https://zhuanlan.zhihu.com/p/346651831">参考2</a></p><p>△ 30次</p><p>产生死锁的必要条件有哪些？如何解决死锁？  中等 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks.html">参考1</a> <a href="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Phyduck/database/%E5%85%A8%E5%B1%80%E9%94%81%E3%80%81%E8%A1%A8%E7%BA%A7%E9%94%81%E4%BB%A5%E5%8F%8A%E8%A1%8C%E9%94%81%EF%BC%88%E4%B8%8A%EF%BC%89.pdf">参考2</a> <a href="https://www.gatevidyalay.com/deadlock-in-os-conditions-for-deadlock/">参考3</a></p><p>△ 28次</p><p>简述 Redis 中常见类型的底层数据结构 <a href="https://redis.io/topics/data-types">参考1</a> <a href="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Phyduck/database/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.pdf">参考2</a></p><p>△ 28次</p><p>简述什么是最左匹配原则  简单</p><p>△ 26次</p><p>简述 Redis 的过期机制和内存淘汰策略  困难</p><p>△ 24次</p><p>数据库有哪些常见索引？数据库设计的范式是什么？  中等 <a href="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Phyduck/database/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20InnoDB%20Index.pdf">参考1</a></p><p>△ 24次</p><p>简述乐观锁以及悲观锁的区别以及使用场景  简单 <a href="https://stackoverflow.com/questions/129329/optimistic-vs-pessimistic-locking">参考1</a> <a href="https://juejin.cn/post/6844903639207641096">参考2</a></p><p>△ 24次</p><p>MySQL 中 join 与 left join 的区别是什么？  简单</p><p>△ 24次</p><p>简述 MySQL MVCC 的实现原理  困难 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html">参考1</a></p><p>△ 22次</p><p>简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？  中等 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html">参考1</a> <a href="https://cloud.tencent.com/developer/article/1450773">参考2</a></p><p>△ 20次</p><p>Redis 有几种数据结构？Zset 是如何实现的？  中等 <a href="https://redis.io/topics/data-types">参考1</a> <a href="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Phyduck/database/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.pdf">参考2</a></p><p>△ 20次</p><p>简述 Redis 中跳表的应用以及优缺点  中等</p><p>△ 18次</p><p>聚簇索引和非聚簇索引有什么区别？  简单 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html">参考1</a> <a href="https://cloud.tencent.com/developer/article/1541265">参考2</a></p><p>△ 17次</p><p>MySQL 中 varchar 和 char 的区别是什么？  简单</p><p>△ 16次</p><p>简述数据库中的 ACID 分别是什么？  简单</p><p>△ 16次</p><p>简述 MySQL 三种日志的使用场景  中等 <a href="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Phyduck/database/InnoDB-WAL.pdf">参考1</a> <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-log.html">参考2</a></p><p>△ 16次</p><p>模糊查询是如何实现的？  简单</p><p>△ 14次</p><p>并发事务会引发哪些问题？如何解决？  中等</p><p>△ 12次</p><p>什么是数据库事务，MySQL 为什么会使用 InnoDB 作为默认选项</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang GC 详解</title>
      <link href="/uncategorized/go-gc/"/>
      <url>/uncategorized/go-gc/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go-sync-map</title>
      <link href="/uncategorized/go-sync-map/"/>
      <url>/uncategorized/go-sync-map/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leet212</title>
      <link href="/interview/juan/Blind75/leet212/"/>
      <url>/interview/juan/Blind75/leet212/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet211</title>
      <link href="/interview/juan/Blind75/leet211/"/>
      <url>/interview/juan/Blind75/leet211/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet208</title>
      <link href="/interview/juan/Blind75/leet208/"/>
      <url>/interview/juan/Blind75/leet208/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet235</title>
      <link href="/interview/juan/Blind75/leet235/"/>
      <url>/interview/juan/Blind75/leet235/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet230</title>
      <link href="/interview/juan/Blind75/leet230/"/>
      <url>/interview/juan/Blind75/leet230/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.98 验证二叉搜索树</title>
      <link href="/interview/juan/Blind75/leet98/"/>
      <url>/interview/juan/Blind75/leet98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">Leetcode.98 验证二叉搜索树</a></p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg"></p><pre><code>输入：root = [2,1,3]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg"></p><pre><code>输入：root = [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123; </span><br><span class="line">stack := []*TreeNode&#123;&#125; </span><br><span class="line">inorder := math.MinInt64 </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> || root != <span class="literal">nil</span> &#123; </span><br><span class="line"><span class="keyword">for</span> root != <span class="literal">nil</span> &#123; </span><br><span class="line">stack = <span class="built_in">append</span>(stack, root) </span><br><span class="line">root = root.Left </span><br><span class="line">&#125; </span><br><span class="line">root = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] </span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>] </span><br><span class="line"><span class="keyword">if</span> root.Val &lt;= inorder &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">&#125; </span><br><span class="line">inorder = root.Val </span><br><span class="line">root = root.Right </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> helper(root, math.MinInt64, math.MaxInt64) &#125; <span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode, lower, upper <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125; <span class="keyword">if</span> root.Val &lt;= lower || root.Val &gt;= upper &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125; <span class="keyword">return</span> helper(root.Left, lower, root.Val) &amp;&amp; helper(root.Right, root.Val, upper) &#125; 作者：力扣官方题解 链接：https:<span class="comment">//leetcode.cn/problems/validate-binary-search-tree/solutions/230256/yan-zheng-er-cha-sou-suo-shu-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet105</title>
      <link href="/interview/juan/Blind75/leet105/"/>
      <url>/interview/juan/Blind75/leet105/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet572</title>
      <link href="/interview/juan/Blind75/leet572/"/>
      <url>/interview/juan/Blind75/leet572/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet297</title>
      <link href="/interview/juan/Blind75/leet297/"/>
      <url>/interview/juan/Blind75/leet297/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet102</title>
      <link href="/interview/juan/Blind75/leet102/"/>
      <url>/interview/juan/Blind75/leet102/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet124</title>
      <link href="/interview/juan/Blind75/leet124/"/>
      <url>/interview/juan/Blind75/leet124/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet226</title>
      <link href="/interview/juan/Blind75/leet226/"/>
      <url>/interview/juan/Blind75/leet226/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet100</title>
      <link href="/interview/juan/Blind75/leet100/"/>
      <url>/interview/juan/Blind75/leet100/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet104</title>
      <link href="/interview/juan/Blind75/leet104/"/>
      <url>/interview/juan/Blind75/leet104/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet295</title>
      <link href="/interview/juan/Blind75/leet295/"/>
      <url>/interview/juan/Blind75/leet295/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet347</title>
      <link href="/interview/juan/Blind75/leet347/"/>
      <url>/interview/juan/Blind75/leet347/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet23</title>
      <link href="/interview/juan/Blind75/leet23/"/>
      <url>/interview/juan/Blind75/leet23/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet647</title>
      <link href="/interview/juan/Blind75/leet647/"/>
      <url>/interview/juan/Blind75/leet647/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet5</title>
      <link href="/interview/juan/Blind75/leet5/"/>
      <url>/interview/juan/Blind75/leet5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet125</title>
      <link href="/interview/juan/Blind75/leet125/"/>
      <url>/interview/juan/Blind75/leet125/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet20</title>
      <link href="/interview/juan/Blind75/leet20/"/>
      <url>/interview/juan/Blind75/leet20/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet49</title>
      <link href="/interview/juan/Blind75/leet49/"/>
      <url>/interview/juan/Blind75/leet49/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet242</title>
      <link href="/interview/juan/Blind75/leet242/"/>
      <url>/interview/juan/Blind75/leet242/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet76</title>
      <link href="/interview/juan/Blind75/leet76/"/>
      <url>/interview/juan/Blind75/leet76/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet424</title>
      <link href="/interview/juan/Blind75/leet424/"/>
      <url>/interview/juan/Blind75/leet424/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet3</title>
      <link href="/interview/juan/Blind75/leet3/"/>
      <url>/interview/juan/Blind75/leet3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet79</title>
      <link href="/interview/juan/Blind75/leet79/"/>
      <url>/interview/juan/Blind75/leet79/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet48</title>
      <link href="/interview/juan/Blind75/leet48/"/>
      <url>/interview/juan/Blind75/leet48/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet54</title>
      <link href="/interview/juan/Blind75/leet54/"/>
      <url>/interview/juan/Blind75/leet54/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet73</title>
      <link href="/interview/juan/Blind75/leet73/"/>
      <url>/interview/juan/Blind75/leet73/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet143</title>
      <link href="/interview/juan/Blind75/leet143/"/>
      <url>/interview/juan/Blind75/leet143/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet19</title>
      <link href="/interview/juan/Blind75/leet19/"/>
      <url>/interview/juan/Blind75/leet19/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet23</title>
      <link href="/interview/juan/Blind75/leet23/"/>
      <url>/interview/juan/Blind75/leet23/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet21</title>
      <link href="/interview/juan/Blind75/leet21/"/>
      <url>/interview/juan/Blind75/leet21/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet141</title>
      <link href="/interview/juan/Blind75/leet141/"/>
      <url>/interview/juan/Blind75/leet141/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet206</title>
      <link href="/interview/juan/Blind75/leet206/"/>
      <url>/interview/juan/Blind75/leet206/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet435</title>
      <link href="/interview/juan/Blind75/leet435/"/>
      <url>/interview/juan/Blind75/leet435/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet57</title>
      <link href="/interview/juan/Blind75/leet57/"/>
      <url>/interview/juan/Blind75/leet57/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet56</title>
      <link href="/interview/juan/Blind75/leet56/"/>
      <url>/interview/juan/Blind75/leet56/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.128 最长连续序列</title>
      <link href="/interview/juan/Blind75/leet128/"/>
      <url>/interview/juan/Blind75/leet128/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/">Leetcode.128 最长连续序列</a><br>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [100,4,200,1,3,2]输出：4解释：最长数字连续序列是 `[1, 2, 3, 4]。它的长度为 4。`</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,3,7,2,5,8,4,6,0,1]输出：9</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestConsecutive</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">hs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>, <span class="number">0</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">hs[nums[i]] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> num, _ := <span class="keyword">range</span> hs &#123;</span><br><span class="line"><span class="comment">// 找前一个数字，存在则当前数字不是开头</span></span><br><span class="line"><span class="keyword">if</span> _, ok := hs[num<span class="number">-1</span>]; ok &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// num 是开头</span></span><br><span class="line">cn := num</span><br><span class="line">cnt := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> hs[cn+<span class="number">1</span>] &#123;</span><br><span class="line">cn += <span class="number">1</span></span><br><span class="line">cnt += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, cnt)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet200</title>
      <link href="/interview/juan/Blind75/leet200/"/>
      <url>/interview/juan/Blind75/leet200/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet417</title>
      <link href="/interview/juan/Blind75/leet417/"/>
      <url>/interview/juan/Blind75/leet417/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet207</title>
      <link href="/interview/juan/Blind75/leet207/"/>
      <url>/interview/juan/Blind75/leet207/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet133</title>
      <link href="/interview/juan/Blind75/leet133/"/>
      <url>/interview/juan/Blind75/leet133/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet55</title>
      <link href="/interview/juan/Blind75/leet55/"/>
      <url>/interview/juan/Blind75/leet55/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet62</title>
      <link href="/interview/juan/Blind75/leet62/"/>
      <url>/interview/juan/Blind75/leet62/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet91</title>
      <link href="/interview/juan/Blind75/leet91/"/>
      <url>/interview/juan/Blind75/leet91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet213</title>
      <link href="/interview/juan/Blind75/leet213/"/>
      <url>/interview/juan/Blind75/leet213/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet198</title>
      <link href="/interview/juan/Blind75/leet198/"/>
      <url>/interview/juan/Blind75/leet198/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet39</title>
      <link href="/interview/juan/Blind75/leet39/"/>
      <url>/interview/juan/Blind75/leet39/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet139</title>
      <link href="/interview/juan/Blind75/leet139/"/>
      <url>/interview/juan/Blind75/leet139/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet1143</title>
      <link href="/interview/juan/Blind75/leet1143/"/>
      <url>/interview/juan/Blind75/leet1143/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet300</title>
      <link href="/interview/juan/Blind75/leet300/"/>
      <url>/interview/juan/Blind75/leet300/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet322</title>
      <link href="/interview/juan/Blind75/leet322/"/>
      <url>/interview/juan/Blind75/leet322/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet70</title>
      <link href="/interview/juan/Blind75/leet70/"/>
      <url>/interview/juan/Blind75/leet70/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet190</title>
      <link href="/interview/juan/Blind75/leet190/"/>
      <url>/interview/juan/Blind75/leet190/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.268 丢失的数字</title>
      <link href="/interview/juan/Blind75/leet268/"/>
      <url>/interview/juan/Blind75/leet268/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/missing-number/">Leetcode.268 丢失的数字</a></p><p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [3,0,1]输出：2解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</code></pre><p><strong>示例 2：</strong></p><pre><code>**输入：nums = [0,1]**输出：2**解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。</code></pre><p><strong>示例 3：</strong></p><pre><code>**输入：nums = [9,6,4,2,3,5,7,0,1]**输出：8**解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。</code></pre><p><strong>示例 4：</strong></p><pre><code>**输入：nums = [0]**输出：1**解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。</code></pre><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= n</code></li><li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求和取差值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">missingNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> total <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;=<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">total += i</span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">sum += nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> total - sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异或思路</span></span><br><span class="line"><span class="comment">// xor 将 nums 中元素异或一遍，然后再异或一遍 0-n，由异或的特性可知，出现两次的数据会消失，最终留下的就是未出现的那个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">missingNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> xor <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">xor ^= i</span><br><span class="line">xor ^= n</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> xor ^ <span class="built_in">len</span>(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet338</title>
      <link href="/interview/juan/Blind75/leet338/"/>
      <url>/interview/juan/Blind75/leet338/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.191 位1的个数</title>
      <link href="/interview/juan/Blind75/leet191/"/>
      <url>/interview/juan/Blind75/leet191/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/number-of-1-bits/description/">Leetcode.191 位1的个数</a></p><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中 设置位 的个数（也被称为<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F">汉明重量</a>）。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 11输出：3解释：输入的二进制串 `1011 中，共有 3 个设置位。`</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 128输出：1解释：输入的二进制串 10000000 中，共有 1 个设置位。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：n = 2147483645输出：30解释：输入的二进制串 11111111111111111111111111111101 中，共有 30 个设置位。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hammingWeight</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> ones <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span>&lt;&lt;i &amp; num &gt; <span class="number">0</span> &#123;</span><br><span class="line">ones += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ones</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>math</title>
      <link href="/uncategorized/math/"/>
      <url>/uncategorized/math/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/jzj_c_love/article/details/122279703">https://blog.csdn.net/jzj_c_love/article/details/122279703</a></p><h1 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h1><h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p>$$<br>A_1^2<br>\<br>B_{12}<br>\<br>2^{x^2+y}<br>$$</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">A_1^2</span><br><span class="line">\\</span><br><span class="line">B_&#123;12&#125;</span><br><span class="line">\\</span><br><span class="line">2^&#123;x^2+y&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h2 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h2><p>$$<br>\frac{x}{1+x^2}<br>\<br>\frac{\frac{1}{2}+x}{y}<br>\<br>\tfrac{a}{b}<br>\frac{a}{b}<br>$$</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\frac&#123;x&#125;&#123;1+x^2&#125;</span><br><span class="line">\\</span><br><span class="line">\frac&#123;\frac&#123;1&#125;&#123;2&#125;+x&#125;&#123;y&#125;</span><br><span class="line">\\</span><br><span class="line">\tfrac&#123;a&#125;&#123;b&#125;</span><br><span class="line">\frac&#123;a&#125;&#123;b&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h2 id="开根"><a href="#开根" class="headerlink" title="开根"></a>开根</h2><p>$$<br>\sqrt{x}<br>\sqrt[3]{x}<br>$$</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\sqrt&#123;x&#125;</span><br><span class="line">\sqrt[3]&#123;x&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>$$<br>\binom{n}{k}<br>\tbinom{n}{k}<br>$$</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\binom&#123;n&#125;&#123;k&#125;</span><br><span class="line">\tbinom&#123;n&#125;&#123;k&#125;</span><br></pre></td></tr></table></figure><h2 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h2><p>$$<br>a′a′′a′<br>$$</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">𝑎′𝑎″𝑎′</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h2 id="偏微分"><a href="#偏微分" class="headerlink" title="偏微分"></a>偏微分</h2><p>$$<br>∂∇∂∇<br>$$</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">a&#x27;</span><br><span class="line">a&#x27;&#x27;</span><br><span class="line">a^&#123;\prime&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h2 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h2><p>$$<br>x(moda)2modx𝑥(mod𝑎)2mod𝑥<br>$$</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">x \pmod a</span><br><span class="line">\\</span><br><span class="line">2\mod&#123;x&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h2><p>$$<br>∫211∫2∮∫∬∯∭∰∫12∫21∮⁡∫∬∯⁡∭∰<br>$$</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">$</span><span class="operator">$</span></span><br><span class="line">\<span class="keyword">int_</span>&#123;<span class="number">1</span>&#125;<span class="operator">^</span>&#123;<span class="number">2</span>&#125;</span><br><span class="line">\<span class="keyword">intop_</span>&#123;<span class="number">2</span>&#125;<span class="operator">^</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">\oint</span><br><span class="line">\smallint</span><br><span class="line">\\</span><br><span class="line">\iint</span><br><span class="line">\oiint</span><br><span class="line">\iiint</span><br><span class="line">\oiiint</span><br></pre></td></tr></table></figure><h2 id="累加-x2F-累乘-x2F-极限"><a href="#累加-x2F-累乘-x2F-极限" class="headerlink" title="累加&#x2F;累乘&#x2F;极限"></a>累加&#x2F;累乘&#x2F;极限</h2><p>k∑i&#x3D;1n∑i&#x3D;1∑ni&#x3D;1k∏i&#x3D;1n∏i&#x3D;1∏ni&#x3D;1limk→∞limk→∞limk→∞∑𝑖&#x3D;1𝑘∑𝑖&#x3D;1𝑛∑𝑖&#x3D;1𝑛∏𝑖&#x3D;1𝑘∏𝑖&#x3D;1𝑛∏𝑖&#x3D;1𝑛lim𝑘→∞lim𝑘→∞lim𝑘→∞</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\<span class="keyword">sum_</span>&#123;i<span class="operator">=</span><span class="number">1</span>&#125;<span class="operator">^</span>&#123;k&#125;</span><br><span class="line">\displaystyle\<span class="keyword">sum_</span>&#123;i<span class="operator">=</span><span class="number">1</span>&#125;<span class="symbol">^n</span></span><br><span class="line">\textstyle\<span class="keyword">sum_</span>&#123;i<span class="operator">=</span><span class="number">1</span>&#125;<span class="symbol">^n</span></span><br><span class="line">\\</span><br><span class="line">\<span class="keyword">prod_</span>&#123;i<span class="operator">=</span><span class="number">1</span>&#125;<span class="operator">^</span>&#123;k&#125;</span><br><span class="line">\displaystyle\<span class="keyword">prod_</span>&#123;i<span class="operator">=</span><span class="number">1</span>&#125;<span class="symbol">^n</span></span><br><span class="line">\textstyle\<span class="keyword">prod_</span>&#123;i<span class="operator">=</span><span class="number">1</span>&#125;<span class="symbol">^n</span></span><br><span class="line">\\</span><br><span class="line">\<span class="keyword">lim_</span>&#123;k \<span class="keyword">to</span> \infty&#125;</span><br><span class="line">\lim\<span class="keyword">limits_</span>&#123;k \<span class="keyword">to</span> \infty&#125;</span><br><span class="line">\lim\<span class="keyword">nolimits_</span>&#123;k \<span class="keyword">to</span> \infty&#125;</span><br></pre></td></tr></table></figure><h1 id="修饰符号"><a href="#修饰符号" class="headerlink" title="修饰符号"></a>修饰符号</h1><p><strong>简单的帽子</strong></p><p>^θˆAB¯y¯¯¯¯¯¯¯¯AB<del>a˜ac¯a´aˇa&#96;a˙a¨a𝜃^𝐴𝐵^𝑦¯𝐴𝐵¯𝑎</del>𝑎𝑐~𝑎¯𝑎´𝑎ˇ𝑎&#96;𝑎˙𝑎¨</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">\hat&#123;\theta&#125;</span><br><span class="line">\widehat&#123;AB&#125;</span><br><span class="line">\\</span><br><span class="line">\bar&#123;y&#125;</span><br><span class="line">\overline&#123;AB&#125;</span><br><span class="line">\\</span><br><span class="line">\tilde&#123;a&#125;</span><br><span class="line">\widetilde&#123;ac&#125;</span><br><span class="line">\\</span><br><span class="line">\bar&#123;a&#125;</span><br><span class="line">\acute&#123;a&#125;</span><br><span class="line">\check&#123;a&#125;</span><br><span class="line">\grave&#123;a&#125;</span><br><span class="line">\\</span><br><span class="line">\dot&#123;a&#125;</span><br><span class="line">\ddot&#123;a&#125;</span><br></pre></td></tr></table></figure><p><strong>帽子和袜子</strong></p><p>←−−AB−−→AB←→ABAB←−−AB−−→AB←→ABAB¯¯¯¯¯¯¯¯ABAB––––𝐴𝐵←𝐴𝐵→𝐴𝐵↔𝐴𝐵←𝐴𝐵→𝐴𝐵↔𝐴𝐵⏞𝐴𝐵⏟𝐴𝐵¯𝐴𝐵_</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\overleftarrow&#123;AB&#125;</span><br><span class="line">\overrightarrow&#123;AB&#125;</span><br><span class="line">\overleftrightarrow&#123;AB&#125;</span><br><span class="line">\\</span><br><span class="line">\underleftarrow&#123;AB&#125;</span><br><span class="line">\underrightarrow&#123;AB&#125;</span><br><span class="line">\underleftrightarrow&#123;AB&#125;</span><br><span class="line">\\</span><br><span class="line">\overbrace&#123;AB&#125;</span><br><span class="line">\underbrace&#123;AB&#125;</span><br><span class="line">\\</span><br><span class="line">\overline&#123;AB&#125;</span><br><span class="line">\underline&#123;AB&#125;</span><br></pre></td></tr></table></figure><p><strong>盖子和盒子</strong></p><p>notea+b+ca+b+cnoteπ&#x3D;3.14𝑎+𝑏+𝑐⏞note𝑎+𝑏+𝑐⏟note𝜋&#x3D;3.14</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\<span class="keyword">overbrace</span>&#123;a<span class="operator">+</span>b<span class="operator">+</span>c&#125;<span class="operator">^</span>&#123;\<span class="keyword">text</span>&#123;note&#125;&#125;</span><br><span class="line">\\</span><br><span class="line">\<span class="keyword">underbrace</span>&#123;a<span class="operator">+</span>b<span class="operator">+</span>c&#125;<span class="keyword">_</span>&#123;\<span class="keyword">text</span>&#123;note&#125;&#125;</span><br><span class="line">\\</span><br><span class="line">\<span class="keyword">boxed</span>&#123;\pi<span class="operator">=</span><span class="number">3.14</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="各种括号"><a href="#各种括号" class="headerlink" title="各种括号"></a>各种括号</h1><p>((((((((((</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">\<span class="keyword">big(</span></span><br><span class="line"><span class="keyword"></span>\<span class="keyword">Big(</span></span><br><span class="line"><span class="keyword"></span>\<span class="keyword">bigg(</span></span><br><span class="line"><span class="keyword"></span>\<span class="keyword">Bigg(</span></span><br></pre></td></tr></table></figure><p>[]&lt;&gt;|−2|{}[]&lt;&gt;|−2|{}</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br><span class="line"><span class="tag">&lt;&gt;</span></span><br><span class="line">|-2|</span><br><span class="line">\&#123;\&#125;</span><br></pre></td></tr></table></figure><p>⟮x⟯∥a∥⌈2.6⌉⌊1.2⌋⟮𝑥⟯‖𝑎‖⌈2.6⌉⌊1.2⌋</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\lgroup x \rgroup</span><br><span class="line">\lVert <span class="selector-tag">a</span> \rVert</span><br><span class="line">\lceil <span class="number">2.6</span> \rceil</span><br><span class="line">\lfloor <span class="number">1.2</span> \rfloor</span><br></pre></td></tr></table></figure><p>┌┐└┘⌜⌝⌞⌟</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\ulcorner</span><br><span class="line">\urcorner</span><br><span class="line">\<span class="keyword">llcorner</span></span><br><span class="line"><span class="keyword"></span>\lrcorner</span><br></pre></td></tr></table></figure><h1 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h1><p><img src="https://img2020.cnblogs.com/blog/2068113/202008/2068113-20200816212452725-1705310605.jpg" alt="希腊字母"></p><h1 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h1><p>+−×&#x2F;÷⋅#%+−×&#x2F;÷⋅#%</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+</span><br><span class="line">-</span><br><span class="line">\<span class="built_in">times</span></span><br><span class="line">/</span><br><span class="line">\div</span><br><span class="line">\cdot</span><br><span class="line">\<span class="comment">#</span></span><br><span class="line">\%</span><br></pre></td></tr></table></figure><p>∩∪∧∨⊔⊓∩∪∧∨⊔⊓</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\<span class="built_in">cap</span></span><br><span class="line">\cup</span><br><span class="line">\land</span><br><span class="line">\lor</span><br><span class="line">\sqcup</span><br><span class="line">\sqcap</span><br></pre></td></tr></table></figure><p>∘∗⋆⊗⊕⊙∘∗⋆⊗⊕⊙</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\circ</span><br><span class="line">\ast</span><br><span class="line">\star</span><br><span class="line">\otimes</span><br><span class="line">\oplus</span><br><span class="line">\odot</span><br></pre></td></tr></table></figure><p>±∓∔⋇±∓∔⋇</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\pm</span><br><span class="line">\mp</span><br><span class="line">\dotplus</span><br><span class="line">\<span class="keyword">divideontimes</span></span><br></pre></td></tr></table></figure><h1 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h1><p>&#x3D;&#x3D;≢≈≊≅∼&#x3D;&#x3D;≢≈≊≅∼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=</span><br><span class="line">= \not</span><br><span class="line">\equiv</span><br><span class="line">\approx</span><br><span class="line">\approxeq</span><br><span class="line">\cong</span><br><span class="line">\sim</span><br></pre></td></tr></table></figure><p>&lt;&gt;≤≥≫≪&lt;&gt;≤≥≫≪</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;</span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">\le</span></span><br><span class="line">\ge</span><br><span class="line">\gg</span><br><span class="line">\ll</span><br></pre></td></tr></table></figure><p>⋞⋟≺≻⪯⪰⋞⋟≺≻⪯⪰</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\curlyeqprec</span><br><span class="line">\curlyeqsucc</span><br><span class="line">\prec</span><br><span class="line">\succ</span><br><span class="line">\preceq</span><br><span class="line">\succeq</span><br></pre></td></tr></table></figure><h1 id="集合-x2F-逻辑相关"><a href="#集合-x2F-逻辑相关" class="headerlink" title="集合&#x2F;逻辑相关"></a>集合&#x2F;逻辑相关</h1><p>∈∋⊄⊅⊆⊇∩∪∧∨¬∅∅∵∀∃∴∈∋⊄⊅⊆⊇∩∪∧∨¬∅∅∵∀∃∴</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">\in</span><br><span class="line">\owns \not</span><br><span class="line">\<span class="keyword">subset </span>\not</span><br><span class="line">\supset</span><br><span class="line">\<span class="keyword">subseteq</span></span><br><span class="line"><span class="keyword"></span>\supseteq</span><br><span class="line">\\</span><br><span class="line">\cap</span><br><span class="line">\cup</span><br><span class="line">\land</span><br><span class="line">\lor</span><br><span class="line">\\</span><br><span class="line">\neg</span><br><span class="line">\emptyset</span><br><span class="line">\varnothing</span><br><span class="line">\\</span><br><span class="line">\<span class="keyword">because</span></span><br><span class="line"><span class="keyword"></span>\forall</span><br><span class="line">\exists</span><br><span class="line">\therefore</span><br></pre></td></tr></table></figure><h1 id="各种箭头"><a href="#各种箭头" class="headerlink" title="各种箭头"></a>各种箭头</h1><p><strong>细箭头</strong></p><p>←←→→↔↑↓↕←←→→↔↑↓↕</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\gets</span><br><span class="line">\leftarrow</span><br><span class="line">\<span class="selector-tag">to</span></span><br><span class="line">\rightarrow</span><br><span class="line">\leftrightarrow</span><br><span class="line">\\</span><br><span class="line">\uparrow</span><br><span class="line">\downarrow</span><br><span class="line">\updownarrow</span><br></pre></td></tr></table></figure><p><strong>粗箭头</strong></p><p>⇐⇒⇔⟺⇑⇓⇕⇐⇒⇔⟺⇑⇓⇕</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\Leftarrow</span><br><span class="line">\Rightarrow</span><br><span class="line">\Leftrightarrow</span><br><span class="line">\<span class="keyword">iff</span></span><br><span class="line">\\</span><br><span class="line">\Uparrow</span><br><span class="line">\Downarrow</span><br><span class="line">\Updownarrow</span><br></pre></td></tr></table></figure><p><strong>斜箭头</strong></p><p>↗↘↙↖↗↘↙↖</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\nearrow</span><br><span class="line">\searrow</span><br><span class="line">\<span class="keyword">swarrow</span></span><br><span class="line"><span class="keyword"></span>\nwarrow</span><br></pre></td></tr></table></figure><p><strong>半边箭头</strong></p><p>↼↽⇀⇁⇌↼↽⇀⇁⇌</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\leftharpoonup</span><br><span class="line">\leftharpoondown</span><br><span class="line">\rightharpoonup</span><br><span class="line">\rightharpoondown</span><br><span class="line">\rightleftharpoons</span><br></pre></td></tr></table></figure><p><strong>特殊箭头</strong></p><p>↦⇝↩↪↦⇝↩↪</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\mapsto</span><br><span class="line">\leadsto</span><br><span class="line">\hookleftarrow</span><br><span class="line">\hookrightarrow</span><br></pre></td></tr></table></figure><p><strong>加长箭头</strong></p><p>⟵⟶⟷⟸⟹⟺⟼⟵⟶⟷⟸⟹⟺⟼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\longleftarrow</span><br><span class="line">\longrightarrow</span><br><span class="line">\longleftrightarrow</span><br><span class="line">\Longleftarrow</span><br><span class="line">\Longrightarrow</span><br><span class="line">\Longleftrightarrow</span><br><span class="line">\longmapsto</span><br></pre></td></tr></table></figure><p><strong>带文本箭头</strong></p><p>over−−→−−→overover−−−→underover←−−←−−−underover←−−−under→𝑜𝑣𝑒𝑟→𝑜𝑣𝑒𝑟→𝑢𝑛𝑑𝑒𝑟𝑜𝑣𝑒𝑟←𝑜𝑣𝑒𝑟←𝑢𝑛𝑑𝑒𝑟←𝑢𝑛𝑑𝑒𝑟𝑜𝑣𝑒𝑟</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\xrightarrow&#123;over&#125;</span><br><span class="line">\xrightarrow<span class="selector-attr">[over]</span>&#123;&#125;</span><br><span class="line">\xrightarrow<span class="selector-attr">[under]</span>&#123;over&#125;</span><br><span class="line">\xleftarrow<span class="selector-attr">[]</span>&#123;over&#125;</span><br><span class="line">\xleftarrow<span class="selector-attr">[under]</span>&#123;&#125;</span><br><span class="line">\xleftarrow<span class="selector-attr">[under]</span>&#123;over&#125;</span><br></pre></td></tr></table></figure><h1 id="空格间距"><a href="#空格间距" class="headerlink" title="空格间距"></a>空格间距</h1><p>ABABABABA BABABAB𝐴𝐵𝐴𝐵𝐴𝐵𝐴𝐵𝐴 𝐵𝐴𝐵𝐴𝐵𝐴𝐵</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">A\!B</span><br><span class="line">\\</span><br><span class="line">AB</span><br><span class="line">\\</span><br><span class="line">A\thinspace B</span><br><span class="line">\\</span><br><span class="line">A\:B</span><br><span class="line">\\</span><br><span class="line">A\ B</span><br><span class="line">\\</span><br><span class="line">A \enspace B</span><br><span class="line">\\</span><br><span class="line">A\quad B</span><br><span class="line">\\</span><br><span class="line">A\qquad B</span><br></pre></td></tr></table></figure><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p>A&#x3D;abcd𝐴&#x3D;𝑎𝑏𝑐𝑑</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = \<span class="keyword">begin</span>&#123;matrix&#125;</span><br><span class="line">a &amp; b\\</span><br><span class="line">c &amp; d</span><br><span class="line">\<span class="keyword">end</span>&#123;matrix&#125;</span><br></pre></td></tr></table></figure><p>B&#x3D;(abcd)𝐵&#x3D;(𝑎𝑏𝑐𝑑)</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">B </span>= \<span class="keyword">begin&#123;pmatrix&#125;</span></span><br><span class="line"><span class="keyword"></span>a &amp; <span class="keyword">b\\</span></span><br><span class="line"><span class="keyword"></span>c &amp; d</span><br><span class="line">\end&#123;pmatrix&#125;</span><br></pre></td></tr></table></figure><p>C&#x3D;∣∣∣abcd∣∣∣𝐶&#x3D;|𝑎𝑏𝑐𝑑|</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C = \<span class="keyword">begin</span>&#123;vmatrix&#125;</span><br><span class="line">a &amp; b\\</span><br><span class="line">c &amp; d</span><br><span class="line">\<span class="keyword">end</span>&#123;vmatrix&#125;</span><br></pre></td></tr></table></figure><p>D&#x3D;[abcd]𝐷&#x3D;[𝑎𝑏𝑐𝑑]</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D = \<span class="keyword">begin&#123;bmatrix&#125;</span></span><br><span class="line"><span class="keyword"></span>a &amp; <span class="keyword">b\\</span></span><br><span class="line"><span class="keyword"></span>c &amp; d</span><br><span class="line">\end&#123;<span class="keyword">bmatrix&#125;</span></span><br></pre></td></tr></table></figure><p>E&#x3D;∥∥∥abcd∥∥∥𝐸&#x3D;‖𝑎𝑏𝑐𝑑‖</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E = \<span class="keyword">begin</span>&#123;Vmatrix&#125;</span><br><span class="line">a &amp; b\\</span><br><span class="line">c &amp; d</span><br><span class="line">\<span class="keyword">end</span>&#123;Vmatrix&#125;</span><br></pre></td></tr></table></figure><p>F&#x3D;{abcd}𝐹&#x3D;{𝑎𝑏𝑐𝑑}</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F = \<span class="keyword">begin&#123;Bmatrix&#125;</span></span><br><span class="line"><span class="keyword"></span>a &amp; <span class="keyword">b\\</span></span><br><span class="line"><span class="keyword"></span>c &amp; d</span><br><span class="line">\end&#123;<span class="keyword">Bmatrix&#125;</span></span><br></pre></td></tr></table></figure><p>[A b]&#x3D;⎡⎢ ⎢⎣a11a12a13b1a21a22a23b2a31a32a33b3⎤⎥ ⎥⎦[𝐴 𝑏]&#x3D;[𝑎11𝑎12𝑎13𝑏1𝑎21𝑎22𝑎23𝑏2𝑎31𝑎32𝑎33𝑏3]</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[A\ b] <span class="operator">=</span> </span><br><span class="line">\<span class="keyword">begin</span>&#123;bmatrix&#125;</span><br><span class="line">\<span class="keyword">begin</span>&#123;array&#125;&#123;c c c<span class="operator">|</span>c&#125;</span><br><span class="line"><span class="keyword">a_</span>&#123;<span class="number">11</span>&#125; <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">12</span>&#125; <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">13</span>&#125; <span class="operator">&amp;</span> b_1\\</span><br><span class="line"><span class="keyword">a_</span>&#123;<span class="number">21</span>&#125; <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">22</span>&#125; <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">23</span>&#125; <span class="operator">&amp;</span> b_2\\</span><br><span class="line"><span class="keyword">a_</span>&#123;<span class="number">31</span>&#125; <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">32</span>&#125; <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">33</span>&#125; <span class="operator">&amp;</span> b_3\\</span><br><span class="line">\<span class="keyword">end</span>&#123;array&#125;</span><br><span class="line">\<span class="keyword">end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure><p>abcdefghi𝑎𝑏𝑐𝑑𝑒𝑓𝑔ℎ𝑖</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;array&#125;&#123;c:c:c&#125;</span><br><span class="line"><span class="selector-tag">a</span> &amp; <span class="selector-tag">b</span> &amp; c \\ </span><br><span class="line">\hline</span><br><span class="line">d &amp; e &amp; f \\</span><br><span class="line">\hdashline</span><br><span class="line"> g &amp; h &amp; <span class="selector-tag">i</span></span><br><span class="line">\end&#123;array&#125;</span><br></pre></td></tr></table></figure><p>Ln×n&#x3D;⎡⎢ ⎢ ⎢ ⎢ ⎢⎣a11a12⋯a1na21a22⋯a2n⋮⋮⋱⋮an1an2⋯ann⎤⎥ ⎥ ⎥ ⎥ ⎥⎦𝐿𝑛×𝑛&#x3D;[𝑎11𝑎12⋯𝑎1𝑛𝑎21𝑎22⋯𝑎2𝑛⋮⋮⋱⋮𝑎𝑛1𝑎𝑛2⋯𝑎𝑛𝑛]</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L_&#123;n\times n&#125; <span class="operator">=</span> \<span class="keyword">begin</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">a_</span>&#123;<span class="number">11</span>&#125; <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">12</span>&#125; <span class="operator">&amp;</span> \cdots <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">1</span>n&#125; \\ </span><br><span class="line"><span class="keyword">a_</span>&#123;<span class="number">21</span>&#125; <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">22</span>&#125; <span class="operator">&amp;</span> \cdots <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">2</span>n&#125; \\ </span><br><span class="line">\vdots <span class="operator">&amp;</span> \vdots <span class="operator">&amp;</span>\ddots <span class="operator">&amp;</span> \vdots\\</span><br><span class="line"><span class="keyword">a_</span>&#123;n1&#125; <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;n2&#125; <span class="operator">&amp;</span> \cdots <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;nn&#125; \\ </span><br><span class="line">\<span class="keyword">end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure><h1 id="列式-x2F-方程组"><a href="#列式-x2F-方程组" class="headerlink" title="列式&#x2F;方程组"></a>列式&#x2F;方程组</h1><p>f(x)&#x3D;(x+1)2&#x3D;x2+2x+1𝑓(𝑥)&#x3D;(𝑥+1)2&#x3D;𝑥2+2𝑥+1</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\<span class="keyword">begin</span>&#123;aligned&#125;</span><br><span class="line">f(x) &amp;= (x+<span class="number">1</span>)^<span class="number">2</span>\\</span><br><span class="line">&amp;= x^<span class="number">2</span> + 2x + <span class="number">1</span></span><br><span class="line">\<span class="keyword">end</span>&#123;aligned&#125;</span><br></pre></td></tr></table></figure><p>f(x)&#x3D;{aif bbif a𝑓(𝑥)&#x3D;{𝑎if b𝑏if a</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(x) <span class="operator">=</span> \<span class="keyword">begin</span>&#123;cases&#125;</span><br><span class="line">a <span class="operator">&amp;</span>\<span class="keyword">text</span>&#123;<span class="keyword">if</span> b&#125;\\</span><br><span class="line">b <span class="operator">&amp;</span>\<span class="keyword">text</span>&#123;<span class="keyword">if</span> a&#125;\\</span><br><span class="line">\<span class="keyword">end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure><p>{x+2y&#x3D;13x−y&#x3D;5{𝑥+2𝑦&#x3D;13𝑥−𝑦&#x3D;5</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\<span class="keyword">begin</span>&#123;cases&#125;</span><br><span class="line">\<span class="keyword">begin</span>&#123;aligned&#125;</span><br><span class="line">x + 2y &amp;= <span class="number">1</span>\\</span><br><span class="line">3x - y &amp;= <span class="number">5</span></span><br><span class="line">\<span class="keyword">end</span>&#123;aligned&#125;</span><br><span class="line">\<span class="keyword">end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure><h1 id="字体操作"><a href="#字体操作" class="headerlink" title="字体操作"></a>字体操作</h1><h2 id="修改字体"><a href="#修改字体" class="headerlink" title="修改字体"></a>修改字体</h2><p><img src="https://img2020.cnblogs.com/blog/2068113/202008/2068113-20200816212537331-1196114732.jpg"></p><h2 id="修改大小"><a href="#修改大小" class="headerlink" title="修改大小"></a>修改大小</h2><p>dABddAB𝑑𝐴𝐵𝑑𝑑𝐴𝐵</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\Huge AB</span><br><span class="line">d</span><br><span class="line">\\</span><br><span class="line">d</span><br><span class="line">\<span class="keyword">normalsize </span>AB</span><br></pre></td></tr></table></figure><p>修改字体的操作影响效果到行末。</p><p>ABABABABABABABABABAB𝐴𝐵𝐴𝐵𝐴𝐵𝐴𝐵𝐴𝐵𝐴𝐵𝐴𝐵𝐴𝐵𝐴𝐵𝐴𝐵</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AB</span><br><span class="line">\Huge AB</span><br><span class="line">\huge AB</span><br><span class="line">\\</span><br><span class="line">AB</span><br><span class="line">\<span class="keyword">LARGE</span> AB</span><br><span class="line">\<span class="keyword">Large</span> AB</span><br><span class="line">\<span class="keyword">large</span> AB</span><br><span class="line">\\</span><br><span class="line">AB</span><br><span class="line">\small AB</span><br><span class="line">\tiny AB</span><br></pre></td></tr></table></figure><h2 id="修改颜色"><a href="#修改颜色" class="headerlink" title="修改颜色"></a>修改颜色</h2><p>\textcolor{blue}{F&#x3D;ma}<br>\<br>\textcolor</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode121. 买卖股票的最佳时间</title>
      <link href="/interview/juan/Blind75/leet121/"/>
      <url>/interview/juan/Blind75/leet121/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">Leetcode121. 买卖股票的最佳时间</a></p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><p>遍历的过程当中找到 cost 最小的那一天 or 那一天的成本，用当前的 price 减去 cost，就是在这一天所能达到的最大收益</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">cost, profit := prices[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, n := <span class="number">0</span>, <span class="built_in">len</span>(prices); i&lt;n; i++ &#123;</span><br><span class="line">cost = min(cost, prices[i])</span><br><span class="line">profit = max(profit, prices[i] - cost)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> profit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line"><span class="keyword">if</span> a &lt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.217 存在重复元素</title>
      <link href="/interview/juan/Blind75/leet217/"/>
      <url>/interview/juan/Blind75/leet217/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/contains-duplicate/description/">Leetcode.217 存在重复元素</a></p><p>给你一个整数数组 <code>nums</code> 。如果任一值在数组中出现 <strong>至少两次</strong> ，返回 <code>true</code> ；如果数组中每个元素互不相同，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3,1]输出：true</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,2,3,4]输出：false</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1,1,1,3,3,4,3,2,4,2]输出：true</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><p>哈希表，秒了！<br>直接排序，秒了！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsDuplicate</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; </span><br><span class="line">sort.Ints(nums) </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123; </span><br><span class="line"><span class="keyword">if</span> nums[i] == nums[i<span class="number">-1</span>] &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsDuplicate</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; </span><br><span class="line">set := <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125; </span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123; </span><br><span class="line"><span class="keyword">if</span> _, has := set[v]; has &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">&#125; </span><br><span class="line">set[v] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.238 除自身以外数组的乘积</title>
      <link href="/interview/juan/Blind75/leet238/"/>
      <url>/interview/juan/Blind75/leet238/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/product-of-array-except-self/description/">Leetcode.238 除自身以外数组的乘积</a></p><p>给你一个整数数组 <code>nums</code>，返回 <em>数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。</p><p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在  <strong>32 位</strong> 整数范围内。</p><p>请 <strong>不要使用除法，</strong>且在 <code>O(_n_)</code> 时间复杂度内完成此题。</p><p><strong>示例 1:</strong></p><pre><code>输入: nums = `[1,2,3,4]`输出: `[24,12,8,6]`</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: nums = [-1,1,0,-3,3]输出: [0,0,9,0,0]</code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>-30 &lt;= nums[i] &lt;= 30</code></li><li><strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在  <strong>32 位</strong> 整数范围内</li></ul><p><strong>进阶：</strong>你可以在 <code>O(1)</code> 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 <strong>不被视为</strong> 额外空间。）</p><p>主要思路是想办法计算当前位置的前缀和后缀乘积</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productExceptSelf</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123; </span><br><span class="line">length := <span class="built_in">len</span>(nums) </span><br><span class="line"></span><br><span class="line"><span class="comment">// L 和 R 分别表示左右两侧的乘积列表 </span></span><br><span class="line">L, R, answer := <span class="built_in">make</span>([]<span class="type">int</span>, length), <span class="built_in">make</span>([]<span class="type">int</span>, length), <span class="built_in">make</span>([]<span class="type">int</span>, length) </span><br><span class="line"><span class="comment">// L[i] 为索引 i 左侧所有元素的乘积 </span></span><br><span class="line"><span class="comment">// 对于索引为 &#x27;0&#x27; 的元素，因为左侧没有元素，所以 L[0] = 1 </span></span><br><span class="line">L[<span class="number">0</span>] = <span class="number">1</span> </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123; </span><br><span class="line">L[i] = nums[i<span class="number">-1</span>] * L[i<span class="number">-1</span>] </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// R[i] 为索引 i 右侧所有元素的乘积 </span></span><br><span class="line"><span class="comment">// 对于索引为 &#x27;length-1&#x27; 的元素，因为右侧没有元素，所以 R[length-1] = 1 </span></span><br><span class="line">R[length<span class="number">-1</span>] = <span class="number">1</span> </span><br><span class="line"><span class="keyword">for</span> i := length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123; </span><br><span class="line">R[i] = nums[i+<span class="number">1</span>] * R[i+<span class="number">1</span>] </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积 </span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123; </span><br><span class="line">answer[i] = L[i] * R[i] </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> answer </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// O(1) 版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productExceptSelf</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(nums)</span><br><span class="line">ans := <span class="built_in">make</span>([]<span class="type">int</span>, length)</span><br><span class="line"><span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ans[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 因为索引为 &#x27;0&#x27; 的元素左侧没有元素， 所以 ans[0] = 1</span></span><br><span class="line">ans[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">ans[i] = nums[i<span class="number">-1</span>] * ans[i<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x 为右侧所有元素的乘积</span></span><br><span class="line"><span class="comment">// 刚开始右边没有元素，所以 x = 1</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j:=length<span class="number">-1</span>; j &gt;=<span class="number">0</span>; j-- &#123;</span><br><span class="line"><span class="comment">// 对于索引 i，左边的乘积为 ans[i]，右边的乘积为 x</span></span><br><span class="line">ans[j] = ans[j] * x</span><br><span class="line"><span class="comment">// x 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 x 上</span></span><br><span class="line">x = nums[j] * x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode53. 最大子数组和</title>
      <link href="/interview/juan/Blind75/leet53/"/>
      <url>/interview/juan/Blind75/leet53/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/maximum-subarray/description/">Leetcode53. 最大子数组和</a></p><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong></p><p>是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1]输出：1</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [5,4,-1,7,8]输出：23</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p>思路和算法</p><p>假设 nums 数组的长度是 n，下标从 0 到 n−1。</p><p>我们用 f(i) 代表以第 i 个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：</p><p>$$max0≤i≤n−1​{f(i)}$$</p><p>因此我们只需要求出每个位置的 f(i)，然后返回 f 数组中的最大值即可。那么我们如何求 f(i)f(i)f(i) 呢？我们可以考虑 nums[i] 单独成为一段还是加入 f(i−1) 对应的那一段，这取决于 nums[i] 和 f(i−1)+nums[i] 的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：</p><p>$$f(i)&#x3D;max{f(i−1)+nums[i],nums[i]}$$</p><p>不难给出一个时间复杂度 O(n)、空间复杂度 O(n) 的实现，即用一个 f 数组来保存 f(i) 的值，用一个循环求出所有 f(i)。考虑到 f(i) 只和 f(i−1) 相关，于是我们可以只用一个变量 pre 来维护对于当前 f(i) 的 f(i−1) 的值是多少，从而让空间复杂度降低到 O(1)，这有点类似「滚动数组」的思想。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; </span><br><span class="line">max := nums[<span class="number">0</span>] </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123; </span><br><span class="line"><span class="keyword">if</span> nums[i] + nums[i<span class="number">-1</span>] &gt; nums[i] &#123; </span><br><span class="line">nums[i] += nums[i<span class="number">-1</span>] </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> nums[i] &gt; max &#123; </span><br><span class="line">max = nums[i] </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> max </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// -2,1,-3,4,-1,2,1,-5,4</span></span><br><span class="line"><span class="comment">// -2,1,-2,4,3,5,6,1,5</span></span><br></pre></td></tr></table></figure><p>简单来说就是看前一个元素是否大于 0 ，如果符合条件，那么就加到当前位置上</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.152 乘积最大子数组</title>
      <link href="/interview/juan/Blind75/leet152/"/>
      <url>/interview/juan/Blind75/leet152/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/maximum-product-subarray/description/">Leetcode.152 乘积最大子数组</a></p><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>测试用例的答案是一个 <strong>32-位</strong> 整数。</p><p><strong>示例 1:</strong></p><pre><code>输入: nums = [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: nums = [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 的任何前缀或后缀的乘积都 <strong>保证</strong> 是一个 <strong>32-位</strong> 整数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.153 寻找旋转排序数组中的最小值</title>
      <link href="/interview/juan/Blind75/leet153/"/>
      <url>/interview/juan/Blind75/leet153/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">Leetcode.153 寻找旋转排序数组中的最小值</a></p><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [3,4,5,1,2]输出：1解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [4,5,6,7,0,1,2]输出：0解释：原数组为 [0,1,2,4,5,6,7] ，旋转 3 次得到输入数组。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [11,13,15,17]输出：11解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</code></pre><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li><li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li></ul><p>类比 <a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">Leetcode.33 搜索旋转排序数组</a> 也可以用二分查找的思路</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">low, high := <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line">pivot := low + (high - low) / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> nums[pivot] &lt; nums[high] &#123;</span><br><span class="line">high = pivot</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">low = pivot + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[low]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.33 搜索旋转排序数组</title>
      <link href="/interview/juan/Blind75/leet33/"/>
      <url>/interview/juan/Blind75/leet33/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">Leetcode.33 搜索旋转排序数组</a></p><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [`4,5,6,7,0,1,2]`, target = 0输出：4</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [`4,5,6,7,0,1,2]`, target = 3输出：-1</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1], target = 0输出：-1</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><p>二分查找嗷</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> l&lt;=r &#123;</span><br><span class="line">mid=(l+r)/<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= target &lt; nums[mid] &#123;</span><br><span class="line"><span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= nums[mid] &#123;</span><br><span class="line">r = mid - <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = mid + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[<span class="built_in">len</span>(nums) - <span class="number">1</span>] &#123;</span><br><span class="line">l = mid + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r = mid - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路和算法</p><p>对于有序数组，可以使用二分查找的方法查找元素。</p><p>但是这道题中，数组本身不是有序的，进行旋转后只保证了数组的局部是有序的，这还能进行二分查找吗？答案是可以的。</p><p>可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从 6 这个位置分开以后数组变成了 [4, 5, 6] 和 [7, 0, 1, 2] 两个部分，其中左边 [4, 5, 6] 这个部分的数组是有序的，其他也是如此。</p><p>这启示我们可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分：</p><p>如果 [l, mid - 1] 是有序数组，且 target 的大小满足 [nums[l],nums[mid])[\textit{nums}[l],\textit{nums}[mid])[nums[l],nums[mid])，则我们应该将搜索范围缩小至 [l, mid - 1]，否则在 [mid + 1, r] 中寻找。<br>如果 [mid, r] 是有序数组，且 target 的大小满足 (nums[mid+1],nums[r]](\textit{nums}[mid+1],\textit{nums}[r]](nums[mid+1],nums[r]]，则我们应该将搜索范围缩小至 [mid + 1, r]，否则在 [l, mid - 1] 中寻找。</p><p><img src="https://assets.leetcode-cn.com/solution-static/33/33_fig1.png"></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.15 三数之和</title>
      <link href="/interview/juan/Blind75/leet15/"/>
      <url>/interview/juan/Blind75/leet15/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/3sum/description/">Leetcode.15 三数之和</a></p><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。</code></pre><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><p>流程可以参考 <a href="https://leetcode.cn/problems/two-sum/">两数之和</a> 和 <a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/">两数之和 II</a></p><p>设置 a，b，c 三个指针，首先固定 a 指针，可以确定当前目标求和为 - nums[a]<br>在 a 指针后续的位置设置 b 指针，通过 c 指针遍历 b 后面的位置，确定符合的三元组<br>c 指针遍历一轮之后，可以将 b 指针向后移动，直到当前从 a 指针出发的所有三元组都被找到<br>然后再移动 a 指针</p><p>比较关键的点是，结果中的三元组不能重复，那么我们可以通过先排序的方法，在求解过程中提前将重复结果过滤掉</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123; </span><br><span class="line">n := <span class="built_in">len</span>(nums) </span><br><span class="line">sort.Ints(nums) </span><br><span class="line">ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举 a </span></span><br><span class="line"><span class="keyword">for</span> first := <span class="number">0</span>; first &lt; n; first++ &#123; </span><br><span class="line"><span class="comment">// 需要和上一次枚举的数不相同 </span></span><br><span class="line"><span class="keyword">if</span> first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>] &#123; </span><br><span class="line"><span class="keyword">continue</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// c 对应的指针初始指向数组的最右端 </span></span><br><span class="line">third := n - <span class="number">1</span> </span><br><span class="line">target := <span class="number">-1</span> * nums[first] </span><br><span class="line"><span class="comment">// 枚举 b </span></span><br><span class="line"><span class="keyword">for</span> second := first + <span class="number">1</span>; second &lt; n; second++ &#123; </span><br><span class="line"><span class="comment">// 需要和上一次枚举的数不相同 </span></span><br><span class="line"><span class="keyword">if</span> second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>] &#123; </span><br><span class="line"><span class="keyword">continue</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 需要保证 b 的指针在 c 的指针的左侧 </span></span><br><span class="line"><span class="keyword">for</span> second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target &#123; </span><br><span class="line">third-- </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果指针重合，随着 b 后续的增加 </span></span><br><span class="line"><span class="comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环 </span></span><br><span class="line"><span class="keyword">if</span> second == third &#123; </span><br><span class="line"><span class="keyword">break</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> nums[second] + nums[third] == target &#123; </span><br><span class="line">ans = <span class="built_in">append</span>(ans, []<span class="type">int</span>&#123;nums[first], nums[second], nums[third]&#125;) </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> ans </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.11 盛最多水的容器</title>
      <link href="/interview/juan/Blind75/leet11/"/>
      <url>/interview/juan/Blind75/leet11/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/container-with-most-water/description/">Leetcode.11 盛最多水的容器</a></p><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg"></p><pre><code>输入：[1,8,6,2,5,4,8,3,7]输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：height = [1,1]输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= height[i] &lt;= 104</code></li></ul><p>采用双指针方式，每次移动短边<br>移动短边可能变得更好，一定不会变得更坏</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">l, r := <span class="number">0</span>, <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> l&lt;r &#123;</span><br><span class="line">area := min(height[l], height[r]) * (r-l)</span><br><span class="line">ans = max(area, ans)</span><br><span class="line"><span class="keyword">if</span> height[l] &lt;= height[r] &#123;</span><br><span class="line">l += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.1 两数之和</title>
      <link href="/interview/juan/Blind75/leet1/"/>
      <url>/interview/juan/Blind75/leet1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/two-sum/description/">Leetcode.1 两数之和</a></p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [3,2,4], target = 6输出：[1,2]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [3,3], target = 6输出：[0,1]</code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><p>暴力法 O(N^2)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">for</span> first:=<span class="number">0</span>; first&lt;<span class="built_in">len</span>(nums)<span class="number">-1</span>; first++ &#123;</span><br><span class="line"><span class="keyword">for</span> second := first + <span class="number">1</span>; second&lt;<span class="built_in">len</span>(nums); second ++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[first] + nums[second] == target &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;first, second&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈希法 O(N)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">hashTable := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> p, ok := hashTable[target-x]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;p, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hashTable[x] = i</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> Blind75 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>go 八股</title>
      <link href="/interview/go/go-EightPartFrame/"/>
      <url>/interview/go/go-EightPartFrame/</url>
      
        <content type="html"><![CDATA[<h2 id="Sync-map"><a href="#Sync-map" class="headerlink" title="Sync.map"></a>Sync.map</h2><h4 id="golang-中原生的-map-本身是线程不安全的，主要表现在以下方面："><a href="#golang-中原生的-map-本身是线程不安全的，主要表现在以下方面：" class="headerlink" title="golang 中原生的 map 本身是线程不安全的，主要表现在以下方面："></a>golang 中原生的 map 本身是线程不安全的，主要表现在以下方面：</h4><ol><li>对于 map 结构的并发访问，会报错 panic。</li><li>即使通过某种方式不同时写一个 key，在 map 扩容的时候也会有问题，因为 map 的扩容是线程不安全的</li></ol><h4 id="sync-Map-相对-map-的优势："><a href="#sync-Map-相对-map-的优势：" class="headerlink" title="sync.Map 相对 map 的优势："></a>sync.Map 相对 map 的优势：</h4><ol><li>一写多读</li><li>空间换时间 &#x3D; read 和 dirty</li><li>double-checking</li><li>缓存思路</li><li>延时删除</li></ol><h4 id="关于-dirty-的提升"><a href="#关于-dirty-的提升" class="headerlink" title="关于 dirty 的提升"></a>关于 dirty 的提升</h4><p>Map 中维持了一个 int 类型的 <code>misses</code> 每当 Map 未命中 read 时，会将该值自增 1， 当该值大于 dirty 的长度后，dirty 就会被提升为 read，提升之后，dirty 和 misses 会被重置，等下一次插入新值时，会将 read 中未删除的数据复制到 dirty 中。<br>除此之外，执行 <code>Range</code> 时，也会先进行一次提升。</p><h4 id="关于延迟删除"><a href="#关于延迟删除" class="headerlink" title="关于延迟删除"></a>关于延迟删除</h4><p>当执行 <code>Delete</code> 时，如果 read 没有击中， 就会直接从 dirty 中删除，否则如果键值在 read 中，会先将其 Value 的指针（enter.p）标记为 nil, 等下一次执行复制时，这些被标记为 nil 的键值会被重新标记为 expunged，即 enter.p 有三种可能的值：</p><ol><li>nil: 表示 键值已经被删除，但这一版的 read 还没有被复制到 dirty 中，所以 dirty 此时为 nil, 遇到要重新插入这个key时，可以直接修改 read，之后进行复制时，这个最新的值会被同步回 dirty。</li><li>expunged: 表示该键值已经被删除并且经历了复制， dirty 不为 nil， 这时需要同时修改 read 和 dirty， 避免 read 的数据比 dirty 中的数据新，导致下一次提升时丢失新数据。</li><li><code>!= nil</code>: 表示存储的是具体的 value 的指针。</li></ol><p>sync.Map 具有以下结构和方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123; </span><br><span class="line">mu sync.Mutex <span class="comment">// 互斥锁</span></span><br><span class="line">read atomic.Value <span class="comment">// 原子化只读操作</span></span><br><span class="line">dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry <span class="comment">// 新增的 kv 会存储到这里</span></span><br><span class="line">misses <span class="type">int</span> <span class="comment">// 当 read 中查询失败时，misses+=1，当 miss 的数量超过 dirty 时，会触发将 dirty 转化到 read</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 Map 中取出一个 value </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Load(key <span class="keyword">interface</span>&#123;&#125;) (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>) &#123; </span><br><span class="line">read, _ := m.read.Load().(readOnly) </span><br><span class="line"><span class="comment">// 优先从 read 中读取</span></span><br><span class="line">e, ok := read.m[key] </span><br><span class="line"><span class="comment">// 当读不到且 amended = true 时，再互斥的从 dirty 中查找</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; </span><br><span class="line">m.mu.Lock() </span><br><span class="line"><span class="comment">// double-checking， 避免在加锁过程中有其他 goroutine 将 dirty 提升为 read 的情况</span></span><br><span class="line">read, _ = m.read.Load().(readOnly) e, ok = read.m[key] </span><br><span class="line"><span class="comment">// 双重查找后还找不到，再去 dirty 中查找，同时 misses += 1</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; </span><br><span class="line">e, ok = m.dirty[key] <span class="comment">// 修改 misses，尝试提升 dirty </span></span><br><span class="line">m.missLocked() </span><br><span class="line">&#125; </span><br><span class="line">m.mu.Unlock()</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span> !ok &#123; <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span> &#125; </span><br><span class="line"><span class="comment">// 需要注意这里取到的是指向真实 value 的指针，还需要读取出真正的 value</span></span><br><span class="line"><span class="keyword">return</span> e.load() </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> missLocked() &#123; </span><br><span class="line">m.misses++ </span><br><span class="line"><span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 将 dirty 提升为 read </span></span><br><span class="line">m.read.Store(readOnly&#123;m: m.dirty&#125;) </span><br><span class="line"><span class="comment">// 重置相关字段 </span></span><br><span class="line">m.dirty = <span class="literal">nil</span> </span><br><span class="line">m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 Map 中 存入一个 KV 对 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line"><span class="comment">// 优先从 read 中读取</span></span><br><span class="line"><span class="comment">// 如果 read 中找到了，利用 entry 的 tryStore 方法更新 value</span></span><br><span class="line">read, _ := m.read.Load().(readOnly) </span><br><span class="line"><span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁， 二次检查</span></span><br><span class="line">m.mu.Lock() </span><br><span class="line">read, _ = m.read.Load().(readOnly) </span><br><span class="line"><span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line"><span class="comment">// 当对已经存在于 `read` 中的键值对执行删除操作时，而是会把其暂时标记为 `nil`,</span></span><br><span class="line"><span class="comment">// 等 dirty 升级为 read 后再插入新值时会把 read 中标记为 `nil` 的值标记为 `expunged`, </span></span><br><span class="line"><span class="comment">// 而其他的值会被重新复制到 dirty 中，当这时插入刚被删除的键后，就会直接把之前标记为 `expunged` 的键的值赋为新值</span></span><br><span class="line"><span class="keyword">if</span> e.unexpungeLocked() &#123; </span><br><span class="line">m.dirty[key] = e </span><br><span class="line">&#125; </span><br><span class="line">e.storeLocked(&amp;value) </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line"><span class="comment">// 如果 dirty 中找到了，通过 storeLocked 修改 dirty 中的 entry</span></span><br><span class="line">e.storeLocked(&amp;value) </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="comment">// dirty 中也没有，那么就直接插入到 dirty 中</span></span><br><span class="line"><span class="keyword">if</span> !read.amended &#123; </span><br><span class="line"><span class="comment">// 此时如果 amended == false，对应两种情况</span></span><br><span class="line"><span class="comment">// 1. 第一次插入数据，read 和 dirty 都为空，此时需要对 read 进行初始化</span></span><br><span class="line"><span class="comment">// 2. 之前的 dirty 刚刚升级成为 read，此时 dirty 为空，需要将之前有可能存在的已标记删除的进行惰性删除</span></span><br><span class="line">m.dirtyLocked() </span><br><span class="line">m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;) </span><br><span class="line">&#125; </span><br><span class="line">m.dirty[key] = newEntry(value) </span><br><span class="line">&#125; </span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 Map 中存在 key,覆盖并返回 (旧值, true), 否则返回 (新值, false) </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadOrStore(key, value <span class="keyword">interface</span>&#123;&#125;) (actual <span class="keyword">interface</span>&#123;&#125;, loaded <span class="type">bool</span>) </span><br><span class="line"><span class="comment">// 从 Map 中删除一个 KV 对 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line"><span class="comment">// 二次检查 read</span></span><br><span class="line">read, _ := m.read.Load().(readOnly) </span><br><span class="line">e, ok := read.m[key] </span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; </span><br><span class="line">m.mu.Lock() </span><br><span class="line">read, _ = m.read.Load().(readOnly) </span><br><span class="line">e, ok = read.m[key] </span><br><span class="line"><span class="comment">// 不存在，就从 dirty 中删除</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; </span><br><span class="line"><span class="built_in">delete</span>(m.dirty, key) </span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock() </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 存在的话就调用 entry 的 delete() 从 read 中删除</span></span><br><span class="line"><span class="keyword">if</span> ok &#123; e.<span class="built_in">delete</span>() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 Map 中的所有 KV 执行 f, 直到 f 返回 false </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>) &#123; </span><br><span class="line">read, _ := m.read.Load().(readOnly) </span><br><span class="line"><span class="keyword">if</span> read.amended &#123; </span><br><span class="line"><span class="comment">// double-checking</span></span><br><span class="line">m.mu.Lock() </span><br><span class="line">read, _ = m.read.Load().(readOnly) </span><br><span class="line"><span class="keyword">if</span> read.amended &#123; </span><br><span class="line"><span class="comment">// 提升 dirty</span></span><br><span class="line">read = readOnly&#123;m: m.dirty&#125; </span><br><span class="line">m.read.Store(read) </span><br><span class="line">m.dirty = <span class="literal">nil</span> </span><br><span class="line">m.misses = <span class="number">0</span> </span><br><span class="line">&#125; </span><br><span class="line">m.mu.Unlock() </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123; </span><br><span class="line">v, ok := e.load() </span><br><span class="line"><span class="keyword">if</span> !ok &#123; </span><br><span class="line"><span class="keyword">continue</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> !f(k, v) &#123; </span><br><span class="line"><span class="keyword">break</span> </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> dirtyLocked() &#123; </span><br><span class="line"><span class="comment">// 对应情况 1 </span></span><br><span class="line"><span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123; <span class="keyword">return</span> &#125; </span><br><span class="line"><span class="comment">// 情况 2 </span></span><br><span class="line">read, _ := m.read.Load().(readOnly) </span><br><span class="line">m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry, <span class="built_in">len</span>(read.m)) </span><br><span class="line"><span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line"><span class="comment">// 没有被删除，复制到 dirty 中 </span></span><br><span class="line"><span class="keyword">if</span> !e.tryExpungeLocked() &#123; m.dirty[k] = e &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123; </span><br><span class="line"><span class="comment">// m 和 dirty 中的 value 是同一块内存 </span></span><br><span class="line">m <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry </span><br><span class="line"><span class="comment">// 如果 dirty 和 read 中的数据不一致时，amended 为 true。若此时 read 中读不到，就要去 dirty 中查询</span></span><br><span class="line">amended <span class="type">bool</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read 和 dirty 中的 entry 指向的是同一地址，修改会同时生效；减少空间浪费</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">p unsafe.Pointer <span class="comment">// *interface&#123;&#125; </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> load() (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>) &#123; </span><br><span class="line">p := atomic.LoadPointer(&amp;e.p) </span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123; <span class="comment">// 由于 Map 的延时删除策略，出现这两种情况均代表 kv 已经不存在了</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> *(*<span class="keyword">interface</span>&#123;&#125;)(p), <span class="literal">true</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> <span class="built_in">delete</span>() (hadValue <span class="type">bool</span>) &#123; </span><br><span class="line"><span class="comment">// 这里不是真的删除嗷，只是将对应 value 的 p 指向了 nil。直到下一次 dirty 升级时才会真正的删除，aka Map 的延时删除策略</span></span><br><span class="line"><span class="keyword">for</span> &#123; p := atomic.LoadPointer(&amp;e.p) </span><br><span class="line"><span class="comment">// 不存在或被删除</span></span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125; </span><br><span class="line"><span class="comment">// CAS 将 enter.p 指向 nil </span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryStore(i *<span class="keyword">interface</span>&#123;&#125;) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123; </span><br><span class="line">p := atomic.LoadPointer(&amp;e.p) <span class="comment">// 被删除 </span></span><br><span class="line"><span class="keyword">if</span> p == expunged &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125; <span class="comment">// 比较 e.p 与 p, 相等赋新值，否则自旋比较 </span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> storeLocked(i *<span class="keyword">interface</span>&#123;&#125;) &#123; </span><br><span class="line">atomic.StorePointer(&amp;e.p, unsafe.Pointer(i)) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用来判断 `entry` 是否被删除，当 `entry.p == nil` 时，说明这个 value 被标记为删除，这时会把它重新标记为 `expunged` 返回 true， 否则返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryExpungeLocked() (isExpunged <span class="type">bool</span>) &#123; </span><br><span class="line">p := atomic.LoadPointer(&amp;e.p) </span><br><span class="line"><span class="keyword">for</span> p == <span class="literal">nil</span> &#123; </span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, <span class="literal">nil</span>, expunged) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">&#125; </span><br><span class="line">p = atomic.LoadPointer(&amp;e.p) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> p == expunged </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>比较常见的问题是 slice 和普通 array 的区别：array 是值类型；slice 是引用类型，指向底层的数组地址<br>子切片：引用的底层数组是一致的，但是 slice 本身对应的内存地址不一致；当子切片长度超过原切片的时候，会产生扩容，替换掉原来的底层数组</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><ol><li>Channel本质上是由三个FIFO（First In FirstOut，先进先出）队列组成的用于协程之间传输数据的协程安全的通道；FIFO的设计是为了保障公平，让事情变得简单，原则是让等待时间最长的协程最有资格先从channel发送或接收数据；</li><li>三个FIFO队列依次是buf循环队列，sendq待发送者队列，recvq待接收者队列。buf循环队列是大小固定的用来存放channel接收的数据的队列；sendq待发送者队列，用来存放等待发送数据到channel的goroutine的双向链表，recvq待接收者队列，用来存放等待从channel读取数据的goroutine的双向链表；sendq和recvq可以认为不限大小；</li><li>跟函数调用传参本质都是传值一样，channel传递数据的本质就是值拷贝，引用类型数据的传递也是地址拷贝；有从缓冲区buf地址拷贝数据到接收者receiver栈内存地址，也有从发送者sender栈内存地址拷贝数据到缓冲区buf；</li><li>Channel里面参数的修改不是并发安全的，包括对三个队列及其他参数的访问，因此需要加锁，本质上，channel就是一个有锁队列；</li><li>Channel 的性能跟 sync.Mutex 差不多，没有谁比谁强。Go官方之所以推荐使用Channel进行并发协程的数据交互，是因为channel的设计理念能让程序变得简单，在大型程序、高并发复杂的运行状况中也是如此。</li></ol><p>关注下方代码 <code>makechan</code> 中 <code>switch-case</code> 相关语句，可以发现当存储在 buf 中的元素不包含指针时，hchan 中也不包含 GC 关心的指针。buf 指向一段相同元素类型的内存，elemtype 固定不变。受到垃圾回收器的限制，指针类型的缓冲 buf 需要单独分配内存。<br>channel 本身是引用类型，其创建全部调用的是 mallocgc()，在<em>堆</em>上开辟的内存空间，说明 channel 本身会被 GC 自动回收。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123; </span><br><span class="line">qcount <span class="type">uint</span> <span class="comment">// 队列中所有数据总数 </span></span><br><span class="line">dataqsiz <span class="type">uint</span> <span class="comment">// 循环队列大小 </span></span><br><span class="line">buf unsafe.Pointer <span class="comment">// 指向循环队列的指针 </span></span><br><span class="line">elemsize <span class="type">uint16</span> <span class="comment">// 循环队列中元素的大小 </span></span><br><span class="line">closed <span class="type">uint32</span> <span class="comment">// chan是否关闭的标识 </span></span><br><span class="line">elemtype *_type <span class="comment">// 循环队列中元素的类型 </span></span><br><span class="line">sendx <span class="type">uint</span> <span class="comment">// 已发送元素在循环队列中的位置 </span></span><br><span class="line">recvx <span class="type">uint</span> <span class="comment">// 已接收元素在循环队列中的位置 </span></span><br><span class="line">recvq waitq <span class="comment">// 等待接收的goroutine的等待队列 </span></span><br><span class="line">sendq waitq <span class="comment">// 等待发送的goroutine的等待队列 </span></span><br><span class="line">lock mutex <span class="comment">// 控制chan并发访问的互斥锁 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123; </span><br><span class="line">elem := t.elem </span><br><span class="line"><span class="comment">// 检查数据项大小不能超过 64KB </span></span><br><span class="line"><span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123; throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>) &#125; <span class="comment">// 检查内存对齐是否正确 </span></span><br><span class="line"><span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123; </span><br><span class="line">throw(<span class="string">&quot;makechan: bad alignment&quot;</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 缓冲区大小检查，判断是否溢出 </span></span><br><span class="line">mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size)) </span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123; </span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>)) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> c *hchan </span><br><span class="line"><span class="keyword">switch</span> &#123; </span><br><span class="line"><span class="comment">// 当队列或者元素大小为 0 时，调用 mallocgc() 在堆上为 channel 开辟一段大小为 hchanSize 的内存空间；</span></span><br><span class="line"><span class="keyword">case</span> mem == <span class="number">0</span>: </span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>)) </span><br><span class="line"><span class="comment">// 竞态检查，利用这个地址进行同步操作. </span></span><br><span class="line">c.buf = c.raceaddr() </span><br><span class="line"><span class="comment">// 当元素类型不是指针类型时，调用 mallocgc() 在堆上为 channel 和底层 buf 缓冲区数组开辟一段大小为 hchanSize + mem 连续的内存空间；</span></span><br><span class="line"><span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>: </span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>)) </span><br><span class="line"><span class="comment">// 表示hchan后面在内存里紧跟着就是buf环形队列 </span></span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize) </span><br><span class="line"><span class="comment">// 默认情况元素类型中有指针类型，调用 mallocgc() 在堆上分别为 channel 和 buf 缓冲区分配内存。</span></span><br><span class="line"><span class="keyword">default</span>:  </span><br><span class="line">c = <span class="built_in">new</span>(hchan) c.buf = mallocgc(mem, elem, <span class="literal">true</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 设置元素个数、元素类型给创建的chan </span></span><br><span class="line">c.elemsize = <span class="type">uint16</span>(elem.size) </span><br><span class="line">c.elemtype = elem </span><br><span class="line">c.dataqsiz = <span class="type">uint</span>(size) </span><br><span class="line">lockInit(&amp;c.lock, lockRankHchan) </span><br><span class="line"><span class="keyword">if</span> debugChan &#123; </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.size, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> c </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><ol><li>首先 select 非阻塞的发送，需要判断两种情况；</li><li>一般的阻塞调用，先判断 recvq 等待接收队列是否为空，如果不为空，那么说明缓冲区为空 or 无缓冲 Channel；</li><li>如果 recvq 有接收者，则属于缓冲区空，从 recvq 中取出一个 goroutine，然后写入数据，接着唤醒 goroutine，结束发送过程；</li><li>如果缓冲区有空位，写入数据到缓冲区，完成发送；</li><li>如果缓冲区满，将发送数据的 goroutine 放到 sendq 中，进入睡眠，等待唤醒。<h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h4></li><li>也是先判断select这种非阻塞接收的两种情况（block为false）；然后是加锁进行阻塞调用的逻辑；</li><li>同步接收：如果发送者队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出一个 goroutine，读取消息，唤醒该 goroutine，结束读取；</li><li>同步接收：如果发送者队列 sendq 不为空，有缓冲区，说明缓冲区已经满了，移动 recvx 指针的位置，取出一个数据，同时从 sendq 中取出一个 goroutine，拷贝里面的数据到 buf 中，结束读取；</li><li>异步接收：如果发送者队列 sendq 为空，且缓冲区有数据（有缓冲 channel），直接从缓冲区取出数据，结束读取；</li><li>阻塞接收：如果发送者队列 sendq 为空，且缓冲区无数据（无缓冲 channel），就将当前的 goroutine 加入 recvq，进入睡眠等待唤醒。</li></ol><h4 id="关闭-Chan"><a href="#关闭-Chan" class="headerlink" title="关闭 Chan"></a>关闭 Chan</h4><ol><li>判断 channel 当前状态，如果 channel &#x3D;&#x3D; nil || channel 已经关闭，会直接 panic；</li><li>关闭的主要工作是释放所有的接收者和发送者：先回收接收者，因为从一个关闭的 channel 中读数据，不会发生 panic，顶多读到一个默认零值。再回收发送者。注意这里可能会产生 panic，因为往一个关闭的 channel 中发送数据，会产生 panic。</li></ol><h4 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(data <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123; </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123; </span><br><span class="line">data &lt;- i </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 这里记得要关闭channel，不然会发生阻塞，因为消费者的数量没有限制， </span></span><br><span class="line"><span class="comment">// 当消费者从空的channel取值的时候会阻塞 </span></span><br><span class="line"><span class="built_in">close</span>(data) </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(data &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123; </span><br><span class="line"><span class="keyword">defer</span> wg.Done() </span><br><span class="line"><span class="keyword">for</span> &#123; </span><br><span class="line">v, ok := &lt;-data </span><br><span class="line"><span class="keyword">if</span> !ok &#123; </span><br><span class="line"><span class="keyword">break</span> </span><br><span class="line">&#125; </span><br><span class="line">fmt.Println(<span class="string">&quot;---:&quot;</span>, v, <span class="string">&quot; ===:&quot;</span>, ok) </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">data := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) </span><br><span class="line"><span class="keyword">go</span> producer(data) </span><br><span class="line">wg.Add(<span class="number">1</span>) </span><br><span class="line"><span class="keyword">go</span> consumer(data) </span><br><span class="line">wg.Wait() </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// Output // ---: 0 ===: true // ---: 1 ===: true // ---: 2 ===: true // ---: 3 ===: true</span></span><br></pre></td></tr></table></figure><h4 id="发布订阅模型"><a href="#发布订阅模型" class="headerlink" title="发布订阅模型"></a>发布订阅模型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Broker <span class="keyword">struct</span> &#123; </span><br><span class="line">consumers []*Consumer </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">type</span> Consumer <span class="keyword">struct</span> &#123; </span><br><span class="line">ch <span class="keyword">chan</span> <span class="type">string</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Broker)</span></span> produce(msg <span class="type">string</span>) &#123; </span><br><span class="line"><span class="comment">// 轮询给消费者发送消息 </span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> b.consumers &#123; </span><br><span class="line">v.ch &lt;- msg </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Broker)</span></span> subscribe(consumer *Consumer) &#123; </span><br><span class="line">b.consumers = <span class="built_in">append</span>(b.consumers, consumer) </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMq1</span><span class="params">(t *testing.T)</span></span> &#123; </span><br><span class="line"><span class="comment">// 初始化一个Broker节点 </span></span><br><span class="line">b := &amp;Broker&#123; </span><br><span class="line">consumers: <span class="built_in">make</span>([]*Consumer, <span class="number">0</span>, <span class="number">4</span>), </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 创建2个消费者 </span></span><br><span class="line">consumer1 := &amp;Consumer&#123; ch: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>), &#125; </span><br><span class="line">consumer2 := &amp;Consumer&#123; ch: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>), &#125; </span><br><span class="line"><span class="comment">// 这2个消费者订阅Broker </span></span><br><span class="line">b.subscribe(consumer1) </span><br><span class="line">b.subscribe(consumer2) </span><br><span class="line"><span class="comment">// 生产者发送一个消息 </span></span><br><span class="line">b.produce(<span class="string">&quot;一条消息&quot;</span>) </span><br><span class="line"><span class="comment">// 2个消费者拿到了刚才生产者发送的消息 </span></span><br><span class="line">fmt.Println(&lt;-consumer1.ch) </span><br><span class="line">fmt.Println(&lt;-consumer2.ch) </span><br><span class="line"><span class="comment">// Output </span></span><br><span class="line"><span class="comment">// 一条消息 </span></span><br><span class="line"><span class="comment">// 一条消息 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环打印abc"><a href="#循环打印abc" class="headerlink" title="循环打印abc"></a>循环打印abc</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">5</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   wg := sync.WaitGroup&#123;&#125;  </span><br><span class="line">   chanA := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)  </span><br><span class="line">   chanB := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">2</span>)  </span><br><span class="line">   chanC := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">3</span>)  </span><br><span class="line">   chanA &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  </span><br><span class="line">   wg.Add(<span class="number">3</span>)  </span><br><span class="line">   <span class="keyword">go</span> printA(&amp;wg, chanA, chanB)  </span><br><span class="line">   <span class="keyword">go</span> printB(&amp;wg, chanB, chanC)  </span><br><span class="line">   <span class="keyword">go</span> printC(&amp;wg, chanC, chanA)  </span><br><span class="line">   wg.Wait()  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printA</span><span class="params">(wg *sync.WaitGroup, chanA <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, chanB <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">defer</span> wg.Done()  </span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;  </span><br><span class="line">      &lt;-chanA  </span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;A&quot;</span>)  </span><br><span class="line">      chanB &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printB</span><span class="params">(wg *sync.WaitGroup, chanB <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, chanC <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">defer</span> wg.Done()  </span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;  </span><br><span class="line">      &lt;-chanB  </span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;B&quot;</span>)  </span><br><span class="line">      chanC &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printC</span><span class="params">(wg *sync.WaitGroup, chanC <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, chanA <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">defer</span> wg.Done()  </span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;  </span><br><span class="line">      &lt;-chanC  </span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;C&quot;</span>)  </span><br><span class="line">      chanA &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原生-Map"><a href="#原生-Map" class="headerlink" title="原生 Map"></a>原生 Map</h2><p>Golang 中 map 是一个指针，占用 8 个字节。当使用 make 创建 map 时，底层调用的是 makemap() 函数，makemap() 函数返回的是一个指针，因为返回的是指针，所以 map 作为参数的时候，函数内部能修改map。<br>golang 中 map 底层使用的是哈希查找表，用链表来解决哈希冲突。每个 map 的底层结构是 hmap，是由若干个结构为 bmap 的 bucket 组成的数组，每个 bucket 底层都采用链表结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">count      <span class="type">int</span>            <span class="comment">// map中元素的数量，调用len()直接返回此值</span></span><br><span class="line">flags      <span class="type">uint8</span>          <span class="comment">// 状态标识符，key和value是否包指针、是否正在扩容、是否已经被迭代</span></span><br><span class="line">B          <span class="type">uint8</span>          <span class="comment">// map中桶数组的数量，桶数组的长度的对数，len(buckets) == 2^B，可以最多容纳 6.5 * 2 ^ B 个元素，6.5为装载因子</span></span><br><span class="line">noverflow  <span class="type">uint16</span>         <span class="comment">// 溢出桶的大概数量，当B小于16时是准确值，大于等于16时是大概的值</span></span><br><span class="line">hash0      <span class="type">uint32</span>         <span class="comment">// 哈希种子，用于计算哈希值，为哈希函数的结果引入一定的随机性</span></span><br><span class="line">buckets    unsafe.Pointer <span class="comment">// 指向桶数组的指针，长度为 2^B ，如果元素个数为0，就为 nil</span></span><br><span class="line">oldbuckets unsafe.Pointer <span class="comment">// 指向一个旧桶数组，用于扩容，它的长度是当前桶数组的一半</span></span><br><span class="line">nevacuate  <span class="type">uintptr</span>        <span class="comment">// 搬迁进度，小于此地址的桶数组迁移完成</span></span><br><span class="line">extra      *mapextra      <span class="comment">// 可选字段，用于gc，指向所有的溢出桶，避免gc时扫描整个map，仅扫描所有溢出桶就足够了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 溢出桶结构</span></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">overflow    *[]*bmap <span class="comment">// 指针数组，指向所有溢出桶</span></span><br><span class="line">oldoverflow *[]*bmap <span class="comment">// 指针数组，发生扩容时，指向所有旧的溢出桶</span></span><br><span class="line">nextOverflow *bmap <span class="comment">// 指向所有溢出桶中下一个可以使用的溢出桶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bmap的结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [bucketCnt]<span class="type">uint8</span>    <span class="comment">// bucketCnt=8，// 存放key哈希值的高8位，用于决定kv键值对放在桶内的哪个位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上编辑期间会动态生成一个新的结构体</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">topbits  [<span class="number">8</span>]<span class="type">uint8</span>     <span class="comment">// 存放key哈希值的高8位，用于决定kv键值对放在桶内的哪个位置</span></span><br><span class="line">keys     [<span class="number">8</span>]keytype   <span class="comment">// 存放key的数组</span></span><br><span class="line">values   [<span class="number">8</span>]valuetype <span class="comment">// 存放value的数组</span></span><br><span class="line">pad      <span class="type">uintptr</span>      <span class="comment">// 用于对齐内存</span></span><br><span class="line">overflow <span class="type">uintptr</span>      <span class="comment">// 指向下一个桶，即溢出桶，拉链法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buckets是一个bmap数组，数组的长度就是 2^B。每个bucket固定包含8个key和value，实现上面是一个固定的大小连续内存块，分成四部分：tophash 值，8个key值，8个value值，指向下个bucket的指针。<br>tophash 值用于快速查找key是否在该bucket中，当插入和查询运行时都会使用哈希哈数对key做哈希运算，获取一个hashcode，取高8位存放在bmap tophash字段中。<br>桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置）<br>桶结构的很多字段得在编译时才会动态生成，比如key和values等<br>桶结构中，之所以所有的key放一起，所有的value放一起，而不是key&#x2F;value一对对的一起存放，目的便是在某些情况下可以省去pad字段，节省内存空间。由于内存对齐的原因，key0&#x2F;value0&#x2F;key1&#x2F;value1… 这样的形式可能需要更多的补齐空间，比如 map[int64]int8 ，1字节的value后面需要补齐7个字节才能保证下一个key是 int64 对齐的。<br>golang中的map使用的内存是不会收缩的，只会越用越多。</p><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><ol><li>触发 map 扩容的时机（插入、删除key）<ul><li>当装载因子超过6.5时，扩容一倍，属于增量扩容；</li><li>当使用的溢出桶过多时，重新分配一样大的内存空间，属于等量扩容；（实际上没有扩容，主要是为了回收空闲的溢出桶，节省空间，提高 map 的查找和插入效率）</li></ul><ol><li>为什么会出现这种情况？<br>   这种情况可能是因为 map 删除的特性导致的。当我们不断向哈希表中插入数据，并且将他们又全部删除时，其内存占用并不会减少，因为删除只是将桶对应位置的 tophash 置 nil 而已。<br>   这种情况下，就会不断的积累溢出桶造成内存泄露，为了解决这种情况，采用了等量扩容的机制，一旦哈希表中出现了过多的溢出桶，会创建新桶保存数据，gc 会清理掉老的溢出桶，从而避免内存泄露。</li><li>如何定义溢出桶是否太多需要等量扩容呢？两种情况：<ul><li>当 B 小于 15时，溢出桶的数量超过 2^B，属于溢出桶数量太多，需要等量扩容；</li><li>当 B 大于等于 15 时，溢出桶数量超过 2^15，属于溢出桶数量太多，需要等量扩容。</li></ul></li></ol></li><li>扩容策略（怎么扩容？）<br>  Go 会创建一个新的 buckets 数组，新的 buckets 数组的容量是旧buckets数组的两倍（或者和旧桶容量相同），将原始桶数组中的所有元素重新散列到新的桶数组中。这样做的目的是为了使每个桶中的元素数量尽可能平均分布，以提高查询效率。<br>  旧的 buckets 数组不会被直接删除，而是会把原来对旧数组的引用去掉，让 GC 来清除内存。<br>  在 map 进行扩容迁移的期间，不会触发第二次扩容。只有在前一个扩容迁移工作完成后，map 才能进行下一次扩容操作。</li><li>搬迁策略<br>  由于 map 扩容需要将原有的 kv 键值对搬迁到新的内存地址，如果一下子全部搬完，会非常的影响性能。go 中 map 的扩容采用渐进式的搬迁策略，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket，将搬迁的O(N)开销均摊到O(1)的赋值和删除操作上。<br>  hashGrow() 只是分配了新的 buckets，并将老 buckets 挂在到 oldbuckets 字段上。<br>  而且实际的搬迁并不在 hashGrow() 而是在 growWork() 函数中，而调用 growWork() 函数的动作是在 mapassign 和 mapdelete 函数中，所以真正的‘搬迁’操作被离散在了 map 插入修改、删除 key 的动作中。会尝试检查 oldbucket，有待执行的数据，则‘搬迁’。</li></ol><h2 id="Sync-Mutex"><a href="#Sync-Mutex" class="headerlink" title="Sync.Mutex"></a>Sync.Mutex</h2><h4 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h4><p>当一个 goroutine 持有锁时，后续的 goroutine 会以先进先出的方式排队等待，当锁被释放时，队列中第一个 goroutine 会被唤醒。但是它需要和新到来的 goroutine 争夺锁，由于新来的 goroutine 已经在 CPU 中，刚刚唤醒的大概率会竞争失败，重新被放到队首。这种情况有可能导致 goroutine 迟迟不能被执行而被“饿死”</p><h4 id="饥饿模式"><a href="#饥饿模式" class="headerlink" title="饥饿模式"></a>饥饿模式</h4><p>为了解决“饿死”的问题，如果一个等待的 goroutine 超过 1 ms (starvationThresholdNs) 没有得到锁，这个锁就会被转换为饥饿模式。饥饿模式下，锁会直接交给队列中的第一个 goroutine，而新来的 goroutine 会放到队尾等待。正常状态下的性能是高于饥饿模式的，所以在大部分情况下，还是应该回到正常模式去的。<br>当队列中最后一个 goroutine 被执行或者它的等待时间低于 1 ms 时，会将该锁的状态切换回正常模式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123; </span><br><span class="line"><span class="comment">// +---------------------------------+-----------+</span></span><br><span class="line"><span class="comment">// |        WaitersCount             |  status   | </span></span><br><span class="line"><span class="comment">// +---------------------------------+-----------+ </span></span><br><span class="line"><span class="comment">// &lt;-----------+ 29 +---------------&gt; &lt;--+ 3 +---&gt;</span></span><br><span class="line">state <span class="type">int32</span> <span class="comment">// 锁状态，其中低三位用来表示锁状态，高 29 位用来记录等待当前互斥锁的 goroutine 个数</span></span><br><span class="line">sema <span class="type">uint32</span> <span class="comment">// 控制锁状态的信号量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ( </span><br><span class="line">mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 0001 表示互斥锁处于锁定状态 </span></span><br><span class="line">mutexWoken <span class="comment">// 0010 表示从正常模式被唤醒 </span></span><br><span class="line">mutexStarving <span class="comment">// 0100 饥饿模式 </span></span><br><span class="line">mutexWaiterShift = <span class="literal">iota</span> <span class="comment">// 3 表示除 WaitersCount 外，状态占用了三个 bite </span></span><br><span class="line">starvationThresholdNs = <span class="number">1e6</span> <span class="comment">// 饥饿的阈值， 1ms </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>通过 CAS 判断 <code>m.state == 0</code> 时，意味着当前锁处于正常的解锁状态，只需要将锁设置为 <code>mutexLocked</code> 即可，否则就需要进入 <code>lockSlow</code> 通过自旋等方式等待锁释放。<code>lockslow</code> 大致分为以下几个部分：</p><ol><li>判断是否可以自旋：自旋需要满足两个条件：<ul><li>处于正常模式，且锁已经被锁定</li><li><code>runtime_canSpin</code> 返回 true:<ul><li>运行在多 CPU 的机器上；</li><li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li><li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li></ul></li></ul></li><li>一旦进入自旋，会通过 <code>runtime_doSpin</code> ,去执行 30 次的 <code>PAUSE</code> 指令，该指令只会占用 CPU 并消耗 CPU 时间，一旦不满足上面的两个条件了，就会去计算当前锁的最新状态，导致其不满足的原因有很多，如：<ul><li>其他 goroutine 已经释放锁</li><li>其他 goroutine 导致该锁进入饥饿模式</li><li>自旋次数超过 4 次</li></ul></li><li>计算和更新状态其实就是去更新 <code>state</code> 中的四个值；一旦计算完毕后，通过 CAS 尝试更新<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123; </span><br><span class="line"><span class="comment">// Fast path: grab unlocked mutex. </span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123; </span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123; </span><br><span class="line">race.Acquire(unsafe.Pointer(m)) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// Slow path (outlined so that the fast path can be inlined) </span></span><br><span class="line">m.lockSlow() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123; </span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123; </span><br><span class="line">_ = m.state race.Release(unsafe.Pointer(m)) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果 m.state - mutexLocked == 0 说明没人等待该锁，同时该锁处于正常状态 </span></span><br><span class="line"><span class="comment">// 这时可以快速解锁，即锁状态会直接赋成 0 </span></span><br><span class="line"><span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked) </span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123; </span><br><span class="line"><span class="comment">// 否则则需要慢速解锁 </span></span><br><span class="line">m.unlockSlow(<span class="built_in">new</span>) </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) &#123; </span><br><span class="line"><span class="comment">// 如果锁没锁定，直接抛出异常 </span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123; </span><br><span class="line">throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 正常模式下 </span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123; </span><br><span class="line">old := <span class="built_in">new</span> </span><br><span class="line"><span class="keyword">for</span> &#123; </span><br><span class="line"><span class="comment">// 如果没有其他等待者或者锁不处于空闲状态，直接返回，不需要唤醒其他等待着 </span></span><br><span class="line"><span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123; </span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 唤醒新的等待者 </span></span><br><span class="line"><span class="comment">// 等待者减一，设置唤醒标志 woken </span></span><br><span class="line"><span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken </span><br><span class="line"><span class="comment">// 设置 state, 唤醒一个阻塞着的 goroutine </span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123; </span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>) </span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 设置失败，重新获取状态设置 </span></span><br><span class="line">old = m.state </span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 饥饿模式下，直接唤醒队首的 goroutine，这时 mutexLocked 位依然是 0 </span></span><br><span class="line"><span class="comment">// 但由于处在饥饿状态下，锁不会被其他新来的 goroutine 抢占 </span></span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>) </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">// Context 提供跨越API的截止时间获取，取消信号，以及请求范围值的功能。 </span></span><br><span class="line"><span class="comment">// 它的这些方案在多个 goroutine 中使用是安全的 </span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;     </span><br><span class="line"><span class="comment">// 如果设置了截止时间，这个方法ok会是true，并返回设置的截止时间  </span></span><br><span class="line">Deadline() (deadline time.Time, ok <span class="type">bool</span>)     </span><br><span class="line"><span class="comment">// 如果 Context 超时或者主动取消返回一个关闭的channel，如果返回的是nil，表示这个     </span></span><br><span class="line"><span class="comment">// context 永远不会关闭，比如：Background()  </span></span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;     </span><br><span class="line"><span class="comment">// 返回发生的错误  </span></span><br><span class="line">Err() <span class="type">error</span>     </span><br><span class="line"><span class="comment">// 它的作用就是传值  </span></span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用方法</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;Goroutine canceled&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Working...&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(ctx)</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">cancel()</span><br><span class="line"></span><br><span class="line">ctx := context.Background()  </span><br><span class="line">fmt.Printf(<span class="string">&quot;ctx: %p \n&quot;</span>, &amp;ctx)  <span class="comment">// ctx: 0xc0000103f0 </span></span><br><span class="line">ctx1 := ctx  <span class="comment">// 深拷贝</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;ctx1: %p \n&quot;</span>, &amp;ctx1) <span class="comment">// ctx1: 0xc000010400 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><h4 id="1、浅拷贝"><a href="#1、浅拷贝" class="headerlink" title="1、浅拷贝"></a>1、浅拷贝</h4><p>浅拷贝是指对地址的拷贝<br>浅拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化，释放内存地址时，同时释放内存地址<br>引用类型的都是浅拷贝：<code>slice</code>、<code>map</code>、<code>function</code><br>浅拷贝的特点：</p><ul><li>拷贝的时候仅仅拷贝地址，地址指向的都是同一个值</li><li>在<code>a</code>中修改，则<code>b</code>中也跟着变化</li><li>内存销毁是一致的</li></ul><h4 id="2、深拷贝"><a href="#2、深拷贝" class="headerlink" title="2、深拷贝"></a>2、深拷贝</h4><p>深拷贝是指将地址指向的值进行拷贝<br>深拷贝的是数据本身，创造一个一样的新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值。既然内存地址不同，释放内存地址时，可分别释放<br>值类似的都是深拷贝：<code>int</code>、<code>float</code>、<code>bool</code>、<code>array</code>、<code>struct</code><br>深拷贝的特点：</p><ul><li>复制的时候会新创建一个对象</li><li>指向完全不同的内存地址</li><li>修改是互不影响的<br>通过指针求值，将值拷贝实现，修改拷贝的值不影响原来的值<h4 id="3、结构体的深拷贝"><a href="#3、结构体的深拷贝" class="headerlink" title="3、结构体的深拷贝"></a>3、结构体的深拷贝</h4>默认情况下，结构体类型中的字段是值类型，拷贝时都是深拷贝<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Per <span class="keyword">struct</span> &#123; </span><br><span class="line">Name <span class="type">string</span> </span><br><span class="line">Age <span class="type">int</span> </span><br><span class="line">HouseIds [<span class="number">2</span>]<span class="type">int</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">p1 := Per&#123; Name: <span class="string">&quot;ssgeek&quot;</span>, Age: <span class="number">24</span>, HouseIds: [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">22</span>, <span class="number">33</span>&#125;, &#125; </span><br><span class="line">p2 := p1 </span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p1, &amp;p1) <span class="comment">// &#123;ssgeek 24 [22 33]&#125; 0xc000180030 </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p2, &amp;p2) <span class="comment">// &#123;ssgeek 24 [22 33]&#125; 0xc000180060 </span></span><br><span class="line">p2.Age = <span class="number">19</span> </span><br><span class="line">p2.Name = <span class="string">&quot;likui&quot;</span> </span><br><span class="line">p2.HouseIds[<span class="number">1</span>] = <span class="number">44</span> </span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p1, &amp;p1) <span class="comment">// &#123;ssgeek 24 [22 33]&#125; 0xc000098180 </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p2, &amp;p2) <span class="comment">// &#123;likui 19 [22 44]&#125; 0xc0000981b0 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、结构体的浅拷贝"><a href="#4、结构体的浅拷贝" class="headerlink" title="4、结构体的浅拷贝"></a>4、结构体的浅拷贝</h4>使用指针进行浅拷贝，浅拷贝中，可以看到<code>p1</code>和<code>p2</code>的内存地址是相同的，修改其中一个对象的属性时，另一个也会产生变化<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span> </span><br><span class="line"><span class="keyword">type</span> Per <span class="keyword">struct</span> &#123; </span><br><span class="line">Name <span class="type">string</span> </span><br><span class="line">Age <span class="type">int</span> </span><br><span class="line">HouseIds [<span class="number">2</span>]<span class="type">int</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">p1 := Per&#123; Name: <span class="string">&quot;ssgeek&quot;</span>, Age: <span class="number">24</span>, HouseIds: [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">22</span>, <span class="number">33</span>&#125;, &#125; </span><br><span class="line">p2 := &amp;p1 </span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p1, &amp;p1) <span class="comment">// &#123;ssgeek 24 [22 33]&#125; 0xc000076180 </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p2, p2) <span class="comment">// &amp;&#123;ssgeek 24 [22 33]&#125; 0xc000076180 </span></span><br><span class="line">p2.Age = <span class="number">19</span> </span><br><span class="line">p2.Name = <span class="string">&quot;likui&quot;</span> </span><br><span class="line">p2.HouseIds[<span class="number">1</span>] = <span class="number">44</span> </span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p1, &amp;p1) <span class="comment">// &#123;likui 19 [22 44]&#125; 0xc000076180 </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p2, p2) <span class="comment">// &amp;&#123;likui 19 [22 44]&#125; 0xc000076180 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、结构体值类型的浅拷贝"><a href="#5、结构体值类型的浅拷贝" class="headerlink" title="5、结构体值类型的浅拷贝"></a>5、结构体值类型的浅拷贝</h4><p>使用<code>new</code>函数实现值类型的浅拷贝<br>值类型的默认是深拷贝，想要实现值类型的浅拷贝，一般是两种方法</p><ul><li>使用指针</li><li>使用new函数（new函数返回的是指针）</li></ul><h4 id="6、结构体引用类型的浅拷贝"><a href="#6、结构体引用类型的浅拷贝" class="headerlink" title="6、结构体引用类型的浅拷贝"></a>6、结构体引用类型的浅拷贝</h4><p>结构体默认是深拷贝，但如果结构体中包含map、slice等这些引用类型，默认也还是浅拷贝<br>map是引用类型，引用类型浅拷贝是默认的情况</p><h4 id="7、结构体引用类型的深拷贝"><a href="#7、结构体引用类型的深拷贝" class="headerlink" title="7、结构体引用类型的深拷贝"></a>7、结构体引用类型的深拷贝</h4><p>结构体中含有引用类型的字段，那么这个字段就是浅拷贝，但是往往希望的是深拷贝，解决方案如下</p><ul><li>方法一：挨个把可导致浅拷贝的引用类型字段自行赋值。赋值后，修改值就相互不影响了</li><li>方法二：使用<code>json</code>或反射。简单来说：<code>json</code>将引用类型的数据进行<code>dump</code>，<code>dump</code>后就和原来的引用类型没有关系了</li></ul><h2 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h2><h4 id="Go-协程为什么快？"><a href="#Go-协程为什么快？" class="headerlink" title="Go 协程为什么快？"></a>Go 协程为什么快？</h4><p>这就要从进程，线程，协程三者的关系讲起。<br>最早的进程时代，是单 CPU 单进程，一切皆是串行执行；到了多进程&#x2F;线程时代，当一个进程阻塞时，切换到另外等候的进程，时间片轮转法保证了等待的进程都能够被运行，但是进程间的调度会占用CPU大部分时间；而到了高并发的场景下，为每个任务都去创建一个线程显然是不合理的，那么，golang 将原来的线程分为了两部分，一个是用户级别的线程（轻量级的线程，运行在用户态，即 goroutine），一个是内核级的线程（即一般意义上的线程，运行在内核态），这样，对于协程的切换和调度都是在用户态进行，不涉及内核级别的调度，因此这是 goroutine 能够很好地支持高并发的场景的基础。</p><ul><li>进程: 进程是具有一定独立功能的程序，进程是系统资源分配和调度的最小单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</li><li>线程: 线程是进程的一个实体,线程是内核态,而且是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</li><li>程: 协程是一种用户态的轻量级线程，协程的调度完全是由用户来控制的。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</li></ul><h4 id="调度器的三个基本对象："><a href="#调度器的三个基本对象：" class="headerlink" title="调度器的三个基本对象："></a>调度器的三个基本对象：</h4><ul><li><p>G（Goroutine），代表协程，go关键字创建的对象</p></li><li><p>M（Work Thread），工作线程，一个 M 关联一个内核级线程</p></li><li><p>P（Processor），代表一个 处理器，又称上下文</p><h4 id="G-M-P三者的关系与特点："><a href="#G-M-P三者的关系与特点：" class="headerlink" title="G-M-P三者的关系与特点："></a>G-M-P三者的关系与特点：</h4></li><li><p>每一个运行的 M 必须绑定一个 P，线程 M 创建后会检查并执行G（goroutine）对象。</p></li><li><p>每一个 P 保存着一个协程 G 的队列。</p></li><li><p>除了每个 P 自身保存的G的队列外，调度器还有一个全局的G队列</p></li><li><p>M 从队列中提取 G，并执行</p></li><li><p>P 的个数就是 GOMAXPROCS（最大256），启动时固定，一般不修改</p></li><li><p>M 的个数和 P 的个数不一定一样多（会有sleep的M或者P不绑定M）(最大10000)</p></li><li><p>P 是用一个全局数组(255)来保存的，并维护一个全局的 P 的空闲链表</p></li></ul><h4 id="局部G队列与全局G队列的关系"><a href="#局部G队列与全局G队列的关系" class="headerlink" title="局部G队列与全局G队列的关系"></a>局部G队列与全局G队列的关系</h4><ul><li>全局G任务队列会和本地G任务队列按照一定策略互相交换。</li><li>G的执行顺序，先从本地队列找，本地没有则从全局队列找</li><li>转移    局部与全局，全局G个数&#x2F;P个数   局部与局部，一次性转移一半</li></ul><h4 id="Gorutine-从入队到执行"><a href="#Gorutine-从入队到执行" class="headerlink" title="Gorutine 从入队到执行"></a>Gorutine 从入队到执行</h4><ol><li>当我们创建一个G对象，就是 gorutine，它会加入到本地队列或者全局队列</li><li>如果还有空闲的P，则创建一个M 绑定该 P ，注意！这里，P 此前必须还没绑定过M 的，否则不满足空闲的条件<ol><li>先找到一个空闲的P，如果没有则直接返回</li><li>P 个数不会占用超过自己设定的cpu个数</li><li>P 在被 M 绑定后，就会初始化自己的 G 队列，此时是一个空队列</li></ol></li><li>M 会启动一个底层线程，循环执行能找到的 G 任务。这里的寻找的 G 从下面几方面找：<ol><li>当前 M 所绑的 P 队列中找</li><li>去别的 P 的队列中找</li><li>去全局 G 队列中找</li></ol></li><li>G任务的执行顺序是，先从本地队列找，本地没有则从全局队列找</li><li>程序启动的时候，首先跑的是主线程，然后这个主线程会绑定第一个 P</li><li>入口 main 函数，其实是作为一个 goroutine 来执行</li></ol><p>1、runtime创建第一个线程M0：M0是启动进程后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G，在之后M0就和其他的M一样了。<br>2、runtime创建第一个Go协程G0：G0是每次启动一个M都会第一个创建的goroutine，G0仅用于负责调度G，G0不指向任何可执行函数，每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间，全局变量的G0是M0的G0。一般的G0放在本地队列中。<br>3、关联M0和G0。<br>4、调度初始化初始化M0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。<br>5、创建main()中的goroutine，即runtime.main创建goroutine。<br>6、启动M0，此时M0已经绑定了P，从P的本地队列中获取G，获取到main goroutine。<br>7、M绑定P。<br>8、循环判断M通过P是否能够获取到G。<br>9、获取不到则M进入休眠队列，等待被唤醒后再重新与P绑定。<br>10、能够获取到G，则M根据G中的栈信息和调度信息设置运行环境。<br>11、M执行G。<br>12、G退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。</p><h4 id="中断挂起与恢复"><a href="#中断挂起与恢复" class="headerlink" title="中断挂起与恢复"></a>中断挂起与恢复</h4><p>goroutine协程的中断挂起与恢复 ：协程的切换时间片是10ms，也就是说 goroutine 最多执行10ms就会被 M 切换到下一个 G。这个过程，又被称为 中断，挂起<br>go程序启动时会首先创建一个特殊的内核线程 sysmon，用来监控和管理，其内部是一个循环：</p><ol><li>记录所有 P 的 G 任务的计数 schedtick，schedtick会在每执行一个G任务后递增</li><li>如果检查到 schedtick 一直没有递增，说明这个 P 一直在执行同一个 G 任务，如果超过10ms，就在这个G任务的栈信息里面加一个 tag 标记</li><li>然后这个 G 任务在执行的时候，如果遇到非内联函数调用，就会检查一次这个标记，然后中断自己，把自己加到队列末尾，执行下一个G</li><li>如果没有遇到非内联函数 调用（有时候正常的小函数会被优化成内联函数）的话，那就会一直执行这个G任务，直到它自己结束；如果是个死循环，并且 GOMAXPROCS&#x3D;1 的话。那么一直只会只有一个 P 与一个 M，且队列中的其他 G 不会被执行！</li></ol><p>中断后的恢复</p><ol><li>中断的时候将寄存器里的栈信息，保存到自己的 G 对象里面</li><li>当再次轮到自己执行时，将自己保存的栈信息复制到寄存器里面，这样就接着上次之后运行</li></ol><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count)，Go 语言 采用的是标记清除算法。1.5 版本以后在此基础上使用了三色标记法和写屏障技术，提高了效率。</p><p>标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p><ul><li>标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；</li><li>清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。</li></ul><p>标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW，这也是 GC 算法优化的重点），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。</p><p>三色标记算法将程序中的对象分成白色、黑色和灰色三类。</p><ul><li>白色：不确定对象。</li><li>灰色：存活对象，子对象待处理。</li><li>黑色：存活对象。</li></ul><p>标记开始时，所有内存加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入待扫描队列（灰色集合）；使用并发的 goroutine 扫描队列，取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入队列。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。</p><p>三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。</p><p>三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A (黑) -&gt; B (灰) -&gt; C (白) -&gt; D (白)  </span><br></pre></td></tr></table></figure><p>正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A (黑) -&gt; B (灰) -&gt; C (白)   </span><br><span class="line"> ↓  </span><br><span class="line">D (白)  </span><br></pre></td></tr></table></figure><p>为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，这个计数会拦截将白色指针插入黑色对象的操作，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。</p><p>一次完整的 GC 分为四个阶段：</p><ul><li>标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)，开启辅助 GC （mutator assist），统计 root 对象的任务数量</li><li>使用三色标记法标记（Marking, 并发）</li><li>标记结束(Mark Termination，需 STW)，关闭写屏障。</li><li>清理(Sweeping, 并发)</li></ul><h4 id="GC-的触发时机"><a href="#GC-的触发时机" class="headerlink" title="GC 的触发时机"></a>GC 的触发时机</h4><p>使用系统监控，该触发条件由 <code>runtime.forcegcperiod</code> 变量控制，默认为 2 分 钟。当超过两分钟没有产生任何 GC 时，强制触发 GC。 使用步调（Pacing）算法，其核心思想是控制内存增长的比例。如 Go 的 GC 是一种比例 GC, 下一次 GC 结束时的堆大小和上一次 GC <code>存活</code>堆大小成比例。一般来说，当前申请的内存是上一次 GC 两倍时触发。</p><h2 id="一些细碎知识点"><a href="#一些细碎知识点" class="headerlink" title="一些细碎知识点"></a>一些细碎知识点</h2><h4 id="Golang-传参"><a href="#Golang-传参" class="headerlink" title="Golang 传参"></a>Golang 传参</h4><ol><li>理论上来说，Golang 只有值传递，所有协程的入参都是值拷贝，协程内部的修改，无法影响原参数</li><li>对于指针类型的参数，是对其指向地址的拷贝，因此可以使用地址来修改原参数</li><li>Slice 底层是引用数组，因此对于 Slice 的修改可以反映到原数组；注意 扩容相关内容</li></ol><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> go </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>todo</title>
      <link href="/uncategorized/todo/"/>
      <url>/uncategorized/todo/</url>
      
        <content type="html"><![CDATA[<p>raft<br><a href="https://cloud.tencent.com/developer/article/2168468">https://cloud.tencent.com/developer/article/2168468</a></p><p>kafka<br><a href="https://cloud.tencent.com/developer/article/2240297?areaId=106001">https://cloud.tencent.com/developer/article/2240297?areaId=106001</a></p><p>sync.map<br><a href="https://cloud.tencent.com/developer/article/2140224">https://cloud.tencent.com/developer/article/2140224</a><br><a href="https://cloud.tencent.com/developer/article/2140226">https://cloud.tencent.com/developer/article/2140226</a><br>go.map<br><a href="https://blog.csdn.net/lp15929801907/article/details/130229409?utm_source=miniapp_weixin">https://blog.csdn.net/lp15929801907/article/details/130229409?utm_source=miniapp_weixin</a><br><a href="https://segmentfault.com/a/1190000023879178?utm_source=sf-similar-article">https://segmentfault.com/a/1190000023879178?utm_source=sf-similar-article</a></p><p>sync.Mutex<br><a href="https://cloud.tencent.com/developer/article/2140227">https://cloud.tencent.com/developer/article/2140227</a></p><p>defer<br><a href="https://cloud.tencent.com/developer/article/1410243">https://cloud.tencent.com/developer/article/1410243</a></p><p>gmp<br><a href="https://cloud.tencent.com/developer/article/2191347">https://cloud.tencent.com/developer/article/2191347</a><br><a href="https://cloud.tencent.com/developer/article/1680164">https://cloud.tencent.com/developer/article/1680164</a></p><p>redis<br><a href="https://blog.csdn.net/qq1515312832/article/details/113880849">https://blog.csdn.net/qq1515312832/article/details/113880849</a></p><p>channel<br><a href="https://cloud.tencent.com/developer/article/1651356">https://cloud.tencent.com/developer/article/1651356</a><br><a href="https://cloud.tencent.com/developer/article/2078995?areaId=106001">https://cloud.tencent.com/developer/article/2078995?areaId=106001</a></p><p>拷贝<br><a href="https://cloud.tencent.com/developer/article/1870553">https://cloud.tencent.com/developer/article/1870553</a></p><p>位运算<br><a href="https://cloud.tencent.com/developer/article/2046380">https://cloud.tencent.com/developer/article/2046380</a></p><p>context<br><a href="https://cloud.tencent.com/developer/article/2259772">https://cloud.tencent.com/developer/article/2259772</a></p><p>排序<br><a href="https://www.cnblogs.com/onepixel/p/7674659.html">https://www.cnblogs.com/onepixel/p/7674659.html</a></p><p>刷题 Leetcode<br>152</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/interview/simulation/%E8%AF%9D%E6%9C%AF/"/>
      <url>/interview/simulation/%E8%AF%9D%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="自我介绍："><a href="#自我介绍：" class="headerlink" title="自我介绍："></a>自我介绍：</h3><p>您好，我是王鑫宇，非常感谢给我的这次面试机会，拥有几年k12教育公司负责增长业务相关的系统和模型设计，其中主要包括活动营销平台的开发，以及相关系统的重构与升级，有过多次大型系统研发经验，有过多次跨部门系统研发经验。有过5人小组的管理经验。</p><h3 id="您在前一家公司的离职原因是什么？"><a href="#您在前一家公司的离职原因是什么？" class="headerlink" title="您在前一家公司的离职原因是什么？"></a>您在前一家公司的离职原因是什么？</h3><p>政策限制后，公司尝试了多种方向，比如海外业务、多学科等探索，初步是有一些成果的。我自身来说还是想要和公司一同发展的，但是随着时间的推移，各方向业务收缩，研发工作以维护为主，对于系统层面的迭代实际上是在不断地做减法。并且家人生病，需要人照顾，综合考虑下就出来了</p><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><h4 id="广告平台"><a href="#广告平台" class="headerlink" title="广告平台"></a>广告平台</h4><p>初衷是这样的，做活动的时候需要在公司内部多个 app 做展示推送，那么涉及到了不同业务方的展示规则不尽相同，需求提过去又需要结合其他业务方评估是否支持，以及研发周期，对于所有人来说都是很高的成本，并且数据统计也是各管各的，从活动角度很难一键式的获取营销数据，需要额外的再提一些数据需求；再者，有一些 ab 实验的展示要求，也很难推广，基本上只能选取最大流量的来做评估，但是最大流量的 app 从付费模式上来说又不一样，所以其实获取的数据很难得到想要的结果。<br>为了解决上述的问题，我就牵头想要说整理一个针对公司内部的配置平台，然后对接数据、ab 实验平台等，统一输出广告展示给用户。<br>因为可以预见的这个服务的访问量会很高嘛，一个用户单 app 大概有十几个位置需要拉取信息，绘本的用户因为没有严格的上课时间，所以虽然用户量大，日活高，但是理论上不会短时间集中访问。但是一对一就不一样了，用户一般上下课时间是固定的，那么这一段短时间内，可能会有2-3w用户并发的来获取广告内容，双减前高峰期也能有 5w+ 的用户，估算大概至少是百万级别的 qps，那为了保证服务的质量和稳定性，采用了 内存-redis-tidb 三层缓存结构，系统启动时，将相关广告配置加载到内存和 redis 中，如果是活动或者营销高峰，还会针对热点数据再缓存一层到 redis 中，第三层是 tidb 持久化的数据。<br>为了减少前两层同时失效的情况，内存级别做了定时更新，更新阶段会请求会透传到 redis 这一层。redis 层每个实例随机刷新时间，尽量与内存更新错开。另外针对持久化配置数据的更改，为了保证数据一致性，会在更新的时候按唯一标识更新缓存数据。刷新时间基本在1-2分钟，业务上评估的话，对于这种延时是可以接受且影响不大的。对于极端情况下的产生的异常数据，也提供了紧急更新的动态配置开关，这时候对于缓存的更新会强制变成随 tidb 更新的事务方式。</p><p>能够支持的配置维度大概有：</p><ol><li>静默期</li><li>最近N（小时&#x2F;天&#x2F;周&#x2F;月）最多投放M次、<ol><li>按照自然周期设置一个桶，用户a在该周期1展示的广告x，用户每次展示成功了就往该 key 中添加一个元素，最后判断是否达到 M 来确定是否继续展示</li><li>zset 结构</li></ol></li><li>每日投放区间<ol><li>可以配置多个</li><li>设计上比较像 leet 合并区间，</li><li>最后判断当前时间即可</li></ol></li><li>用户标签 or 用户身份规则<br>并且对接了 ab 测试系统，可以自动的参与实验。且使用广告的唯一标识来串联了数据漏斗，可以很好地查看投放的效果。</li></ol><p>一个比较有意思的功能是轮播，用户每次进来都能看到不同的广告，实现方式是利用了redis中zset的结构。首先用户有一个可见广告的集合，用户+广告位来标识一个桶，每次访问将广告的唯一id加入桶内，利用 zscore 来做判断，访问一轮以后清除桶重新计数。当时也是想了一些缓存计数方案，但是都不如 zset 来的方便</p><p>排名变动怎么办，热key怎么办，快速定位自己排名怎么办，还有离线数据链路以及容灾<br>冷热数据，前几页请求量大，中间页码是基本没流量的，这种又咋做</p><p>容灾，读取容灾就是redis挂了降级穿透去数据库，如果qps超过熔断值就算求了，如果数据库也g了就更算了。写入容灾就是两件事嘛，一个是消息队列持久化重试，这个八股文都会问，还有个就是每天晚上离线对账机制。<br>热数据，单独起一个缓存维护前100名<br>后续升级就是每个实例都做被动式内存缓存</p><p>使用 etcd 来完成微服务注册和发现，使用 thrift 和 grpc 作为微服务的框架。<br>rpc访问量、耗时，sql耗时等关键指标暴露给 Prometheus，并通过 Grafana 展示，便于监控服务质量，以及出现问题时可以帮助快速定位异常接口</p><p>context多数用来进行上下文信息传递，在实际开发中，会记录整条调用链路。一般来说，需要注意的是超时机制；context只能自顶向下传值；context一定不能为nil，在不确定的情况下可以使用 context.TODO() 或者 context.Background()</p><p>etcd中的分布式锁一般用来在集群系统启动时确定由哪一个系统来全局单例业务操作，比如数据刷新、业务数据清洗等<br>依据当前接口的唯一标识数据来实现幂等<br>不同系统间调用顺序可以用消息队列保证<br>分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p><p>分布式系统一般使用 redis 来做分布式锁（缺点：redis主从切换时可能丢失数据）<br>redis分布式锁，我们使用的业务场景，加锁时间一般为1s-3s，根据场景浮动，其中3s是我们设定的最长响应时间。</p><p>如果加锁后，过期时间内业务由于某种原因还没执行完，下一次请求再次加锁后打进来，而此时上一次的请求还未执行完毕，这时候需要对锁进行延期。可以采用协程的方法来设置一个ticker，在执行完毕的channel中如果没有收到通知，那么就需要对这个锁进行有限次的续期，来保证不会出现超卖这类情况。</p><p>另一种情况是如果当前锁是全局的，那么可能会出现锁被其他集群的进程解锁的情况，这种一般针对加锁的key进行处理即可</p><p>对于活动呢，由于运营提出的活动形式有很多，且对于上线时间有强要求，所以一般初次出现的活动形式，会采取敏捷开发的方式，以达到最快且稳定上线的目的</p><p>任务系统，初期设计呢是很死板的，根据运营设计的任务动作从涉及到的多个方向拉取或者等待信息推送，但是这个方案对于其他业务的侵入性太高，风险极高。针对这一点，我将所有的业务动作全部转移到消息队列来获取，这样对于其他业务线或者系统来说，大部分是已经支持的</p><p>抽奖系统，可以讲讲分布式锁相关，</p><p>slice底层实现方法，map底层实现方法</p><p>redis 跳表</p><p>golang 语言的优势：静态语言，编译阶段可以发现一些问题；并发支持好，耗时随并发数线性增加；垃圾回收处理好</p><p>golang 文件操作使用比较少，了解不多</p><p>golang channel 利用协程通信来共享内存</p><p>常见排序：快排，堆排，归并</p><p>内核线程才是并行的基本单位</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 实录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常见排序</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/algorithm-sort/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/algorithm-sort/</url>
      
        <content type="html"><![CDATA[<p>![[source&#x2F;images&#x2F;elementary-sort.png]]</p><h2 id="常考排序"><a href="#常考排序" class="headerlink" title="常考排序"></a>常考排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 思路：把一个数组分为左右两段，左段小于右段</span></span><br><span class="line">    quickSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原地交换，所以传入交换索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="type">int</span>, start, end <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> start &lt; end &#123;</span><br><span class="line">        <span class="comment">// 分治法：divide</span></span><br><span class="line">        pivot := partition(nums, start, end)</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, pivot<span class="number">-1</span>)</span><br><span class="line">        quickSort(nums, pivot+<span class="number">1</span>, end)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(nums []<span class="type">int</span>, start, end <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 选取最后一个元素作为基准pivot</span></span><br><span class="line">    p := nums[end]</span><br><span class="line">    i := start</span><br><span class="line">    <span class="comment">// 最后一个值就是基准所以不用比较</span></span><br><span class="line">    <span class="keyword">for</span> j := start; j &lt; end; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[j] &lt; p &#123;</span><br><span class="line">            swap(nums, i, j)</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把基准值换到中间</span></span><br><span class="line">    swap(nums, i, end)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换两个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(nums []<span class="type">int</span>, i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    t := nums[i]</span><br><span class="line">    nums[i] = nums[j]</span><br><span class="line">    nums[j] = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergeSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mergeSort(nums)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分治法：divide 分为两段</span></span><br><span class="line">    mid := <span class="built_in">len</span>(nums) / <span class="number">2</span></span><br><span class="line">    left := mergeSort(nums[:mid])</span><br><span class="line">    right := mergeSort(nums[mid:])</span><br><span class="line">    <span class="comment">// 合并两段数据</span></span><br><span class="line">    result := merge(left, right)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="type">int</span>)</span></span> (result []<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 两边数组合并游标</span></span><br><span class="line">    l := <span class="number">0</span></span><br><span class="line">    r := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 注意不能越界</span></span><br><span class="line">    <span class="keyword">for</span> l &lt; <span class="built_in">len</span>(left) &amp;&amp; r &lt; <span class="built_in">len</span>(right) &#123;</span><br><span class="line">        <span class="comment">// 谁小合并谁</span></span><br><span class="line">        <span class="keyword">if</span> left[l] &gt; right[r] &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, right[r])</span><br><span class="line">            r++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, left[l])</span><br><span class="line">            l++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剩余部分合并</span></span><br><span class="line">    result = <span class="built_in">append</span>(result, left[l:]...)</span><br><span class="line">    result = <span class="built_in">append</span>(result, right[r:]...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>用数组表示的完美二叉树 complete binary tree</p><blockquote><p>完美二叉树 VS 其他二叉树</p></blockquote><p><img src="https://greyireland.gitbook.io/~gitbook/image?url=https://img.fuiboom.com/img/tree_type.png&width=768&dpr=4&quality=100&sign=da697a19f8b79e11953a90709485d8e615dda884e21047841e538aa29ce671d3"></p><p>核心代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(a []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 1、无序数组a</span></span><br><span class="line">    <span class="comment">// 2、将无序数组a构建为一个大根堆</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(a)/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        sink(a, i, <span class="built_in">len</span>(a))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、交换a[0]和a[len(a)-1]</span></span><br><span class="line">    <span class="comment">// 4、然后把前面这段数组继续下沉保持堆结构，如此循环即可</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(a) - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 从后往前填充值</span></span><br><span class="line">        swap(a, <span class="number">0</span>, i)</span><br><span class="line">        <span class="comment">// 前面的长度也减一</span></span><br><span class="line">        sink(a, <span class="number">0</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sink</span><span class="params">(a []<span class="type">int</span>, i <span class="type">int</span>, length <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 左节点索引(从0开始，所以左节点为i*2+1)</span></span><br><span class="line">        l := i*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="comment">// 右节点索引</span></span><br><span class="line">        r := i*<span class="number">2</span> + <span class="number">2</span></span><br><span class="line">        <span class="comment">// idx保存根、左、右三者之间较大值的索引</span></span><br><span class="line">        idx := i</span><br><span class="line">        <span class="comment">// 存在左节点，左节点值较大，则取左节点</span></span><br><span class="line">        <span class="keyword">if</span> l &lt; length &amp;&amp; a[l] &gt; a[idx] &#123;</span><br><span class="line">            idx = l</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在右节点，且值较大，取右节点</span></span><br><span class="line">        <span class="keyword">if</span> r &lt; length &amp;&amp; a[r] &gt; a[idx] &#123;</span><br><span class="line">            idx = r</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果根节点较大，则不用下沉</span></span><br><span class="line">        <span class="keyword">if</span> idx == i &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果根节点较小，则交换值，并继续下沉</span></span><br><span class="line">        swap(a, i, idx)</span><br><span class="line">        <span class="comment">// 继续下沉idx节点</span></span><br><span class="line">        i = idx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a []<span class="type">int</span>, i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 必看必会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/algorithm-time-complixty/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/algorithm-time-complixty/</url>
      
        <content type="html"><![CDATA[<h2 id="时间复杂度-大-O"><a href="#时间复杂度-大-O" class="headerlink" title="时间复杂度 (大 O)"></a>时间复杂度 (大 O)</h2><p>![[Pasted image 20240429194251.png]]</p><p>![[Pasted image 20240429194302.png]]</p><p>首先，我们来谈谈常用操作的时间复杂度，按数据结构&#x2F;算法划分。然后，我们将讨论给定输入大小的合理复杂性。</p><h4 id="数组（动态数组-x2F-列表）"><a href="#数组（动态数组-x2F-列表）" class="headerlink" title="数组（动态数组&#x2F;列表）"></a>数组（动态数组&#x2F;列表）</h4><p>规定 <em>n &#x3D; arr.length</em>,</p><ul><li>结尾添加或删除元素: 𝑂(1)</li><li>从任意索引中添加或删除元素: 𝑂(𝑛)</li><li>访问或修改任意索引处的元素: 𝑂(1)</li><li>检查元素是否存在: 𝑂(𝑛)</li><li>双指针: 𝑂(𝑛⋅𝑘), 𝑘 是每次迭代所做的工作，包括滑动窗口</li><li>构建前缀和: 𝑂(𝑛)</li><li>求给定前缀和的子数组的和：𝑂(1)</li></ul><h4 id="字符串-不可变"><a href="#字符串-不可变" class="headerlink" title="字符串 (不可变)"></a>字符串 (不可变)</h4><p>规定 <em>n &#x3D; s.length</em>,</p><ul><li>添加或删除字符: 𝑂(𝑛)</li><li>任意索引处的访问元素: 𝑂(1)</li><li>两个字符串之间的连接: 𝑂(𝑛+𝑚), 𝑚 是另一个字符串的长度</li><li>创建子字符串: 𝑂(𝑚), 𝑚 是子字符串的长度</li><li>双指针: 𝑂(𝑛⋅𝑘), 𝑘 是每次迭代所做的工作，包括滑动窗口</li><li>通过连接数组、stringbuilder 等构建字符串：𝑂(𝑛)</li></ul><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>给定 𝑛n 作为链表中的节点数，</p><ul><li>给定指针位置的后面添加或删除元素: 𝑂(1)</li><li>如果是双向链表，给定指针位置添加或删除元素: 𝑂(1)</li><li>在没有指针的任意位置添加或删除元素: 𝑂(𝑛)</li><li>无指针任意位置的访问元素: 𝑂(𝑛)</li><li>检查元素是否存在: 𝑂(𝑛)</li><li>在位置 i 和 j 之间反转: 𝑂(𝑗−𝑖)</li><li>使用快慢指针或哈希映射完成一次遍历: 𝑂(𝑛)</li></ul><h4 id="哈希表-x2F-字典"><a href="#哈希表-x2F-字典" class="headerlink" title="哈希表&#x2F;字典"></a>哈希表&#x2F;字典</h4><p>给定 <em>n &#x3D; dic.length</em>,</p><ul><li>添加或删除键值对: 𝑂(1)</li><li>检查 key 是否存在: 𝑂(1)</li><li>检查值是否存在: 𝑂(𝑛)</li><li>访问或修改与 key 相关的值: 𝑂(1)</li><li>遍历所有键值: 𝑂(𝑛)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意: 𝑂(1)O(1) 操作相对于 n 是常数.实际上，哈希算法可能代价很高。例如，如果你的键是字符串，那么它将花费 𝑂(𝑚)O(m)，其中 𝑚m 是字符串的长度。 这些操作只需要相对于哈希映射大小的常数时间。</span><br></pre></td></tr></table></figure></li></ul><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>给定 <em>n &#x3D; set.length</em>,</p><ul><li>添加或删除元素: 𝑂(1)</li><li>检测元素是否存在: 𝑂(1)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面的说明也适用于这里。</span><br></pre></td></tr></table></figure></li></ul><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈操作依赖于它们的实现。栈只需要支持弹出和推入。如果使用动态数组实现:给定 <em>n &#x3D; stack.length</em>,</p><ul><li>推入元素: 𝑂(1)</li><li>弹出元素: 𝑂(1)</li><li>查看 (查看栈顶元素): 𝑂(1)</li><li>访问或修改任意索引处的元素: 𝑂(1)</li><li>检测元素是否存在: 𝑂(𝑛)</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列操作依赖于它们的实现。队列只需要支持出队列和入队列。如果使用双链表实现:给定 <em>n &#x3D; queue.length</em>,</p><ul><li>入队的元素: 𝑂(1)</li><li>出队的元素: 𝑂(1)</li><li>查看 (查看队列前面的元素): 𝑂(1)</li><li>访问或修改任意索引处的元素: 𝑂(𝑛)</li><li>检查元素是否存在: 𝑂(𝑛)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意:大多数编程语言实现队列的方式比简单的双链表更复杂。根据实现的不同，通过索引访问元素可能比 𝑂(𝑛)O(n) 快，但有一个重要的常量除数。</span><br></pre></td></tr></table></figure></li></ul><h4 id="二叉树问题-DFS-x2F-BFS"><a href="#二叉树问题-DFS-x2F-BFS" class="headerlink" title="二叉树问题 (DFS&#x2F;BFS)"></a>二叉树问题 (DFS&#x2F;BFS)</h4><p>给定  𝑛 作为树的节点数，大多数算法的时间复杂度为 𝑂(𝑛⋅𝑘), 𝑘 是在每个节点上做的操作数, 通常是 𝑂(1)。这只是一个普遍规律，并非总是如此。我们在这里假设 BFS 是用高效队列实现的。</p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>给定 𝑛 作为树中的节点数，</p><ul><li>添加或删除元素：最坏的情况下 𝑂(𝑛),平均情况 𝑂(log⁡𝑛)</li><li>检查元素是否存在：最坏的情况下 𝑂(𝑛), 平均情况 𝑂(log⁡𝑛)<br>平均情况是当树很平衡时 —— 每个深度都接近满。最坏的情况是树只是一条直线。</li></ul><h4 id="堆-x2F-优先队列"><a href="#堆-x2F-优先队列" class="headerlink" title="堆&#x2F;优先队列"></a>堆&#x2F;优先队列</h4><p>给定 <em>n &#x3D; heap.length</em> 并讨论最小堆,</p><ul><li>添加一个元素: 𝑂(log⁡𝑛)</li><li>删除最小的元素: 𝑂(log⁡𝑛)</li><li>找到最小的元素: 𝑂(1)</li><li>查看元素是否存在: 𝑂(𝑛)</li></ul><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>在最坏的情况下，二分查找的时间复杂度为 𝑂(log⁡𝑛)，其中 𝑛 是初始搜索空间的大小。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>排序: 𝑂(𝑛⋅log⁡𝑛), 其中 𝑛 是要排序的数据的大小</li><li>图上的 DFS 和 BFS：𝑂(𝑛⋅𝑘+𝑒)，其中 𝑛 是节点数，𝑒 是边数，前提是每个节点处理花费都是 𝑂(1)，不需要重复遍历。</li><li>DFS 和 BFS 空间复杂度：通常为 𝑂(𝑛)，但如果它在图形中，则可能为 𝑂(𝑛+𝑒) 来存储图形</li><li>动态规划时间复杂度：𝑂(𝑛⋅𝑘)，其中 𝑛 是状态数，𝑘 是每个状态所需要的操作数</li><li>动态规划空间复杂度：𝑂(𝑛)，其中 𝑛 是状态数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 必看必会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raft 面试必备</title>
      <link href="/interview/distribution/raft/"/>
      <url>/interview/distribution/raft/</url>
      
        <content type="html"><![CDATA[<p>Raft<br>Raft协议呢，一般包括这三种节点：Follower、Candidate、Leader；其中，候选人是只有在选举期间才存在的节点，一旦选举结束，那么集群中就只有 Leader，Follower</p><p>节点之间使用 rpc 来通信，包括 投票rpc，复制日志心跳rpc，快照rpc</p><p>选举过程如下：<br>选举时机：当网络刚刚启动或者集群节点变更，或者上一任期结束后。所有节点进入选举阶段，每个人持有一个随机的选举时钟，时钟结束后，节点优先给自己投票，然后广播投票rpc。会有三种结果：赢得多数选票成为 Leader； 其他人当选，自己成为 follower；没有人当选，开启下一轮投票。<br>由于raft的机制，可以认为能够成为 Leader 的节点，一定是包含所有日志的节点<br>leader选举的过程是：1、增加term号；2、给自己投票；3、重置选举超时计时器；4、发送请求投票的RPC给其它节点</p><p>Leader 被选举出来以后，就开始接收客户端的消息。Leader 会将这一条消息作为日志记录下来，并将其通过心跳包同步给集群中的 follower，当大部分节点都同步这条日志以后，Leader 将这个请求应用到自身的状态机并回复客户端。follower 如果发生宕机或者丢包，Leader 会不断尝试直到所有节点都同步了这条日志。<br>日志由有序编号（log index）的日志条目组成。每个日志条目包含它被创建时的任期号（term）和用于状态机执行的命令。</p><p>日志复制的过程有两条保证：</p><ol><li>如果不同节点的两条日志有相同的索引和任期，那么他们存储的命令是一致的（由于主从同步的特性，Leader 节点上的日志和命令落库后就不会更改）</li><li>如果不同节点的两条日志有相同的索引和任期，那么他们之前存储的日志也是一致的（由于日志的一致性检查，当 follower 收到来自 Leader 的心跳包以后，会与本地的日志索引和任期做匹配，如果有不一致，那么会拒绝掉这个心跳包）</li></ol><p>日志复制的异常情况包括：<br>Leader 宕机或者崩溃，旧 Leader 没有复制完所有的日志。可能多，可能少，可能不一致</p><p>日志复制的过程，需要通过与 Leader 保证强一致性来保证安全复制。当日志产生不一致时，Leader 会从后往前尝试同步日志心跳包给其他节点，直到找到一个双方都符合的日志，然后 Leader 会把从这条日志以后的所有内容同步给该节点，将不一致的部分覆盖掉，直到与 Leader 保持完全一致<br><strong>当 leader 和 follower 日志冲突的时候</strong>，leader 将<strong>校验 follower 最后一条日志是否和 leader 匹配</strong>，如果不匹配，<strong>将递减查询，直到匹配，匹配后，删除冲突的日志</strong></p><p>那么像之前提到 Leader 中的日志可能也不是最新的，会不会同步出去的日志本身就是异常的呢？<br>这个就是 raft 通过两条限制来保证了日志复制的安全性：</p><ol><li>只有log索引和任期是最新的节点才有可能成为 Leader，这个在选举投票期间是可以判断的，非最新的就不给他投票</li><li>Leader 只能推进日志的索引进行提交，以前任期的要在检查一致性的过程中同步过去。</li></ol><p>那么在实际使用过程中，为了保证日志不会无限增长，每隔一段时间，每个节点独立的进行快照，将某个时间点以前的日志落库后丢弃。<br>当 Leader 在同步日志的过程中发现某个节点的日志特别老，那么这时候，Leader 会发送快照rpc来将日志打包复制。<br>当然实际使用中，需要控制间隔的时间，和快照的频率（防止发生 io 阻塞），一般达到固定大小发生一次。<br>同时可以使用 copy-on-write 技术来保证正常的日志同步</p><p>脑裂问题是说一次性在集群中增加了太多的节点，比如超过了原来节点数量的一半，那么就有可能产生双主的现象，即一个集群中有两个 Leader，彼此成员之间没有交集。解决办法是一次变更一个节点，少量多次的来完成。<br>另外还有一个情况是，如果发生了网络分区故障或者异常，导致老 Leader 失联了，剩下的节点会重新选举出一个新 Leader，并与客户端继续交流。当老 Leader 恢复连接以后，他上面的 commit 都会被视作失效，本身会转化为 follower 接收从新 Leader 来的日志。</p><p>另外一种还有一个 <strong>Prevote</strong> 机制<br>当有一个 follower 与集群隔离后，他会自己进入候选阶段，并由于无法获得投票成为 Leader 而一直刷新任期，导致该节点任期非常大。当该节点重进集群以后，会由于任期导致选举混乱，因此 raft 采用 prevote 机制，是一个类似于两阶段提交的协议，第一阶段先征求其他节点是否同意选举，如果同意选举则发起真正的选举操作，否则降为Follower角色。这样就避免了网络分区节点重新加入集群，触发不必要的选举操作</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>simulation02</title>
      <link href="/interview/simulation/simulation02/"/>
      <url>/interview/simulation/simulation02/</url>
      
        <content type="html"><![CDATA[<p>深维：<br>一面：</p><h4 id="1-用过哪些分布式锁-redis-key用什么类型-用string有什么坏处-？没抢到的都在干等着，浪费cpu？如何规避。-etcd如何分布式锁"><a href="#1-用过哪些分布式锁-redis-key用什么类型-用string有什么坏处-？没抢到的都在干等着，浪费cpu？如何规避。-etcd如何分布式锁" class="headerlink" title="1.用过哪些分布式锁 redis key用什么类型 用string有什么坏处 ？没抢到的都在干等着，浪费cpu？如何规避。 etcd如何分布式锁"></a>1.用过哪些分布式锁 redis key用什么类型 用string有什么坏处 ？没抢到的都在干等着，浪费cpu？如何规避。 etcd如何分布式锁</h4><p>redis 锁 可能存在的问题：</p><ul><li>业务超时，导致锁失效，造成多实例持有锁：延长过期时间（不推荐）；类似 java 的看门狗机制，另外启用一个协程对锁续约。</li><li>redis 主从切换时可能造成多实例持有锁，这个是用的 redlock 来解决的，不过具体的方案我就没有看过了<br>用过redis锁， setnx属于原子操作，上锁失败一般认为是锁已经存在了。一般使用string类型作为key，string类型有一个缺点是会占用比较大的空间，<br>可以根据业务具体情况使用 hset ，但是需要保证单个集合中的 kv 数量，如果超过某个界限，redis 就不会用 ziplist 来存储这个集合了</li></ul><p>etcd<br>prefix<br>etcd支持前缀查找，所以可以用一个前缀表示锁资源，前缀 + 唯一id的方式表示锁资源的持有者。</p><p>lease机制<br>租约机制可以保证锁的活性，持有锁的客户端宕机，key自动过期，避免宕机。etcd客户端提供的lease续租机制解决客户端长时间阻塞导致锁失效问题。</p><p>watch机制<br>redis采用忙轮询的方式来获取锁，etcd可以使用watch机制监听锁的删除事件，更加高效。</p><h4 id="2-数据库-隔离级别-没有解决什么问题-幻读是什么"><a href="#2-数据库-隔离级别-没有解决什么问题-幻读是什么" class="headerlink" title="2.数据库 隔离级别 没有解决什么问题 幻读是什么"></a>2.数据库 隔离级别 没有解决什么问题 幻读是什么</h4><p>一共有五种：<br>不使用事务<br>read uncommitted 允许脏读<br>read committed 防止脏读 最常用<br>repeatable read 防止脏读，不可重复读 mysql 默认<br>serilized 串行事务，防止幻读，脏读，不可重复读<br>级别越高，安全性越好，并发性能约低</p><p>幻读就是在一个事务过程中用相同条件查询时，获取的结果不一致<br>事务A获取的结果集，事务B对其中的数据进行了修改并提交，事务A在重新执行查询时，可能会发现原本不存在的数据行（幻影），或者原本存在的数据行消失了</p><h4 id="3-布隆过滤器的原理"><a href="#3-布隆过滤器的原理" class="headerlink" title="3.布隆过滤器的原理"></a>3.布隆过滤器的原理</h4><p>利用位数组和哈希函数来判断一个元素是否存在于集合中<br>布隆过滤器基于一个位数组和若干个哈希函数，其中位数组是一个由0和1组成的数组，初始值全部为0。当一个元素加入到布隆过滤器中时，会通过多个哈希函数生成多个哈希值，然后将这些哈希值对应的位数组位置设置为1。当一个元素要查询是否存在于布隆过滤器中时，也会通过多个哈希函数生成多个哈希值，然后查询这些哈希值对应的位数组位置是否都为1。如果任何一个位数组位置不为1，那么该元素肯定不存在于布隆过滤器中。如果所有位数组位置都为1，那么该元素可能存在于布隆过滤器中。因为多个元素可能会被哈希到同一个位数组位置上，所以存在误判的情况，但是不会漏掉任何一个元素。<br>哈希函数数量与位数组长度无关，位数组存储的是元素哈希以后的结果</p><p>优点是查询快，不需要真正查询数据；位数组扩展性强；占用内存小<br>缺点是无法删除，且有一定程度误判的概率</p><p>redis中提供了布隆过滤器的功能，但是我没有实际使用过</p><h4 id="4-channel相关-1-有缓存-没有缓存-send什么情况下会阻塞2-已经关闭的channel取数据-返回什么3-往没有初始化的channel里send会返回什么"><a href="#4-channel相关-1-有缓存-没有缓存-send什么情况下会阻塞2-已经关闭的channel取数据-返回什么3-往没有初始化的channel里send会返回什么" class="headerlink" title="4.channel相关 1.有缓存 没有缓存 send什么情况下会阻塞2.已经关闭的channel取数据 返回什么3.往没有初始化的channel里send会返回什么"></a>4.channel相关 1.有缓存 没有缓存 send什么情况下会阻塞2.已经关闭的channel取数据 返回什么3.往没有初始化的channel里send会返回什么</h4><h4 id="5-slice和数组的区别-各自的好处-地址引用和值引用的好处"><a href="#5-slice和数组的区别-各自的好处-地址引用和值引用的好处" class="headerlink" title="5.slice和数组的区别 各自的好处 地址引用和值引用的好处"></a>5.slice和数组的区别 各自的好处 地址引用和值引用的好处</h4><p>区别仅在于数据在声明时定长，切片可拓展长度<br>值引用是对原数据进行了一份拷贝后传入函数，一般用于函数改值不影响原数据的场景；地址引用是对原数据地址指针的引用，一般函数中对于这个引用的改动会反映到原数据上</p><h4 id="6-mysql的索引如何实现的，二级索引如何实现的"><a href="#6-mysql的索引如何实现的，二级索引如何实现的" class="headerlink" title="6.mysql的索引如何实现的，二级索引如何实现的"></a>6.mysql的索引如何实现的，二级索引如何实现的</h4><p>由于聚集索引是利用表的主键构建的，所以每张表只能拥有一个聚集索引。</p><p>聚集索引的叶子节点就是数据页。换句话说，数据页上存放的是完整的每行记录。因此聚集索引的一个优点就是：通过过聚集索引能获取完整的整行数据。另一个优点是：对于主键的排序查找和范围查找速度非常快。<br>使用B+树作为索引结构，其中聚集索引（Primary Index）的叶子节点包含行数据，而非聚集索引（Secondary Index）的叶子节点包含主键值。<br>二级索引（也称为辅助索引）实现方式与主索引类似，只是它不是主键。在InnoDB中，二级索引的叶子节点包含指向主键的指针，这个指针用于回表查询获取完整的数据行。</p><h4 id="7-map的底层如何实现的-什么类型不能用做map的key"><a href="#7-map的底层如何实现的-什么类型不能用做map的key" class="headerlink" title="7.map的底层如何实现的 什么类型不能用做map的key"></a>7.map的底层如何实现的 什么类型不能用做map的key</h4><h4 id="9-如何实现LRU"><a href="#9-如何实现LRU" class="headerlink" title="9.如何实现LRU"></a>9.如何实现LRU</h4><p>双向链表 + 哈希表<br>双向链表存储节点，哈希表存储节点值到节点地址的映射</p><h4 id="10-索引（a-b-c-a-x3D-b-x3D-c-x3D-c-x3D-b-x3D-a-x3D-a-x3D-b-gt-c-x3D-命中索引的哪一段"><a href="#10-索引（a-b-c-a-x3D-b-x3D-c-x3D-c-x3D-b-x3D-a-x3D-a-x3D-b-gt-c-x3D-命中索引的哪一段" class="headerlink" title="10.索引（a,b,c) a&#x3D; b&#x3D; c&#x3D;, c&#x3D; b&#x3D; a&#x3D;, a&#x3D; b&gt; c&#x3D;命中索引的哪一段"></a>10.索引（a,b,c) a&#x3D; b&#x3D; c&#x3D;, c&#x3D; b&#x3D; a&#x3D;, a&#x3D; b&gt; c&#x3D;命中索引的哪一段</h4><h4 id="11-数据库间隙锁是什么"><a href="#11-数据库间隙锁是什么" class="headerlink" title="11.数据库间隙锁是什么"></a>11.数据库间隙锁是什么</h4><p>MySQL InnoDB支持三种行锁定方式：</p><p>行锁（Record Lock）：锁直接加在索引记录上面。<br>间隙锁（Gap Lock）：锁加在不存在的空闲空间，可以是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。<br>Next-Key Lock：行锁与间隙锁组合起来用就叫做Next-Key Lock。</p><p>在一般范围区间查询数据时，会对命中的行加行锁，但是对于条件范围内但是还不存在的行也会加间隙锁。如果上一次区间查询没有执行完毕，那么针对该表区间内的insert操作会因为间隙锁而阻塞，直到查询执行完毕才会继续执行<br>可以解决幻读问题</p><p>可以防止数据误删改</p><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>T0</td><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>T1</td><td>delete from t_student where id &lt; 4;</td><td></td></tr><tr><td>T2</td><td></td><td>insert into t_student VALUES(2,‘戏子111’,1,“杭州”);</td></tr><tr><td>T3</td><td></td><td>commit;</td></tr><tr><td>T4</td><td>commit;</td><td></td></tr><tr><td>会对插入性能有一定影响</td><td></td><td></td></tr></tbody></table><h4 id="12-分布式事务了解过哪些-如何实现"><a href="#12-分布式事务了解过哪些-如何实现" class="headerlink" title="12.分布式事务了解过哪些 如何实现"></a>12.分布式事务了解过哪些 如何实现</h4><h4 id="13-电商系统如何防止超买超卖"><a href="#13-电商系统如何防止超买超卖" class="headerlink" title="13.电商系统如何防止超买超卖"></a>13.电商系统如何防止超买超卖</h4><p>一般来说，超买超卖发生在高并发的情况下。那么针对高并发的情况，可以通过加并发锁控制并发；采用队列方式改为顺序执行；利用数据库的原子语句（不推荐）<br>一般减库存区分 下单、付款、预扣（例如下单后保留10分钟）这几个节点</p><h4 id="14-悲观锁和乐观锁分别适合什么样的场景"><a href="#14-悲观锁和乐观锁分别适合什么样的场景" class="headerlink" title="14.悲观锁和乐观锁分别适合什么样的场景"></a>14.悲观锁和乐观锁分别适合什么样的场景</h4><p>悲观锁：担心数据被他人修改，因此每次修改都期望加锁，适合写大于读的情况。主要利用数据库中的读锁，行锁，写锁<br>乐观锁因为不担心数据修改问题，更多适合读大于写的场景，使用版本号或者时间戳（updatetime）</p><h4 id="15-负载均衡-etcd如何做-NGINX如何做-k8s如何做"><a href="#15-负载均衡-etcd如何做-NGINX如何做-k8s如何做" class="headerlink" title="15.负载均衡 etcd如何做 NGINX如何做 k8s如何做"></a>15.负载均衡 etcd如何做 NGINX如何做 k8s如何做</h4><p>轮询和加权轮询；权重可以根据节点的状态来动态调整。要注意权重的上下限<br>一致性哈希： 哈希环，服务端节点在环上，距离哈希结果最近的下一个节点<br>最少连接数<br>最快响应等</p><h4 id="16-普罗米修斯"><a href="#16-普罗米修斯" class="headerlink" title="16.普罗米修斯"></a>16.普罗米修斯</h4><h4 id="17-traceid系统怎么做的-如何从前端传到后端各个服务"><a href="#17-traceid系统怎么做的-如何从前端传到后端各个服务" class="headerlink" title="17.traceid系统怎么做的 如何从前端传到后端各个服务"></a>17.traceid系统怎么做的 如何从前端传到后端各个服务</h4><p>伴鱼使用的是jager，最初的采集方式是每隔一段时间采集一次。主要用来排查异常，解决业务问题，但是有间隔的采样命中相关异常的概率很小，经常是遇到了问题但是采集不到。后期结合社区内的一些组件，更新了采集方式，</p><p>二面：<br>1.挑一个项目能代表你的架构设计或者解决问题的能力（需要偏技术而不是业务）</p><p>2.如何做服务治理</p><p>3.etcd是ap系统还是cp系统<br>&#x3D;&#x3D;<strong>etcd是CP实现</strong>&#x3D;&#x3D;,它保证一致性与分区容错性,一定程度上牺牲了可用性。</p><p>4.etcd如何做负载均衡</p><p>5.K8S+docker A服务调用B服务是怎么知道B服务的地址的 </p><p>6.降级限流熔断怎么做的 熔断的原理是什么</p><ol><li>降级（Degradation）<br>概念：降级是指在系统遇到异常或高负载等情况下，暂时关闭或者切换到一些功能简化的模式，以保证核心流程的可用性和稳定性。<br>作用：通过舍弃一些非核心或不重要的功能，保护核心功能的正常运行。<br>示例：在高负载情况下，关闭一些消耗较大的查询功能，只提供基本的读写操作。</li><li>熔断（Circuit Breaker）<br>概念：熔断是指在服务调用过程中，当某个服务出现故障或不可用时，暂时停止调用该服务，直到服务恢复正常。<br>作用：通过熔断机制，保护系统免受故障服务的影响，避免雪崩效应。<br>示例：监控服务调用的失败率或错误率，当达到一定阈值时，打开熔断器，停止对该服务的调用。一段时间后，再进行尝试，如果调用成功，则关闭熔断器，继续正常调用。</li><li>限流（Rate Limiting）<br>概念：限流是指在系统的请求流量过大时，对请求进行控制和限制，使得系统在可接受的范围内进行处理，避免系统超出处理能力而崩溃。<br>作用：通过限制请求的数量或速度，保护系统免受过载的影响。<br>示例：设置每秒最大请求数或最大并发数，当请求数或并发数达到阈值时，拒绝额外的请求或者将其放入等待队列，直到系统能够处理。</li></ol><p>7.post报文由什么组成</p><p>8.tcp如何定位双方 三次握手</p><p>9.如果有M个东西，每8个为一组，每两组之间有两个重叠，会分成多少组</p><p>10.人才管理</p><p>11.逃逸分析</p><p>12.设计模式</p><p>一面<br>epoll、select、poll 区别<br>epoll 的水平触发和边缘触发的区别<br>TCP 的流量控制<br>为什么有了流量控制还要有拥塞控制?<br>TCP 不是可靠传输吗？为什么会丢包呢？<br>那你介绍一下拥塞控制的算法？<br>进程、线程的区别<br>Go里面GMP模型是怎么样的？<br>算法：旋转矩阵，牛客上写过，easy，秒<br>二面<br>如何用栈实现队列<br>如何判断一个链表有没有环？<br>那为什么快慢指针一定能够相遇？<br>你用的是 mysql 是吧，那 B树 和 B+树 的区别是？<br>介绍一下死锁产生的必要条件<br>如何实现互斥锁？<br>如何实现自旋锁？<br>算法：三数之和。秒<br>三面<br>kafka 和 其他消息队列，比如 rocketmq，rabbitmq ，有什么优势？<br>kafka如何保证消息不丢失？<br>https为什么是安全的？<br>ssl&#x2F;tls 是怎么保证安全的？经过几次握手？<br>事务的四大特性？<br>用过哪些排序？<br>快排一定最快吗？<br>场景题：如果我有100G文件，但是只有 500 M 的内存，这些文件存着一行行的数字，如何获取最小的10个？<br>算法：最长有序括号，常见题，秒</p><h4 id="grpc-和-http-的区别"><a href="#grpc-和-http-的区别" class="headerlink" title="grpc 和 http 的区别"></a>grpc 和 http 的区别</h4><p>grpc的话是使用 http&#x2F;2 协议进行通信，传输内容为二进制内容，因此grpc的关键算法是 payload 的序列化和反序列化，一般使用 protocol buffer 序列化库。服务之间使用 rpc 调用</p><h5 id="数据序列化："><a href="#数据序列化：" class="headerlink" title="数据序列化："></a>数据序列化：</h5><p>gRPC使用Protocol Buffers对数据进行序列化和反序列化，实现跨语言、跨平台的数据交换。Protocol Buffers的序列化和反序列化过程可以通过以下公式表示：</p><ul><li>序列化(M)&#x3D;Encode(M)</li><li>反序列化(M)&#x3D;Decode(M)<br>其中，$M$ 是数据结构，$Encode$ 和 $Decode$ 分别表示序列化和反序列化操作。</li></ul><h5 id="RPC调用："><a href="#RPC调用：" class="headerlink" title="RPC调用："></a>RPC调用：</h5><p>gRPC的RPC调用过程可以分为以下步骤：</p><ul><li>客户端通过Protocol Buffers序列化请求数据，并使用HTTP&#x2F;2发送请求。</li><li>服务器接收请求，使用Protocol Buffers反序列化请求数据。</li><li>服务器执行RPC方法，并将结果序列化为Protocol Buffers格式。</li><li>服务器使用HTTP&#x2F;2发送响应给客户端。</li><li>客户端使用Protocol Buffers反序列化响应数据，并处理结果。</li></ul><ol><li>通信方式</li></ol><ul><li>RPC:远程过程调用,是一种进程间通信方式。双方建立链接后,一个进程可以直接调用另一个进程的函数。</li><li>HTTP:超文本传输协议,是一种客户端和服务器之间的请求-响应模式。客户端发送请求,服务器返回响应,两者连接后立即断开。</li></ul><ol start="2"><li>传输协议</li></ol><ul><li>RPC:可以使用TCP或UDP作为传输协议。</li><li>HTTP:使用TCP作为传输协议。</li></ul><ol start="3"><li>数据格式</li></ol><ul><li>RPC:通常使用自定义的数据格式,比如XML、JSON等。</li><li>HTTP:使用标准的MIME类型,如HTML、XML、JSON、图片等多种格式。</li></ul><ol start="4"><li>连接方式</li></ol><ul><li>RPC:双方在通信期间会持续连接。</li><li>HTTP:采用无连接的传输协议,每次连接后立即断开,下次通信需要重新建立连接。</li></ul><ol start="5"><li>应用场景</li></ol><ul><li>RPC:适用于内部系统集成,提供服务的调用和响应。</li><li>HTTP:适用于Web应用,网页访问和文件传输。</li></ul><p>总结一下</p><ul><li>RPC是一种进程内通信机制,HTTP是一种网络应用协议。</li><li>RPC使用TCP或UDP,HTTP只使用TCP。 </li><li>RPC使用自定义的数据格式,HTTP使用标准MIME类型。</li><li>RPC是持续连接,HTTP是短连接。</li><li>RPC用于内部集成,HTTP用于Web应用。</li></ul><p>伊对</p><ol><li>项目，活动营销平台，感觉没有什么技术难点。。。</li><li>slice 底层实现是什么，源代码里面有哪些结构，是否是线程安全的</li><li>sync.map 怎么实现的？为什么他是线程安全的，做了哪些处理</li><li>redis zset，是什么数据结构，redis怎么存的</li><li>redis 大key问题？</li><li>mysql 慢查询怎么解决？除了索引（创建合适的索引和修改语句）+数据量 还有哪些方法？</li><li>go 内存泄漏？ 哪些情况会产生内存泄漏<ol><li>内存泄漏可能是因为长期运行的后台服务，或者是因为对象没有被适当地清理。</li><li>比如写入超过channel缓冲区间的 goroutine，但是没有人消费，后续写入全部阻塞</li><li>比如读取channel数据时，由于写入端已经执行完毕，造成饥饿阻塞</li><li>多个协程由于通信问题造成死锁</li><li>某些链接句柄采用了无限循环的方式来保证链接成功<br> 解决方法：</li><li>检查代码中是否有全局变量或长生命周期对象持有小对象的引用，导致小对象不能被垃圾回收。  </li><li>确保使用了智能指针（如<code>sync.Pool</code>）来管理共享资源的生命周期。</li><li>使用工具如<code>go tool pprof</code>分析内存使用情况，找出内存泄漏的位置。</li><li>定期重启服务以清理内存中的无用数据。</li><li>如果使用了第三方库，确保它们在使用后释放所有资源。</li><li>在代码中使用<code>defer</code>语句释放资源，如文件句柄、数据库连接等。</li><li>如果可能，使用上下文（Context）管理和取消长时间运行的操作，以便在操作完成前取消，释放资源。</li></ol></li></ol><p>题：283 移动0 改为 移动target；移动至末尾改为移动至前面</p><p>给定一个字符串str，返回字符串中字母顺序最大的而且同时在字符串中出现大写和小写的字母。 如果不存在这样的字母，返回‘~‘。<br>请返回大写字母<br>|str|&lt;&#x3D;1000<br>‘aAbBcD’ 返回 B</p><p>leetcode 931</p><p>需要自己写输入输出</p><h3 id="昆仑万维"><a href="#昆仑万维" class="headerlink" title="昆仑万维"></a>昆仑万维</h3><ol><li>gc流程？gc触发时机？</li><li>channel底层实现？</li><li>mutex底层实现？ 自旋？</li><li>mysql 多主多从？</li><li>raft协议，怎么同步日志？脑裂？怎么解决？</li><li>Kafka 为什么不支持读写分离？</li></ol><p>leet 71<br>leet 三数之和</p><p>Go channel mutex map slice 源码解析 check<br>Go gc gmp check<br>mysql B+树<br>redis raft<br>kafka<br>elasticsearch<br>etcd<br>grpc<br>zookeeper</p><p>微服务拆分。服务治理（服务发现，管理配置？流量控制，日志监控？容错容灾？）<br>网络协议：tcp&#x2F;ip，http，<br>高并发，高可用，数据一致性</p><p>dau 1-2w 上课人数，绘本 20w+<br>广告位：十几个位置 乘 dau 差不多 百万级别 qps；活动高峰期总参与差不多百万，日均大概能有10-20w，任务接口大概10-20个，综合起来差不多大几百万qps<br>相关系统 差不多 4核8g，4实例</p><p>区块链<br>1.接口加密怎么做<br>2.https是安全的么？<br>3.map为什么是线程不安全的，添加kv的流程是怎么样的？<br>4.channel区满，剩下阻塞状态的 routine 是怎么调度的？<br>5.redis 大key<br>6.go内存对齐<br>7.mysql B+树<br>8.雪崩，穿透（互斥锁 + 空缓存；布隆，但是怎么给所有接口加？）是什么？怎么解决？<br>9.kafka为什么读取比较快？<br>10.10个G的手机号，内存1G，怎么排序？</p><p>newstart 做企业erp的，说是tob但是有点像外包了<br>1.go for 和 for range 有什么区别？哪个好？<br>2.go context 过期、复制<br>3.go slice底层有哪些结构？ 扩容怎么扩的<br>4.做工资报表，有一批人员，有一批第三方考勤数据，有一批历史工资数据。你会怎么设计数据库？</p><p>区块链<br>接口怎么加密？可以用类似 sign ，对接口参数前后端同时加密对比<br>https 安全么？抓包？<br>k8s 崩溃了 有什么恢复手段？自动重启靠什么？<br>map 为什么线程不安全？ 扩容不是原子性<br>channel 10缓冲区，100 协程，写满了以后，阻塞的协程会被调度到哪里？归谁管？<br>redis 大key 问题。kv 中的 v 大，主因还是在于 redis 中 string 类型是用 sds 结构存储，最大一块内存区是 128k，更大的 value 会造成不连续的磁盘存储，影响取值速度；另一个会影响io，但相对不是主要原因<br>kafka 为什么会快呢？因为他的存储是在一段连续的区域<br>go 内存对齐<br>tidb 用的底层是啥？<br>mysql b+树，叶子节点存在哪里<br>缓存雪崩？<br>击穿怎么解决？<br>10个G的手机号文件，内存1个G，怎么排序？：拆文件，然后可以根据手机号特性，排序第一位第二位，分别放到不同的文件内</p><p>阿里：<br>1.服务拆分 原则 为什么要拆 方法论  颗粒度的粗细 数据一致性 上线之后遇到的问题<br>2.mongo mysql tidb 有什么优劣<br>3.kafka pulsuar 有什么优劣<br>4.数据库迁移遇到过哪些问题 怎么解决的<br>5.幂等 如何设计<br>6.给一个视频评论页面，数据库如何设计 索引 缓存<br>7.二分查找一个小于X的最大数<br>8.ES的原理</p><p>conviva:<br>1.网址敲了之后会发生什么<br>2.为什么用tidb<br>3.数据统计怎么做的<br>4.算法题 有向无环图求经过三个点的路径总数</p><p>旷视：<br>1.写一个结构体的快排<br>2.append的第二个参数是什么<br>3.append了之后会发生什么<br>3.用var 初始化一个slice 容量有多大 占多少字节<br>4.随机写一个leetcode中等难度的题</p><p>作业帮<br>1.讲项目，问了问活动数据<br>2.压力测试怎么做的<br>3.怎么避免高并发的请求到数据库（我讲了缓存）<br>4.数据迁移怎么做的？<br>5.算法题：不重叠的区间<br>6.go interface 能不能比较？<br>7.go 协程为什么快？</p><p>海纳AI<br>1.打开文件 应该是打开了才关，没打开不用关<br>2.for range 是复制出来的<br>3.协程传参<br>4.你写代码的层级架构是什么样<br>5.update where 如果没有索引会发生什么 跟隔离级别有关系吗<br>6.如何保证数据库和缓存的一致性：<br>    读缓存失败读sql的时候同时更新缓存<br>    对于更新频繁且一致性要求高的场景：更新时先更新缓存，再同步更新sql<br>    更新频繁但是一致性要求低：优先更新缓存，异步更新sql<br>    事务方式双写<br>    使用乐观锁 + 版本控制<br>7.缓存雪崩的解决办法<br>8.限流是怎么做的 令牌桶算法 有什么特点<br>    控制请求速率<br>    定时生成令牌，请求需要拿取令牌来执行<br>    漏桶算法：未满入桶，定速漏出来执行<br>9.假设有一场几十万人的在线考试，如何做到数据持久化数据一致性和高可用<br>10.什么是k8s的hpa<br>11.这种场景下redis和数据库的一致性<br>12.假如有一个表有几百个字段 这时候怎么办</p><p>进程，线程，协程的区别<br>进程间怎么通信<br>http，socket，rpc 概念和区别？优缺点<br>微服务怎么分的</p><p>n个数，任取 0-k 个求和，求有多少种可能的结果</p><p>与爱为舞<br>项目<br>微服务<br>数据库<br>redis<br>es<br>kafka</p><p>缓存怎么做的<br>消息触达平台 - kafka - 延时队列，<br>mysql 数据怎么落到磁盘上的<br>前后端加密 session鉴权怎么做的<br>服务治理<br>dns 和 ip 怎么弄得？如果是自建站，是什么流程<br>redis 相关结构底层 跳表，压缩表，跳表怎么确定层级<br>由概率问到了项目里面的抽奖</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 实录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ETCD 面试必备</title>
      <link href="/interview/distribution/etcd/"/>
      <url>/interview/distribution/etcd/</url>
      
        <content type="html"><![CDATA[<p>etcd分布式锁的实现流程</p><ol><li><p>建立连接<br>客户端连接 etcd，以 &#x2F;etcd&#x2F;lock 为前缀创建全局唯一的 key， 假设第一个客户端对应的 key&#x3D;“&#x2F;etcd&#x2F;lock&#x2F;UUID1”，第二个为 key&#x3D;“&#x2F;etcd&#x2F;lock&#x2F;UUID2”； 客户端分别为自己的 key 创建租约 - Lease，租约的长度根据业务耗时确定；</p></li><li><p>创建定时任务作为租约的“心跳”<br>当一个客户端持有锁期间，其它客户端只能等待，为了避免等待期间租约失效， 客户端需创建一个定时任务作为“心跳”进行续约。此外，如果持有锁期间客户端崩溃， 心跳停止，key 将因租约到期而被删除，从而锁释放，避免死锁；</p></li><li><p>客户端将自己全局唯一的 key 写入 etcd<br>执行 put 操作，将步骤 1 中创建的 key 绑定租约写入 Etcd，根据 Etcd 的 Revision 机制， 假设两个客户端 put 操作返回的 Revision 分别为 1、2，客户端需记录 Revision 用以 接下来判断自己是否获得锁；</p></li><li><p>客户端判断是否获得锁<br>客户端以前缀 &#x2F;etcd&#x2F;lock&#x2F; 读取 key-Value 列表，判断自己 key 的 Revision 是否为当前列表中 最小的，如果是则认为获得锁；否则监听列表中前一个 Revision 比自己小的 key 的删除事件，一旦监听到删除事件或者因租约失效而删除的事件，则自己获得锁；</p></li><li><p>执行业务<br>获得锁后，操作共享资源，执行业务代码</p></li><li><p>释放锁<br>完成业务流程后，删除对应的key释放锁</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 面试 </tag>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 面试必备</title>
      <link href="/interview/distribution/kafka/"/>
      <url>/interview/distribution/kafka/</url>
      
        <content type="html"><![CDATA[<h5 id="Kafka-线上消息积压怎么解决"><a href="#Kafka-线上消息积压怎么解决" class="headerlink" title="Kafka 线上消息积压怎么解决"></a>Kafka 线上消息积压怎么解决</h5><ol><li>消费端拿到的消息并发消耗掉</li><li>转发到一个新的队列</li></ol><h5 id="kafka-消息重复消费？怎么解决？"><a href="#kafka-消息重复消费？怎么解决？" class="headerlink" title="kafka 消息重复消费？怎么解决？"></a>kafka 消息重复消费？怎么解决？</h5><ol><li>如果发送端使用了重试机制，由于网络原因没有收到发送成功的 ACK</li><li>消费者手动提交 offset，拉取一批数据，没有执行完但是服务宕机，这部分会再次拉出来执行<br>解决方法：幂等处理，自动提交</li></ol><h5 id="Kafka-消息丢失？怎么解决？"><a href="#Kafka-消息丢失？怎么解决？" class="headerlink" title="Kafka 消息丢失？怎么解决？"></a>Kafka 消息丢失？怎么解决？</h5><p>学习 kafka 呢需要明确几个概念<br>生产者发送消息到 broker 中某一个 topic 的具体分区里，消费者从一个或多个分区中拉取数据进行消费</p><p>这里整理了 Kafka 的一些关键术语：</p><ul><li>Producer：生产者，消息产生和发送端。</li><li>Broker：Kafka 实例，多个 broker 组成一个 Kafka 集群，通常一台机器部署一个 Kafka 实例，一个实例挂了不影响其他实例。</li><li>Consumer：消费者，拉取消息进行消费。 一个 topic 可以让若干个消费者进行消费，若干个消费者组成一个 Consumer Group 即消费组，一条消息只能被消费组中一个 Consumer 消费。</li><li>Topic：主题，服务端消息的逻辑存储单元。一个 topic 通常包含若干个 Partition 分区。</li><li>Partition：topic 的分区，分布式存储在各个 broker 中， 实现发布与订阅的负载均衡。若干个分区可以被若干个 Consumer 同时消费，达到消费者高吞吐量。一个分区拥有多个副本（Replica），这是Kafka在可靠性和可用性方面的设计，后面会重点介绍。</li><li>message：消息，或称日志消息，是 Kafka 服务端实际存储的数据，每一条消息都由一个 key、一个 value 以及消息时间戳 timestamp 组成。</li><li>offset：偏移量，分区中的消息位置，由 Kafka 自身维护，Consumer 消费时也要保存一份 offset 以维护消费过的消息位置。</li></ul><p>消费队列呢一般用来实现 同步到异步的转换，削峰，解耦 等目标</p><h5 id="kafka-设计特性"><a href="#kafka-设计特性" class="headerlink" title="kafka 设计特性"></a>kafka 设计特性</h5><ul><li>高吞吐、低延迟：kakfa 最大的特点就是收发消息非常快，kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒。</li><li>高伸缩性： 每个主题(topic) 包含多个分区(partition)，主题中的分区可以分布在不同的主机(broker)中。</li><li>持久性、可靠性： Kafka 能够允许数据的持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，Kafka 底层的数据存储是基于 Zookeeper 存储的，Zookeeper 我们知道它的数据能够持久存储。</li><li>容错性： 允许集群中的节点失败，某个节点宕机，Kafka 集群能够正常工作</li><li>高并发： 支持数千个客户端同时读写</li></ul><h2 id="Kafka-方案及其痛点"><a href="#Kafka-方案及其痛点" class="headerlink" title="Kafka 方案及其痛点"></a>Kafka 方案及其痛点</h2><p>之前，我们采用 Apache Kafka 作为消息平台， 为了让业务在高峰期（晚上八点到十点）不受影响，我们根据消息业务量的大小， 分别搭建了不同的集群。对于一些业务场景的需求， 比如需要重置 offset 来消费过去几天的消息，使用 Kafka 需要停掉消费者才可以进行， 这种方式对大量在线业务非常不利，只能采用重写消息或者一些不太灵活的方式来实现， 极大降低了使用体验。</p><p>我们在使用 Kafka 集群过程中，主要遇到以下问题：  </p><ol><li>Kafka 没有租户概念，需要手动维护多个集群，不方便运维。</li><li>Kafka 集群扩容后需要做 Reassign Partitions，IO 消耗大。</li><li>Kafka 监控体系不完善，排查问题较为繁琐。</li><li>在线业务消息重置不方便，实现起来较为麻烦，需要停掉消费组。</li><li>Kafka 不支持死信队列和延迟队列。</li><li>Kafka 没有官方维护和支持的 Go 语言客户端。</li><li>在 Kafka 中支持 schema，需要引入额外组件，不方便维护。</li></ol><h2 id="为什么选择-Pulsar"><a href="#为什么选择-Pulsar" class="headerlink" title="为什么选择 Pulsar"></a>为什么选择 Pulsar</h2><ul><li>Pulsar 采用云原生的架构，存储和计算分离。</li><li>Pulsar 支持多租户，我们可以按照不同的业务线、业务小组和对应的服务级别来管理消息保存时间、持久化、堆积清除策略等，统一维护一套 Pulsar 集群。</li><li>Pulsar 支持灵活的水平扩容。当存储不够时，直接增加 bookie 进行扩容，不会对用户产生任何影响。</li><li>Pulsar 自带监控体系，broker，bookie 相关指标清晰，方便快速定位问题，给出解决方案。</li><li>Pulsar cursor 方便重置消息，给业务带来很好的体验。</li><li>Pulsar 支持死信队列和延迟队列。</li><li>Pulsar schema 集成在 broker 中，不需要引入单独的组件。Golang client 支持 schema，减少了维护成本。</li></ul><p>1 什么是kafka</p><blockquote><p>Kafka是分布式发布-订阅消息系统，它最初是由LinkedIn公司开发的，之后成为Apache项目的一部分，Kafka是一个分布式，可划分的，冗余备份的持久性的<a href="https://cloud.tencent.com/product/cls?from_column=20065&from=20065">日志服务</a>，它主要用于处理流式数据。</p></blockquote><p>2 为什么要使用 kafka，为什么要使用<a href="https://cloud.tencent.com/product/cmq?from_column=20065&from=20065">消息队列</a></p><blockquote><p>缓冲和削峰：上游数据时有突发流量，下游可能扛不住，或者下游没有足够多的机器来保证冗余，kafka在中间可以起到一个缓冲的作用，把消息暂存在kafka中，下游服务就可以按照自己的节奏进行慢慢处理。 解耦和扩展性：项目开始的时候，并不能确定具体需求。消息队列可以作为一个接口层，解耦重要的业务流程。只需要遵守约定，针对数据编程即可获取扩展能力。 冗余：可以采用一对多的方式，一个生产者发布消息，可以被多个订阅topic的服务消费到，供多个毫无关联的业务使用。 健壮性：消息队列可以堆积请求，所以消费端业务即使短时间死掉，也不会影响主要业务的正常进行。 异步通信：很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p></blockquote><p>3.Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么</p><blockquote><p>ISR:In-Sync Replicas 副本同步队列 AR:Assigned Replicas 所有副本 ISR是由leader维护，follower从leader同步数据有一些延迟（包括延迟时间replica.lag.time.max.ms和延迟条数replica.lag.max.messages两个维度, 当前最新的版本0.10.x中只支持replica.lag.time.max.ms这个维度），任意一个超过阈值都会把follower剔除出ISR, 存入OSR（Outof-Sync Replicas）列表，新加入的follower也会先存放在OSR中。AR&#x3D;ISR+OSR。</p></blockquote><p>4.kafka中的broker 是干什么的</p><blockquote><p>broker 是消息的代理，Producers往Brokers里面的指定Topic中写消息，Consumers从Brokers里面拉取指定Topic的消息，然后进行业务处理，broker在中间起到一个代理保存消息的中转站。</p></blockquote><p>5.kafka中的 zookeeper 起到什么作用，可以不用zookeeper么</p><blockquote><p>zookeeper 是一个分布式的协调组件，早期版本的kafka用zk做meta信息存储，consumer的消费状态，group的管理以及 offset的值。考虑到zk本身的一些因素以及整个架构较大概率存在单点问题，新版本中逐渐弱化了zookeeper的作用。新的consumer使用了kafka内部的group coordination协议，也减少了对zookeeper的依赖， 但是broker依然依赖于ZK，zookeeper 在kafka中还用来选举controller 和 检测broker是否存活等等。</p></blockquote><p>6.kafka follower如何与leader同步数据</p><blockquote><p>Kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。完全同步复制要求All Alive Follower都复制完，这条消息才会被认为commit，这种复制方式极大的影响了吞吐率。而异步复制方式下，Follower异步的从Leader复制数据，数据只要被Leader写入log就被认为已经commit，这种情况下，如果leader挂掉，会丢失数据，kafka使用ISR的方式很好的均衡了确保数据不丢失以及吞吐率。Follower可以批量的从Leader复制数据，而且Leader充分利用磁盘顺序读以及send file(zero copy)机制，这样极大的提高复制性能，内部批量写磁盘，大幅减少了Follower与Leader的消息量差。</p></blockquote><p>7.什么情况下一个 broker 会从 isr中踢出去</p><blockquote><p>leader会维护一个与其基本保持同步的Replica列表，该列表称为ISR(in-sync Replica)，每个Partition都会有一个ISR，而且是由leader动态维护 ，如果一个follower比一个leader落后太多，或者超过一定时间未发起数据复制请求，则leader将其重ISR中移除 。</p></blockquote><p>8.kafka 为什么那么快</p><ul><li>Cache Filesystem Cache PageCache缓存</li><li>顺序写 由于现代的操作系统提供了预读和写技术，磁盘的顺序写大多数情况下比随机写内存还要快。</li><li>Zero-copy 零拷技术减少拷贝次数</li><li>Batching of Messages 批量量处理。合并小的请求，然后以流的方式进行交互，直顶网络上限。</li><li>Pull 拉模式 使用拉模式进行消息的获取消费，与消费端处理能力相符。</li></ul><p>9.kafka producer如何优化打入速度</p><ul><li>增加线程</li><li>提高 batch.size</li><li>增加更多 producer 实例</li><li>增加 partition 数</li><li>设置 acks&#x3D;-1 时，如果延迟增大：可以增大 num.replica.fetchers（follower 同步数据的线程数）来调解；</li><li>跨数据中心的传输：增加 socket 缓冲区设置以及 OS tcp 缓冲区设置。</li></ul><p>10.kafka producer 打数据，ack 为 0， 1， -1 的时候代表啥， 设置 -1 的时候，什么情况下，leader 会认为一条消息 commit了</p><ol><li>1（默认） 数据发送到Kafka后，经过leader成功接收消息的的确认，就算是发送成功了。在这种情况下，如果leader宕机了，则会丢失数据。</li><li>0 生产者将数据发送出去就不管了，不去等待任何返回。这种情况下数据传输效率最高，但是数据可靠性确是最低的。</li><li>-1 producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高。当ISR中所有Replica都向Leader发送ACK时，leader才commit，这时候producer才能认为一个请求中的消息都commit了。</li></ol><p>11.kafka unclean 配置代表啥，会对 spark streaming 消费有什么影响</p><blockquote><p>unclean.leader.election.enable 为true的话，意味着非ISR集合的broker 也可以参与选举，这样有可能就会丢数据，spark streaming在消费过程中拿到的 end offset 会突然变小，导致 spark streaming job挂掉。如果unclean.leader.election.enable参数设置为true，就有可能发生数据丢失和数据不一致的情况，Kafka的可靠性就会降低；而如果unclean.leader.election.enable参数设置为false，Kafka的可用性就会降低。</p></blockquote><p>12.如果leader crash时，ISR为空怎么办</p><blockquote><p>kafka在Broker端提供了一个配置参数：unclean.leader.election,这个参数有两个值： true（默认）：允许不同步副本成为leader，由于不同步副本的消息较为滞后，此时成为leader，可能会出现消息不一致的情况。 false：不允许不同步副本成为leader，此时如果发生ISR列表为空，会一直等待旧leader恢复，降低了可用性。</p></blockquote><p>13.kafka的message格式是什么样的</p><blockquote><p>一个Kafka的Message由一个固定长度的header和一个变长的消息体body组成 header部分由一个字节的magic(文件格式)和四个字节的CRC32(用于判断body消息体是否正常)构成。 当magic的值为1的时候，会在magic和crc32之间多一个字节的数据：attributes(保存一些相关属性， 比如是否压缩、压缩格式等等);如果magic的值为0，那么不存在attributes属性 body是由N个字节构成的一个消息体，包含了具体的key&#x2F;value消息</p></blockquote><p>14.kafka中consumer group 是什么概念</p><blockquote><p>同样是逻辑上的概念，是Kafka实现单播和广播两种消息模型的手段。同一个topic的数据，会广播给不同的group；同一个group中的worker，只有一个worker能拿到这个数据。换句话说，对于同一个topic，每个group都可以拿到同样的所有数据，但是数据进入group后只能被其中的一个worker消费。group内的worker可以使用多线程或多进程来实现，也可以将进程分散在多台机器上，worker的数量通常不超过partition的数量，且二者最好保持整数倍关系，因为Kafka在设计时假定了一个partition只能被一个worker消费（同一group内）。</p></blockquote><p>15.Kafka中的消息是否会丢失和重复消费？</p><blockquote><p>要确定Kafka的消息是否丢失或重复，从两个方面分析入手：消息发送和消息消费。 1、消息发送 Kafka消息发送有两种方式：同步（sync）和异步（async），默认是同步方式，可通过producer.type属性进行配置。Kafka通过配置request.required.acks属性来确认消息的生产：</p></blockquote><ol><li><em>0—表示不进行消息接收是否成功的确认；</em></li><li><em>1—表示当Leader接收成功时确认；</em></li><li><em>-1—表示Leader和Follower都接收成功时确认；</em></li></ol><p>综上所述，有6种消息生产的情况，下面分情况来分析消息丢失的场景： （1）acks&#x3D;0，不和Kafka集群进行消息接收确认，则当网络异常、缓冲区满了等情况时，消息可能丢失； （2）acks&#x3D;1、同步模式下，只有Leader确认接收成功后但挂掉了，副本没有同步，数据可能丢失； 2、消息消费 Kafka消息消费有两个consumer接口，Low-level API和High-level API：</p><ol><li>Low-level API：消费者自己维护offset等值，可以实现对Kafka的完全控制；</li><li>High-level API：封装了对parition和offset的管理，使用简单；</li></ol><p>如果使用高级接口High-level API，可能存在一个问题就是当消息消费者从集群中把消息取出来、并提交了新的消息offset值后，还没来得及消费就挂掉了，那么下次再消费时之前没消费成功的消息就“_诡异_”的消失了； 解决办法： 针对消息丢失：同步模式下，确认机制设置为-1，即让消息写入Leader和Follower之后再确认消息发送成功；异步模式下，为防止缓冲区满，可以在配置文件设置不限制阻塞超时时间，当缓冲区满时让生产者一直处于阻塞状态； 针对消息重复：将消息的唯一标识保存到外部介质中，每次消费时判断是否处理过即可。 消息重复消费及解决参考：<a href="https://www.javazhiyin.com/22910.html">https://www.javazhiyin.com/22910.html</a></p><p>16.为什么Kafka不支持读写分离？</p><blockquote><p>在 Kafka 中，生产者写入消息、消费者读取消息的操作都是与 leader 副本进行交互的，从 而实现的是一种主写主读的生产消费模型。 Kafka 并不支持主写从读，因为主写从读有 2 个很明 显的缺点:</p></blockquote><ul><li>(1)数据一致性问题。数据从主节点转到从节点必然会有一个延时的时间窗口，这个时间 窗口会导致主从节点之间的数据不一致。某一时刻，在主节点和从节点中 A 数据的值都为 X， 之后将主节点中 A 的值修改为 Y，那么在这个变更通知到从节点之前，应用读取从节点中的 A 数据的值并不为最新的 Y，由此便产生了数据不一致的问题。</li><li>(2)延时问题。类似 <a href="https://cloud.tencent.com/product/crs?from_column=20065&from=20065">Redis</a> 这种组件，数据从写入主节点到同步至从节点中的过程需要经 历网络→主节点内存→网络→从节点内存这几个阶段，整个过程会耗费一定的时间。而在 Kafka 中，主从同步会比 Redis 更加耗时，它需要经历网络→主节点内存→主节点磁盘→网络→从节 点内存→从节点磁盘这几个阶段。对延时敏感的应用而言，主写从读的功能并不太适用。</li></ul><p>17.Kafka中是怎么体现消息顺序性的？</p><blockquote><p>kafka每个partition中的消息在写入时都是有序的，消费时，每个partition只能被每一个group中的一个消费者消费，保证了消费时也是有序的。 整个topic不保证有序。如果为了保证topic整个有序，那么将partition调整为1.</p></blockquote><p>18.消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1?</p><blockquote><p>offset+1</p></blockquote><p>19.kafka如何实现延迟队列？</p><blockquote><p>Kafka并没有使用JDK自带的Timer或者DelayQueue来实现延迟的功能，而是基于时间轮自定义了一个用于实现延迟功能的定时器（SystemTimer）。JDK的Timer和DelayQueue插入和删除操作的平均时间复杂度为O(nlog(n))，并不能满足Kafka的高性能要求，而基于时间轮可以将插入和删除操作的时间复杂度都降为O(1)。时间轮的应用并非Kafka独有，其应用场景还有很多，在Netty、Akka、Quartz、Zookeeper等组件中都存在时间轮的踪影。 底层使用数组实现，数组中的每个元素可以存放一个TimerTaskList对象。TimerTaskList是一个环形双向链表，在其中的链表项TimerTaskEntry中封装了真正的定时任务TimerTask. Kafka中到底是怎么推进时间的呢？Kafka中的定时器借助了JDK中的DelayQueue来协助推进时间轮。具体做法是对于每个使用到的TimerTaskList都会加入到DelayQueue中。Kafka中的TimingWheel专门用来执行插入和删除TimerTaskEntry的操作，而DelayQueue专门负责时间推进的任务。再试想一下，DelayQueue中的第一个超时任务列表的expiration为200ms，第二个超时任务为840ms，这里获取DelayQueue的队头只需要O(1)的时间复杂度。如果采用每秒定时推进，那么获取到第一个超时的任务列表时执行的200次推进中有199次属于“空推进”，而获取到第二个超时任务时有需要执行639次“空推进”，这样会无故空耗机器的性能资源，这里采用DelayQueue来辅助以少量空间换时间，从而做到了“精准推进”。Kafka中的定时器真可谓是“知人善用”，用TimingWheel做最擅长的任务添加和删除操作，而用DelayQueue做最擅长的时间推进工作，相辅相成。</p></blockquote><h2 id="Kafka集群leader选举"><a href="#Kafka集群leader选举" class="headerlink" title="Kafka集群leader选举"></a>Kafka集群leader选举</h2><ol><li>在kafka集群中，第一个启动的broker会在zk中创建一个临时节点&#x2F;controller让自己成为控制器。其他broker启动时也会试着创建这个节点当然他们会失败，因为已经有人创建过了。那么这些节点会在控制器节点上创建zk watch对象，这样他们就可以收到这个节点变更的通知。任何时刻都确保集群中只有一个leader的存在。</li><li>如果控制器被关闭或者与zk断开连接，zk上的KB是节点马上就会消失。那么其他订阅了leader节点的broker也会收到通知随后他们会尝试让自己成为新的leader，重复第一步的操作。</li><li>如果leader完好但是别的broker离开了集群，那么leader会去确定离开的broker的分区并确认新的分区领导者(即分区副本列表里的下一个副本)。然后向所有包含该副本的follower或者observer发送请求。随后新的分区首领开始处理请求。</li></ol><h2 id="Kafka创建副本的2种模式——同步复制和异步复制"><a href="#Kafka创建副本的2种模式——同步复制和异步复制" class="headerlink" title="Kafka创建副本的2种模式——同步复制和异步复制"></a>Kafka创建副本的2种模式——同步复制和异步复制</h2><blockquote><p>Kafka动态维护了一个同步状态的副本的集合（a set of In-Sync Replicas），简称ISR，在这个集合中的节点都是和leader保持高度一致的，任何一条消息只有被这个集合中的每个节点读取并追加到日志中，才会向外部通知说“这个消息已经被提交”。</p><p>只有当消息被所有的副本加入到日志中时，才算是“committed”，只有committed的消息才会发送给consumer，这样就不用担心一旦leader down掉了消息会丢失。消息从leader复制到follower,我们可以通过决定Producer是否等待消息被提交的通知(ack)来区分同步复制和异步复制。</p></blockquote><h3 id="同步复制流程"><a href="#同步复制流程" class="headerlink" title="同步复制流程"></a>同步复制流程</h3><blockquote><p>同步复制流程：</p></blockquote><ul><li>producer联系zk识别leader；</li><li>向leader发送消息；</li><li>leadr收到消息写入到本地log；</li><li>follower从leader pull消息；</li><li>follower向本地写入log；</li><li>follower向leader发送ack消息；</li><li>leader收到所有follower的ack消息；</li><li>leader向producer回传ack。</li></ul><h3 id="异步复制流程"><a href="#异步复制流程" class="headerlink" title="异步复制流程"></a>异步复制流程</h3><blockquote><p>异步复制流程： 和同步复制的区别在于，leader写入本地log之后，直接向client回传ack消息，不需要等待所有follower复制完成。 既然kafka支持副本模式，那么其中一个Broker里的挂掉，一个新的leader就能通过ISR机制推选出来，继续处理读写请求。</p></blockquote><h2 id="Kafka判断一个broker节点是否存活"><a href="#Kafka判断一个broker节点是否存活" class="headerlink" title="Kafka判断一个broker节点是否存活"></a>Kafka判断一个broker节点是否存活</h2><blockquote><p>依据两个条件：</p></blockquote><ul><li>节点必须可以维护和ZooKeeper的连接，Zookeeper通过心跳机制检查每个节点的连接;</li><li>如果节点是个follower,他必须能及时的同步leader的写操作，延时不能太久。Leader会追踪所有“同步中”的节点，一旦一个down掉了，或是卡住了，或是延时太久，leader就会把它移除。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 面试 </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang语言面试题 - Grpc</title>
      <link href="/interview/go/go-grpc/"/>
      <url>/interview/go/go-grpc/</url>
      
        <content type="html"><![CDATA[<h3 id="grpc和http区别"><a href="#grpc和http区别" class="headerlink" title="grpc和http区别"></a>grpc和http区别</h3><p>gRPC和HTTP的主要区别在于它们的传输协议、序列化和反序列化方法、性能特性以及使用场景。具体如下：</p><ul><li>传输协议不同。gRPC使用基于二进制的HTTP&#x2F;2作为传输协议，支持多路复用、头部压缩和服务器推送等功能，提高了性能和效率，而HTTP通常使用文本协议，基于HTTP&#x2F;1.1或HTTP&#x2F;2，HTTP&#x2F;1.1是基于请求-响应模式的协议，每次请求都需要建立新的连接，HTTP&#x2F;2引入了多路复用和头部压缩等功能。</li><li>序列化和反序列化方法不同。gRPC使用Protocol Buffers（protobuf）作为默认的接口定义语言（IDL），用于描述数据结构和服务接口，protobuf是一种高效的二进制序列化格式，可以提供更小的数据包大小和更快的序列化&#x2F;反序列化速度，而HTTP使用普通文本格式进行数据交换，通常使用JSON或XML作为数据的表示格式。</li><li>性能特性不同。gRPC在性能方面优于HTTP，由于使用了二进制格式，因此传输速度更快、更稳定，而且gRPC通过使用连接池，实现客户端与服务端的长连接机制，使得延迟较低，在高网络带宽时表现更好，而HTTP设计目标是作为一种通用的、可扩展的协议，用于在客户端和服务器之间传输超文本数据，广泛用于Web应用程序和浏览器之间的通信。</li><li>使用场景不同。gRPC通常用于服务之间的通信，特别是分布式系统中，例如微服务框架等，具有高性能、低延迟、易扩展等特点，是一个理想的分布式系统通信协议，而HTTP主要用于Web中浏览器和服务器之间的交互，在Web应用程序中非常常见。</li></ul><p>1.grpc底层用的什么协议?</p><blockquote><p>http2.0</p></blockquote><p>2.http2.0和1.1的区别?</p><blockquote><ol><li>多路复用: 1.1每个请求必须是独立的TCP请求, 2.0采用多路复用, 一个TCP连接可以进行多次请求, 大大提升性能</li><li>数据传输: 2.0引入数据流的概念, 允许不同请求在同一连接交错发送</li><li>头部处理: 2.0 采用HPACK算法对头部数据进行压缩, 降低数据大小和网络开销</li><li>二进制协议: http&#x2F;1.1报文头信息必须是文本, 数据体可以是二进制,也可是文本。2.0 头信息和数据体都是二进制, 更加高效的处理数据</li><li>错误处理: 1.1处理错误需要关闭连接, 2.0引入可以在不关闭连接的情况下处理错误</li></ol></blockquote><p>3.gRPC有几种请求模式?</p><blockquote><ol><li>简单模式: 客户端发起请求, 等待服务端响应. (例如普通的grpc定义message, 一次请求一次响应)</li><li>服务端流式(长连接): 客户端发送请求, 服务端返回一个流, 客户端持续监听这个流, 反序列化其中的内容, 返回给用户,适用于客户端需要向服务端发送大量数据的情况, 如文件上传</li><li>客户端流式(长连接): 客户端创建一个流, 将请求参数以流的方式给服务端, 服务端再返回单个响应, 适合服务端向客户端发送大量数据的情况, 例如实时数据传输</li><li>双向流式: 允许客户端和服务端同时读写数据. 双方都可以随时开始和结束数据的发送. 适合双向数据传输模式</li></ol><p>传统的http连接时短连接, 一次请求一次响应后, 连接就断开了, 然而, 客户端流式RPC和服务端流式RPC模式基于TCP长连接, 用于多次数据交换.</p></blockquote><p>4.protobuf了解过吗? 和有什么区别? 对比json有什么优势? 压缩率对比json来说能达到多少?</p><blockquote><p>和json的对比:</p><ol><li>protobuf使用二进制格式, json为文本格式, 所以protobuf的序列化和反序列化更加高效</li><li>由于使用二进制传输, protobuf的体积通常更小</li><li>protobuf是强类型的, 定义数据结构时必须指定每个字段的类型, 可以减少解析时的错误, json是弱类型的, 不强制字段的类型</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> go </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go语言 Slice 结构的底层实现</title>
      <link href="/golang/advanced-tutorial/go-slice/"/>
      <url>/golang/advanced-tutorial/go-slice/</url>
      
        <content type="html"><![CDATA[<h4 id="append-性能损耗"><a href="#append-性能损耗" class="headerlink" title="append 性能损耗"></a>append 性能损耗</h4><p>未指定长度或者长度不足时，双倍扩容（cap &lt; 1024）; 1.25倍扩容(cap &gt; 1024)。把元内存空间的数据拷贝过来，然后在新的内存空间继续append数据</p><p>在 Go 1.18 以后，扩容使用threshold为临界点（源码中设置为256）<br>当slice容量 &lt; 256时， 每次扩容为原来的两倍。当slice容量 &gt; 256时， 每次增加(oldcap + 3*threshold) 3&#x2F;4</p><h4 id="母子切片共享内存问题"><a href="#母子切片共享内存问题" class="headerlink" title="母子切片共享内存问题"></a>母子切片共享内存问题</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slicem := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>) <span class="comment">// len = 3, cap = 5 分配了5个空间，置入了3个数据</span></span><br><span class="line">slices := slicem[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">// len = 2, cap = 4</span></span><br></pre></td></tr></table></figure><p>最开始时，子切片和母切片共享母切片的内存空间，对子切片的修改会反映到母切片上，对子切片的 append 操作，会将数据添加到母切片预留的内存空间内。<br>如持续进行 append 操作，直到将母切片预留的内存空间完全消耗完毕后，二者就会发生内存分离，从此再无关系</p><h4 id="切片导致内存泄漏"><a href="#切片导致内存泄漏" class="headerlink" title="切片导致内存泄漏"></a>切片导致内存泄漏</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Leak</span><span class="params">()</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">parent := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">son := parent[<span class="number">10</span>:<span class="number">20</span>]</span><br><span class="line"><span class="keyword">return</span> son</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>func 返回子切片，只要这个子切片没有被 GC 回收，子切片持有的母切片的内存空间就得不到释放，导致泄漏</p><h4 id="函数参数需要用切片指针么"><a href="#函数参数需要用切片指针么" class="headerlink" title="函数参数需要用切片指针么"></a>函数参数需要用切片指针么</h4><p>如果函数内部需要对切片的 len 和 cap 进行修改，且修改要反映在函数外部，那么需要传入切片的指针</p><h4 id="一边遍历一边修改切片"><a href="#一边遍历一边修改切片" class="headerlink" title="一边遍历一边修改切片"></a>一边遍历一边修改切片</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// go 中 for-range 遍历的是原集合的拷贝</span></span><br><span class="line"><span class="keyword">for</span> i, m := <span class="keyword">range</span> arr &#123;</span><br><span class="line">m += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下方这种才能修改成功</span></span><br><span class="line"><span class="keyword">for</span> i, m := <span class="keyword">range</span> arr &#123;</span><br><span class="line">arr[i] = m + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 进阶教程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 必看必会 </tag>
            
            <tag> go </tag>
            
            <tag> Slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式23-中介模式</title>
      <link href="/golang/go-design-pattern/gdp-act/23-mediator/"/>
      <url>/golang/go-design-pattern/gdp-act/23-mediator/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式22-解释器模式</title>
      <link href="/golang/go-design-pattern/gdp-act/22-interpreter/"/>
      <url>/golang/go-design-pattern/gdp-act/22-interpreter/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式21-命令模式</title>
      <link href="/golang/go-design-pattern/gdp-act/21-command/"/>
      <url>/golang/go-design-pattern/gdp-act/21-command/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式20-备忘录模式</title>
      <link href="/golang/go-design-pattern/gdp-act/20-memento/"/>
      <url>/golang/go-design-pattern/gdp-act/20-memento/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式19-访问者模式</title>
      <link href="/golang/go-design-pattern/gdp-act/19-visitor/"/>
      <url>/golang/go-design-pattern/gdp-act/19-visitor/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式18-迭代器模式</title>
      <link href="/golang/go-design-pattern/gdp-act/18-iterator/"/>
      <url>/golang/go-design-pattern/gdp-act/18-iterator/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式17-状态模式</title>
      <link href="/golang/go-design-pattern/gdp-act/17-state/"/>
      <url>/golang/go-design-pattern/gdp-act/17-state/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言 Map 结构的底层实现</title>
      <link href="/golang/advanced-tutorial/go-map/"/>
      <url>/golang/advanced-tutorial/go-map/</url>
      
        <content type="html"><![CDATA[<h2 id="Golang-中的-map-详解"><a href="#Golang-中的-map-详解" class="headerlink" title="Golang 中的 map 详解"></a>Golang 中的 map 详解</h2><h3 id="一、什么是-map？"><a href="#一、什么是-map？" class="headerlink" title="一、什么是 map？"></a>一、什么是 map？</h3><h4 id="1、map-的定义"><a href="#1、map-的定义" class="headerlink" title="1、map 的定义"></a>1、map 的定义</h4><p>  在计算机科学里，被称为相关数组、map、符号表或者字典，是由一组 &lt;key, value&gt; 对组成的抽象数据结构，并且同一个 key 只会出现一次。<br>  两个关键点：map 是由 key-value 对组成的；key 只会出现一次。<br>  map 的设计也被称为 “The dictionary problem（字典问题）”，它的任务是设计一种数据结构用来维护一个集合的数据，并且可以同时对集合进行增删查改的操作。</p><h4 id="2、map-的数据结构"><a href="#2、map-的数据结构" class="headerlink" title="2、map 的数据结构"></a>2、map 的数据结构</h4><p>  最主要的数据结构有两种：哈希查找表（Hash table）、搜索树（Search tree）。</p><p>哈希查找表（Hash table）<br>  哈希查找表使用哈希函数将 key 分配到不同的桶（bucket，也就是数组的不同 index），开销主要在哈希函数的计算以及数组的常数访问时间，在很多场景下，哈希查找表的性能很高。</p><p>搜索树（Search tree）<br>  搜索树一般采用自平衡搜索树，包括：AVL 树，红黑树。<br>  哈希查找表的平均查找效率是 O(1)，最差是 O(N)，如果哈希函数设计的很好，最坏的情况基本不会出现。自平衡搜索树法的最差搜索效率是 O(logN)。遍历自平衡搜索树，返回的 key 序列，一般会按照从小到大的顺序；而哈希查找表则是乱序的。</p><h3 id="二、Golang-中-map-的类型"><a href="#二、Golang-中-map-的类型" class="headerlink" title="二、Golang 中 map 的类型"></a>二、Golang 中 map 的类型</h3><p>  Golang 中 map 是一个指针，占用 8 个字节。当使用 make 创建 map 时，底层调用的是 makemap() 函数，makemap() 函数返回的是一个指针，因为返回的是指针，所以 map 作为参数的时候，函数内部能修改map。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="三、map-的底层实现"><a href="#三、map-的底层实现" class="headerlink" title="三、map 的底层实现"></a>三、map 的底层实现</h3><p>   源码位于 src\runtime\map.go 中。</p><p>  golang 中 map 底层使用的是哈希查找表，用链表来解决哈希冲突。每个 map 的底层结构是 hmap，是由若干个结构为 bmap 的 bucket 组成的数组，每个 bucket 底层都采用链表结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.  </span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;  </span><br><span class="line"><span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.   </span></span><br><span class="line"><span class="comment">// Make sure this stays in sync with the compiler&#x27;s definition.   </span></span><br><span class="line">count     <span class="type">int</span>    <span class="comment">// map中元素的数量，调用len()直接返回此值  </span></span><br><span class="line">flags     <span class="type">uint8</span>  <span class="comment">// 状态标识符，key和value是否包指针、是否正在扩容、是否已经被迭代</span></span><br><span class="line">B         <span class="type">uint8</span>  <span class="comment">// map中桶数组的数量，桶数组的长度的对数，len(buckets) == 2^B，可以最多容纳 6.5 * 2 ^ B 个元素，6.5为装载因子  </span></span><br><span class="line">noverflow <span class="type">uint16</span> <span class="comment">// 溢出桶的大概数量，当B小于16时是准确值，大于等于16时是大概的值</span></span><br><span class="line">hash0     <span class="type">uint32</span> <span class="comment">// 哈希种子，用于计算哈希值，为哈希函数的结果引入一定的随机性</span></span><br><span class="line"></span><br><span class="line">buckets    unsafe.Pointer <span class="comment">// 指向桶数组的指针，长度为 2^B ，如果元素个数为0，就为 nil  </span></span><br><span class="line">oldbuckets unsafe.Pointer <span class="comment">// 指向一个旧桶数组，用于扩容，它的长度是当前桶数组的一半, 扩容时非空  </span></span><br><span class="line">nevacuate  <span class="type">uintptr</span>        <span class="comment">// 搬迁进度，小于此地址的桶数组迁移完成  </span></span><br><span class="line"></span><br><span class="line">extra *mapextra <span class="comment">// 可选字段，用于gc，指向所有的溢出桶，避免gc时扫描整个map，仅扫描所有溢出桶就足够了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mapextra holds fields that are not present on all maps.type </span></span><br><span class="line">mapextra <span class="keyword">struct</span> &#123;  </span><br><span class="line">   <span class="comment">// If both key and elem do not contain pointers and are inline, then we mark bucket  </span></span><br><span class="line">   <span class="comment">// type as containing no pointers. This avoids scanning such maps.  </span></span><br><span class="line">   <span class="comment">// However, bmap.overflow is a pointer. In order to keep overflow buckets   </span></span><br><span class="line">   <span class="comment">// alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow.   </span></span><br><span class="line">   <span class="comment">// overflow and oldoverflow are only used if key and elem do not contain pointers.   </span></span><br><span class="line">   <span class="comment">// overflow contains overflow buckets for hmap.buckets.  </span></span><br><span class="line">   <span class="comment">// oldoverflow contains overflow buckets for hmap.oldbuckets.  </span></span><br><span class="line">   <span class="comment">// The indirection allows to store a pointer to the slice in hiter.  </span></span><br><span class="line">   overflow    *[]*bmap  <span class="comment">// 指针数组，指向所有溢出桶</span></span><br><span class="line">   oldoverflow *[]*bmap  <span class="comment">// 指针数组，发生扩容时，指向所有旧的溢出桶</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// nextOverflow holds a pointer to a free overflow bucket.  </span></span><br><span class="line">   nextOverflow *bmap  <span class="comment">// 指向所有溢出桶中下一个可以使用的溢出桶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bmap的结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [bucketCnt]<span class="type">uint8</span>    <span class="comment">// bucketCnt=8，// 存放key哈希值的高8位，用于决定kv键值对放在桶内的哪个位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上编辑期间会动态生成一个新的结构体</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">topbits  [<span class="number">8</span>]<span class="type">uint8</span>     <span class="comment">// 存放key哈希值的高8位，用于决定kv键值对放在桶内的哪个位置</span></span><br><span class="line">keys     [<span class="number">8</span>]keytype   <span class="comment">// 存放key的数组</span></span><br><span class="line">values   [<span class="number">8</span>]valuetype <span class="comment">// 存放value的数组</span></span><br><span class="line">pad      <span class="type">uintptr</span>      <span class="comment">// 用于对齐内存</span></span><br><span class="line">overflow <span class="type">uintptr</span>      <span class="comment">// 指向下一个桶，即溢出桶，拉链法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buckets是一个bmap数组，数组的长度就是 2^B。每个bucket固定包含8个key和value，实现上面是一个固定的大小连续内存块，分成四部分：tophash 值，8个key值，8个value值，指向下个bucket的指针。</p><p>tophash 值用于快速查找key是否在该bucket中，当插入和查询运行时都会使用哈希哈数对key做哈希运算，获取一个hashcode，取高8位存放在bmap tophash字段中。</p><p>桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置）。</p><p>如图，B&#x3D;5 表示hmap的有2^5&#x3D;32个bmap，buckets是一个bmap数组，其长度为32，每个bmap有8个key。</p><p>桶结构的很多字段得在编译时才会动态生成，比如 key 和 values 等</p><p>桶结构中，之所以所有的 key 放一起，所有的 value 放一起，而不是 key&#x2F;value 一对对的一起存放，目的便是在某些情况下可以省去pad字段，节省内存空间。由于内存对齐的原因，key0&#x2F;value0&#x2F;key1&#x2F;value1… 这样的形式可能需要更多的补齐空间，比如 map[int64]int8 ，1字节的value后面需要补齐7个字节才能保证下一个key是 int64 对齐的。</p><p>golang中的map使用的内存是不会收缩的，只会越用越多。</p><p>每个 bucket 设计成最多只能放 8 个 key-value 对，如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个溢出桶 bucket ，通过 overflow 指针连接起来。</p><h3 id="四、map-的扩容"><a href="#四、map-的扩容" class="headerlink" title="四、map 的扩容"></a>四、map 的扩容</h3><h4 id="1、装载因子（平均每个桶存储的元素个数）"><a href="#1、装载因子（平均每个桶存储的元素个数）" class="headerlink" title="1、装载因子（平均每个桶存储的元素个数）"></a>1、装载因子（平均每个桶存储的元素个数）</h4><p>  Go的装载因子阈值常量：6.5，map 最多可容纳 6.5*2^B 个元素。</p><p>  装载因子等于 map中元素的个数 &#x2F; map的容量，即len(map) &#x2F; 2^B。装载因子用来表示空闲位置的情况，装载因子越大，表明空闲位置越少，冲突也越多。随着装载因子的增大，哈希表线性探测的平均用时就会增加，这会影响哈希表的性能，当装载因子大于70%，哈希表的性能就会急剧下降，当装载因子达到100%，整个哈希表就会完全失效，这个时候，查找和插入任意元素的复杂度都是O(N),因为需要遍历所有元素。</p><p>  另外装载因子与扩容、迁移等重新散列(rehash) 行为有直接关系：</p><p>在程序运行时，会不断地进行插入、删除等，会导致 bucket 不均，内存利用率低，需要迁移。<br>在程序运行时，出现装载因子过大，需要做扩容，解决 bucket 过大的问题。<br>为什么装载因子是6.5？不是8？不是1？<br>  装载因子是哈希表中的一个重要指标，主要目的是为了平衡 buckets 的存储空间大小和查找元素时的性能高低。实际上这是 Go 官方的经过认真的测试得出的数字，一起来看看官方的这份测试报告。包含四个指标：</p><p>loadFactor：负载因子，也叫装载因子；<br>%overflow：溢出率，有溢出 bukcet 的百分比；<br>bytes&#x2F;entry：平均每对 key&#x2F;alue 的开销字节数；<br>hitprobe：查找一个存在的 key 时，要查找的平均个数；<br>missprobe：查找一个不存在的 key 时，要查找的平均个数。</p><p>  Go 官方发现：装载因子越大，填入的元素越多，空间利用率就越高，但发生冲突的几率就变大；反之，装数因子越小，填入的元素越少，冲突发生的几率减小，但空间利用率低，而且还会提高扩容操作的次数。</p><p>  根据这份测试结果和讨论，Go 官方取了一个相对适中的值，把 Go 中的 map 的负数因子硬编码为 6.5，这就是 6.5 的选择缘由。这意味着在 Go 语言中，当 map存储的元素个数大于或等于 6.5*桶个数 时，就会发扩容行为。</p><h4 id="2、触发-map-扩容的时机（插入、删除key）"><a href="#2、触发-map-扩容的时机（插入、删除key）" class="headerlink" title="2、触发 map 扩容的时机（插入、删除key）"></a>2、触发 map 扩容的时机（插入、删除key）</h4><p>当装载因子超过6.5时，扩容一倍，属于增量扩容；<br>当使用的溢出桶过多时，重新分配一样大的内存空间，属于等量扩容；<br>（实际上没有扩容，主要是为了回收空闲的溢出桶，节省空间，提高 map 的查找和插入效率）<br>为什么会出现这种情况？<br>  这种情况可能是因为map删除的特性导致的。当我们不断向哈希表中插入数据，并且将他们又全部删除时，其内存占用并不会减少，因为删除只是将桶对应位置的tophash置nil而已。<br>  这种情况下，就会不断的积累溢出桶造成内存泄露，为了解决这种情况，采用了等量扩容的机制，一旦哈希表中出现了过多的溢出桶，会创建新桶保存数据，gc会清理掉老的溢出桶，从而避免内存泄露。</p><p>如何定义溢出桶是否太多需要等量扩容呢？两种情况：</p><p>当B小于15时，溢出桶的数量超过2^B，属于溢出桶数量太多，需要等量扩容；<br>当B大于等于15时，溢出桶数量超过2^15，属于溢出桶数量太多，需要等量扩容。</p><h4 id="3、扩容策略（怎么扩容？）"><a href="#3、扩容策略（怎么扩容？）" class="headerlink" title="3、扩容策略（怎么扩容？）"></a>3、扩容策略（怎么扩容？）</h4><p>  Go 会创建一个新的 buckets 数组，新的 buckets 数组的容量是旧buckets数组的两倍（或者和旧桶容量相同），将原始桶数组中的所有元素重新散列到新的桶数组中。这样做的目的是为了使每个桶中的元素数量尽可能平均分布，以提高查询效率。旧的buckets数组不会被直接删除，而是会把原来对旧数组的引用去掉，让GC来清除内存。</p><p>  在map进行扩容迁移的期间，不会触发第二次扩容。只有在前一个扩容迁移工作完成后，map才能进行下一次扩容操作。</p><h4 id="4、搬迁策略"><a href="#4、搬迁策略" class="headerlink" title="4、搬迁策略"></a>4、搬迁策略</h4><p>  由于map扩容需要将原有的kv键值对搬迁到新的内存地址，如果一下子全部搬完，会非常的影响性能。go 中 map 的扩容采用渐进式的搬迁策略，原有的 key 并不会一次性搬迁完毕，一次性搬迁会造成比较大的延时，每次最多只会搬迁 2 个 bucket，将搬迁的O(N)开销均摊到O(1)的赋值和删除操作上。</p><p>  上面说的 hashGrow() 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets 挂到了 oldbuckets 字段上。真正搬迁 buckets 的动作在 growWork() 函数中，而调用 growWork() 函数的动作是在 mapassign 和 mapdelete 函数中。也就是插入或修改、删除 key 的时候，都会尝试进行搬迁 buckets 的工作。先检查 oldbuckets 是否搬迁完毕，具体来说就是检查 oldbuckets 是否为 nil。</p><h3 id="五、解决哈希冲突"><a href="#五、解决哈希冲突" class="headerlink" title="五、解决哈希冲突"></a>五、解决哈希冲突</h3><h4 id="1、开放寻址法"><a href="#1、开放寻址法" class="headerlink" title="1、开放寻址法"></a>1、开放寻址法</h4><p>  如果发生哈希冲突，从发生冲突的那个单元起，按一定的次序，不断重复，从哈希表中寻找一个空闲的单元，将该键值对存储在该单元中。具体的实现方式包括线性探测法、平方探测法、随机探测法和双重哈希法等。开放寻址法需要的表长度要大于等于所需要存放的元素数量。</p><h4 id="2、链地址法"><a href="#2、链地址法" class="headerlink" title="2、链地址法"></a>2、链地址法</h4><p>  基于数组 + 链表 实现哈希表，数组中每个元素都是一个链表，将每个桶都指向一个链表，当哈希冲突发生时，新的键值对会按顺序添加到该桶对应的链表的尾部。在查找特定键值对时，可以遍历该链表以查找与之匹配的键值对。</p><h4 id="3、两种方案的比较"><a href="#3、两种方案的比较" class="headerlink" title="3、两种方案的比较"></a>3、两种方案的比较</h4><p>内存利用率<br>  对于链地址法，基于 数组 + 链表 进行存储，链表节点可以在需要时再创建，开放寻址法需要事先申请好足够内存，因此链地址法对内存的利用率高。<br>适用场景<br>  链地址法对装载因子的容忍度会更高，适合存储大对象、大数据量的哈希表，而且相较于开放寻址法，它更加灵活，支持更多的优化策略，比如可采用红黑树代替链表。但是链地址法需要额外的空间来存储指针。<br>  对于开放寻址法，它只有数组一种数据结构就可完成存储，继承了数组的优点，对CPU缓存友好，易于序列化操作，但是它对内存的利用率不高，且发生冲突时代价更高。当数据量明确、装载因子小，适合采用开放寻址法。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 进阶教程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 必看必会 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式16-职责链模式</title>
      <link href="/golang/go-design-pattern/gdp-act/16-chain/"/>
      <url>/golang/go-design-pattern/gdp-act/16-chain/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式15-策略模式</title>
      <link href="/golang/go-design-pattern/gdp-act/15-strategy/"/>
      <url>/golang/go-design-pattern/gdp-act/15-strategy/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式14-模板模式</title>
      <link href="/golang/go-design-pattern/gdp-act/14-template/"/>
      <url>/golang/go-design-pattern/gdp-act/14-template/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式13-观察者模式</title>
      <link href="/golang/go-design-pattern/gdp-act/13-observer/"/>
      <url>/golang/go-design-pattern/gdp-act/13-observer/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式12-享元模式</title>
      <link href="/golang/go-design-pattern/gdp-struct/12-flyweight/"/>
      <url>/golang/go-design-pattern/gdp-struct/12-flyweight/</url>
      
        <content type="html"><![CDATA[<p>按照课程中的例子来理解，就是象棋棋子作为享元，可以被所有的对局共享，以达到减少内存的目的</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式11-组合模式</title>
      <link href="/golang/go-design-pattern/gdp-struct/11-composite/"/>
      <url>/golang/go-design-pattern/gdp-struct/11-composite/</url>
      
        <content type="html"><![CDATA[<p>比较简单的例子是 人员架构中 部门和人员的关系，二者可以形成简单的树形接口，部门中规定了一些功能；而人员又有自己的基本属性功能</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式10-门面模式</title>
      <link href="/golang/go-design-pattern/gdp-struct/10-facade/"/>
      <url>/golang/go-design-pattern/gdp-struct/10-facade/</url>
      
        <content type="html"><![CDATA[<p>简单来理解就是 有登录和注册两个基础功能，对外统一封装成 登录&amp;注册，上层调用无需知道具体调用的逻辑，只通过一个接口获取登录状态即可</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式09-适配器模式</title>
      <link href="/golang/go-design-pattern/gdp-struct/09-adapter/"/>
      <url>/golang/go-design-pattern/gdp-struct/09-adapter/</url>
      
        <content type="html"><![CDATA[<p>简单理解是有两个不同的业务系统，需要同时完成同一种业务动作，可以封装后统一提供给上层调用</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式08-装饰器模式</title>
      <link href="/golang/go-design-pattern/gdp-struct/08-decorator/"/>
      <url>/golang/go-design-pattern/gdp-struct/08-decorator/</url>
      
        <content type="html"><![CDATA[<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>下面是一个简单的画画的例子，默认的 <code>Line</code>  只有基础的画画功能， <code>ColorLine</code>  为他加上了颜色，本质上是对现有功能类进行包装，增加新功能点</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> decorator  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// IDraw IDraw  </span></span><br><span class="line"><span class="keyword">type</span> IDraw <span class="keyword">interface</span> &#123;  </span><br><span class="line">   Draw() <span class="type">string</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Line 划线  </span></span><br><span class="line"><span class="keyword">type</span> Line <span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Draw Draw  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Line)</span></span> Draw() <span class="type">string</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;Drawing a line here&quot;</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ColorLine 有颜色的线  </span></span><br><span class="line"><span class="keyword">type</span> ColorLine <span class="keyword">struct</span> &#123;  </span><br><span class="line">   line IDraw  </span><br><span class="line">   color  <span class="type">string</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// NewColorLine NewColorLine  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewColorLine</span><span class="params">(line IDraw, color <span class="type">string</span>)</span></span> ColorLine &#123;  </span><br><span class="line">   <span class="keyword">return</span> ColorLine&#123;color: color, line: line&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Draw Draw  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ColorLine)</span></span> Draw() <span class="type">string</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> c.line.Draw() + <span class="string">&quot;, color is &quot;</span> + c.color  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestColorLine_Draw</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">   l := Line&#123;&#125;  </span><br><span class="line">   ncl := NewColorLine(sq, <span class="string">&quot;red&quot;</span>)  </span><br><span class="line">   got := ncl.Draw()  </span><br><span class="line">   assert.Equal(t, <span class="string">&quot;Drawing a line here, color is red&quot;</span>, got)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式07-桥接模式</title>
      <link href="/golang/go-design-pattern/gdp-struct/07-bridge/"/>
      <url>/golang/go-design-pattern/gdp-struct/07-bridge/</url>
      
        <content type="html"><![CDATA[<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bridge  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// IMsgSender IMsgSender  </span></span><br><span class="line"><span class="keyword">type</span> IMsgSender <span class="keyword">interface</span> &#123;  </span><br><span class="line">   Send(msg <span class="type">string</span>) <span class="type">error</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// EmailMsgSender 发送邮件  </span></span><br><span class="line"><span class="comment">// 可能还有 电话、短信等各种实现  </span></span><br><span class="line"><span class="keyword">type</span> EmailMsgSender <span class="keyword">struct</span> &#123;  </span><br><span class="line">   emails []<span class="type">string</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// NewEmailMsgSender NewEmailMsgSender  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEmailMsgSender</span><span class="params">(emails []<span class="type">string</span>)</span></span> *EmailMsgSender &#123;  </span><br><span class="line">   <span class="keyword">return</span> &amp;EmailMsgSender&#123;emails: emails&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Send Send  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmailMsgSender)</span></span> Send(msg <span class="type">string</span>) <span class="type">error</span> &#123;  </span><br><span class="line">   <span class="comment">// 这里去发送消息  </span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// INotification 通知接口  </span></span><br><span class="line"><span class="keyword">type</span> INotification <span class="keyword">interface</span> &#123;  </span><br><span class="line">   Notify(msg <span class="type">string</span>) <span class="type">error</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ErrorNotification 错误通知  </span></span><br><span class="line"><span class="comment">// 后面可能还有 warning 各种级别  </span></span><br><span class="line"><span class="keyword">type</span> ErrorNotification <span class="keyword">struct</span> &#123;  </span><br><span class="line">   sender IMsgSender  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// NewErrorNotification NewErrorNotification  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewErrorNotification</span><span class="params">(sender IMsgSender)</span></span> *ErrorNotification &#123;  </span><br><span class="line">   <span class="keyword">return</span> &amp;ErrorNotification&#123;sender: sender&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Notify 发送通知  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *ErrorNotification)</span></span> Notify(msg <span class="type">string</span>) <span class="type">error</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> n.sender.Send(msg)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestErrorNotification_Notify</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">   sender := NewEmailMsgSender([]<span class="type">string</span>&#123;<span class="string">&quot;test@test.com&quot;</span>&#125;)  </span><br><span class="line">   n := NewErrorNotification(sender)  </span><br><span class="line">   err := n.Notify(<span class="string">&quot;test msg&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">   assert.Nil(t, err)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式06-代理模式</title>
      <link href="/golang/go-design-pattern/gdp-struct/06-proxy/"/>
      <url>/golang/go-design-pattern/gdp-struct/06-proxy/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式05-创造者模式总结</title>
      <link href="/golang/go-design-pattern/gdp-create/05-create-summarize/"/>
      <url>/golang/go-design-pattern/gdp-create/05-create-summarize/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 创建型模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式04-原型模式</title>
      <link href="/golang/go-design-pattern/gdp-create/04-prototype/"/>
      <url>/golang/go-design-pattern/gdp-create/04-prototype/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 创建型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式03-构造模式</title>
      <link href="/golang/go-design-pattern/gdp-create/03-builder/"/>
      <url>/golang/go-design-pattern/gdp-create/03-builder/</url>
      
        <content type="html"><![CDATA[<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>其实在 Golang 中对于创建类参数比较多的对象的时候，我们常见的做法是必填参数直接传递，可选参数通过传递可变的方法进行创建。<br>本文会先实现课程中的建造者模式，然后再实现我们常用的方式。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>通过下面可以看到，使用 Go 编写建造者模式的代码其实会很长，这些是它的一个缺点，所以如果不是参数的校验逻辑很复杂的情况下一般我们在 Go 中不会采用这种方式，而会采用后面的另外一种方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> (  </span><br><span class="line">   defaultMaxTotal = <span class="number">10</span>  </span><br><span class="line">   defaultMaxIdle  = <span class="number">9</span>  </span><br><span class="line">   defaultMinIdle  = <span class="number">1</span>  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ResourcePoolConfig resource pooltype ResourcePoolConfig struct &#123;  </span></span><br><span class="line">   name     <span class="type">string</span>  </span><br><span class="line">   maxTotal <span class="type">int</span>  </span><br><span class="line">   maxIdle  <span class="type">int</span>  </span><br><span class="line">   minIdle  <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ResourcePoolConfigBuilder 用于构建 ResourcePoolConfig  </span></span><br><span class="line"><span class="keyword">type</span> ResourcePoolConfigBuilder <span class="keyword">struct</span> &#123;  </span><br><span class="line">   name     <span class="type">string</span>  </span><br><span class="line">   maxTotal <span class="type">int</span>  </span><br><span class="line">   maxIdle  <span class="type">int</span>  </span><br><span class="line">   minIdle  <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// SetName SetName  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span></span> SetName(name <span class="type">string</span>) <span class="type">error</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;name can not be empty&quot;</span>)  </span><br><span class="line">   &#125;  </span><br><span class="line">   b.name = name  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// SetMinIdle SetMinIdle  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span></span> SetMinIdle(minIdle <span class="type">int</span>) <span class="type">error</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> minIdle &lt; <span class="number">0</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;max tatal cannot &lt; 0, input: %d&quot;</span>, minIdle)  </span><br><span class="line">   &#125;  </span><br><span class="line">   b.minIdle = minIdle  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// SetMaxIdle SetMaxIdle  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span></span> SetMaxIdle(maxIdle <span class="type">int</span>) <span class="type">error</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> maxIdle &lt; <span class="number">0</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;max tatal cannot &lt; 0, input: %d&quot;</span>, maxIdle)  </span><br><span class="line">   &#125;  </span><br><span class="line">   b.maxIdle = maxIdle  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// SetMaxTotal SetMaxTotal  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span></span> SetMaxTotal(maxTotal <span class="type">int</span>) <span class="type">error</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> maxTotal &lt;= <span class="number">0</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;max tatal cannot &lt;= 0, input: %d&quot;</span>, maxTotal)  </span><br><span class="line">   &#125;  </span><br><span class="line">   b.maxTotal = maxTotal  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Build Build  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span></span> Build() (*ResourcePoolConfig, <span class="type">error</span>) &#123;  </span><br><span class="line">   <span class="keyword">if</span> b.name == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;name can not be empty&quot;</span>)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 设置默认值  </span></span><br><span class="line">   <span class="keyword">if</span> b.minIdle == <span class="number">0</span> &#123;  </span><br><span class="line">      b.minIdle = defaultMinIdle  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> b.maxIdle == <span class="number">0</span> &#123;  </span><br><span class="line">      b.maxIdle = defaultMaxIdle  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> b.maxTotal == <span class="number">0</span> &#123;  </span><br><span class="line">      b.maxTotal = defaultMaxTotal  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> b.maxTotal &lt; b.maxIdle &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;max total(%d) cannot &lt; max idle(%d)&quot;</span>, b.maxTotal, b.maxIdle)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> b.minIdle &gt; b.maxIdle &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;max idle(%d) cannot &lt; min idle(%d)&quot;</span>, b.maxIdle, b.minIdle)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> &amp;ResourcePoolConfig&#123;  </span><br><span class="line">      name:     b.name,  </span><br><span class="line">      maxTotal: b.maxTotal,  </span><br><span class="line">      maxIdle:  b.maxIdle,  </span><br><span class="line">      minIdle:  b.minIdle,  </span><br><span class="line">   &#125;, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;testing&quot;</span>  </span><br><span class="line">   <span class="string">&quot;github.com/stretchr/testify/assert&quot;</span>   </span><br><span class="line">   <span class="string">&quot;github.com/stretchr/testify/require&quot;</span></span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestResourcePoolConfigBuilder_Build</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">   tests := []<span class="keyword">struct</span> &#123;  </span><br><span class="line">      name    <span class="type">string</span>  </span><br><span class="line">      builder *ResourcePoolConfigBuilder  </span><br><span class="line">      want    *ResourcePoolConfig  </span><br><span class="line">      wantErr <span class="type">bool</span>  </span><br><span class="line">   &#125;&#123;  </span><br><span class="line">      &#123;  </span><br><span class="line">         name: <span class="string">&quot;name empty&quot;</span>,  </span><br><span class="line">         builder: &amp;ResourcePoolConfigBuilder&#123;  </span><br><span class="line">            name:     <span class="string">&quot;&quot;</span>,  </span><br><span class="line">            maxTotal: <span class="number">0</span>,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         want:    <span class="literal">nil</span>,  </span><br><span class="line">         wantErr: <span class="literal">true</span>,  </span><br><span class="line">      &#125;,  </span><br><span class="line">      &#123;  </span><br><span class="line">         name: <span class="string">&quot;maxIdle &lt; minIdle&quot;</span>,  </span><br><span class="line">         builder: &amp;ResourcePoolConfigBuilder&#123;  </span><br><span class="line">            name:     <span class="string">&quot;test&quot;</span>,  </span><br><span class="line">            maxTotal: <span class="number">0</span>,  </span><br><span class="line">            maxIdle:  <span class="number">10</span>,  </span><br><span class="line">            minIdle:  <span class="number">20</span>,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         want:    <span class="literal">nil</span>,  </span><br><span class="line">         wantErr: <span class="literal">true</span>,  </span><br><span class="line">      &#125;,  </span><br><span class="line">      &#123;  </span><br><span class="line">         name: <span class="string">&quot;success&quot;</span>,  </span><br><span class="line">         builder: &amp;ResourcePoolConfigBuilder&#123;  </span><br><span class="line">            name: <span class="string">&quot;test&quot;</span>,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         want: &amp;ResourcePoolConfig&#123;  </span><br><span class="line">            name:     <span class="string">&quot;test&quot;</span>,  </span><br><span class="line">            maxTotal: defaultMaxTotal,  </span><br><span class="line">            maxIdle:  defaultMaxIdle,  </span><br><span class="line">            minIdle:  defaultMinIdle,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         wantErr: <span class="literal">false</span>,  </span><br><span class="line">      &#125;,  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;  </span><br><span class="line">      t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">         got, err := tt.builder.Build()  </span><br><span class="line">         require.Equalf(t, tt.wantErr, err != <span class="literal">nil</span>, <span class="string">&quot;Build() error = %v, wantErr %v&quot;</span>, err, tt.wantErr)  </span><br><span class="line">         assert.Equal(t, tt.want, got)  </span><br><span class="line">      &#125;)  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go-常用的参数传递方法"><a href="#Go-常用的参数传递方法" class="headerlink" title="Go 常用的参数传递方法"></a>Go 常用的参数传递方法</h3><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ResourcePoolConfigOption option</span></span><br><span class="line"><span class="keyword">type</span> ResourcePoolConfigOption <span class="keyword">struct</span> &#123;  </span><br><span class="line">   maxTotal <span class="type">int</span>  </span><br><span class="line">   maxIdle  <span class="type">int</span>  </span><br><span class="line">   minIdle  <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ResourcePoolConfigOptFunc to set option</span></span><br><span class="line"><span class="keyword">type</span> ResourcePoolConfigOptFunc <span class="function"><span class="keyword">func</span><span class="params">(option *ResourcePoolConfigOption)</span></span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// NewResourcePoolConfig NewResourcePoolConfig  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewResourcePoolConfig</span><span class="params">(name <span class="type">string</span>, opts ...ResourcePoolConfigOptFunc)</span></span> (*ResourcePoolConfig, <span class="type">error</span>) &#123;  </span><br><span class="line">   <span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;name can not be empty&quot;</span>)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   option := &amp;ResourcePoolConfigOption&#123;  </span><br><span class="line">      maxTotal: <span class="number">10</span>,  </span><br><span class="line">      maxIdle:  <span class="number">9</span>,  </span><br><span class="line">      minIdle:  <span class="number">1</span>,  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;  </span><br><span class="line">      opt(option)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> option.maxTotal &lt; <span class="number">0</span> || option.maxIdle &lt; <span class="number">0</span> || option.minIdle &lt; <span class="number">0</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;args err, option: %v&quot;</span>, option)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> option.maxTotal &lt; option.maxIdle || option.minIdle &gt; option.maxIdle &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;args err, option: %v&quot;</span>, option)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> &amp;ResourcePoolConfig&#123;  </span><br><span class="line">      name:     name,  </span><br><span class="line">      maxTotal: option.maxTotal,  </span><br><span class="line">      maxIdle:  option.maxIdle,  </span><br><span class="line">      minIdle:  option.minIdle,  </span><br><span class="line">   &#125;, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;testing&quot;</span>  </span><br><span class="line">   <span class="string">&quot;github.com/stretchr/testify/assert&quot;</span>   </span><br><span class="line">   <span class="string">&quot;github.com/stretchr/testify/require&quot;</span></span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNewResourcePoolConfig</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">type</span> args <span class="keyword">struct</span> &#123;  </span><br><span class="line">      name <span class="type">string</span>  </span><br><span class="line">      opts []ResourcePoolConfigOptFunc  </span><br><span class="line">   &#125;  </span><br><span class="line">   tests := []<span class="keyword">struct</span> &#123;  </span><br><span class="line">      name    <span class="type">string</span>  </span><br><span class="line">      args    args  </span><br><span class="line">      want    *ResourcePoolConfig  </span><br><span class="line">      wantErr <span class="type">bool</span>  </span><br><span class="line">   &#125;&#123;  </span><br><span class="line">      &#123;  </span><br><span class="line">         name: <span class="string">&quot;name empty&quot;</span>,  </span><br><span class="line">         args: args&#123;  </span><br><span class="line">            name: <span class="string">&quot;&quot;</span>,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         want:    <span class="literal">nil</span>,  </span><br><span class="line">         wantErr: <span class="literal">true</span>,  </span><br><span class="line">      &#125;,  </span><br><span class="line">      &#123;  </span><br><span class="line">         name: <span class="string">&quot;success&quot;</span>,  </span><br><span class="line">         args: args&#123;  </span><br><span class="line">            name: <span class="string">&quot;test&quot;</span>,  </span><br><span class="line">            opts: []ResourcePoolConfigOptFunc&#123;  </span><br><span class="line">               <span class="function"><span class="keyword">func</span><span class="params">(option *ResourcePoolConfigOption)</span></span> &#123;  </span><br><span class="line">                  option.minIdle = <span class="number">2</span>  </span><br><span class="line">               &#125;,  </span><br><span class="line">            &#125;,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         want: &amp;ResourcePoolConfig&#123;  </span><br><span class="line">            name:     <span class="string">&quot;test&quot;</span>,  </span><br><span class="line">            maxTotal: <span class="number">10</span>,  </span><br><span class="line">            maxIdle:  <span class="number">9</span>,  </span><br><span class="line">            minIdle:  <span class="number">2</span>,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         wantErr: <span class="literal">false</span>,  </span><br><span class="line">      &#125;,  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;  </span><br><span class="line">      t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">         got, err := NewResourcePoolConfig(tt.args.name, tt.args.opts...)  </span><br><span class="line">         require.Equalf(t, tt.wantErr, err != <span class="literal">nil</span>, <span class="string">&quot;error = %v, wantErr %v&quot;</span>, err, tt.wantErr)  </span><br><span class="line">         assert.Equal(t, tt.want, got)  </span><br><span class="line">      &#125;)  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发一些公共库的时候，对于入口参数的传递推荐后面一种方法，可以一定程度上避免参数变化破坏式更新的情况</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 创建型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试官101</title>
      <link href="/interview/interviewer/interviewer101/"/>
      <url>/interview/interviewer/interviewer101/</url>
      
        <content type="html"><![CDATA[<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a><strong>面试</strong></h3><h4 id="算法能力-一题5-10min"><a href="#算法能力-一题5-10min" class="headerlink" title="算法能力 一题5-10min :"></a>算法能力 一题5-10min :</h4><ol><li>题目：仅出现一次的数</li><li>题目：连续固定区间最大值<br>给你一个数组 nums 和一个大小为 k的区间。这个区间可以从数组的最左侧不断移动到数组的最右侧。每个移动区间固定有 k 个数字。这个区间每次只向右移动一位。<br>让你返回移动过程中，这些固定区间中的最大值。</li></ol><p>样例输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br></pre></td></tr></table></figure><p>样例输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,3,5,5,6,7]</span><br></pre></td></tr></table></figure><p>样例解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">移动情况 最大值</span><br><span class="line"></span><br><span class="line">[1 3 -1] -3 5 3 6 7 3</span><br><span class="line"></span><br><span class="line">1 [3 -1 -3] 5 3 6 7 3</span><br><span class="line"></span><br><span class="line">1 3 [-1 -3 5] 3 6 7 5</span><br><span class="line"></span><br><span class="line">1 3 -1 [-3 5 3] 6 7 5</span><br><span class="line"></span><br><span class="line">1 3 -1 -3 [5 3 6] 7 6</span><br><span class="line"></span><br><span class="line">1 3 -1 -3 5 [3 6 7] 7</span><br></pre></td></tr></table></figure><ol start="3"><li>拓展</li></ol><p>样例输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,5,3,6,7], t = 5</span><br><span class="line">k = 2</span><br><span class="line">k = 3</span><br><span class="line">k = 4</span><br><span class="line">k = 5</span><br><span class="line">k = 6</span><br></pre></td></tr></table></figure><p>样例输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 3 -1 5 5 6 7</span><br><span class="line">3 3 5 5 6 7</span><br><span class="line">3 5 5 6 7</span><br><span class="line">5 5 6 7</span><br><span class="line">5 6 7</span><br></pre></td></tr></table></figure><h4 id="基础能力"><a href="#基础能力" class="headerlink" title="基础能力"></a>基础能力</h4><h6 id="Go八股"><a href="#Go八股" class="headerlink" title="Go八股"></a>Go八股</h6><p><a href="https://www.topgoer.cn/docs/gomianshiti/gomianshiti-1dd225t6esqld">https://www.topgoer.cn/docs/gomianshiti/gomianshiti-1dd225t6esqld</a></p><h6 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h6><ol><li><p>Redis是单线程的，但Redis为什么这么快？</p><ul><li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</li><li>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li><li>使用多路I&#x2F;O复用模型，非阻塞IO；这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程</li><li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</li></ul></li><li><p>缓存穿透和雪崩的解决方案</p></li><li><p>请简述Reids的删除策略</p><ul><li>定时删除：在设置键的过期时间的同时，创建一个定时任务，当键达到过期时间时，立即执行对键的删除操作</li><li>惰性删除：放任键过期不管，但在每次从键空间获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，如果没有过期，就返回该键</li><li>定期删除：每隔一点时间，程序就对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li></ul><ol start="3"><li>索引的构建流程？</li><li>b树，b+树区别，MongoDB为什么选用b树</li></ol></li></ol><h6 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h6><ol><li>CPU三级缓存</li><li>进程与线程<ul><li>进程: 进程是具有一定独立功能的程序，进程是系统资源分配和调度的最小单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</li><li>线程: 线程是进程的一个实体,线程是内核态,而且是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</li><li>协程: 协程是一种用户态的轻量级线程，协程的调度完全是由用户来控制的。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</li></ul></li></ol><h6 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h6><ol><li><p>创建索引的规则：最左匹配，区分度等</p></li><li><p>索引失效的情况</p><ul><li>未遵循最佳左前缀规则导致索引失效</li><li>计算、函数、类型转换(自动或手动)导致索引失效</li><li>范围条件右边列索引失效</li><li>不等于(!&#x3D;)会导致索引失效</li><li>is null可以用到索引，is not null不能用到索引</li><li>like以通配符%开头索引失效</li><li>or 前的列建立了索引 or后面的列没有建立索引 会导致索引失效</li><li>不同字符集进行比较前需要进行转换，会导致索引失效</li></ul></li><li><p>数据的存储方式： B+树</p><ul><li>非叶子节点不存储数据，只存索引（冗余），这样可以保证存放更多的索引</li><li>叶子节点存储所有索引字段</li><li>叶子节点用指针连接，提高区间访问性能<br> ![[Pasted image 20221201183525.png]]</li></ul></li><li><p>大数据量级的mysql，如何分库分表？解决方案？</p></li><li><p>网络这些可以挑一两个主题聊。</p></li><li><p>自我介绍，告知规则与流程：两个部分：算法题 &amp; 聊一聊基础问题</p></li><li><p>先介绍下自己；主要技能，常用语言，工作经历简单叙述</p></li><li><p>项目：支付相关，幂等？</p></li><li><p>发过去在线文档</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试官 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试官 </tag>
            
            <tag> 初学者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-连续固定区间最大值</title>
      <link href="/interview/interviewer/maximum-of-segments/"/>
      <url>/interview/interviewer/maximum-of-segments/</url>
      
        <content type="html"><![CDATA[<h1 id="连续固定区间最大值"><a href="#连续固定区间最大值" class="headerlink" title="连续固定区间最大值"></a>连续固定区间最大值</h1><ul><li>涉及知识点：堆，栈、双指针、滑动窗口，双向队列、线段树，树状数组, dp 等。</li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>nums</code> 和一个大小为 <code>k</code>的区间。这个区间可以从数组的最左侧不断移动到数组的最右侧。每个移动区间固定有 <code>k</code> 个数字。这个区间每次只向右移动一位。</p><p>让你返回移动过程中，这些固定区间中的最大值。</p><p>样例输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br></pre></td></tr></table></figure><p>样例输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,3,5,5,6,7]</span><br></pre></td></tr></table></figure><p>样例解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">          移动情况              最大值</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果候选人询问到数据范围，可提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.size() &lt;= 10^5</span><br><span class="line">-10^4 &lt;= nums[i] &lt;= 10^4</span><br><span class="line">1 &lt;= k &lt;= nums.size()</span><br></pre></td></tr></table></figure><h2 id="思路描述"><a href="#思路描述" class="headerlink" title="思路描述"></a>思路描述</h2><h3 id="思路-1：暴力滑动-O-n-2"><a href="#思路-1：暴力滑动-O-n-2" class="headerlink" title="思路 1：暴力滑动 O(n^2)"></a>思路 1：暴力滑动 O(n^2)</h3><p>暴力进行滑动窗口， 每次遍历当前窗口内的元素取最大值。</p><p>参考代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">find_maximum_of_sgements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + k &lt;= nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(*<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>() + i, nums.<span class="built_in">begin</span>() + i + k));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度 <code>O(n * k)～O(n^2)</code></li><li>空间复杂度 <code>O(n - k + 1)</code></li></ul><p><strong>这个是暴力解，非正确解，只能给 2 分，可提示次优解和最优解</strong></p><blockquote><p>优化提示 1：可以优化到低于 O(n^2) 的吗？比如 O(nlogn)，O(nlogk), 甚至是线性 O(n) 的做法。</p></blockquote><blockquote><p>优化提示 2：可以想到用一些可以维护极值的数据结构做吗？</p></blockquote><blockquote><p>优化提示 3：那如果拆分成子问题，快速求连续区间的最大值，你怎么做才会有带 log 的时间复杂度？</p></blockquote><p><strong>提示后，候选人还是不会。可换题。</strong></p><h3 id="思路-2：堆-O-nlogk"><a href="#思路-2：堆-O-nlogk" class="headerlink" title="思路 2：堆 O(nlogk)"></a>思路 2：堆 O(nlogk)</h3><p>维护一个大小为 <code>k</code> 的堆，向堆中插入一个元素(单个操作时间复杂度 <code>O(logk)</code>), 将数据不断 <code>push</code> 进堆，每次取结果都将 <code>top</code> 的数取出来就是序列答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">find_maximum_of_segments</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  priority_queue&lt; pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; pq;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">      pq.<span class="built_in">push</span>(&#123;nums[i],i&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = k;i &lt; nums.<span class="built_in">size</span>(); i++) &#123; </span><br><span class="line">      <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>() &amp;&amp; pq.<span class="built_in">top</span>().second &lt;= (i - k)) &#123;</span><br><span class="line">          pq.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      pq.<span class="built_in">push</span>(&#123;nums[i],i&#125;);</span><br><span class="line">      res.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().first);   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<code>O(nlogk)</code>, 候选人有可能写成<code>O(nlogn)</code>, 但问题不大。</li><li>空间复杂度：<code>O(k)</code>。</li></ul><p><strong>这个是正确解，但非最优解，可给 3 分，通过。</strong></p><h3 id="思路-3：双向队列-O-n"><a href="#思路-3：双向队列-O-n" class="headerlink" title="思路 3：双向队列 O(n)"></a>思路 3：双向队列 O(n)</h3><p>可以维护一个双向队列，这个队列是递减的。队列用来保存可能是最大值的数字的 <code>index</code>。<br>当前窗口最大值的 <code>index</code> 在队首，当窗口滑动时，会进入一个新值，出去一个旧值，不断更新给出当前窗口的最大值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">find_maximum_of_segments</span>(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> k) &#123;</span><br><span class="line">  deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">      <span class="comment">// 新元素入队时, 比队尾元素大的话则替代队尾元素</span></span><br><span class="line">      <span class="keyword">while</span>(!que.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[que.<span class="built_in">back</span>()])&#123;</span><br><span class="line">          que.<span class="built_in">pop_back</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 检查队首的 index 是否在窗口内，不在则出队</span></span><br><span class="line">      <span class="keyword">if</span>(!que.<span class="built_in">empty</span>() &amp;&amp; que.<span class="built_in">front</span>() &lt; i - k + <span class="number">1</span>) &#123;</span><br><span class="line">          que.<span class="built_in">pop_front</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      que.<span class="built_in">push_back</span>(i);</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= k <span class="number">-1</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(nums[que.<span class="built_in">front</span>()]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<code>O(n)</code>。</li><li>空间复杂度：<code>O(k)</code>。</li></ul><p><strong>这个是正确解，最优解，可给 4 分，通过。</strong></p><h3 id="思路-4：dynamic-programming"><a href="#思路-4：dynamic-programming" class="headerlink" title="思路 4：dynamic programming"></a>思路 4：dynamic programming</h3><p>先将数组分割成有 <code>k</code> 个元素的块。<br>建立数组 <code>left</code>,其中 <code>left[j]</code> 是从块的开始到下标 <code>j</code> 最大的元素，方向： <code>左-&gt;右</code>。<br>数组 <code>right</code>，其中 <code>right[j]</code> 是从块的结尾到下标 <code>j</code> 最大的元素，方向： <code>右-&gt;左</code>。</p><p>从左到右遍历数组，建立数组 <code>left</code>。</p><p>从右到左遍历数组，建立数组 <code>right</code>。</p><p>因为一个窗口 <code>[i, i + k - 1]</code> 最多跨越两个块，所以求窗口中的最大值就是求这个窗口跨越的块中的最大值，<br>可以知道，无论是跨越 1 个块也好，2 个块也好，计算处于边界的 <code>i</code> 和 <code>i + k - 1</code> 对应的值即可。</p><p><code>right[i]</code> 表示从块的结尾到下标 <code>j</code> 的最大的元素。</p><p><code>left[i + k - 1]</code> 表示从块的开始到下标 <code>i + k - 1</code> 的最大的元素。</p><p>这两个范围刚好是整个窗口。</p><p>所以窗口的最大值是 <code>max(right[i], left[i + k - 1])</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">find_maximum_of_segments</span>(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> k) &#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">right</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="type">int</span> max_num;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i % k == <span class="number">0</span>)&#123;</span><br><span class="line">          max_num = nums[i];</span><br><span class="line">      &#125;</span><br><span class="line">      max_num = <span class="built_in">max</span>(max_num, nums[i]);</span><br><span class="line">      left[i] = max_num;</span><br><span class="line">  &#125;</span><br><span class="line">  max_num = nums[n - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i % k == k - <span class="number">1</span>)&#123;</span><br><span class="line">          max_num = nums[i];</span><br><span class="line">      &#125;</span><br><span class="line">      max_num = <span class="built_in">max</span>(max_num, nums[i]);</span><br><span class="line">      right[i] = max_num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - k; i ++)&#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(<span class="built_in">max</span>(right[i], left[i + k - <span class="number">1</span>]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个是正确解，最优解，但比较难想到。可给 5 分，通过。</strong></p><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<code>O(n)</code>。</li><li>空间复杂度：<code>O(n)</code>。</li></ul><h2 id="其他思路参考"><a href="#其他思路参考" class="headerlink" title="其他思路参考"></a>其他思路参考</h2><p>以下解法比较特殊，而且编码比较复杂，如果真的有候选人在面试中写了，可以考虑给 5 分。</p><h3 id="思路-4-线段树-segment-tree"><a href="#思路-4-线段树-segment-tree" class="headerlink" title="思路 4: 线段树 (segment tree)"></a>思路 4: 线段树 (segment tree)</h3><p>比较裸的线段树维护极值的做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;tree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushUp</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">  tree[rt] = <span class="built_in">max</span>(tree[<span class="number">1</span> &lt;&lt; rt], tree[<span class="number">1</span> &lt;&lt; rt | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l,<span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">    tree[rt] = nums[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span> &lt;&lt; rt, l, mid, nums);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span> &lt;&lt; rt | <span class="number">1</span>, mid + <span class="number">1</span>, r, nums);</span><br><span class="line">  <span class="built_in">pushUp</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l &gt; r) &#123;</span><br><span class="line">    <span class="keyword">return</span> INT_MIN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(l &gt; qr || r &lt; ql) &#123;</span><br><span class="line">    <span class="keyword">return</span> INT_MIN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// [ql [l, r] qr]</span></span><br><span class="line">  <span class="keyword">if</span>(l &gt;= ql &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">      <span class="keyword">return</span> tree[rt];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> left_val = <span class="built_in">query</span>(<span class="number">1</span> &lt;&lt; rt, l, mid, ql, qr);</span><br><span class="line">  <span class="type">int</span> right_val = <span class="built_in">query</span>(<span class="number">1</span> &lt;&lt; rt | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(left_val, right_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">find_maximum_of_segments</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">0</span> || n &lt; k) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  tree.<span class="built_in">resize</span>(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, nums);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + k - <span class="number">1</span> &lt; n; i++) &#123;</span><br><span class="line">      <span class="type">int</span> val = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, i, i + k - <span class="number">1</span>);</span><br><span class="line">      res.<span class="built_in">push_back</span>(val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<ul><li>建树：<code>O(n)</code>。</li><li>查询：<code>O(logn)</code></li></ul></li><li>空间复杂度：<code>O(3 * n)</code>。</li></ul><h3 id="思路-5：树状数组-fenwick-tree"><a href="#思路-5：树状数组-fenwick-tree" class="headerlink" title="思路 5：树状数组 (fenwick tree)"></a>思路 5：树状数组 (fenwick tree)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;val;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;tmp;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_VAL = <span class="number">1e5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">    val[x] = v;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">    <span class="type">int</span> lx = <span class="built_in">lowbit</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; lx; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      val[x] = <span class="built_in">max</span>(val[x], val[x - i]);</span><br><span class="line">    &#125;</span><br><span class="line">    x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(r &gt;= l) &#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;r = &quot; &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">    ans = <span class="built_in">max</span>(tmp[r - <span class="number">1</span>], ans);</span><br><span class="line">    r--;</span><br><span class="line">    <span class="keyword">while</span>(r &gt;= l + <span class="built_in">lowbit</span>(r))&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(val[r], ans);</span><br><span class="line">        r -= <span class="built_in">lowbit</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">find_maximum_of_segments</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  n = nums.<span class="built_in">size</span>();</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">0</span> || n &lt; k) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  val.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> num = nums[i] + MAX_VAL;</span><br><span class="line">    tmp.<span class="built_in">push_back</span>(num);</span><br><span class="line">    <span class="built_in">update</span>(i + <span class="number">1</span>, num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + k - <span class="number">1</span> &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> max_val = <span class="built_in">query</span>(i + <span class="number">1</span>, i + k);</span><br><span class="line">    res.<span class="built_in">push_back</span>(max_val - MAX_VAL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<ul><li>建树：<code>O(n)</code>。</li><li>查询：<code>O(logn)</code></li></ul></li><li>空间复杂度：<code>O(3 * n)</code>。</li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>如果遇到水平比较高的候选人，比如具有 OI 或者 ACM 经历且实力比较强的候选人。</p><p>候选人只需要口述解法即可。</p><p>可将上面题目改编成：</p><p>题意不变，同样是给你一个数组 <code>nums = [1,3,-1,-3,5,3,6,7]</code> 和 一个 <code>t</code>, <code>t</code> 代表查询次数。<br>即存在多组查询，每次查询给你不一样的 <code>k</code>, 让你输出每个查询区间为 <code>k</code> 的区间的答案序列。</p><p>数据范围：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.size() &lt;= 10^5</span><br><span class="line">-10^4 &lt;= nums[i] &lt;= 10^4</span><br><span class="line">1 &lt;= k &lt;= nums.size()</span><br><span class="line">1 &lt;= t &lt;= 10^3</span><br></pre></td></tr></table></figure><p>样例输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,5,3,6,7], t = 5</span><br><span class="line">k = 2</span><br><span class="line">k = 3</span><br><span class="line">k = 4</span><br><span class="line">k = 5</span><br><span class="line">k = 6</span><br></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 3 -1 5 5 6 7</span><br><span class="line">3 3 5 5 6 7 </span><br><span class="line">3 5 5 6 7 </span><br><span class="line">5 5 6 7 </span><br><span class="line">5 6 7</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h3><p>这种属于比较经典的 RMQ (Range Minimum&#x2F;Maximum Query) 问题。</p><p>可以使用一种数据结构 <code>Sparse Tables</code> 来解决。</p><p>该数据结构可在 <code>O(nlogn)</code> 内完成数据预处理， 在 <code>O(1)</code> 内完成查询。</p><ul><li>时间复杂度：<ul><li>预处理：<code>O(nlogn)</code>。</li><li>查询：<code>O(1)</code></li></ul></li><li>空间复杂度：<code>O(nlogn)</code>。</li></ul><p>代码参考：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> M;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">(vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;&amp;dp, vector&lt;<span class="type">int</span>&gt;&amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">          dp[i][j] = <span class="built_in">max</span>(dp[i][j<span class="number">-1</span>], dp[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;&amp;dp, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> k = (<span class="type">int</span>) (<span class="built_in">log</span>(r - l + <span class="number">1</span>) / <span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(dp[l][k], dp[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_maximum_of_segments</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  M = (<span class="type">int</span>) (<span class="built_in">log</span>(n) / <span class="built_in">log</span>(<span class="number">2</span>)) + <span class="number">1</span>; </span><br><span class="line">  vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(M + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">  <span class="built_in">prepare</span>(dp, nums);</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + k - <span class="number">1</span> &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(<span class="built_in">query</span>(dp, i, i + k - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: res) &#123;</span><br><span class="line">      cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试官 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-移掉K位数字</title>
      <link href="/interview/interviewer/remove-the-k-digit/"/>
      <url>/interview/interviewer/remove-the-k-digit/</url>
      
        <content type="html"><![CDATA[<h1 id="移掉K位数字-leetcode-402"><a href="#移掉K位数字-leetcode-402" class="headerlink" title="移掉K位数字-leetcode-402"></a>移掉K位数字-leetcode-402</h1><ul><li>涉及知识点：贪心,栈</li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。  </p><p>注意:  </p><ul><li>num 的长度小于 10002 且 ≥ k。  </li><li>num 不会包含任何前导零。</li></ul><p>输入&#x2F;输出示例：  </p><p>Example 1:  </p><p>Input:   </p><pre><code>num = &quot;1432219&quot;, k = 3  </code></pre><p>Output:   </p><pre><code>&quot;1219&quot;  </code></pre><p>Explanation: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。  </p><p>Example 2:  </p><p>Input:   </p><pre><code>num = &quot;10200&quot;, k = 1  </code></pre><p>Output:   </p><pre><code>&quot;200&quot;  </code></pre><p>Explanation: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。  </p><p>Example 3:  </p><p>Input:   </p><pre><code>num = &quot;10&quot;, k = 2  </code></pre><p>Output:   </p><pre><code>&quot;0&quot;  </code></pre><p>Explanation: 从原数字移除所有的数字，剩余为空就是0。  </p><h2 id="思路描述"><a href="#思路描述" class="headerlink" title="思路描述"></a>思路描述</h2><h2 id="思路-0"><a href="#思路-0" class="headerlink" title="思路 0"></a>思路 0</h2><p>详细描述：思路，从左到右，找第一个比后面大的字符，删除，清零，k次扫描。  </p><ul><li>时间复杂度：o(n*k)  </li><li>空间复杂度：o(1)</li></ul><p>代码：  </p><pre><code class="java">class Solution &#123;      public String removeKdigits(String num, int k) &#123;        if (num.length() == k) return &quot;0&quot;;        StringBuilder s = new StringBuilder(num);        for (int i = 0; i &lt; k; i++) &#123;            int idx = 0;            for (int j = 1; j &lt; s.length() &amp;&amp; s.charAt(j) &gt;= s.charAt(j - 1); j++) idx = j;            s.delete(idx, idx + 1);            while (s.length() &gt; 1 &amp;&amp; s.charAt(0) == &#39;0&#39;) s.delete(0, 1);        &#125;        return s.toString();    &#125;&#125;  </code></pre><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h3><p>详细描述：在一定的范围内逐步选取最小的数字。<br>  </p><ol><li>在第一次循环中，num &#x3D; 1432219, k&#x3D;3，此时我们要删去k&#x3D;3个数字，保留n-k&#x3D;7-3&#x3D;4个数字。  </li><li>最终要挑选4个字符，那么我们先来挑选 千位 的字符，，由于挑选完千位后还需要挑选百位，十位，个位这三个位置的字符，所以千位能选择的范围只能在1432之间,因为要留出末尾的219这三个字符供百位、十位、个位 去挑选。  </li><li>1432中最小的值是1，所以千位的值选好了，就是1，接下来就是从千位后面的432219中去挑选百位值，可以发现挑选每一位的值是一个递归的过程。  </li><li>start &#x3D; 0, end &#x3D; k。也就是要在[start,end]中选取一个最小的进行保留，返回最小数字的下标minIndex。而在下次循环中，start &#x3D; minIndex+1, end++ ，也就是在[start,end]中选择下一个最小的数字。以此类推，直至所有数字都选取完毕。</li></ol><p>注意：当返回的下标minIndex及后面的字符串的长度 &#x3D; 还需要保留的字符串的长度的时候，直接返回  </p><ul><li>时间复杂度：o(n*k)  </li><li>空间复杂度：o(1)</li></ul><p>代码：  </p><pre><code class="go">func removeKdigits(num string, k int) string &#123;      if 0 == k &#123;        return num    &#125;    if k == len(num) &#123;        return &quot;0&quot;    &#125;    result := &quot;&quot;    i := len(num)-k    for &#123;        if i == 0 &#123;            break        &#125;        minIndex := 0        for  j := 0; j &lt; len(num)-(i-1); j++ &#123;            if num[j] &lt; num[minIndex] &#123;                minIndex = j            &#125;        &#125;        // 优化        if len(num)- minIndex == i &#123;            result = result + num[minIndex:]            break        &#125;        result += num[minIndex:minIndex+1]        num = num[minIndex+1:]        i--    &#125;    // 前导0    ans := strings.TrimLeft(result, &quot;0&quot;)    if ans == &quot;&quot; &#123;        ans = &quot;0&quot;    &#125;    return ans&#125;    </code></pre><h3 id="思路2-贪心-单调栈（一般可用-栈、队列、双端队列、双指针-实现）"><a href="#思路2-贪心-单调栈（一般可用-栈、队列、双端队列、双指针-实现）" class="headerlink" title="思路2: 贪心 + 单调栈（一般可用 栈、队列、双端队列、双指针 实现）"></a>思路2: 贪心 + 单调栈（一般可用 栈、队列、双端队列、双指针 实现）</h3><p>详细描述：  </p><ul><li><p>遍历字符串，逐个入栈,若新来的比栈顶小，则栈顶出栈 ,出栈相当于移除动作，需次数并与 k 比较，别删多了  </p></li><li><p>移除头部零有 ‘0’,全空，return “0”,构建字符串，顺序返回整个单调栈元素.  </p></li><li><p>时间复杂度：o(n+k)  </p></li><li><p>空间复杂度：o(n)</p></li></ul><p>代码：  </p><pre><code class="go">func removeKdigits(num string, k int) string &#123;      stack := []byte&#123;&#125;        for i := range num &#123;        digit := num[i]        for k &gt; 0 &amp;&amp; len(stack) &gt; 0 &amp;&amp; digit &lt; stack[len(stack)-1] &#123;            stack = stack[:len(stack)-1]            k--                &#125;        stack = append(stack, digit)     &#125;    stack = stack[:len(stack)-k]    ans := strings.TrimLeft(string(stack), &quot;0&quot;)    if ans == &quot;&quot; &#123;        ans = &quot;0&quot;        &#125;    return ans&#125;  </code></pre><h4 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h4><ul><li>提出思路0，能正确分析时空复杂度(2分)  </li><li>提出思路1，能正确分析时空复杂度(3分)  </li><li>提出思路2，能正确分析时空复杂度(4分)  </li><li>bugfree且代码简洁(5分)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试官 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-仅出现一次的元素</title>
      <link href="/interview/interviewer/single-numbers/"/>
      <url>/interview/interviewer/single-numbers/</url>
      
        <content type="html"><![CDATA[<h1 id="仅出现一次的元素"><a href="#仅出现一次的元素" class="headerlink" title="仅出现一次的元素"></a>仅出现一次的元素</h1><ul><li>涉及知识点：散列表、位运算</li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>（英文）<br>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.  </p><p>For example:  </p><p>Given nums &#x3D; [1, 2, 1, 3, 2, 5], return [3, 5].  </p><p>Note:  </p><ol><li>The order of the result is not important. So in the above example, [5, 3] is also correct.</li></ol><p>（中文）<br>给定一个整数数组，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出仅出现一次的那两个元素。要求时间复杂度在O(N)内。  </p><p>示例输入:  </p><pre><code>[1, 2, 1, 3, 2, 5]  </code></pre><p>示例输出：  </p><pre><code>[3, 5]  </code></pre><h2 id="思路描述"><a href="#思路描述" class="headerlink" title="思路描述"></a>思路描述</h2><h3 id="思路1：排序-遍历"><a href="#思路1：排序-遍历" class="headerlink" title="思路1：排序+遍历"></a>思路1：排序+遍历</h3><p>对序列排序，后遍历所有元素，通过相邻元素是否有相同值来判断是否满足条件，输出。  </p><p>常规排序方案的时空复杂度如下：  </p><ul><li>时间复杂度 <code>O(N*log(N))</code>  </li><li>空间复杂度 <code>O(1)</code></li></ul><p>此时解法不满足要求，可给到2分，若能给出计数排序（时间复杂度O(N)）法，可给到3分。  </p><h3 id="思路2：散列表-遍历"><a href="#思路2：散列表-遍历" class="headerlink" title="思路2：散列表+遍历"></a>思路2：散列表+遍历</h3><p>遍历每个元素，使用散列表存储元素值到数量的映射关系，再遍历散列表找出其中value为1的key，输出。  </p><p>该方案的时空复杂度分析如下：  </p><ul><li>时间复杂度 <code>O(N)</code>  </li><li>空间复杂度 <code>O(N)</code></li></ul><p>此时为次优解，可延伸提问对散列表的理解（如遍历结果是否有序，两个元素输出顺序是否确定），回答正确可给到4分  </p><h3 id="思路3：位运算"><a href="#思路3：位运算" class="headerlink" title="思路3：位运算"></a>思路3：位运算</h3><p>遍历元素，使用异或运算可消除相同的元素，得到所求两个元素的异或结果，从中找出二进制为1的最低位数字，再遍历一次，求出其中一个元素，再与前面结果异或得到另一个元素，输出。  </p><p>该方案的时空复杂度分析如下：  </p><ul><li>时间复杂度 <code>O(N)</code>  </li><li>空间复杂度 <code>O(1)</code></li></ul><p>此为最优解，可给到5分  </p><h2 id="解法示例"><a href="#解法示例" class="headerlink" title="解法示例"></a>解法示例</h2><p><a href="./single-numbers/sortSolution.go">排序+遍历</a>  </p><p><a href="./single-numbers/hashSolution.go">hash+遍历</a>  </p><p><a href="./single-numbers/bitSolution.go">位运算</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试官 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/%E8%BD%AF%E5%AE%9E%E5%8A%9B/1/"/>
      <url>/%E8%BD%AF%E5%AE%9E%E5%8A%9B/1/</url>
      
        <content type="html"><![CDATA[<h1 id="软实力"><a href="#软实力" class="headerlink" title="软实力"></a>软实力</h1><h2 id="主动性，责任心"><a href="#主动性，责任心" class="headerlink" title="主动性，责任心"></a>主动性，责任心</h2><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>主动推进自己参与的每一个项目，将自己看作是每一个项目的负责人，以项目负责人的角度去看待事情，一方面能够让自己更好的做事情，另一方面也能培养自己的项目推动能力</p><h3 id="个人事务"><a href="#个人事务" class="headerlink" title="个人事务"></a>个人事务</h3><p>转介绍相关链路很长，用户从看到第三方广告开始，到最终成为忠实用户</p><h2 id="抗压能力–》有所进步，还需加强"><a href="#抗压能力–》有所进步，还需加强" class="headerlink" title="抗压能力–》有所进步，还需加强"></a>抗压能力–》有所进步，还需加强</h2><p>这一点我最初做的不够好，现在相对而言已经做的不错，总体经验如下</p><p><strong>学会区分事情的轻重缓急，不那么紧急的事情就先放着，不去理会，集中精神解决掉紧急的事情，然后以平和的心态去解决那些不紧急的</strong></p><p>可能说起来简单，但是具体如何实施，还是要自己多经历</p><h2 id="沟通能力–》在沟通中的谦逊没有问题，一向是自己错了就是错了不找接口，但是有时候事情多了，语气会急躁，有所注意和改进，还需要继续努力"><a href="#沟通能力–》在沟通中的谦逊没有问题，一向是自己错了就是错了不找接口，但是有时候事情多了，语气会急躁，有所注意和改进，还需要继续努力" class="headerlink" title="沟通能力–》在沟通中的谦逊没有问题，一向是自己错了就是错了不找接口，但是有时候事情多了，语气会急躁，有所注意和改进，还需要继续努力"></a>沟通能力–》在沟通中的谦逊没有问题，一向是自己错了就是错了不找接口，但是有时候事情多了，语气会急躁，有所注意和改进，还需要继续努力</h2><h3 id="保证沟通的高效性"><a href="#保证沟通的高效性" class="headerlink" title="保证沟通的高效性"></a>保证沟通的高效性</h3><p>低效的沟通不仅会让你烦，也会让沟通对象感到烦，当发现打字已经说不清楚事情的时候可以考虑直接语音，或者直接当面对接。</p><h3 id="沟通过程保持谦逊和平和"><a href="#沟通过程保持谦逊和平和" class="headerlink" title="沟通过程保持谦逊和平和"></a>沟通过程保持谦逊和平和</h3><h4 id="方案沟通"><a href="#方案沟通" class="headerlink" title="方案沟通"></a>方案沟通</h4><p>与他人沟通过程中难免有所争执，要能明确的从对方的角度思考，对方说的一些解决方案你可能一开始不认可，但是别人既然这么说了就一定有他这么说的原因，可以先问清楚，是不是有什么历史遗留问题或者业务场景，导致他要采用你不认可的方案，如果发现确实是对方思考不周，然后可以提供自己的想法，互相沟通，总会达成一致。</p><h4 id="接受自己不足"><a href="#接受自己不足" class="headerlink" title="接受自己不足"></a>接受自己不足</h4><p>不要有自己绝对不能犯错的思想，有时候明明是你的问题或者就是你能力不足没有思考到一些东西，被同事当面指出，这时候要保持谦逊的心，不要硬抗，这没有任何意义，错了就是错了，没有想到就是没有想到，接受别人的指责，然后反省进步即可，硬抗对他人对自己都不是一个好的方式。</p><h1 id="一些好的工作习惯和建议"><a href="#一些好的工作习惯和建议" class="headerlink" title="一些好的工作习惯和建议"></a>一些好的工作习惯和建议</h1><p><strong>1.事事有回音</strong></p><p>这一点很多鸡汤文都有写，但是真的很重要，所以在此放在第一个强调。</p><p>交给你的任务，你做到哪一步，一定要让给你布置的人心里有数，或者说你打算什么时候做完，也一定要给一个deadline，若是长久没有回音，或者最后出了岔子，难免就会留下不靠谱的印象。</p><p><strong>2.跟事情要跟到底</strong></p><p>让你跟一件事情，就要跟到底，中间如果遇到阻碍发现事情没有进展，就要想办法去解决，如果实在解决不了，就要跟向你布置任务的人主动沟通，最起码我们组内达成共识得出一个结论。</p><p><strong>3.不只是完成任务</strong></p><p> 以高标准要求自己，在完成任务的同时能否做的更好，或者说给我的方案是这样，我能否想出更好的方案，在这样的思考中自己的能力也会有所提升。</p><p><strong>4.高效</strong></p><p>一个任务，他花费多少时间，大家心里一般都有数，如果这个任务一般只花费一天，结果你做了两天，三天还没有做好，那一定是你的问题，还有的情况是因为其他事情多，所以设置了deadline，但是出现一拖再拖，到了deadline还继续往下拖的情况，那最起码也是你对自己时间规划不清楚所造成的问题，哪怕自己加班也不能出现因为自己导致项目block的情况，这是我对我自己的要求。</p><p><strong>5.团队配合</strong></p><p>不要怕问问题，但是要问对的问题。</p><p>当出现了问题，一定要先判定问题的范畴，是技术问题，还是非技术问题。</p><p>技术问题当然要靠自己搜资料和想办法解决，但是可以分情况给自己一个时间限制，比如我手上还有很多事情，我已经花了一个小时，还是解决不了这个问题，但是我这边该做的都做了，实在找不到问题了，问了避免浪费时间可以考虑求助一下资深同事或者自己组内的leader。</p><p>非技术问题，可能是我们公司的组件，或者相关的技术规范导致，是一种你知道了就知道了，不知道就无法解决的问题，完全没有下手思路，这种问题可以给自己的时间限制少一些，比如10分钟，当然在提问之前也要确定自己把该做的排查都做了，然后去问一下知道的人。</p><p>于我们组而言，大家都是比较平和的人，所以不要怕问问题，但是也不要问浪费大家时间的低级问题。</p><p><strong>6.不当传话筒</strong></p><p>组内负责的服务很多，有的业务不了解每个人负责的范畴会出现问错人的情况，如果这个问题你恰好也知道可以协助做答，不过作答后也要跟业务明确负责这问题的人其实是谁，不让以后所有这些问题都可能会先问你，如果你不清楚，就不要做传话筒，可以直接拉群或者直接告诉业务方应该问谁，不要转发问题，这样业务方跟问题负责人的沟通中就多加了一层你，有时候业务方对服务了解不清楚，问的问题本身就不正确，你还协助传达，那就是在浪费所有人的时间。</p>]]></content>
      
      
      <categories>
          
          <category> 软实力 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>序</title>
      <link href="/golang/go-design-pattern/startup/"/>
      <url>/golang/go-design-pattern/startup/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含 23 种常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记</li><li>一些基础原则和思想</li></ul><h3 id="“好”代码的几个标准"><a href="#“好”代码的几个标准" class="headerlink" title="“好”代码的几个标准"></a>“好”代码的几个标准</h3><ol><li>如何评价代码质量的高低？<br>代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁等，这些词汇是从不同的维度去评价代码质量的。它们之间有互相作用，并不是独立的，比如，代码的可读性好、可扩展性好就意味着代码的可维护性好。代码质量高低是一个综合各种因素得到的结论。我们并不能通过单一的维度去评价一段代码的好坏。</li><li>最常用的评价标准有哪几个？<br>最常用到几个评判代码质量的标准是：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。</li><li>如何才能写出高质量的代码？<br>要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等等</li></ol>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper</title>
      <link href="/interview/distribution/zookeeper/"/>
      <url>/interview/distribution/zookeeper/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是-zookeeper-？"><a href="#1-什么是-zookeeper-？" class="headerlink" title="1. 什么是 zookeeper ？"></a>1. 什么是 zookeeper ？</h3><p>Zookeeper（CP）<br>作为一个分布式协同服务，ZooKeeper非常好，但是对于Service发现服务来说就不合适了，因为对于Service发现服务来说就算是返回了包含不实的信息的结果也比什么都不返回要好。所以当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。</p><p>但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。</p><p>所以说，作为注册中心，可用性的要求要高于一致性！</p><p>在 CAP 模型中，Zookeeper整体遵循一致性（CP）原则，即在任何时候对 Zookeeper 的访问请求能得到一致的数据结果，但是当机器下线或者宕机时，不能保证服务可用性。</p><p>那为什么Zookeeper不使用最终一致性（AP）模型呢？因为这个依赖Zookeeper的核心算法是ZAB，所有设计都是为了强一致性。这个对于分布式协调系统，完全没有毛病，但是你如果将Zookeeper为分布式协调服务所做的一致性保障，用在注册中心，或者说服务发现场景，这个其实就不合适。</p><h3 id="2-什么是强、弱、最终一致性"><a href="#2-什么是强、弱、最终一致性" class="headerlink" title="2. 什么是强、弱、最终一致性"></a>2. 什么是强、弱、最终一致性</h3><h3 id="3-ZooKeeper-快速领导选举是如何实现的？"><a href="#3-ZooKeeper-快速领导选举是如何实现的？" class="headerlink" title="3. ZooKeeper 快速领导选举是如何实现的？"></a>3. ZooKeeper 快速领导选举是如何实现的？</h3><h3 id="4-如何通过两阶段提交来保证一致性"><a href="#4-如何通过两阶段提交来保证一致性" class="headerlink" title="4. 如何通过两阶段提交来保证一致性"></a>4. 如何通过两阶段提交来保证一致性</h3><h3 id="5-观察者节点的作用"><a href="#5-观察者节点的作用" class="headerlink" title="5. 观察者节点的作用"></a>5. 观察者节点的作用</h3><h3 id="6-为什么建议使用奇数台机器来构建集群？"><a href="#6-为什么建议使用奇数台机器来构建集群？" class="headerlink" title="6. 为什么建议使用奇数台机器来构建集群？"></a>6. 为什么建议使用奇数台机器来构建集群？</h3><h3 id="7-为什么会出现脑裂问题？"><a href="#7-为什么会出现脑裂问题？" class="headerlink" title="7. 为什么会出现脑裂问题？"></a>7. 为什么会出现脑裂问题？</h3>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GMP 原理与调度</title>
      <link href="/golang/concurrency/go-gmp/"/>
      <url>/golang/concurrency/go-gmp/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>M(machine): 代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。<br>P(processor): 表示逻辑processor，是线程M的执行的上下文。<br>G(goroutine): 调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。</p><h1 id="1-GMP-原理与调度"><a href="#1-GMP-原理与调度" class="headerlink" title="1. GMP 原理与调度"></a>1. GMP 原理与调度</h1><h3 id="1-1-1-一、Golang-“调度器”-的由来？"><a href="#1-1-1-一、Golang-“调度器”-的由来？" class="headerlink" title="1.1.1 一、Golang “调度器” 的由来？"></a>1.1.1 一、Golang “调度器” 的由来？</h3><h4 id="1-单进程时代不需要调度器"><a href="#1-单进程时代不需要调度器" class="headerlink" title="(1) 单进程时代不需要调度器"></a>(1) 单进程时代不需要调度器</h4><p>我们知道，一切的软件都是跑在操作系统上，真正用来干活 (计算) 的是 CPU。早期的操作系统每个程序就是一个进程，知道一个程序运行完，才能进行下一个进程，就是 “单进程时代”<br>一切的程序只能串行发生。<br>早期的单进程操作系统，面临 2 个问题：</p><ol><li><p>单一的执行流程，计算机只能一个任务一个任务处理。</p></li><li><p>进程阻塞所带来的 CPU 时间浪费。</p></li></ol><p>那么能不能有多个进程来宏观一起来执行多个任务呢？</p><p>后来操作系统就具有了最早的并发能力：多进程并发，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把 CPU 利用起来，CPU 就不浪费了。</p><h4 id="2-多进程-x2F-线程时代有了调度器需求"><a href="#2-多进程-x2F-线程时代有了调度器需求" class="headerlink" title="(2) 多进程 &#x2F; 线程时代有了调度器需求"></a>(2) 多进程 &#x2F; 线程时代有了调度器需求</h4><p><img src="https://s3.bmp.ovh/imgs/2022/02/921c521bed752387.jpg" alt="image"><br>在多进程 &#x2F; 多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞 cpu 可以立刻切换到其他进程中去执行，而且调度 cpu 的算法可以保证在运行的进程都可以被分配到 cpu 的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。</p><p>但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU 虽然利用起来了，但如果进程过多，CPU 有很大的一部分都被用来进行进程调度了。</p><p>怎么才能提高 CPU 的利用率呢？</p><p>但是对于 Linux 操作系统来讲，cpu 对进程的态度和线程的态度是一样的。<br><img src="https://s3.bmp.ovh/imgs/2022/02/bad5998d362c5be9.jpg" alt="image"></p><p>所有应用程序都是运行在操作系统上，真正用来干活(计算)的是<code>CPU</code>。所以谈到<code>Go</code>语言调度器，我们也绕不开操作系统、进程与线程这些概念。线程是操作系统调度时的最基本单元，而 Linux 在调度器并不区分进程和线程的调度，它们在不同操作系统上也有不同的实现，但是在大多数的实现中线程都属于进程。</p><p>多个线程可以属于同一个进程并共享内存空间。因为多线程不需要创建新的虚拟内存空间，所以它们也不需要内存管理单元处理上下文的切换，线程之间的通信也正是基于共享的内存进行的，与重量级的进程相比，线程显得比较轻量。</p><p>虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1 兆以上的内存空间，在对线程进行切换时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁对应的资源。</p><p>大量的线程出现了新的问题</p><ul><li><p>高内存占用</p></li><li><p>调度的CPU高消耗</p></li></ul><p>然后工程师们就发现，其实一个线程分为”内核态”线程和”用户态”线程。</p><p>一个<code>用户态线程</code>必须要绑定一个<code>内核态线程</code>，但是CPU并不知道有<code>用户态线程</code>的存在，它只知道它运行的是一个<code>内核态线程</code>(Linux的PCB进程控制块)。这样，我们再去细化分类，内核线程依然叫线程(thread)，用户线程叫协程(co-routine)。既然一个协程可以绑定一个线程，那么也可以通过实现协程调度器把多个协程与一个或者多个线程进行绑定。</p><p><code>Go</code>语言的<code>goroutine</code>来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被<code>runtime</code>调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。</p><p><code>Go</code>中，协程被称为<code>goroutine</code>，它非常轻量，一个<code>goroutine</code>只占几KB，并且这几KB就足够<code>goroutine</code>运行完，这就能在有限的内存空间内支持大量<code>goroutine</code>，支持了更多的并发。虽然一个<code>goroutine</code>的栈只占几KB，但实际是可伸缩的，如果需要更多内存，<code>runtime</code>会自动为<code>goroutine</code>分配。</p><p>既然我们知道了<code>goroutine</code>和系统线程的关系，那么最关键的一点就是实现协程调度器了。</p><p><code>Go</code>目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了。重新设计的调度器使用<code>G-M-P</code>模型并一直沿用至今。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f68Yc2PzBpdRSf4iaE1bicpADBkw9ITic8G4yctoweOep4Yc0fQKlkHeWkUIsUatove0g7AFsIAw22tA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="调度器G-M-P模型"></p><p>调度器G-M-P模型</p><ul><li><p>G — 表示 goroutine，它是一个待执行的任务；</p></li><li><p>M — 表示操作系统的线程，它由操作系统的调度器调度和管理；</p></li><li><p>P — 表示处理器，它可以被看做运行在线程上的本地调度器；</p></li></ul><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p><code>gorotuine</code> 就是<code>Go</code>语言调度器中待执行的任务，它在运行时调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销。</p><p><code>goroutine</code>只存在于<code>Go</code>语言的运行时，它是<code>Go</code>语言在用户态提供的线程，作为一种粒度更细的资源调度单元，如果使用得当能够在高并发的场景下更高效地利用机器的<code>CPU</code>。</p><h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p><code>Go</code>语言并发模型中的<code>M</code>是操作系统线程。调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有 <code>GOMAXPROCS</code> 个活跃线程能够正常运行。</p><p>在默认情况下，运行时会将 <code>GOMAXPROCS</code> 设置成当前机器的核数，我们也可以使用 <code>runtime.GOMAXPROCS</code> 来改变程序中最大的线程数。一个四核机器上会创建四个活跃的操作系统线程，每一个线程都对应一个运行时中的 <code>runtime.m</code> 结构体。</p><p>在大多数情况下，我们都会使用<code>Go</code>的默认设置，也就是活跃线程数等于<code>CPU</code>个数，在这种情况下不会触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由<code>Go</code>语言调度器触发，能够减少非常多的额外开销。</p><p>操作系统线程在<code>Go</code>语言中会使用私有结构体 <code>runtime.m</code> 来表示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type m struct &#123;    g0   *g     curg *g    ...&#125;</span><br></pre></td></tr></table></figure><p>其中<code>g0</code>是持有调度栈的<code>goroutine</code>，<code>curg</code> 是在当前线程上运行的用户<code>goroutine</code>，用户<code>goroutine</code>执行完后，线程切换回<code>g0</code>上，<code>g0</code>会从线程<code>M</code>绑定的<code>P</code>上的等待队列中获取<code>goroutine</code>交给线程。</p><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>调度器中的处理器<code>P</code>是线程和<code>goroutine</code> 的中间层，它能提供线程需要的上下文环境，也会负责调度线程上的等待队列，通过处理器<code>P</code>的调度，每一个内核线程都能够执行多个 <code>goroutine</code>，它能在<code>goroutine</code> 进行一些 <code>I/O</code> 操作时及时切换，提高线程的利用率。因为调度器在启动时就会创建 <code>GOMAXPROCS</code> 个处理器，所以<code>Go</code>语言程序的处理器数量一定会等于 <code>GOMAXPROCS</code>，这些处理器会绑定到不同的内核线程上并利用线程的计算资源运行<code>goroutine</code>。</p><p>此外在调度器里还有一个全局等待队列，当所有P本地的等待队列被占满后，新创建的<code>goroutine</code>会进入全局等待队列。<code>P</code>的本地队列为空后，<code>M</code>也会从全局队列中拿一批待执行的<code>goroutine</code>放到<code>P</code>本地的等待队列中。</p><h3 id="GMP模型图示"><a href="#GMP模型图示" class="headerlink" title="GMP模型图示"></a>GMP模型图示</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f68Yc2PzBpdRSf4iaE1bicpADicd9ka0ILRcZEob1gRNjuXgu6ic2dBysv5VeibYUUTru76UmRiaFrOmdtg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="GMP模型图示"></p><p>GMP模型图示</p><ul><li><p>全局队列：存放等待运行的G。</p></li><li><p>P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G时，G优先加入到P的本地队列，如果队列已满，则会把本地队列中一半的G移动到全局队列。</p></li><li><p>P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。</p></li><li><p>M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</p></li><li><p><code>goroutine</code>调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU上执行。</p></li></ul><h3 id="调度器的策略"><a href="#调度器的策略" class="headerlink" title="调度器的策略"></a>调度器的策略</h3><p>调度器的一个策略是尽可能的复用现有的活跃线程，通过以下两个机制提高线程的复用：</p><ol><li><p>work stealing机制，当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。</p></li><li><p>hand off机制，当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</p></li></ol><p><code>Go</code>的运行时并不具备操作系统内核级的硬件中断能力，基于工作窃取的调度器实现，本质上属于先来先服务的协作式调度，为了解决响应时间可能较高的问题，目前运行时实现了协作式调度和抢占式调度两种不同的调度策略，保证在大部分情况下，不同的 G 能够获得均匀的<code>CPU</code>时间片。</p><p>协作式调度依靠被调度方主动弃权，系统监控到一个<code>goroutine</code>运行超过10ms会通过 <code>runtime.Gosched</code> 调用主动让出执行机会。抢占式调度则依靠调度器强制将被调度方被动中断。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> go </tag>
            
            <tag> 并发 </tag>
            
            <tag> GMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang Sync.Mutex 详解</title>
      <link href="/golang/concurrency/go-sync-mutex/"/>
      <url>/golang/concurrency/go-sync-mutex/</url>
      
        <content type="html"><![CDATA[<h3 id="lock逻辑："><a href="#lock逻辑：" class="headerlink" title="lock逻辑："></a>lock逻辑：</h3><ol><li>第一次上锁的时候，直接走第一步<strong>CAS</strong>上锁，成功返回</li><li><strong>Mutex</strong>已经被另一个<strong>g</strong>上锁，那么<strong>state</strong>的<strong>g</strong>等待数+1，更新当前的锁状态，然后就进入队列，等待被唤醒，等到另个<strong>g</strong>调用了<strong>Unlock</strong>方法之后，当前<strong>g</strong>被唤醒，然后设置<strong>awoken&#x3D;true</strong>，再执行一遍<strong>for</strong>循环，此时<strong>locked</strong>位就是未上锁状态（0），<strong>new</strong>就是代表上锁，然后清除<strong>woken</strong>位，然后再<strong>CAS</strong>更新<strong>new</strong>到<strong>state</strong>上，因为之前的锁是未上锁状态，那么就代表抢锁成功，<strong>break</strong>，返回</li><li>和第二种一样，只不过，在<strong>CAS</strong>更新<strong>new</strong>到<strong>state</strong>上时，有其他<strong>g</strong>先改掉了<strong>state</strong>的值，那么就继续for循环，然后重复到第二种情况。</li></ol><h3 id="自旋锁："><a href="#自旋锁：" class="headerlink" title="自旋锁："></a>自旋锁：</h3><p>简单概括一下，就是为了解决锁粒度非常小的时候，给系统带来的不必要的调度开销<br>不过自旋要先满足几个条件<br>首先程序要跑在多核的机器上，然后GOMAXPROCS要大于1，并且此时有至少一个P的local runq是空的，才能进入到自旋的状态</p><p>自旋是一种多线程同步机制，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真。在多核的 CPU 上，自旋可以避免 Goroutine 的切换，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 Goroutine 进入自旋的条件非常苛刻</p><p>当<strong>Mutex</strong>已经上锁的时候，当前<strong>G</strong>在满足自旋条件下，进入自旋状态，在自旋中，其他<strong>G</strong>解锁了<strong>Mutex</strong>，那么当前<strong>G</strong>就设置了<strong>woken</strong>标记位，这样其他<strong>G</strong>在<strong>Unlock</strong>的时候就不会去等待队列里面唤醒<strong>G</strong>了，然后当前<strong>G</strong>就顺理成章的抢到了锁</p><p>这样自旋锁在锁粒度非常小的场景下的能对其性能带来一定的优化。</p><p>引入自旋锁之后，又带来了一个问题。就是<strong>G</strong>等待队列的<strong>长尾问题</strong>。因为从等待队列里面被唤醒，然后再去抢锁，对本身就在执行的<strong>G</strong>来说，被唤醒的<strong>G</strong>其实是很难抢过当前执行的<strong>G</strong>的，这样的话，等待队列里面的<strong>G</strong>，就会被饿死(长时间获取不到锁)，这样对等待队列的<strong>G</strong>来说其实是不公平的。</p><h3 id="饥饿模式"><a href="#饥饿模式" class="headerlink" title="饥饿模式"></a>饥饿模式</h3><p>简单概括一下，就是解决了等待G队列的长尾问题<br>饥饿模式下，直接由unlock把锁交给等待队列中排在第一位的G，同时，饥饿模式下，新进来的G不会参与抢锁也不会进入自旋状态，会直接进入等待队列的尾部。<br>饥饿模式的触发条件，当一个G等待锁时间超过1毫秒时，Mutex切换到饥饿模式<br>饥饿模式的取消条件，当一个G获取到锁且在等待队列的末尾，或者这个G获取锁的等待时间在1ms内，那么Mutex切换回正常模式</p><p>带来的改变</p><p>Mutex.state的倒数第三位，变成了mutexStarving标记位，0表示正常模式，1表示饥饿模式，与此同时，支持的最大等待G数量从230个 变成了229个</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> go </tag>
            
            <tag> 并发 </tag>
            
            <tag> mutex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang模拟面试题01</title>
      <link href="/interview/simulation/simulation01/"/>
      <url>/interview/simulation/simulation01/</url>
      
        <content type="html"><![CDATA[<ol><li><p>channel实现原理</p></li><li><p>Mutex 是悲观还是乐观锁（什么是乐观锁）</p></li><li><p>Mutex 有几种模式（饥饿和互斥）</p></li><li><p>Mutex 自旋锁？</p></li><li><p>goroutine 模型 和抢占时机</p><p><a href="https://www.bilibili.com/video/BV19r4y1w7Nx/?spm_id_from=333.788.recommend_more_video.6">https://www.bilibili.com/video/BV19r4y1w7Nx/?spm_id_from&#x3D;333.788.recommend_more_video.6</a></p></li><li><p>GC 原理</p></li><li><p>go内存分配，哪些对象分配在堆上，哪些分配在栈上（大对象小对象）</p></li><li><p>OOM out of MEMERY 内存泄漏</p></li><li><p>signal信号（64种）</p></li><li><p>Go Micro</p></li><li><p>CPU三级缓存，加载固定长度到cache，连续的地址空间</p></li><li><p>多核CPU如何保持cache不冲突（MESI）</p></li><li><p>rune 和 uint 超出位数后计算</p></li></ol><p>小厂01</p><ol><li>mutex有几种锁？<ol><li>互斥锁mutex</li><li>读写互斥锁rwmutex</li></ol></li><li>协程和线程？见golang101-1 .4</li><li>channel的作用？用法？<ol><li>控制并发数，一般结合 waitgroup</li><li>控制协程退出等</li></ol></li><li>tidb基础</li><li>gc流程 原理 golang101-2.4</li><li>线程与进程</li><li>slice 和 map 线程安全否</li><li>使用go遇到的挑战？</li><li>postgre？分布式缓存？</li><li>框架grpc相关</li><li>统计协程数量<ol><li>runtime.NumGoroutine()</li></ol></li><li>为什么转go<ol><li>微服务，上云</li><li>k8s</li><li>大量，分布式</li></ol></li></ol><p>ihandy</p><ol><li>项目</li><li>gc</li><li>redis 持久化</li><li>channel，context</li><li>mutex使用</li><li>gmp</li><li>进程线程协程</li></ol><p>数獨科技：多业务或者多方数据不出库，怎样模型化使用这些数据 tob</p><ol><li>项目<ol><li>最拿手的哪个？</li><li>技术点不是特别突出</li><li>任务系统要讲明白对用户和运营的两套接口模式，以及相关的缓存实现方案和刷新机制</li><li>广告系统要讲明白具体提升了哪些效率</li><li>什么维度的缓存key，等</li></ol></li><li>管理<ol><li>时间分配</li><li>需求评审大概流程和内容</li></ol></li><li>字符串相加</li><li>kafka ：topic， partition和consumer的关系， replica<ol><li>consumer的负载分配等</li><li>组内每个消费者对应一个partition，partition多的话由consumer承接，其中一个或几个接受的量会多；消费者多的话，多出partition的会处于空闲状态</li></ol></li></ol><p>中物联讯</p><ol><li>项目</li></ol><p>字节国际支付</p><ol><li>项目</li><li>redis 持久化</li><li>求根号2<ol><li>卡算法题了你敢信，菜逼</li><li>去把课程中的题每个至少来两遍才够的！！！！！！</li></ol></li></ol><p>循环调度：银行 or 销售的提效工具，通话质量模型 tob</p><ol><li>http + 协程，怎么调度的？是否涉及用户态和核心态的切换？</li><li>索引的构建流程？</li><li>b树，b+树区别，MongoDB为什么选用b树</li><li>gmp调度流程</li><li>redis 哪些命令? 时间复杂度是 o(n)</li><li>kafka 持久化？</li><li>kafka partition数量根据哪些信息确定的？<ol><li>回答：consumer的数量</li><li>答案：？</li></ol></li></ol><p>umu</p><ol><li>mysql 聚合索引和XX索引</li><li>redis 各种数据类型的底层结构</li></ol><p>自己总结：<br>并发，缓存，高可用，grpc，gc，gmp，mutex，channel，context等<br>http，redis，mysql，zookeeper，raft<br>乐观锁悲观锁？<br>cas？</p><p>集度基础服务开发</p><ol><li>grpc通信问题</li><li>grpc限流，熔断相关</li><li>golang 底层，写了就会问，channel实现方式，slice实现方式</li><li>如何做限流，redis请求锁的过期时间为什么，如果有人一直持有锁怎么办？</li><li>延时队列的实现方案</li><li>golang的gc</li><li>redis 锁的实现方案？</li><li>算法：判断二叉树是否对称</li><li>逃逸分析</li></ol><p>刷题：<br>剑指offer<br>算法训练营<br>简单题*3<br>中等题*4</p><p>Tik Tok二面<br>1.介绍数据库索引？<br>    数据库索引是一种数据结构，用于提高数据库查询效率。它通过创建特定的数据结构（如B树、B+树）来存储数据的有序副本，以便更快地定位和检索数据。<br>2.为什么把二叉查找树变成多路平衡查找树就能减少磁盘IO？为什么树的高度决定了磁盘的IO次数？如果查找某一个数据，用二叉查找树和用B+树的时间复杂度分别是多少?<br>3.B+树的叶子结点的默认大小是多少？如果把B树的非叶子结点只存放指针,那B树是不是就和B+树一样了呢？<br>4.除了二叉树，B+树，B树这些索引，还有什么常见的存储数据结构适合做索引呢？<br>    哈希索引和全文索引也常用于数据库索引。<br>5.为什么InnoDB不用哈希做索引，用哈希和用B+树有什么区别？<br>    哈希索引适用于等值查询，而B+树索引支持范围查询和排序。InnoDB使用B+树索引，因为它支持更多的查询类型。<br>6.Redis里面有序集合用的索引？介绍一下跳跃表，与哈希的区别？<br>    跳跃表是一种有序数据结构，用于实现有序集合。与哈希表相比，跳跃表支持有序性和范围查询。<br>7.MySQL事务隔离级别有哪些，会产生哪些问题，MySQL默认的隔离级别是什么<br>    MySQL的事务隔离级别包括读未提交、读已提交、可重复读和串行化。不同的隔离级别可能导致脏读、不可重复读和幻读等问题。MySQL默认的隔离级别是可重复读。<br>8.MySQL如何实现可重复读？MVCC的底层原理？<br>9.看你用过palsuar，也用过Kafka，那你说一下这两者不一样的地方？或者设计上有哪些不一样？<br>    Pulsar和Kafka都是消息中间件，但它们的架构和设计有所不同。例如，Pulsar支持多租户、多数据中心复制和动态消息路由等特性，而Kafka则更加专注于高吞吐量和低延迟。<br>14.说说两者底层存储消息方式的区别？<br>15.为什么这两者要这么设计？<br>17.Redis如何实现高可用和高可靠的？<br>    Redis实现高可用通常通过主从复制和哨兵或集群模式。哨兵负责监控节点健康，并在主节点失败时自动切换到从节点。集群模式支持数据分片和节点自动发现，提高了可用性和可扩展性。<br>18.Redis的主从复制是同步的还是异步的？异步和同步的优缺点？<br>    Redis的主从复制是异步的。异步复制提高了性能，但可能导致数据不一致性和数据丢失。<br>19.了解go吗，说说协程，为什么要用协程？<br>    协程是一种轻量级的线程，由Go语言原生支持。协程的优点包括低开销、高并发和简单易用，使得编写并发程序变得更加简单和高效。<br>20.为什么多线程访问共享资源需要加锁处理？<br>    多线程并发访问共享资源可能导致数据竞态和不一致性。加锁能够保证数据的原子性和一致性，从而确保线程安全。<br>21.说说可见性，为什么一个线程看不到另外一个线程的修改？<br>    线程的可见性指的是一个线程对共享变量的修改能够被其他线程立即看到。在多线程编程中，由于CPU的优化、缓存以及编译器的优化，可能导致线程之间的数据不一致。为了确保线程安全和正确性，我们需要解决这个问题。多线程对同一共享变量做修改时，某个线程修改后的新值可能不会立即更新到主内存，其他线程可能仍旧读到该变量旧值。<br>    使用锁保证同一时刻只有一个线程访问共享变量；<br>    对变量访问使用原子操作<br>23.让你设计一个任务调度器的类，add一个task，指定这个task的执行时间，可以add很多任务，但每个task执行的时间又各不相同，你如何实现，用什么数据结构？<br>    可以使用优先队列（如最小堆）来存储任务，并按照执行时间进行排序。每次调度器检查时，都会选择最早的任务执行。<br>24.优先队列的实现原理？</p><h2 id="定义与概念"><a href="#定义与概念" class="headerlink" title="定义与概念"></a><strong>定义与概念</strong></h2><p>优先队列是一种数据结构，用于存储具有不同优先级的任务或元素</p><p>包括FIFO（先进先出）和LIFO（后进先出）两种基本类型</p><h2 id="实现技术"><a href="#实现技术" class="headerlink" title="实现技术"></a><strong>实现技术</strong></h2><p>数据结构</p><p>堆式队列：高效的数据组织结构</p><p>K叉树：基于K叉树的优先队列算法，运算效率高</p><p>双输入通道优先网络：用于通信网络设计</p><p>算法设计</p><p>PQDSA算法：基于DAG任务集的入口节点数量确定优先队列数</p><p>MP-SAQM算法：基于优先级区分的调度及主动队列管理</p><p>硬件支持</p><p>SP-PIFO: 使用严格优先级队列逼近PIFO行为</p><p>光学优先队列：通过反馈系统实现，提高了缓冲容量的利用率</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h2><p>操作系统</p><p>调度算法优化：提高处理器调度效率</p><p>网络传输</p><p>数据包调度：实现可编程的数据包调度</p><p>人工智能</p><p>异构计算环境下的任务调度问题解决</p><p>中间件技术</p><p>处理多个任务时按轻重顺序执行，缩短用户平均等待时间</p><h2 id="性能分析与优化"><a href="#性能分析与优化" class="headerlink" title="性能分析与优化"></a><strong>性能分析与优化</strong></h2><p>并行操作性能</p><p>并行插入和删除方法：保证并行度和串行存取算法的优先顺序一致</p><p>高效合并优先队列的技术：减少存储开销，提高操作效率</p><p>实验验证与比较</p><p>实验结果验证了不同算法的有效性，如SP-PIFO、PQDSA等</p><p>对比经典堆算法和新颖堆变体在不同输入下的表现</p><h2 id="挑战与未来方向"><a href="#挑战与未来方向" class="headerlink" title="挑战与未来方向"></a><strong>挑战与未来方向</strong></h2><p>技术挑战</p><p>实现大规模并行操作的存储空间自适应性</p><p>提高硬件支持下的实时性和准确性</p><p>发展趋势</p><p>探索新的数据结构和算法以适应更复杂的应用场景</p><p>加强对异构计算环境下的优化和支持能力</p><p>25.算法题：二叉树的完全性检验？</p><h2 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h2><p>1.介绍一下业务表的字段</p><p>2.定时任务刷新字段, 是怎么实现的?</p><p>3.分布式锁? 分布式死锁如何解决? 看门狗机制? 如何避免当前线程加的锁, 被其它线程解锁?</p><p>4.乐观锁和悲观锁的区别? 写多读少的情况, 应该使用乐观锁还是悲观锁?</p><p>5.分布式场景下, 如何实现乐观锁?</p><p>6.kafka的幂等性? 如何避免消息被重复消费?</p><p>7.两个线程, 同时向mysql中插入一条数据?</p><p>8.kafka如何保证消息不丢失</p><p>9.sql优化场景:</p><p>select id,name,balance from account where update_time &gt; ‘2020-09-19’ limit 100000, 10</p><p>该语句为什么查询慢? 有什么优化思路?</p><ol start="10"><li>算法题: 子集</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 实录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式01-单例模式</title>
      <link href="/golang/go-design-pattern/gdp-create/01-singleton/"/>
      <url>/golang/go-design-pattern/gdp-create/01-singleton/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>单例模式采用了 饿汉式 和 懒汉式 两种实现，个人其实更倾向于饿汉式的实现，简单，并且可以将问题及早暴露，懒汉式虽然支持延迟加载，但是这只是把冷启动时间放到了第一次使用的时候，并没有本质上解决问题，并且为了实现懒汉式还不可避免的需要加锁。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><strong>代码实现:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="comment">// Singleton 饿汉式单例</span></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> singleton *Singletonfunc init() &#123;</span><br><span class="line">singleton = &amp;Singleton&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetInstance 获取实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line"><span class="keyword">return</span> singleton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单元测试:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton_test</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">singleton </span><br><span class="line"><span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetInstance</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">assert.Equal(t, singleton.GetInstance(), singleton.GetInstance())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkGetInstanceParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line"><span class="keyword">if</span> singleton.GetInstance() != singleton.GetInstance() &#123;</span><br><span class="line">b.Errorf(<span class="string">&quot;test fail&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式（双重检测）"><a href="#懒汉式（双重检测）" class="headerlink" title="懒汉式（双重检测）"></a>懒汉式（双重检测）</h3><p><strong>代码实现:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">lazySingleton *Singleton</span><br><span class="line">once          = &amp;sync.Once&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetLazyInstance 懒汉式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetLazyInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line"><span class="keyword">if</span> lazySingleton == <span class="literal">nil</span> &#123;</span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">lazySingleton = &amp;Singleton&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lazySingleton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单元测试:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton_test</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">singleton </span><br><span class="line"><span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetInstance</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">assert.Equal(t, singleton.GetInstance(), singleton.GetInstance())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkGetInstanceParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line"><span class="keyword">if</span> singleton.GetInstance() != singleton.GetInstance() &#123;</span><br><span class="line">b.Errorf(<span class="string">&quot;test fail&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 创建型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang201</title>
      <link href="/golang/advanced-tutorial/golang201/"/>
      <url>/golang/advanced-tutorial/golang201/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 进阶教程笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang Channel 详解</title>
      <link href="/golang/concurrency/go-channel/"/>
      <url>/golang/concurrency/go-channel/</url>
      
        <content type="html"><![CDATA[<h2 id="channel-101"><a href="#channel-101" class="headerlink" title="channel 101"></a>channel 101</h2><h3 id="1-引子"><a href="#1-引子" class="headerlink" title="1. 引子"></a>1. 引子</h3><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。</p><p>如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h4><h2 id="channel-底层原理"><a href="#channel-底层原理" class="headerlink" title="channel 底层原理"></a>channel 底层原理</h2><ul><li><code>buf</code>是有缓冲的channel所特有的结构，用来存储缓存数据。是个循环链表 （为啥是循环链表？普通数组不行吗，普通数组地址和容量固定更适合指定的空间。需要pop 掉元素，普通数组需要全部都前移）</li><li><code>sendx</code>和<code>recvx</code>用于记录<code>buf</code>这个循环链表中的<del>发送或者接收的</del>index</li><li><code>lock</code>是个互斥锁。</li><li><code>recvq</code>和<code>sendq</code>分别是接收(&lt;-channel)或者发送(channel &lt;- xxx)的goroutine抽象出来的结构体(sudog)的队列。是个双向链表</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="type">uint</span>  <span class="comment">// 队列中的总元素个数 </span></span><br><span class="line">dataqsiz <span class="type">uint</span>  <span class="comment">// 环形队列大小，即可存放元素的个数 </span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// 环形队列指针 </span></span><br><span class="line">elemsize <span class="type">uint16</span>  <span class="comment">//每个元素的大小 </span></span><br><span class="line">closed   <span class="type">uint32</span>  <span class="comment">//标识关闭状态 </span></span><br><span class="line">elemtype *_type <span class="comment">// 元素类型 </span></span><br><span class="line">sendx    <span class="type">uint</span>   <span class="comment">// 发送索引，元素写入时存放到队列中的位置</span></span><br><span class="line">recvx    <span class="type">uint</span>   <span class="comment">// 接收索引，元素从队列的该位置读出</span></span><br><span class="line">recvq    waitq  <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">sendq    waitq <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex <span class="comment">//互斥锁，chan不允许并发读写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-读写流程"><a href="#1-读写流程" class="headerlink" title="1. 读写流程"></a>1. 读写流程</h4><blockquote><p>向 channel 写数据:</p><ol><li><p>若等待接收队列 recvq 不为空，则缓冲区中无数据或无缓冲区，将直接从 recvq 取出 G ，并把数据写入，最后把该 G 唤醒，结束发送过程。</p></li><li><p>若缓冲区中有空余位置，则将数据写入缓冲区，结束发送过程。</p></li><li><p>若缓冲区中没有空余位置，则将发送数据写入 G，将当前 G 加入 sendq ，进入睡眠，等待被读 goroutine 唤醒。</p></li></ol></blockquote><blockquote><p>从 channel 读数据</p><ol><li><p>若等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G ，把 G 中数据读出，最后把 G 唤醒，结束读取过程。</p></li><li><p>如果等待发送队列 sendq 不为空，说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程。</p></li><li><p>如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程。</p></li><li><p>将当前 goroutine 加入 recvq ，进入睡眠，等待被写 goroutine 唤醒。</p></li></ol></blockquote><blockquote><p>关闭 channel</p><p>1.关闭 channel 时会将 recvq 中的 G 全部唤醒，本该写入 G 的数据位置为 nil。将 sendq 中的 G 全部唤醒，但是这些 G 会 panic。</p><p>panic 出现的场景还有：</p><ul><li>关闭值为 nil 的 channel</li><li>关闭已经关闭的 channel</li><li>向已经关闭的 channel 中写数据</li></ul></blockquote><h4 id="2-创建channel"><a href="#2-创建channel" class="headerlink" title="2. 创建channel"></a>2. 创建channel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无缓冲的channel由于没有缓冲发送和接收需要同步</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)   </span><br><span class="line"><span class="comment">//有缓冲channel不要求发送和接收操作同步</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>实例化了 chan 的结构体，返回ch指针</p><h4 id="channel中发送send-ch-lt-xxx-和recv-lt-ch-接收"><a href="#channel中发送send-ch-lt-xxx-和recv-lt-ch-接收" class="headerlink" title="channel中发送send(ch &lt;- xxx)和recv(&lt;- ch)接收"></a>channel中发送send(ch &lt;- xxx)和recv(&lt;- ch)接收</h4><p>使用 mutex 加锁操作，新进先出的队列</p><h4 id="当channel缓存满后"><a href="#当channel缓存满后" class="headerlink" title="当channel缓存满后"></a>当channel缓存满后</h4><h5 id="发送满的时候"><a href="#发送满的时候" class="headerlink" title="发送满的时候"></a>发送满的时候</h5><p>当队列已满的时候，G1正在运行，当再次send操作时，会主动调用GO的调度器，让G1等待，并让出M，同时G1也会被抽象成含有G1指针和send元素的sudog结构体保存到hchan的<code>sendq</code>中等待被唤醒。</p><p>当G2 recv操作的时候，G2从缓存队列中取出数据，channel会将等待队列中的G1推出，将G1当时send的数据推到缓存中，然后调用Go的scheduler，唤醒G1，并把G1放到可运行的Goroutine队列中。</p><h5 id="接收满的时候"><a href="#接收满的时候" class="headerlink" title="接收满的时候"></a>接收满的时候</h5><p>这个时候G2会主动调用Go的调度器,让G2等待，并从让出M，让其他G去使用。 G2还会被抽象成含有G2指针和recv空元素的<code>sudog</code>结构体保存到hchan的<code>recvq</code>中等待被唤醒。此时恰好有个goroutine G1开始向channel中推送数据 <code>ch &lt;- 1</code>。 此时，非常有意思的事情发生了：G1并没有锁住channel，然后将数据放到缓存中，而是直接把数据从G1直接copy到了G2的栈中。 这种方式非常的赞！在唤醒过程中，G2无需再获得channel的锁，然后从缓存中取数据。减少了内存的copy，提高了效率。</p><h4 id="4-channel-的状态和操作方式"><a href="#4-channel-的状态和操作方式" class="headerlink" title="4. channel 的状态和操作方式"></a>4. channel 的状态和操作方式</h4><p>如下：</p><table><thead><tr><th align="left">操作</th><th align="left">nil 的 channel</th><th align="left">已关闭的 channel</th><th align="left">正常 channel</th></tr></thead><tbody><tr><td align="left">close 关闭</td><td align="left">panic</td><td align="left">panic</td><td align="left">成功</td></tr><tr><td align="left">ch &lt;- 写</td><td align="left">死锁</td><td align="left">panic</td><td align="left">阻塞或成功</td></tr><tr><td align="left">&lt;-ch 读</td><td align="left">死锁</td><td align="left">零值</td><td align="left">阻塞或成功</td></tr></tbody></table><p>channel一个类型管道，通过它可以在goroutine之间发送和接收消息。它是Golang在语言层面提供的goroutine间的通信方式。</p><p>众所周知，Go依赖于称为CSP（Communicating Sequential Processes）的并发模型，通过Channel实现这种同步模式。Go并发的核心哲学是不要通过共享内存进行通信; 相反，通过沟通分享记忆。</p><h2 id="channel-常见用法"><a href="#channel-常见用法" class="headerlink" title="channel 常见用法"></a>channel 常见用法</h2><h4 id="循环读取"><a href="#循环读取" class="headerlink" title="循环读取"></a>循环读取</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x := <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> go </tag>
            
            <tag> 并发 </tag>
            
            <tag> channel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http 网络面试必备</title>
      <link href="/interview/http/"/>
      <url>/interview/http/</url>
      
        <content type="html"><![CDATA[<p>△ 46次</p><p>从输入 URL 到展现页面的全过程  困难 <a href="https://github.com/alex/what-happens-when">参考1</a></p><p>△ 42次</p><p>TCP 怎么保证可靠传输？  中等 <a href="https://www.cs.colostate.edu/~christos/cs557s12/Slides/05TCP.pdf">参考1</a> <a href="https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C?id=%e5%9b%9b-tcp-%e5%8d%8f%e8%ae%ae%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93">参考2</a></p><p>△ 42次</p><p>TCP 中常见的拥塞控制算法有哪些？  中等 <a href="https://zh.wikipedia.org/wiki/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">参考1</a> <a href="https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C?id=%e5%9b%9b-tcp-%e5%8d%8f%e8%ae%ae%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93">参考2</a></p><p>△ 40次</p><p>HTTP 与 HTTPS 有哪些区别？  中等 <a href="https://www.keycdn.com/blog/difference-between-http-and-https">参考1</a> <a href="https://www.runoob.com/w3cnote/http-vs-https.html">参考2</a></p><p>△ 38次</p><p>简述常见的 HTTP 状态码的含义（301，304，401，403）  简单 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">参考1</a></p><p>△ 38次</p><p>简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？  中等 <a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html">参考1</a> <a href="https://zhuanlan.zhihu.com/p/53374516">参考2</a></p><p>△ 34次</p><p>简述 HTTPS 的加密与认证过程  中等 <a href="https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">参考1</a></p><p>△ 34次</p><p>什么是跨域，什么情况下会发生跨域请求？  中等 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">参考1</a></p><p>△ 28次</p><p>DNS 查询服务器的基本流程是什么？DNS 劫持是什么？  中等 <a href="https://www.cloudflare.com/learning/dns/what-is-dns/">参考1</a> <a href="https://www.ruanyifeng.com/blog/2016/06/dns.html">参考2</a></p><p>△ 26次</p><p>TCP的拥塞控制具体是怎么实现的？UDP有拥塞控制吗？  中等 <a href="https://zh.wikipedia.org/wiki/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">参考1</a></p><p>△ 26次</p><p>TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？  简单 <a href="https://www.guru99.com/tcp-vs-udp-understanding-the-difference.html">参考1</a> <a href="https://developer.aliyun.com/article/454541">参考2</a></p><p>△ 24次</p><p>什么是 TCP 粘包和拆包？  简单</p><p>△ 24次</p><p>简述 HTTP 1.0，1.1，2.0 的主要区别  简单 <a href="https://www.digitalocean.com/community/tutorials/http-1-1-vs-http-2-what-s-the-difference">参考1</a> <a href="https://juejin.cn/post/6844903489596833800">参考2</a></p><p>△ 22次</p><p>简述对称与非对称加密的概念  简单</p><p>△ 22次</p><p>简述 OSI 七层模型，TCP，IP 属于哪一层？  简单 <a href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">参考1</a></p><p>△ 20次</p><p>HTTP 的方法有哪些？  简单 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">参考1</a></p><p>△ 18次</p><p>简述 TCP 滑动窗口以及重传机制  简单 <a href="https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C?id=%e5%9b%9b-tcp-%e5%8d%8f%e8%ae%ae%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93">参考1</a></p><p>△ 16次</p><p>简述 JWT 的原理和校验机制  中等</p><p>△ 16次</p><p>Cookie 和 Session 的关系和区别是什么？  简单</p><p>△ 16次</p><p>简述 RPC 的调用过程  简单</p><p>△ 15次</p><p>TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？  简单 <a href="https://superuser.com/questions/173535/what-are-close-wait-and-time-wait-states">参考1</a> <a href="https://zhuanlan.zhihu.com/p/60382685">参考2</a></p><p>△ 14次</p><p>为什么需要序列化？有什么序列化的方式？  中等</p><p>△ 12次</p><p>HTTP 中 GET 和 POST 区别  简单 <a href="https://www.runoob.com/tags/html-httpmethods.html">参考1</a></p><p>△ 12次</p><p>什么是中间人攻击？如何防止攻击？  中等</p><p>△ 2次</p><p>简述 iPv4 和 iPv6 的区别  简单</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
            <tag> 必看必会 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程</title>
      <link href="/golang/concurrency/concurrent%20programming/"/>
      <url>/golang/concurrency/concurrent%20programming/</url>
      
        <content type="html"><![CDATA[<h3 id="goroutine超时处理"><a href="#goroutine超时处理" class="headerlink" title="goroutine超时处理"></a>goroutine超时处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        c1 &lt;- <span class="string">&quot;result 1&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c1:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout 1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        c2 &lt;- <span class="string">&quot;result 2&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c2:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无阻塞"><a href="#无阻塞" class="headerlink" title="无阻塞"></a>无阻塞</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c2:</span><br><span class="line">    fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">    fmt.Println(<span class="string">&quot;timeout 2&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通道关闭"><a href="#通道关闭" class="headerlink" title="通道关闭"></a>通道关闭</h3><ol><li>close(channel) 关闭通道</li><li>j，more :&#x3D; &lt;- channel 如果已关闭，则more为 false</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            j, more := &lt;-jobs</span><br><span class="line">            <span class="keyword">if</span> more &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;received job&quot;</span>, j)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;received all jobs&quot;</span>)</span><br><span class="line">                done &lt;- <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++ &#123;</span><br><span class="line">        jobs &lt;- j</span><br><span class="line">        fmt.Println(<span class="string">&quot;sent job&quot;</span>, j)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(jobs)</span><br><span class="line">    fmt.Println(<span class="string">&quot;sent all jobs&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管道遍历"><a href="#管道遍历" class="headerlink" title="管道遍历"></a>管道遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    queue := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    queue &lt;- <span class="string">&quot;one&quot;</span></span><br><span class="line">    queue &lt;- <span class="string">&quot;two&quot;</span></span><br><span class="line">    <span class="built_in">close</span>(queue)</span><br><span class="line">    <span class="keyword">for</span> elem := <span class="keyword">range</span> queue &#123;</span><br><span class="line">        fmt.Println(elem)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="只读和只写管道"><a href="#只读和只写管道" class="headerlink" title="只读和只写管道"></a>只读和只写管道</h3><ul><li><code>&lt;-chan string</code> 只读</li><li><code>chan&lt;- string</code> 只写</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(jobs <span class="keyword">chan</span> <span class="type">int</span>, done <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">j, more := &lt;-jobs</span><br><span class="line"><span class="keyword">if</span> more &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;received job&quot;</span>, j)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;received all jobs&quot;</span>)</span><br><span class="line">done &lt;- <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMsg</span><span class="params">(jobs <span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++ &#123;</span><br><span class="line">jobs &lt;- j</span><br><span class="line">fmt.Println(<span class="string">&quot;sent job&quot;</span>, j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(jobs)</span><br><span class="line">fmt.Println(<span class="string">&quot;sent all jobs&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> test(jobs, done)</span><br><span class="line"><span class="keyword">go</span> sendMsg(jobs)</span><br><span class="line"></span><br><span class="line">&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制并发数"><a href="#控制并发数" class="headerlink" title="控制并发数"></a>控制并发数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">choice1()</span><br><span class="line">choice2()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">choice1</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span> ,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">time.Sleep( time.Second)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&lt;- ch</span><br><span class="line">&#125;(ch)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">choice2</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span> ,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">time.Sleep( time.Second)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&lt;- ch</span><br><span class="line">&#125;(ch)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> go </tag>
            
            <tag> 并发 </tag>
            
            <tag> channel </tag>
            
            <tag> goroutine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 反射</title>
      <link href="/golang/reflect/"/>
      <url>/golang/reflect/</url>
      
        <content type="html"><![CDATA[<h3 id="Name-and-Kind"><a href="#Name-and-Kind" class="headerlink" title="Name and Kind"></a>Name and Kind</h3><p>可调用函数和含义，以及结果一览</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typeOfCat := reflect.TypeOf(cat&#123;&#125;)</span><br><span class="line">typeOfCat.Name() <span class="comment">// cat</span></span><br><span class="line">typeOfCat.Kind()  <span class="comment">// struct</span></span><br><span class="line">typeOfCat.NumField() <span class="comment">// 2 几个字段</span></span><br><span class="line">typeOfCat.Field(i) <span class="comment">//第几个字段</span></span><br><span class="line">typeOfCat.FieldByName(<span class="string">&quot;Type&quot;</span>) <span class="comment">// 找名为Type的字段</span></span><br><span class="line">typeOfCat.MethodByName(<span class="string">&quot;Start&quot;</span>) <span class="comment">// 找名为Start的方法</span></span><br><span class="line"><span class="keyword">if</span> typeofCat.Kind() == <span class="string">&quot;ptr&quot;</span>&#123;</span><br><span class="line">  res := typeOfCat.Elem()  <span class="comment">// 等价于*ptr</span></span><br><span class="line">  res.Name()</span><br><span class="line">  res.Kind()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reflect-ValueOf-和reflect-Value"><a href="#reflect-ValueOf-和reflect-Value" class="headerlink" title="reflect.ValueOf()和reflect.Value"></a>reflect.ValueOf()和reflect.Value</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">valueOfA := reflect.ValueOf(a)</span><br><span class="line"><span class="keyword">var</span> getA <span class="type">int</span> = valueOfA.Interface().(<span class="type">int</span>)</span><br><span class="line"><span class="keyword">var</span> getA2 <span class="type">int</span> = <span class="type">int</span>(valueOfA.Int())</span><br></pre></td></tr></table></figure><h3 id="通过反射获取值信息"><a href="#通过反射获取值信息" class="headerlink" title="通过反射获取值信息"></a>通过反射获取值信息</h3><h4 id="使用反射值对象包装任意值"><a href="#使用反射值对象包装任意值" class="headerlink" title="使用反射值对象包装任意值"></a>使用反射值对象包装任意值</h4><p>Go语言中，使用 reflect.ValueOf() 函数获得值的反射值对象（reflect.Value）。书写格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value := reflect.ValueOf(rawValue)</span><br></pre></td></tr></table></figure><p>reflect.ValueOf 返回 reflect.Value 类型，包含有 rawValue 的值信息。reflect.Value 与原值间可以通过值包装和值获取互相转化。reflect.Value 是一些反射操作的重要类型，如反射调用函数。</p><h4 id="从反射值对象获取被包装的值"><a href="#从反射值对象获取被包装的值" class="headerlink" title="从反射值对象获取被包装的值"></a>从反射值对象获取被包装的值</h4><p>Go语言中可以通过 reflect.Value 重新获得原始值。</p><h5 id="1-从反射值对象（reflect-Value）中获取值的方法"><a href="#1-从反射值对象（reflect-Value）中获取值的方法" class="headerlink" title="1) 从反射值对象（reflect.Value）中获取值的方法"></a>1) 从反射值对象（reflect.Value）中获取值的方法</h5><p>可以通过下面几种方法从反射值对象 reflect.Value 中获取原值，如下表所示。</p><table><thead><tr><th align="left">方法名</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="left">Interface() interface {}</td><td align="left">将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td></tr><tr><td align="left">Int() int64</td><td align="left">将值以 int 类型返回，所有有符号整型均可以此方式返回</td></tr><tr><td align="left">Uint() uint64</td><td align="left">将值以 uint 类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td align="left">Float() float64</td><td align="left">将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td align="left">Bool() bool</td><td align="left">将值以 bool 类型返回</td></tr><tr><td align="left">Bytes() []bytes</td><td align="left">将值以字节数组 []bytes 类型返回</td></tr><tr><td align="left">String() string</td><td align="left">将值以字符串类型返回</td></tr></tbody></table><h5 id="2-从反射值对象（reflect-Value）中获取值的例子"><a href="#2-从反射值对象（reflect-Value）中获取值的例子" class="headerlink" title="2) 从反射值对象（reflect.Value）中获取值的例子"></a>2) 从反射值对象（reflect.Value）中获取值的例子</h5><p>下面代码中，将整型变量中的值使用 reflect.Value 获取反射值对象（reflect.Value）。再通过 reflect.Value 的 Interface() 方法获得 interface{} 类型的原值，通过 int 类型对应的 reflect.Value 的 Int() 方法获得整型值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明整型变量a并赋初值</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">1024</span></span><br><span class="line">    <span class="comment">// 获取变量a的反射值对象</span></span><br><span class="line">    valueOfA := reflect.ValueOf(a)</span><br><span class="line">    <span class="comment">// 获取interface&#123;&#125;类型的值, 通过类型断言转换</span></span><br><span class="line">    <span class="keyword">var</span> getA <span class="type">int</span> = valueOfA.Interface().(<span class="type">int</span>)</span><br><span class="line">    <span class="comment">// 获取64位的值, 强制类型转换为int类型</span></span><br><span class="line">    <span class="keyword">var</span> getA2 <span class="type">int</span> = <span class="type">int</span>(valueOfA.Int())</span><br><span class="line">    fmt.Println(getA, getA2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代码输出如下：</span></span><br><span class="line"><span class="comment">// 1024 1024</span></span><br></pre></td></tr></table></figure><h3 id="通过reflect反射修改值"><a href="#通过reflect反射修改值" class="headerlink" title="通过reflect反射修改值"></a>通过reflect反射修改值</h3><p>判断反射值是否可以修改？CanSet()，是否能被取址CanAddr()</p><p>结构体成员中，如果字段没有被导出，即便不使用反射也可以被访问，但不能通过反射修改</p><ol><li><p>指针指向的具体元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">v := reflect.ValueOf(&amp;x)</span><br><span class="line">v = v.Elem()</span><br></pre></td></tr></table></figure></li><li><p>slice的元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">1</span>&#125;</span><br><span class="line">v := reflect.ValueOf(s)</span><br><span class="line">e := v.Index(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p>可寻址的结构体的字段(指向结构体的指针)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Orange <span class="keyword">struct</span>&#123;</span><br><span class="line">  Size <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line">a := Orange&#123;<span class="number">99</span>&#125;</span><br><span class="line">v := reflect.ValueOf(&amp;a)</span><br><span class="line">v = v.Elem()</span><br><span class="line">field = v.FieldByName(<span class="string">&quot;field&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>可寻址的数组的元素(指向数组的指针)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">1</span>&#125;</span><br><span class="line">v := reflect.ValueOf(&amp;a)</span><br><span class="line">v = v.Elem()</span><br><span class="line">vIndex = v.Index(<span class="number">0</span>)</span><br><span class="line">vIndex.SetInt(<span class="number">1</span>)</span><br><span class="line">vIndex.SetInt(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ol><table><thead><tr><th align="left">-</th><th align="left">-</th></tr></thead><tbody><tr><td align="left">Set(x Value)</td><td align="left">将值设置为传入的反射值对象的值</td></tr><tr><td align="left">Setlnt(x int64)</td><td align="left">使用 int64 设置值。当值的类型不是 int、int8、int16、 int32、int64 时会发生宕机</td></tr><tr><td align="left">SetUint(x uint64)</td><td align="left">使用 uint64 设置值。当值的类型不是 uint、uint8、uint16、uint32、uint64 时会发生宕机</td></tr><tr><td align="left">SetFloat(x float64)</td><td align="left">使用 float64 设置值。当值的类型不是 float32、float64 时会发生宕机</td></tr><tr><td align="left">SetBool(x bool)</td><td align="left">使用 bool 设置值。当值的类型不是 bod 时会发生宕机</td></tr><tr><td align="left">SetBytes(x []byte)</td><td align="left">设置字节数组 []bytes值。当值的类型不是 []byte 时会发生宕机</td></tr><tr><td align="left">SetString(x string)</td><td align="left">设置字符串值。当值的类型不是 string 时会发生宕机</td></tr></tbody></table><h3 id="通过类型信息创建实例"><a href="#通过类型信息创建实例" class="headerlink" title="通过类型信息创建实例"></a>通过类型信息创建实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">typeOfA := reflect.TypeOf(a)</span><br><span class="line">aIns := reflect.New(typeOfA) <span class="comment">// 等价于 new(int)</span></span><br><span class="line">fmt.Println(aIns.Type(), aIns.Kind())</span><br></pre></td></tr></table></figure><h3 id="Go语言结构体标签（Struct-Tag）"><a href="#Go语言结构体标签（Struct-Tag）" class="headerlink" title="Go语言结构体标签（Struct Tag）"></a>Go语言结构体标签（Struct Tag）</h3><h4 id="结构体标签的格式"><a href="#结构体标签的格式" class="headerlink" title="结构体标签的格式"></a>结构体标签的格式</h4><p>tag 格式：<code>json:&quot;type&quot; id:&quot;100&quot;</code></p><p>注意：</p><ol><li>key:“value” 冒号后没有空格</li><li>两个key之间，一个空格，多一个都不行</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Type <span class="type">int</span> <span class="string">`json:&quot;type&quot; id:&quot;100&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从结构体标签中获取值"><a href="#从结构体标签中获取值" class="headerlink" title="从结构体标签中获取值"></a>从结构体标签中获取值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeOfCat := reflect.TypeOf(cat&#123;&#125;)</span><br><span class="line">catType = typeOfCat.FieldByName(<span class="string">&quot;Type&quot;</span>)</span><br><span class="line">catType.Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><h4 id="动态调用函数（无参数）"><a href="#动态调用函数（无参数）" class="headerlink" title="动态调用函数（无参数）"></a>动态调用函数（无参数）</h4><ol><li>直接<code>reflect.Valueof</code></li><li><code>MethodByName</code></li><li>调用<code>Call</code>方法</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Do&quot;</span></span><br><span class="line">    t := &amp;T&#123;&#125;</span><br><span class="line">    reflect.ValueOf(t).MethodByName(name).Call(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Do() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态调用函数（有参数）"><a href="#动态调用函数（有参数）" class="headerlink" title="动态调用函数（有参数）"></a>动态调用函数（有参数）</h4><ol><li>创建<code>reflect.Value</code>切片</li><li><code>reflect.Valueof(t).MethodByName(string)</code> 调用Call方法传入参数</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Do&quot;</span></span><br><span class="line">    t := &amp;T&#123;&#125;</span><br><span class="line">    a := reflect.ValueOf(<span class="number">1111</span>)</span><br><span class="line">    b := reflect.ValueOf(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    in := []reflect.Value&#123;a, b&#125;</span><br><span class="line">    reflect.ValueOf(t).MethodByName(name).Call(in)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Do(a <span class="type">int</span>, b <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span> + b, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接收返回值"><a href="#接收返回值" class="headerlink" title="接收返回值"></a>接收返回值</h4><ol><li>返回<code>[]reflect.Value</code></li><li>调用<code>Interface()</code>方法，转为<code>interface&#123;&#125;</code>类型</li><li>断言类型</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Do&quot;</span></span><br><span class="line">    t := &amp;T&#123;&#125;</span><br><span class="line">    ret := reflect.ValueOf(t).MethodByName(name).Call(<span class="literal">nil</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;strValue: %[1]v\nerrValue: %[2]v\nstrType: %[1]T\nerrType: %[2]T&quot;</span>, ret[<span class="number">0</span>], ret[<span class="number">1</span>].Interface().(<span class="type">error</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Do() (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>, errors.New(<span class="string">&quot;new error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Tag解析"><a href="#Tag解析" class="headerlink" title="Tag解析"></a>Tag解析</h4><ol><li><code>reflect.Typeof</code>有<code>NumField</code>，Field根据序号索取，取其中的tag</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;</span><br><span class="line">Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Age <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := T&#123;&#125;</span><br><span class="line">tt := reflect.TypeOf(a)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;tt.NumField();i++&#123;</span><br><span class="line">fmt.Println(tt.Field(i).Name)</span><br><span class="line">fmt.Println(tt.Field(i).Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">fmt.Println(tt.Field(i).Tag.Lookup(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">fmt.Println(tt.Field(i).Type)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过kind（）处理不同分支"><a href="#通过kind（）处理不同分支" class="headerlink" title="通过kind（）处理不同分支"></a>通过kind（）处理不同分支</h4><ol><li><code>reflect.Typeof().Kind()</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := <span class="number">1</span></span><br><span class="line">a := reflect.TypeOf(t)</span><br><span class="line"><span class="keyword">switch</span> a.Kind() &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.String:</span><br><span class="line">fmt.Println(<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> reflect.Int:</span><br><span class="line">fmt.Println(<span class="string">&quot;int&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断结构体是否实现接口"><a href="#判断结构体是否实现接口" class="headerlink" title="判断结构体是否实现接口"></a>判断结构体是否实现接口</h4><ol><li>将<code>nil</code>强转为接口指针类型，通过<code>reflect.Typeof().Elem</code>获取其接口类型</li><li><code>reflect.Typeof</code>调用方法<code>Implements</code>来判断</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IT <span class="keyword">interface</span> &#123;</span><br><span class="line">test1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">A <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> test1() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := &amp;T&#123;&#125;</span><br><span class="line">elem := reflect.TypeOf((*IT)(<span class="literal">nil</span>)).Elem()</span><br><span class="line"><span class="keyword">if</span> reflect.TypeOf(t).Implements(elem) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接通过接口强转判断</p><ol><li>将类型转换为 <code>reflect.Value</code></li><li>将<code>reflect.Value</code>调用Interface()方法转为接口类型</li><li>类型断言</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ITester <span class="keyword">interface</span> &#123;</span><br><span class="line">test1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">A <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u := &amp;User&#123;&#125;</span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line">val, ok := v.Interface().(ITester)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Support Interface&quot;</span>, val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> reflect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础知识</title>
      <link href="/interview/elementary/"/>
      <url>/interview/elementary/</url>
      
        <content type="html"><![CDATA[<p>△ 70次</p><p>进程间有哪些通信方式？  困难 <a href="https://www.guru99.com/inter-process-communication-ipc.html">参考1</a> <a href="https://www.coursera.org/lecture/os-pku/jin-cheng-jian-tong-xin-ipc-wbxs5">参考2</a></p><p>△ 44次</p><p>简述 select, poll, epoll 的使用场景以及区别，epoll 中水平触发以及边缘触发有什么不同？  困难 <a href="https://jvns.ca/blog/2017/06/03/async-io-on-linux--select--poll--and-epoll/">参考1</a> <a href="https://imageslr.com/2020/02/27/select-poll-epoll.html">参考2</a></p><p>△ 44次</p><p>进程和线程之间有什么区别？  简单 <a href="https://www.guru99.com/difference-between-process-and-thread.html">参考1</a> <a href="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Phyduck/c%2B%2B/concurrent/1.%20Linux%20%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%B0%83%E5%BA%A6.pdf">参考2</a></p><p>△ 40次</p><p>简述操作系统如何进行内存管理  中等 <a href="https://www.guru99.com/os-memory-management.html">参考1</a> <a href="https://zhuanlan.zhihu.com/p/143273007">参考2</a></p><p>△ 40次</p><p>操作系统中，虚拟地址与物理地址之间如何映射？  中等</p><p>△ 26次</p><p>简述操作系统中的缺页中断  中等 <a href="https://www.oreilly.com/library/view/understanding-the-linux/0596005652/ch04s02.html">参考1</a></p><p>△ 24次</p><p>什么时候会由用户态陷入内核态？  简单</p><p>△ 22次</p><p>简述自旋锁与互斥锁的使用场景  中等</p><p>△ 20次</p><p>简述 mmap 的使用场景以及原理  中等</p><p>△ 20次</p><p>线程间有哪些通信方式？  中等</p><p>△ 20次</p><p>Linux 下如何查看端口被哪个进程占用？  简单</p><p>△ 18次</p><p>两个线程交替打印一个共享变量  中等</p><p>△ 16次</p><p>简述 Linux 进程调度的算法  困难 <a href="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Phyduck/c%2B%2B/concurrent/1.%20Linux%20%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%B0%83%E5%BA%A6.pdf">参考1</a></p><p>△ 12次</p><p>简述 Linux 零拷贝的原理  中等</p><p>△ 12次</p><p>什么情况下，进程会进行切换？  简单</p><p>△ 12次</p><p>Linux 中虚拟内存和物理内存有什么区别？有什么优点？  中等</p><p>△ 10次</p><p>简述 traceroute 命令的原理  简单</p><p>△ 40次</p><p>简述 CAP 理论  简单</p><p>△ 22次</p><p>简述常见的负载均衡算法  简单 <a href="https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/">参考1</a></p><p>△ 18次</p><p>设计一个阻塞队列  中等</p><p>△ 16次</p><p>简述生产者消费者模型  简单</p><p>△ 12次</p><p>简述 MapReduce 的原理  中等</p><p>△ 12次</p><p>kafka 如何保证消息一致性？  中等</p><p>△ 12次</p><p>设计 Tiny URL 系统  中等</p><p>△ 10次</p><p>停车场有有限个车位，有多个车来抢车位，设计一个系统需要根据车辆进入和离开停车场的时间进行计费  困难</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试算法题总结</title>
      <link href="/interview/inter-alg101/"/>
      <url>/interview/inter-alg101/</url>
      
        <content type="html"><![CDATA[<h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><p>更多加分点： 加权等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> LoadBalancer <span class="keyword">struct</span> &#123;</span><br><span class="line">    client []*Client</span><br><span class="line">    size <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLB</span><span class="params">(size <span class="type">int32</span>)</span></span> *LoadBalalcer &#123;</span><br><span class="line">    lb := &amp;LoadBalancer&#123;client: <span class="built_in">make</span>([]*Client, size), size: size&#125;</span><br><span class="line">    lb.client = <span class="built_in">append</span>(lb.client, &amp;Client&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> lb</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LoadBalancer)</span></span> getClient() *Client &#123;</span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">    x := rand.Int31n(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">return</span> m.client[x &amp; m.size]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Client)</span></span> Do &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Do&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    lb := NewLB(<span class="number">4</span>)</span><br><span class="line">    lb.getClient().Do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用反射调用函数"><a href="#利用反射调用函数" class="headerlink" title="利用反射调用函数"></a>利用反射调用函数</h3><p>实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span></span> Drive &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Driving&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    car := Car&#123;&#125;</span><br><span class="line">    val := reflect.ValueOf(&amp;car)</span><br><span class="line">    f := value.MethodByName(<span class="string">&quot;Drive&quot;</span>)</span><br><span class="line">    f.Call([]reflect.Value&#123;&#125;)  <span class="comment">// Drive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给定三个函数-cat-dog-fish-，每个函数启动一个-goroutine-，要求按照顺序打印100次"><a href="#给定三个函数-cat-dog-fish-，每个函数启动一个-goroutine-，要求按照顺序打印100次" class="headerlink" title="给定三个函数 cat dog fish ，每个函数启动一个 goroutine ，要求按照顺序打印100次"></a>给定三个函数 cat dog fish ，每个函数启动一个 goroutine ，要求按照顺序打印100次</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintCat</span><span class="params">(fishCH,catCH <span class="keyword">chan</span> <span class="type">bool</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> waitgroup.Done()</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(catCH)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt;<span class="number">100</span>;i++&#123;</span><br><span class="line">&lt;-fishCH</span><br><span class="line">fmt.Println(<span class="string">&quot;cat ...&quot;</span>)</span><br><span class="line">catCH &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintDog</span><span class="params">(catCH,dogCH <span class="keyword">chan</span> <span class="type">bool</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> waitgroup.Done()</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(dogCH)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt;<span class="number">100</span>;i++&#123;</span><br><span class="line">&lt;-catCH</span><br><span class="line">fmt.Println(<span class="string">&quot;dog ...&quot;</span>)</span><br><span class="line">dogCH&lt;-<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintFish</span><span class="params">(dogCH,fishCH <span class="keyword">chan</span> <span class="type">bool</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> waitgroup.Done()</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(fishCH)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt;<span class="number">100</span>;i++&#123;</span><br><span class="line">&lt;-dogCH</span><br><span class="line">fmt.Println(<span class="string">&quot;fish ...&quot;</span>)</span><br><span class="line">fishCH&lt;-<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> waitgroup sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">catCH := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>,<span class="number">1</span>)</span><br><span class="line">dogCH := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>,<span class="number">1</span>)</span><br><span class="line">fishCH := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>,<span class="number">1</span>)</span><br><span class="line">fishCH &lt;- <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> PrintFish(dogCH,fishCH)</span><br><span class="line"><span class="keyword">go</span> PrintDog(catCH,dogCH)</span><br><span class="line"><span class="keyword">go</span> PrintCat(fishCH,catCH)</span><br><span class="line"></span><br><span class="line">waitgroup.Add(<span class="number">3</span>)</span><br><span class="line">waitgroup.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽奖问题"><a href="#抽奖问题" class="headerlink" title="抽奖问题"></a>抽奖问题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定如下结构</span></span><br><span class="line"><span class="comment">// map中，key代表名称，value代表成交单数</span></span><br><span class="line"><span class="keyword">var</span> users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span> = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>&#123;</span><br><span class="line">  <span class="string">&quot;a&quot;</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="string">&quot;b&quot;</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="string">&quot;c&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&quot;d&quot;</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="string">&quot;f&quot;</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-随机抽奖"><a href="#1-随机抽奖" class="headerlink" title="1. 随机抽奖"></a>1. 随机抽奖</h5><p>从 map 中随机选取用户中奖<br>思路：将用户理解为一个个格子，从中选取一个格子中奖</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAwardUserName</span><span class="params">(users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>)</span></span> (name <span class="type">string</span>) &#123;</span><br><span class="line">  sizeOfUsers := <span class="built_in">len</span>(users)</span><br><span class="line">  award_index := rand.Intn(sizeOfUsers)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> index <span class="type">int</span></span><br><span class="line">  <span class="keyword">for</span> u_name, _ := <span class="keyword">range</span> users &#123;</span><br><span class="line">    <span class="keyword">if</span> index == award_index &#123;</span><br><span class="line">      name = u_name</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span> = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>&#123;</span><br><span class="line">    <span class="string">&quot;a&quot;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="string">&quot;b&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">&quot;c&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;d&quot;</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="string">&quot;e&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&quot;f&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rand.Seed(time.Now().Unix())</span><br><span class="line">  <span class="comment">// 抽奖1次</span></span><br><span class="line">  name := GetAwardUserName(users)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;user: %s jack point&quot;</span>, name)</span><br><span class="line">  <span class="comment">// 抽奖1000次</span></span><br><span class="line">  award_stat := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i += <span class="number">1</span> &#123;</span><br><span class="line">    name := GetAwardUserName(users)</span><br><span class="line">    <span class="keyword">if</span> count, ok := award_stat[name]; ok &#123;</span><br><span class="line">      award_stat[name] = count + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      award_stat[name] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> name, count := <span class="keyword">range</span> award_stat &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;user: %s, award count: %d\n&quot;</span>, name, count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方抽奖代码复杂度为 O(n) ，可以结合二分查找优化为 O(logN)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAwardGenerator</span><span class="params">(users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>)</span></span> (generator <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sum_num <span class="type">int64</span></span><br><span class="line">  name_arr := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(users))</span><br><span class="line">  offset_arr := <span class="built_in">make</span>([]<span class="type">int64</span>, <span class="built_in">len</span>(users))</span><br><span class="line">  <span class="keyword">var</span> index <span class="type">int</span></span><br><span class="line">  <span class="keyword">for</span> u_name, num := <span class="keyword">range</span> users &#123;</span><br><span class="line">    name_arr[index] = u_name</span><br><span class="line">    offset_arr[index] = sum_num</span><br><span class="line">    sum_num += num</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  generator = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    award_num := rand.Int63n(sum_num)</span><br><span class="line">    <span class="keyword">return</span> name_arr[binary_search(offset_arr, award_num)]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binary_search</span><span class="params">(nums []<span class="type">int64</span>, target <span class="type">int64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  start, end := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">  <span class="keyword">for</span> start &lt;= end &#123;</span><br><span class="line">    mid := start + (end-start)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">      end = mid - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">      <span class="keyword">if</span> mid+<span class="number">1</span> == <span class="built_in">len</span>(nums) &#123; <span class="comment">// 最后一名中奖</span></span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> nums[mid+<span class="number">1</span>] &gt; target &#123;</span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line">      &#125;</span><br><span class="line">      start = mid + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mid</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-加权抽奖"><a href="#2-加权抽奖" class="headerlink" title="2. 加权抽奖"></a>2. 加权抽奖</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个也是我们常规概率抽奖的实现方案</span></span><br><span class="line"><span class="comment">// 前置逻辑需要做好并发相关的处理，包括异常状态处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAwardGenerator</span><span class="params">(users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> sum_num <span class="type">int64</span></span><br><span class="line">  name_arr := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(users))</span><br><span class="line">  <span class="keyword">for</span> u_name, num := <span class="keyword">range</span> users &#123;</span><br><span class="line">    sum_num += num</span><br><span class="line">    name_arr = <span class="built_in">append</span>(name_arr, u_name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> generator <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span></span><br><span class="line">  generator = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    award_num := rand.Int63n(sum_num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> offset_num <span class="type">int64</span></span><br><span class="line">    <span class="keyword">for</span> _, u_name := <span class="keyword">range</span> name_arr &#123;</span><br><span class="line">      offset_num += users[u_name]</span><br><span class="line">      <span class="keyword">if</span> award_num &lt; offset_num &#123;</span><br><span class="line">        <span class="keyword">return</span> u_name</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缺省返回，正常情况下，不会运行到此处</span></span><br><span class="line">    <span class="keyword">return</span> name_arr[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个消息队列"><a href="#实现一个消息队列" class="headerlink" title="实现一个消息队列"></a>实现一个消息队列</h3><p>核心：切片 + 锁</p><h3 id="字符串相加-https-leetcode-cn-com-problems-add-s"><a href="#字符串相加-https-leetcode-cn-com-problems-add-s" class="headerlink" title="[字符串相加](https://leetcode-cn.com/problems/add-s"></a>[字符串相加](<a href="https://leetcode-cn.com/problems/add-s">https://leetcode-cn.com/problems/add-s</a></h3><p>trings&#x2F;)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStrings</span><span class="params">(num1 <span class="type">string</span>, num2 <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">add := <span class="number">0</span></span><br><span class="line">ans := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i, j := <span class="built_in">len</span>(num1) - <span class="number">1</span>, <span class="built_in">len</span>(num2) - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>; i, j = i - <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">x = <span class="type">int</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> j &gt;= <span class="number">0</span> &#123;</span><br><span class="line">y = <span class="type">int</span>(num2[j] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">result := x + y + add</span><br><span class="line">ans = strconv.Itoa(result%<span class="number">10</span>) + ans</span><br><span class="line">add = result / <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求根号2的值"><a href="#求根号2的值" class="headerlink" title="求根号2的值"></a>求根号2的值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找法求近似值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;  </span><br><span class="line">    l, r := <span class="type">float64</span>(<span class="number">0</span>), <span class="type">float64</span>(x)  </span><br><span class="line">    <span class="keyword">for</span> r-l &gt; <span class="number">1e-7</span> &#123;  </span><br><span class="line">        mid := l + (r - l) / <span class="number">2</span>  </span><br><span class="line"><span class="keyword">if</span> mid * mid &lt;= <span class="type">float64</span>(x) &#123;  </span><br><span class="line">            l = mid  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            r = mid  </span><br><span class="line">&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> r  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 牛顿迭代</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">&#125;  </span><br><span class="line">    C, x0 := <span class="type">float64</span>(x), <span class="type">float64</span>(x)  </span><br><span class="line">    <span class="keyword">for</span> &#123;  </span><br><span class="line">        xi := <span class="number">0.5</span> * (x0 + C/x0)  </span><br><span class="line">        <span class="keyword">if</span> math.Abs(x0 - xi) &lt; <span class="number">1e-7</span> &#123;  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">&#125;  </span><br><span class="line">        x0 = xi  </span><br><span class="line">&#125;  </span><br><span class="line">    <span class="keyword">return</span> x0  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> check(root, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(p, q *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &amp;&amp; q == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> || q == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p.Val == q.Val &amp;&amp; check(p.Left, q.Right) &amp;&amp; check(p.Right, q.Left) </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> go </tag>
            
            <tag> 算法 </tag>
            
            <tag> 101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>paxos 论文翻译</title>
      <link href="/research/distribution/paxos-original/"/>
      <url>/research/distribution/paxos-original/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 研究所 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mongodb 面试必备</title>
      <link href="/interview/db/mongodb101/"/>
      <url>/interview/db/mongodb101/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 面试 </tag>
            
            <tag> mongo </tag>
            
            <tag> nosql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql 面试必备</title>
      <link href="/interview/db/mysql101/"/>
      <url>/interview/db/mysql101/</url>
      
        <content type="html"><![CDATA[<h1 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h1><h2 id="ACID-特性"><a href="#ACID-特性" class="headerlink" title="ACID 特性"></a>ACID 特性</h2><ul><li><p>**原子性(Atomicity)**：事务是一个不可分割的单位，因此在一个事务里的所有操作要么全部生效，要么全部不生效。</p></li><li><p>**一致性(Consistency)**：也可以理解为是预期状态的正确性，即从一个正确的状态到另一个正确的状态，这里的状态往往是由业务来定义的。比如转账中的一个扣钱一个加钱，是我们规定的一个数据流转，那么执行前的账户余额和转账后的账户余额就得满足加减特性，这就是所谓的业务正确。题外话：银行家舍入 —— 四舍六入五考虑，五后非零则进一，五后皆零看奇偶，奇进偶舍不连续。</p></li><li><p>**隔离性(Isolation)**：事务并发执行时，各个事务之间相互影响的程度。</p></li><li><p>**持久化(Durability)**：通过日志等手段，只要我们的事务提交成功了，那么就意味着这次的数据操作是成功的。即使下次重启了程序，也不会丢失此处的操作结果。</p></li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul><li><p><strong>未提交读：</strong> 即所谓的脏读，事务读取的数据可能是另一个事务已修改但还没提交的，这部分数据有可能产生回滚。导致后续的操作依赖了无效的数据。<br>修改时加排它锁；读取时加共享锁，读完释放。 eg：select for update</p></li><li><p><strong>已提交读：</strong> 如果想防止脏读，就需要等待其他事务提交后再进行读取操作。</p></li><li><p><strong>可重复读：</strong> 已提交读的隔离级别考虑到了数据回滚的无效性，却无法阻止事务的多次提交。比如事务 A 不断的对表进行修改提交，那么事务 B 就会在不同的时间点读取到不同的数据。为了让事务 B 在执行期间读取的数据都是一致的，就有了可重复读的隔离级别，即事务 B 在执行期间，其他事务不得进行修改操作。</p></li><li><p><strong>可串行化：</strong> 上面的可重复读隔离级别保证了事务执行期间读取的一致性。然而这里并不包括插入、删除操作。即会出现读多读少数据的情况，这种现象叫做幻读。为了解决幻读，只得进行串行化执行事务，才能互不影响。而此时的事务并发性是最低的</p></li></ul><h1 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h1><h2 id="Mysql-的索引分类"><a href="#Mysql-的索引分类" class="headerlink" title="Mysql 的索引分类"></a>Mysql 的索引分类</h2><ul><li><p><strong>从数据结构划分：</strong> B+ 树、hash 索引、全文索引</p></li><li><p><strong>从物理结构划分：</strong> 聚集索引、非聚集索引</p></li><li><p><strong>从逻辑用户划分：</strong> 主键、唯一索引、复合索引、普通单列索引</p></li></ul><h2 id="聚集索引、非聚集索引、主建的区别"><a href="#聚集索引、非聚集索引、主建的区别" class="headerlink" title="聚集索引、非聚集索引、主建的区别"></a>聚集索引、非聚集索引、主建的区别</h2><ul><li><p>聚集索引：在索引的叶子节点直接存 data 数据, 使用的是物理排序，一个表只能有一个字段设置了聚集索引（因为物理排序规则只能有一个），允许有 null 的数据存在，数据也不一定是唯一的。实现方案是B+树</p></li><li><p>主建：唯一标识某行记录，不允许有 null 的数据，要求数据必须唯一。在设置某个字段为主建时，数据库一般会自动在这个主建上建立一个唯一索引，并且如果之前表没有创建过聚集索引，还会在这个主建上建立一个聚集索引。自增Id强制设定为主键索引，这是为了b+tree和分页。这棵树的非叶子结点上存的都是主键，那如果一个表没有主键会怎么样？在innodb中，如果一个表没有主键，那默认会找建了唯一索引的列，如果也没有，则会生成一个隐形的字段作为主键！</p></li><li><p>非聚集索引：索引的叶子节点存的是数据域的记录指针，需要跳转查找。排序规则是逻辑排序，因此可以有多个非聚集索引存在。非聚集索引的存储结构与聚集索引是一样的，不同的是在叶子结点的数据部分存的不再是具体的数据，而数据的聚集索引的key。所以通过非聚集索引查找的过程是先找到该索引key对应的聚集索引的key，然后再拿聚集索引的key到主键索引树上查找对应的数据，这个过程称为<strong>回表</strong>！</p></li></ul><h2 id="有哪些情况会让索引失效？"><a href="#有哪些情况会让索引失效？" class="headerlink" title="有哪些情况会让索引失效？"></a>有哪些情况会让索引失效？</h2><ul><li><p>在 where 字段 上使用了函数或其他隐式转换</p></li><li><p>Like 模糊查询，开头使用了 “%”，例如 like ‘%hello%’</p></li><li><p>where 条件里使用了 or</p></li><li><p>建立了复合索引，但 where 条件里使用的是第二个字段的搜索</p></li></ul><h2 id="最左匹配原则是指？"><a href="#最左匹配原则是指？" class="headerlink" title="最左匹配原则是指？"></a>最左匹配原则是指？</h2><p>mysql 建立联合索引后，是按最左匹配原则来筛选记录的，即检索数据是从联合索引的第一个字段来筛选的。如果 where 里的条件只有第二个字段，那么将无法应用到索引。</p><h2 id="索引的底层数据结构-B-树是怎么样的？"><a href="#索引的底层数据结构-B-树是怎么样的？" class="headerlink" title="索引的底层数据结构 B+ 树是怎么样的？"></a>索引的底层数据结构 B+ 树是怎么样的？</h2><p>B+ 树是二叉搜索树的一个扩充，是多路搜索树。它只在叶子节点存储具体的数据或者数据的指向指针，而非叶子节点存放索引数据。这样可以降低磁盘 IO，还能充分利用磁盘的预读功能，批量的加载索引数据。</p><p><img src="https://static001.geekbang.org/infoq/46/467603fbd92fdada63040ebad9b7f628.png"></p><h2 id="b-树-b-树-b-树的区别"><a href="#b-树-b-树-b-树的区别" class="headerlink" title="b 树 b+树 b-树的区别"></a>b 树 b+树 b-树的区别</h2><ul><li><p>b 树就是 b-树， 国外叫 b-tree, 也就是 b 树。</p></li><li><p>b-tree 是在非叶子节点存放了数据，在查询索引时，只要找到索引值也就可以找到数据了，这样可以提前终止搜索。但每个节点就得存储索引值+数据值，占用的页空间会比较大，需要的磁盘 io 次数也会变多，即使是不需要关心的数据也会被预加载出来，浪费性能。</p></li><li><p>b+树是将索引值存在非叶子节点，数据值存在叶子节点，这样可以压缩树的高度，减少磁盘 io。</p></li></ul><h2 id="为什么不能在重复率高，例如性别字段上建立索引？"><a href="#为什么不能在重复率高，例如性别字段上建立索引？" class="headerlink" title="为什么不能在重复率高，例如性别字段上建立索引？"></a>为什么不能在重复率高，例如<code>性别</code>字段上建立索引？</h2><p>对于性别这种索引， 由于重复率高，对于 B+树(多路搜索树)来讲，得遍历多条路径，搜索代价大。还不如全表扫描，这样不需要维护索引，降低开销。</p><h2 id="Mysql-的-hash-索引是怎么样，有什么优缺点？"><a href="#Mysql-的-hash-索引是怎么样，有什么优缺点？" class="headerlink" title="Mysql 的 hash 索引是怎么样，有什么优缺点？"></a>Mysql 的 hash 索引是怎么样，有什么优缺点？</h2><p>hash 索引将列通过 hash 运算得到 hash code，然后将 hash code 跟数据行的指针地址关联在一起，下次查找时只需查找对应 hash code 的数据行地址即可。</p><p>hash 索引非常的紧凑，查找速度很快，适用于内存存储引擎的应用。不过它只能精确查询，不支持范围查找，也不能直接进行排序。限制还是挺多的。</p><p><img src="https://static001.geekbang.org/infoq/12/12bc94c294080d240a165e97e0a5f75e.png"></p><h2 id="Mysql-的全文索引"><a href="#Mysql-的全文索引" class="headerlink" title="Mysql 的全文索引"></a>Mysql 的全文索引</h2><p>全文索引主要是用于文档查找，像我们可能会从多篇文章中查找包含某些词语的文章，这时就可以使用全文索引了。虽然 like 也可以使用，但是效率太低了。全文索引在接收到文档时，会对它进行分词处理，以获取到关键词。然后会将关键词和属于这个文档的 id 关联起来。下次查找，就会先到关键词列表里找到关联的文档 id ，最后利用文档 id 去查找到文档数据。</p><h1 id="3-日志"><a href="#3-日志" class="headerlink" title="3. 日志"></a>3. 日志</h1><h2 id="日志类别"><a href="#日志类别" class="headerlink" title="日志类别"></a>日志类别</h2><ul><li><p><strong>binlog：</strong> 二进制日志，记录了数据库对数据的修改记录，包括了 DDL：例如表的创建，数据更新等。但并不包括 select 这些查询语句。binlog 日志是属于逻辑语句的记录，可用于主从数据库的同步。</p></li><li><p><strong>relay log：</strong> 中继日志，用于主从备份恢复使用的。有主服务器的 binlog 逻辑操作语句，以及当前的恢复位置。</p></li><li><p><strong>慢查询日志：</strong> 记录在 mysql 里执行时间超过预期值的耗时语句</p></li><li><p><strong>redo log：</strong> redo log 是对加载到内存数据页的修改结果的记录，和 binlog 不同的是，binlog 记录的是逻辑操作语句，偏向于过程记录。而 redo log 是一个数据页的修改日志，偏向于结果的记录。</p></li><li><p><strong>undo log：</strong> 回滚日志主要用于回滚数据，和 redo log 不一样的是，undo log 是逻辑日志，是一种相反操作的记录，比如在回滚时，如果是 insert 操作时，则会逆向为 delete，delete 操作时，逆向为 insert 操作，更新则恢复到当时的版本数据。</p></li></ul><h2 id="redo-log-相关概念：writepos、checkpoint、prepare、commit"><a href="#redo-log-相关概念：writepos、checkpoint、prepare、commit" class="headerlink" title="redo log 相关概念：writepos、checkpoint、prepare、commit"></a>redo log 相关概念：writepos、checkpoint、prepare、commit</h2><p>redo log 是用来记录当前数据页的修改情况，由于性能问题，每次修改并不会实时同步到硬盘。而是先在内存中修改，然后将修改情况记录到 redo 里，再定时的去将 redo 刷新到硬盘里。因此，redo log 有 2 个位置，一个是 writepos，自己写日志的位置；另一个是 checkpoint，是定时的将数据页同步到硬盘的位置。</p><p>redo log 在写 binlog 日志前会先记录 redo log，记录完后标记为 prepare 状态。当 binlog 也写入完成后，才将 redo log 标记为 commit 状态。只有当 redo log 是 commit 状态时，事务才能真正的 commit。这样能防止主从节点根据 binlog 同步有可能事务不一致的情况。</p><h1 id="4-Mysql-里的锁"><a href="#4-Mysql-里的锁" class="headerlink" title="4. Mysql 里的锁"></a>4. Mysql 里的锁</h1><h2 id="Mysql-里的锁有哪些？"><a href="#Mysql-里的锁有哪些？" class="headerlink" title="Mysql 里的锁有哪些？"></a>Mysql 里的锁有哪些？</h2><h3 id="乐观-x2F-悲观锁"><a href="#乐观-x2F-悲观锁" class="headerlink" title="乐观&#x2F;悲观锁"></a>乐观&#x2F;悲观锁</h3><ul><li><p>乐观锁：在读取数据时会假设各个事务互不影响，它们会处理好属于自己的那部分数据。如果在更新数据时，发现有其他事务修改了属于自己的数据，则会回滚之前的一切操作。</p></li><li><p>悲观锁：采取了先获取锁再访问的保守策略，如果已经有其他事务获取了锁，则必须等待锁释放才能继续。</p></li></ul><h3 id="共享-x2F-排它锁"><a href="#共享-x2F-排它锁" class="headerlink" title="共享&#x2F;排它锁"></a>共享&#x2F;排它锁</h3><ul><li><p>共享锁：又称读锁，当前事务在读取时，允许其他事务并发读取，但不允许其他事务上排它锁，必须等自己释放了才能继续。</p></li><li><p>排它锁：又称写锁，在写锁占有时，如果其他事务想上读写锁，则得排队等待。</p></li></ul><h3 id="表锁-x2F-行锁"><a href="#表锁-x2F-行锁" class="headerlink" title="表锁&#x2F;行锁"></a>表锁&#x2F;行锁</h3><ul><li><p>表锁：在操作数据时，直接将整张表锁住，操作粒度很大，很容易让其他事务在等待，但不会产生死锁。</p></li><li><p>行锁：针对的是行记录的并发控制，锁粒度很细，能支持高并发，但是不排除会有死锁情况产生。在 mysql 里行锁依赖索引实现，如果没有索引存在，则会直接进行表锁！</p></li></ul><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><ul><li><p>记录锁：只锁住某一条记录。当对唯一索引(包括主键)进行精确查询时，会使用记录锁。</p></li><li><p>间隙锁：当使用范围查询时，会对符合条件的区间数据上锁。在涉及到普通索引（即不是唯一索引）的查询时，都会使用间隙锁。</p></li><li><p>Next-key 锁：临建锁，可以理解为 记录锁 + 间隙锁。当对唯一索引进行范围查找或对唯一索引进行查找但结果不存在时（可以理解为锁住不存在的记录），会使用临建锁。</p></li></ul><p>上面的间隙锁、临建锁有效的防止了事务幻读情况产生，避免了在查找期间有数据新增或删除。</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>表锁的一种，它仅仅表示一种操作意向。当我们使用粒度比较小的行锁时，在检测是否有锁时，需要一行一行的检查，效率较低。有了意向锁之后，则不需一行一行的排查，只需检测对应的意向锁即可。</p><h2 id="事务里锁的应用是怎么样的？"><a href="#事务里锁的应用是怎么样的？" class="headerlink" title="事务里锁的应用是怎么样的？"></a>事务里锁的应用是怎么样的？</h2><h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>可重复读使用的是 MVCC 快照，所以在读取数据时大多数时候不需要使用锁。</p><p>但使用了 <code>UPDATE</code>, <code>DELETE</code>，或 <code>SELECT with FOR UPDATE（排它锁） 或 FOR SHARE（共享锁）</code>，则会根据下面的情况来使用锁：</p><ul><li><p>在唯一索引上精确查找某条记录时，使用记录锁</p></li><li><p>对于其他的搜索，InnoDB 将会锁定扫描到的索引范围，使用间隙锁或临建锁来<strong>防止幻读</strong>的产生</p></li></ul><h3 id="读提交"><a href="#读提交" class="headerlink" title="读提交"></a>读提交</h3><p>也是使用 MVCC 机制来读取数据，不过在使用 <code>UPDATE</code>, <code>DELETE</code>，或 <code>SELECT with FOR UPDATE（排它锁） 或 FOR SHARE（共享锁）</code>时和上面的机制不一样，当存储引擎将筛选到的记录交给 mysql server 层后，会对不相干的数据进行解锁，所以不会涉及间隙锁或临建锁。它们只会在做外键约束检查和重复键检查时使用到。由于间隙锁的禁用，可能会<strong>出现幻读</strong>现象。</p><h3 id="未提交读"><a href="#未提交读" class="headerlink" title="未提交读"></a>未提交读</h3><p>在 mysql 的 innodb 存储引擎里做 <code>SELECT</code>操作不会做任何锁动作，如果是 myisam 存储引擎，则会上共享锁。如果使用<code>UPDATE</code>, <code>DELETE</code>，或 <code>SELECT with FOR UPDATE（排它锁） 或 FOR SHARE（共享锁）</code>则和读提交一样的原则。</p><h3 id="可序列化读"><a href="#可序列化读" class="headerlink" title="可序列化读"></a>可序列化读</h3><p>可序列化读在使用 select 时，一般会自动的转化为 SELECT … FOR SHARE（共享锁），以保证读写序列化。</p><h2 id="lock-in-share-mode-和-for-update-里间隙锁什么时候会应用？"><a href="#lock-in-share-mode-和-for-update-里间隙锁什么时候会应用？" class="headerlink" title="lock in share mode 和 for update 里间隙锁什么时候会应用？"></a>lock in share mode 和 for update 里间隙锁什么时候会应用？</h2><ul><li><p>lock in share mode, for update 如果 where 条件是非索引类的，则不会加间隙锁；</p></li><li><p>lock in share mode, for update 如果 where 条件是主键类的，并且找不到记录时会加间隙锁；如果找到记录了则会将间隙锁给释放了。比如 where 主键 &#x3D; 3 能找到记录时则不会加间隙锁，找不到时会在该数据的前后叶子节点间加间隙锁；此时假如记录里只有 1，8，9，则会在 1, 8 之间加间隙锁</p></li><li><p>lock in share mode, for update 如果 where 条件是非聚集索引类的，会加间隙锁，即使找不到记录。</p></li></ul><h2 id="锁超时的配置"><a href="#锁超时的配置" class="headerlink" title="锁超时的配置"></a>锁超时的配置</h2><p>当 mysql 获取锁超时时候，如果系统变量 innodb_rollback_on_timeout 为 off ,则当前事务只会回滚最后一条 sql, 所以建议设置 innodb_rollback_on_timeout 为 on, 这样在获取锁超时时可以回滚全部 sql。</p><h1 id="5-MVCC-是指什么？"><a href="#5-MVCC-是指什么？" class="headerlink" title="5. MVCC 是指什么？"></a>5. MVCC 是指什么？</h1><p>MVCC 即<strong>多版本并发控制</strong>，它利用了 undo log 会在数据修改时保留上一个修改记录指针的特点，使得每个事务对数据的修改能有自己的历史版本追溯，就像镜像备份一样。当进行读操作时，如果有其他写操作的事务并发进行，那么此时可以根据事务的隔离级别选择读取最新版本亦或自己之前版本的数据。MVCC 不需要加锁的，它能提高事务的并发处理能力。</p><h1 id="6-mysql-的复制技术"><a href="#6-mysql-的复制技术" class="headerlink" title="6. mysql 的复制技术"></a>6. mysql 的复制技术</h1><ul><li><p>全同步复制：只有等所有的 slave 节点将同步的日志写入 relay log，并且响应 ack 确认后，此次的事务才会提交。数据完整性高，但性能低</p></li><li><p>半同步复制：只要有一个 salve 节点响应 ack 后就可以认为同步成功，但细分为了两种，一种是 <code>AFTER_COMMIT</code>：先在主库提交事务, 然后同步从库, 等待从库的 ack 确认. 才告诉客户端是否 Ok。另一种是 <code>AFTER_SYNC</code>：主库先不提交事务, 只有从库 有 replay log ,回复了 ack 后才进行提交事务。后面一种数据一致性较高</p></li><li><p>异步复制：一旦有需要复制的就通知 slave, 但不会等待确认成功才进行后续操作。</p></li></ul><h1 id="7-存储引擎"><a href="#7-存储引擎" class="headerlink" title="7. 存储引擎"></a>7. 存储引擎</h1><h2 id="Mysql-存储引擎有哪些以及特点？"><a href="#Mysql-存储引擎有哪些以及特点？" class="headerlink" title="Mysql 存储引擎有哪些以及特点？"></a>Mysql 存储引擎有哪些以及特点？</h2><ul><li><p><strong>InnoDB：</strong> 它是 mysql 的默认存储引擎，能够实现 ACID 特性的事务，并且能提交、回滚、恢复数据，能很好的保障用户数据。同时支持了行级锁、聚集索引以及外键约束，是一个完善的存储引擎。</p></li><li><p><strong>MyISAM：</strong> 是 mysql 最开始的存储引擎，占用空间小，能快速存储，但不支持事务，提供了基于表级别的锁粒度，适用于配置或只读功能的应用程序。</p></li><li><p><strong>Memory：</strong> 数据都是存在内存里的，能提供快速访问，不过应该较少人使用，毕竟一旦断电数据也就丢失了。</p></li><li><p><strong>CSV：</strong> 带有逗号分隔值的文本文件，没有索引存在。但是兼容性很好，可以跟其他的程序交换数据。</p></li></ul><h2 id="myisam-存储引擎和-innodb-的区别"><a href="#myisam-存储引擎和-innodb-的区别" class="headerlink" title="myisam 存储引擎和 innodb 的区别"></a>myisam 存储引擎和 innodb 的区别</h2><ul><li><p>innoDB 支持事务，myisam 不支持</p></li><li><p>innoDB 支持行锁，myisam 不支持，只能到表锁</p></li><li><p>innoDB 支持外键，myisam 不支持</p></li><li><p>innoDB 不支持全文索引，myisam 支持</p></li><li><p>innoDB 支持聚集索引 和 非聚集索引；myISAM 只支持非聚集索引，该索引存的是数据域的记录指针，还得跳转查找。</p></li></ul><h1 id="8-Mysql-的三层架构"><a href="#8-Mysql-的三层架构" class="headerlink" title="8. Mysql 的三层架构"></a>8. Mysql 的三层架构</h1><ul><li><p><strong>连接层：</strong> 主要负责连接池、通信协议、认证授权等；</p></li><li><p><strong>SQL 层：</strong> 这一层是 mysql 的大脑，通过一系列组件得到数据操作的最优解。</p></li><li><p><strong>存储层：</strong> 负责数据的存储、检索。</p></li><li><p><img src="https://static001.geekbang.org/infoq/7b/7b8895802bcf0c023f64a3ed741c1e46.pngc_center"></p></li></ul><h1 id="9-执行计划是什么？怎么看？"><a href="#9-执行计划是什么？怎么看？" class="headerlink" title="9. 执行计划是什么？怎么看？"></a>9. 执行计划是什么？怎么看？</h1><p>执行计划是 mysql 根据我们的查询语句进行一系列的分析后得到的优化方案。我们可以通过执行计划来获取执行过程。</p><p>执行计划的获取：</p><p><code>explain select 语句</code>  </p><p><img src="https://static001.geekbang.org/infoq/da/da4a15afe4d3bf624e33a136db3eac93.png"></p><p>涉及的字段含义如下：</p><ul><li><p>id： 该 SELECT 标识符</p></li><li><p>select_type： 该 SELECT 类型</p></li><li><p>table： 输出行的表</p></li><li><p>partitions： 匹配的分区</p></li><li><p>type： 联接类型</p></li><li><p>possible_keys： 可供选择的可能索引</p></li><li><p>key： 实际选择的索引</p></li><li><p>key_len： 所选密钥的长度</p></li><li><p>ref： 与索引比较的列</p></li><li><p>rows： 估计要检查的行数</p></li><li><p>filtered： 按表条件过滤的行百分比</p></li><li><p>Extra： 附加信息</p></li></ul><p>其中，有个 type 字段，它的含义大概如下：</p><ul><li><p>eq_ref： 使用到了 UNIQUE 或 PRIMARY KEY 索引</p></li><li><p>ref： 显示索引的哪一列被使用了</p></li><li><p>ref_or_null： 对 Null 进行了索引优化</p></li><li><p>range： 索引范围检索</p></li><li><p>index： 索引扫描</p></li><li><p>unique_subquery： 使用了 in 子查询，里面涉及了主键字段</p></li><li><p>index_subquery： 使用了 in 子查询，里面涉及了非唯一索引</p></li><li><p>fulltext： 全文索引</p></li><li><p>all： 全表扫描数据</p></li></ul><p>从上面大概就能分析出索引的使用情况了，如果是 all，那就是没有用到索引了。</p><h1 id="10-SQL-注入的现象是？"><a href="#10-SQL-注入的现象是？" class="headerlink" title="10. SQL 注入的现象是？"></a>10. SQL 注入的现象是？</h1><p>在拼接 SQL 语句时，直接使用客户端传递过来的值拼接，如果客户端传来包含 <code>or 1=1</code> 类似的语句，那么就会筛选到非预期的结果，进而达到欺骗服务器的效果。</p><p>解决方案是使用现在数据库提供的预编译（prepare）和查询参数绑定功能，例如使用占位符 <code>?</code>，然后将带有占位符的 SQL 语句交给数据库编译，这样数据库就能知道要执行的是哪些语句，条件值又是哪些，而不会混杂在一起。</p><h1 id="11-UNION-和-UNION-ALL-的区别？"><a href="#11-UNION-和-UNION-ALL-的区别？" class="headerlink" title="11. UNION 和 UNION ALL 的区别？"></a>11. UNION 和 UNION ALL 的区别？</h1><ul><li><p>UNION ALL：将所有的数据联合起来，即使有重复数据</p></li><li><p>UNION：会合并重复数据</p></li></ul><h1 id="12-为什么尽量使用自增-ID，而不是-UUID？"><a href="#12-为什么尽量使用自增-ID，而不是-UUID？" class="headerlink" title="12. 为什么尽量使用自增 ID，而不是 UUID？"></a>12. 为什么尽量使用自增 ID，而不是 UUID？</h1><p>自增 ID 是由有序的，而 UUID 是无序的，如果该字段作为索引，那么就会很容易打破 B+ 树的平衡，进而不断的在进行磁盘数据页的调整，导致性能下降</p><h1 id="13-分库分表有哪些？有什么优缺点？"><a href="#13-分库分表有哪些？有什么优缺点？" class="headerlink" title="13. 分库分表有哪些？有什么优缺点？"></a>13. 分库分表有哪些？有什么优缺点？</h1><ul><li><p>分库：从业务角度进行切分</p></li><li><p>分表：将数据根据一定的规则落在多张表上。比如按时间范围来切分，或者通过对 ID 进行 Hash 来路由到对应的表上。</p></li></ul><p>分库分表后使得数据不再集中到一张表上，但也带来了维护以及其他处理问题。比如原来的事务变为分布式事务；原来的 join 操作将要变为在应用层序做过滤；还有数据的后续迁移、扩容规划等。</p><h1 id="14-内连接、外连接区别"><a href="#14-内连接、外连接区别" class="headerlink" title="14. 内连接、外连接区别"></a>14. 内连接、外连接区别</h1><ul><li><p>内连接：只有符合条件的记录才会出现在结果集里</p></li><li><p>外连接：其结果集中不仅包含符合连接条件的行，还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。</p></li></ul><h1 id="15-常见的数据库优化"><a href="#15-常见的数据库优化" class="headerlink" title="15. 常见的数据库优化"></a>15. 常见的数据库优化</h1><ul><li><p>对经常出现在 where 条件里，并且数据重复率不高的字段建立索引</p></li><li><p>使用 JOIN 来代替子查询；</p></li><li><p>能使用 in 就不使用 or，前者能命中索引，后者会让索引失效</p></li><li><p>避免在 where 字段上计算，例如 where a &#x2F; 3 &#x3D; 1，这样会让索引失效；避免在 where 字段上使用 NULL 值的判断</p></li><li><p>打开慢查询日志配置，有针对性的分析响应缓慢的语句。</p></li></ul><h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="sql的执行顺序"><a href="#sql的执行顺序" class="headerlink" title="sql的执行顺序"></a>sql的执行顺序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from on where group by having select distinct order by limit</span><br></pre></td></tr></table></figure><h3 id="一条SQL更新语句执行顺序"><a href="#一条SQL更新语句执行顺序" class="headerlink" title="一条SQL更新语句执行顺序"></a>一条SQL更新语句执行顺序</h3><p>通过分析器分析，执行和查询语句一样。然后写redo log(是个循环日志文件。写完redo log同步到内存中，适当时机更新到磁盘中) 和 binary log，与redo log 采取二阶段事务提交</p><h3 id="事务隔离级别，怎么选择，为什么"><a href="#事务隔离级别，怎么选择，为什么" class="headerlink" title="事务隔离级别，怎么选择，为什么"></a>事务隔离级别，怎么选择，为什么</h3><h4 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h4><p>会读到未提交的事务，脏读，不可重复读，幻读</p><p>幻读：指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的数据行。</p><h4 id="不可重复读（rc）"><a href="#不可重复读（rc）" class="headerlink" title="不可重复读（rc）"></a>不可重复读（rc）</h4><p>别的事务提交，而能直接读到别的事务提交的结果，和别的事务提交之前的不一样，所以不可重复读</p><h4 id="可重复读-rr"><a href="#可重复读-rr" class="headerlink" title="可重复读(rr)"></a>可重复读(rr)</h4><p>读取是从快照中读取，即使别的事务提交仍读的是旧的</p><h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><p>锁表，别人读的时候，你不能干任何事情</p><h4 id="使用RC为默认隔离级别"><a href="#使用RC为默认隔离级别" class="headerlink" title="使用RC为默认隔离级别"></a>使用RC为默认隔离级别</h4><p>innodb默认为RR隔离级别，是由于历史原因binary log同步的原因，默认使用的是statement记录操作语句（是以commit的顺序为记录）。就会出现主从不一致的情况。</p><ol><li>在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多！</li><li>在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行</li><li>在RC隔离级别下，半一致性读(semi-consistent)特性增加了update操作的并发性！</li></ol><p>在RC级别下，不可重复读问题需要解决么？<br>不用解决，这个问题是可以接受的！毕竟你数据都已经提交了，读出来本身就没有太大问题！Oracle的默认隔离级别就是RC，你们改过Oracle的默认隔离级别么？</p><p>在RC级别下，主从复制用什么binlog格式？<br>OK,在该隔离级别下，用的binlog为row格式，是基于行的复制！Innodb的创始人也是建议binlog使用该格式！</p><h3 id="说说你了解的索引"><a href="#说说你了解的索引" class="headerlink" title="说说你了解的索引"></a>说说你了解的索引</h3><p>聚簇索引，使用的是B+ 树类型。</p><p>主键索引，存放的是value和索引</p><p>其余的只存放索引，需要回表查询。因为叶子节点只存放索引。</p><p>索引类型：</p><ol><li>主键索引</li><li>唯一索引</li><li>普通索引</li><li>联合索引</li></ol><p>explain中的字段</p><ul><li><p>id</p><ul><li>id 相同的情况下，执行顺序由上而下</li><li>如果是子查询，id 越大，越先执行</li><li>小表驱动大表</li></ul></li><li><p>select_type</p><ul><li>simple 简单的查询不包含子查询或者union</li><li>primary 主查询，最后加载</li><li>subquery 子查询</li><li>derived 衍生的临时表</li><li>union<ul><li>若第二个select出现在union之后，则标记为union</li><li>若union包含在from子句的子查询中，则外层select标记为derived</li></ul></li><li>union result 从union表获取结果的select<ul><li>两个union合并的select</li></ul></li></ul></li><li><p>table 哪张表</p></li><li><p>type</p><ul><li>从最好到最差依次<ul><li>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all</li><li>system 只有一条记录的单表，系统表</li><li>const 相当于primary key 或 unique 等于一个数值 where id &#x3D;1</li><li>eq_ref 唯一索引 t1.id&#x3D;t2.id</li><li>ref 普通索引，非唯一值</li><li>range 只检索给定范围的行，使用一个索引来选择行</li><li>index 遍历所有索引</li><li>all 全表扫描，需要优化</li></ul></li></ul></li><li><p>possible_keys，key</p><ul><li>可能用到的索引和实际用到的索引</li><li>覆盖索引不会显示在possible_keys上，只会显示在key中</li></ul></li><li><p>key_len</p><ul><li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</li><li>同样的查询结果，长度越少越好</li></ul></li><li><p>ref</p><ul><li>显示索引的哪一列被使用,如果可能的话，是一个常量，哪些列或常量被用于查找索引列上的值</li><li>const 常量</li><li>test1.t1.id</li></ul></li><li><p>rows</p><ul><li>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数</li><li>理论上影响了多少行</li></ul></li><li><p>extra</p><ul><li>不适合在其他列中显示但是十分重要的额外信息</li><li>using filesort<ul><li>mysql 无法利用索引完成的排序，文件排序</li></ul></li><li>using temporary<ul><li>对查询结果，使用了临时表 order by ,group by</li><li>最好使用覆盖索引，不要产生临时表</li></ul></li><li>using index<ul><li>表示相应的select 操作中使用了覆盖索引</li><li>同时出现using where ，表明索引被用来执行索引键值的查找</li><li>没出现using where，表明索引用来读取数据而非执行查找动作</li></ul></li><li>using where<ul><li>使用了 where</li></ul></li><li>using join buffer<ul><li>join 多，而使用了缓冲区</li></ul></li><li>impossible where<ul><li>where子句的值是false</li></ul></li></ul></li><li><p>两表加索引</p><ul><li>左连接<ul><li>加子表上，主表的数据全部都要，加了索引也没用，子表不一定都要，可以加索引优化</li><li>sql执行的顺序为 from on join 其中 on就是可以用到索引的地方</li></ul></li><li>右连接相反</li><li>join 语句的优化<ul><li>尽可能减少join语句的Nestedloop的循环总次数，永远用小结果集驱动大结果集</li><li>优先优化NestedLoop的内层循环</li><li>保证Join语句中被驱动表上Join条件字段已经被索引</li><li>当无法保证被驱动表的Join条件字段被索引且内存资源充足的前提下，不要太吝啬JoinBuffer的设置</li></ul></li></ul></li><li><p>索引失效的情况：</p><ul><li>全值匹配我最爱</li><li>违背最左前缀原则</li><li>跳过索引中的列</li><li>某列属于联合索引，对该列进行范围查询，值使用部分索引，该列右边的列无法使用索引</li><li>!&#x3D;,is null,is not null</li><li>like以通配符开头<ul><li>解决%like% 索引时不能失效的方法</li><li>使用覆盖索引可以解决</li></ul></li><li>用or连接条件</li><li>不在索引列上做任何操作（计算，函数，自动or手动类型转换，会导致索引失效而转向全表扫描）</li><li>尽量使用覆盖索引</li><li>字符串不加单引号索引失效</li><li>索引列的数据长度能少则少</li><li>索引一定不是越多越好，越全越好，一定是建合适的</li><li>匹配列浅醉可用到索引，like %9999%、ike %9999%用不到索引，like 9999%在列离散度高的时候能用到索引，离散度低的时候用不到</li><li>where条件中not in和&lt;&gt;操作无法使用索引</li><li>匹配范围值，order by也可用到索引</li><li>多用指定列查询，只返回自己想要的数据列，少用select*;</li><li>联合索引中如果不是按照索引最左列开始查找，无法使用索引</li><li>联合索引中精确匹配最左前列并范围匹配另外一列可以用到索引</li><li>联合索引中如果查询中有某个列的范围查询，则其右边所有列都无法使用索引</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 面试 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis面试必备</title>
      <link href="/interview/db/redis101/"/>
      <url>/interview/db/redis101/</url>
      
        <content type="html"><![CDATA[<h2 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><h3 id="1-分布式系统中常用的缓存方案有哪些？"><a href="#1-分布式系统中常用的缓存方案有哪些？" class="headerlink" title="1. 分布式系统中常用的缓存方案有哪些？"></a>1. 分布式系统中常用的缓存方案有哪些？</h3><ul><li>客户端缓存：页面和浏览器缓存，app 缓存，h5 缓存，localStorage，sessionStorage</li><li>CDN：内容存储&#x3D;数据存储，内容分发&#x3D;负载均衡</li><li>Nginx 缓存： 静态资源</li><li>服务端缓存：本地缓存，外部缓存</li><li>数据库缓存：持久缓存（mybatis，hibernate 多级缓存），mysql 查询缓存</li><li>操作系统缓存：page cache，buffer cache</li></ul><h3 id="2-常见的缓存淘汰算法"><a href="#2-常见的缓存淘汰算法" class="headerlink" title="2. 常见的缓存淘汰算法"></a>2. 常见的缓存淘汰算法</h3><ul><li>FIFO - 先进先出</li><li>LRU - 最近最少使用</li><li>LFU - 最不经常使用</li></ul><h3 id="3-Redis-如何配置-Key-的过期时间？他的实现原理是什么？"><a href="#3-Redis-如何配置-Key-的过期时间？他的实现原理是什么？" class="headerlink" title="3. Redis 如何配置 Key 的过期时间？他的实现原理是什么？"></a>3. Redis 如何配置 Key 的过期时间？他的实现原理是什么？</h3><ul><li>Expire or SETNX</li><li>原理：<ul><li>定期删除：每隔一段时间，执行一次删除过期 Key 的操作（批量脚本）</li><li>懒汉式删除：每当使用 get，getset 等指令去获取数据时，判断 key 是否过期，过期的话就先删除再操作</li><li>redis 同时使用两者，平衡执行频率和执行时长</li></ul></li></ul><h3 id="4-Redis-线程模型，单线程为什么快？"><a href="#4-Redis-线程模型，单线程为什么快？" class="headerlink" title="4. Redis 线程模型，单线程为什么快？"></a>4. Redis 线程模型，单线程为什么快？</h3><ul><li>基于 Reactor 开发了网络时间处理器 - 文件事件处理器，采用 IO 多路复用监听多个 Socket</li><li>纯内存操作、核心基于非阻塞的 IO 多路复用机制、单线程避免了多线程反复上下文切换的性能问题</li></ul><h3 id="5-redis-的常见结构及应用场景"><a href="#5-redis-的常见结构及应用场景" class="headerlink" title="5. redis 的常见结构及应用场景"></a>5. redis 的常见结构及应用场景</h3><ul><li>string<ul><li>id&#x2F;id_info 缓存  </li><li>计数器  </li><li>setnx 分布式锁 </li><li>分布式ID </li><li>sds（动态简单字符串）<ul><li>读取时间复杂度为 O(1)</li><li>惰性删除，留待下次使用</li><li>一次分配最大为 128kb</li></ul></li><li></li></ul></li><li>list<ul><li>当队列用，最近100个购买用户信息  </li><li>当栈用  </li><li>非实时分页列表，比如小时榜，日榜，周榜</li><li>存储微博、微信公众号等消息流数据</li><li>等于链表，插入删除 O(1)，查找 O(n)</li></ul></li><li>hash<ul><li>相比string获取单个字段节省 序列化与反序列化操作</li><li>相当于 HashMap ，由数组加链表组合而成，当一维的 hash 数组碰撞时，用链表串起来</li></ul></li><li>set<ul><li>取交、并、差集  </li><li>点赞、收藏、关注等…  </li><li>kv 模式</li></ul></li><li>sorted set<ul><li>排行榜功能，实时分页列表，实时榜单等</li><li>set 基础上增加了分数</li><li>结构上是由一个 dict 和一个跳表组成，dict 保证 key 唯一性</li><li>插入删除都是 O(log n)，查找 O(logn)</li><li>一大优点是可以对分数进行范围查找</li><li>少量数据按照 ziplist 存储，大量数据按照跳表存储</li></ul></li></ul><h4 id="redis-大key-问题是什么？怎么查出来？一般怎么解决？"><a href="#redis-大key-问题是什么？怎么查出来？一般怎么解决？" class="headerlink" title="redis 大key 问题是什么？怎么查出来？一般怎么解决？"></a>redis 大key 问题是什么？怎么查出来？一般怎么解决？</h4><p>大key问题呢是说 redis 的 kv 存储中，value值过大，一般超过10kb，我们就会认为这是一个大 key 了。<br>有执行命令，但是没有专门准备这个内容<br>大 key 的危害主要是：在redis内存中分布不均；操作耗时；取结果的数据量大，容易造成网络io堵塞<br>解决方式呢：可以逻辑上对于大 key 的 value 进行拆分和重组。其中 string 类型的大 key 一般不建议存到redis。另外的可以采用 hash 将大 key 拆分</p><h3 id="6-redis-集群方案"><a href="#6-redis-集群方案" class="headerlink" title="6. redis 集群方案"></a>6. redis 集群方案</h3><ul><li>主从模式</li><li>哨兵模式<ul><li>概念<ul><li>集群监控：监控主从是否正常</li><li>消息通知：故障通知</li><li>故障转移：主挂了，移到从身上</li><li>配置中心：通知 client 新的 master 地址</li></ul></li><li>本身也是分布式的，具体方案：<ul><li>通常3个哨兵实例来保证健壮性</li><li>即使哨兵自己挂了，还是可以正常工作</li><li>不保证数据领丢失，可以说主从结构就不保证</li><li>判断故障需要用<code>分布式选举</code>获得大部分哨兵统一才行</li></ul></li></ul></li><li>Redis cluster：服务端 Sharding 计数。采用槽的概念，一共16384个槽，请求发送至任意节点<ul><li>方案说明<ul><li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽（哈希值）区间的数据</li><li>每份数据分片会存储在多个互为主从的多节点上</li><li>数据先写入主节点，再<code>阻塞</code>同步至从节点</li><li>同一分片之间不保证强一致性</li><li>扩容时需要把旧节点数据也迁移一部分至新节点</li></ul></li><li>gossip 协议，多主多从</li></ul></li></ul><h3 id="7-redis-持久化方案"><a href="#7-redis-持久化方案" class="headerlink" title="7. redis 持久化方案"></a>7. redis 持久化方案</h3><ol><li>RDB：Redis Database<br>指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作是 fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，使用二进制压缩存储。<br>优点：</li></ol><ul><li>整个 redis 只包含一个文件 dump.rdb，方便持久化</li><li>容灾性好，易于备份</li><li>性能最大化，使用子进程处理，保证主进程 IO 吞吐，保证了 redis 的高性能</li><li>相对于数据集大时，比 AOF 的启动效率更高<br>缺点：</li><li>数据安全性低，因为会有间隔时间，所以如果间隔期间出现故障，无法保证期间的数据正常备份</li><li>当数据集较大时，子进程长期占用 CPU，会导致服务中断时间延长至秒级</li></ul><ol start="2"><li>AOF：Append Only File<br>以日志的形式记录服务器处理的每个读写操作，以文本的方式详细记录，可以查看历史操作记录<br>优点：</li></ol><ul><li>数据安全：每秒同步、每修改同步、不同步3中策略。每秒同步可以理解为类似1s间隔的 RDB ，可能也会出现丢失的情况；每修改同步可以认为是同步持久化，不会丢失</li><li>通过 append 方式追加新的操作，不惧宕机，可以使用 redis-check-aof 工具来解决一致性的问题。</li><li>rewrite 模式可以定期对 AOF 文件重写，合并相关操作，以达到压缩存储的目的<br>缺点</li><li>AOF 文件较大，恢复速度慢</li><li>数据集大的情况下，启动比 RDB 慢</li><li>运行效率 AOF &lt; RDB</li></ul><p>4.x版本后，把重写方式变成 RDB 直接放到 AOF 文件的头部，比以前版本更快</p><ol start="3"><li>主从同步</li></ol><ul><li>全量复制：<ul><li>主节点通过 bgsave 命令 fork 子进程进行 rdb 持久化，过程非常消耗CPU，内存，硬盘io</li><li>主节点将rdb文件通过网络发给从节点，消耗带宽</li><li>从节点清空数据，使用rdb文件载入，整个过程阻塞，无法响应命令</li></ul></li><li>部分复制：<ul><li>复制偏移量，双方都要维护</li><li>复制积压缓冲区：定长FIFO的队列作为缓冲区</li></ul></li></ul><h3 id="8-Redis-的过期键的删除策略"><a href="#8-Redis-的过期键的删除策略" class="headerlink" title="8. Redis 的过期键的删除策略"></a>8. Redis 的过期键的删除策略</h3><ol><li>惰性过期：访问一个 key 的时候才判断这个 key 是否已经过期，该策略可以最大化的节省 CPU 资源，但是对内存不友好，会存在大量的过期 key 没有被再次访问，从而不会被清除，占用内存</li><li>定期过期：每隔一定的时间，扫描数据库中一定量的 expire 字典中的 key，并清除其中已经过期的 key。该策略是前两者的一个折中方案，通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使内存和 CPU 达到最优平衡</li><li>二种策略同时生效</li></ol><h3 id="9-描述下缓存穿透、击穿、雪崩，以及解决方案"><a href="#9-描述下缓存穿透、击穿、雪崩，以及解决方案" class="headerlink" title="9. 描述下缓存穿透、击穿、雪崩，以及解决方案"></a>9. 描述下缓存穿透、击穿、雪崩，以及解决方案</h3><p>数据库是架构的瓶颈，要尽量保证有效请求到达数据库，可以酌情放大链路上前置位置的复杂度和成本<br>c client；redis ； db&#x2F;mysql</p><p>穿透：缓存和db中都找不到该数据 &#x3D; db中无数据，redis无数据，大量并发，请求打到db层<br>原因：接口请求数据不是有效参数，因此根本查不到结果；有效参数但是确实没有数据<br>解法：接口层增加鉴权，业务层增加有效请求判断；返回空 &amp;&amp; 增加短效的空缓存；布隆过滤器（难道要加到每个接口上么？需要思考嗷）；业务加互斥锁；对于空值可以增加一个空缓存</p><p>击穿：热点key过期 or key从来没有被访问过 &#x3D; db中有数据，大量并发，redis无缓存，请求打到db层<br>解法：热点数据永不过期；互斥锁（挡住大量重复的并发请求）</p><p>雪崩：N个key的都过期了（没有被缓存到） &#x3D; db中有，大量并发，redis无缓存，请求打到db层<br>解法：缓存数据设置随机过期时间；增加缓存失效标记位；缓存预热；互斥锁</p><p>流程： 请求redis，查不到 –&gt; 大家抢锁 O（1） –&gt; 抢上的查db，并更新缓存 O（1） –&gt; 没抢上的重复请求Redis ，拿到数据<br>延伸问题：多个等待的请求，是blocking的轻量级进程，不参与cpu及内核调度，注意处理线程池即可</p><ul><li>sorted set  <ul><li>实时分页列表，如实时榜单</li></ul></li></ul><ul><li>一般就是当缓存用</li><li>单线程模型</li><li>目的是服务无状态：session，token等；分布式锁</li><li>无锁化？</li></ul><h3 id="2-单线程还是多线程？"><a href="#2-单线程还是多线程？" class="headerlink" title="2. 单线程还是多线程？"></a>2. 单线程还是多线程？</h3><ul><li>工作线程都是单线程：<ul><li>操作是原子的单指令 pipeline</li><li>事务 vs pipeline ：事务执行期间是原子的；执行失败就是失败，其他指令继续执行，没有回滚 –&gt; redis 少使用事务 &amp;&amp; 事务内的指令少 + 快</li></ul></li><li>6.x+版本出现了 io 多线程</li></ul><hr><ul><li>详细理解 io 多线程 ：内核，网络通信（懂了再说）</li><li>单线程，满足 redis 的串行原子；io 多线程以后，把输入&#x2F;输出放到线程中并行，好处是：执行时间快；更好的压榨系统及硬件的资源</li></ul><h3 id="3-redis-存在线程安全的问题么？为什么？"><a href="#3-redis-存在线程安全的问题么？为什么？" class="headerlink" title="3. redis 存在线程安全的问题么？为什么？"></a>3. redis 存在线程安全的问题么？为什么？</h3><ul><li>参考问题2，redis核心是单线程串行，业务使用的时候需要自行保障线程安全</li></ul><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><h3 id="6-缓存如何淘汰的？"><a href="#6-缓存如何淘汰的？" class="headerlink" title="6. 缓存如何淘汰的？"></a>6. 缓存如何淘汰的？</h3><p>内存空间不足<br>淘汰机制<br>lru，lfu，random，ttl<br>全空间<br>设置了过期时间的key的集合中</p><h3 id="7-如何进行缓存预热？"><a href="#7-如何进行缓存预热？" class="headerlink" title="7. 如何进行缓存预热？"></a>7. 如何进行缓存预热？</h3><p>提前加载数据（很难判断哪些是真正的热数据，常常会出现缓存失败的情况）<br>开发逻辑上要应对差集数据造成的 击穿，穿透，雪崩</p><h3 id="8-数据库和缓存不一致如何解决？"><a href="#8-数据库和缓存不一致如何解决？" class="headerlink" title="8. 数据库和缓存不一致如何解决？"></a>8. 数据库和缓存不一致如何解决？</h3><p>恶心点的使用事务，但是意义不大，场景多为读多写极少，仅仅在秀肌肉<br>业务写db，然后redis更新缓存<br>业务写到消息队列中，redis和db同时消费数据，同时更新<br>redis缓存，更倾向于允许稍微的时差<br>总思路是减少db操作</p><h3 id="9-redis-主从不一致如何解决？"><a href="#9-redis-主从不一致如何解决？" class="headerlink" title="9. redis 主从不一致如何解决？"></a>9. redis 主从不一致如何解决？</h3><p>redis 默认弱一致性，主从异步同步<br>分布式锁不能用主从，可以用单实例、分片集群、redlock –&gt; redisson<br>配置中可以配置同步因子，总趋向于强一致性</p><h3 id="10-redis-持久化原理"><a href="#10-redis-持久化原理" class="headerlink" title="10. redis 持久化原理"></a>10. redis 持久化原理</h3><p>当前线程阻塞服务<br>后台异步进程完成持久化</p><h3 id="11-并发超量，redis-崩溃后如何处理？"><a href="#11-并发超量，redis-崩溃后如何处理？" class="headerlink" title="11. 并发超量，redis 崩溃后如何处理？"></a>11. 并发超量，redis 崩溃后如何处理？</h3><p>雪崩击穿穿透处理方案</p><h3 id="12-为啥使用setnx"><a href="#12-为啥使用setnx" class="headerlink" title="12. 为啥使用setnx"></a>12. 为啥使用setnx</h3><p>原子，不存在即创建<br>分布式锁，用 set k v nx ex 不存在，过期时间，避免死锁</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 面试 </tag>
            
            <tag> nosql </tag>
            
            <tag> redis </tag>
            
            <tag> 哨兵 </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> raft </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang Context 详解</title>
      <link href="/golang/concurrency/go-context/"/>
      <url>/golang/concurrency/go-context/</url>
      
        <content type="html"><![CDATA[<h3 id="go-并发控制"><a href="#go-并发控制" class="headerlink" title="go 并发控制"></a>go 并发控制</h3><p>实际生产中，WaitGroup 和 Channel 是常见的 2 种并发控制的方式。<br>如果有一系列任务，需要这些任务全部完成以后才能继续执行，WaitGroup 非常适合于这类场景，例如下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doTask</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">  time.Sleep(time.Duration(n))  </span><br><span class="line">  fmt.Printf(<span class="string">&quot;Task %d Done\n&quot;</span>, n)  </span><br><span class="line">  wg.Done()  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;  </span><br><span class="line">    wg.Add(<span class="number">1</span>)  </span><br><span class="line">    <span class="keyword">go</span> doTask(i + <span class="number">1</span>)  </span><br><span class="line">  &#125;  </span><br><span class="line">  wg.Wait()  </span><br><span class="line">  fmt.Println(<span class="string">&quot;All Task Done&quot;</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Task 3 Done  </span></span><br><span class="line"><span class="comment">// Task 1 Done  </span></span><br><span class="line"><span class="comment">// Task 2 Done  </span></span><br><span class="line"><span class="comment">// All Task Done  </span></span><br></pre></td></tr></table></figure><p><code>wg.Wait()</code> 会等待所有的子任务全部完成，所有子协程结束后，才会执行 <code>wg.Wait()</code> 后面的代码。<br>WaitGroup 只能等待子任务全部完成才能执行下一步，那么如果我们想要在主进程中通知子协程退出呢？这种场景下，可以使用 <code>select + chan</code> 机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stop <span class="keyword">chan</span> <span class="type">bool</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reqTask</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;  </span><br><span class="line">  <span class="keyword">for</span> &#123;  </span><br><span class="line">    <span class="keyword">select</span> &#123;  </span><br><span class="line">      <span class="keyword">case</span> &lt;-stop:  </span><br><span class="line">      fmt.Println(<span class="string">&quot;stop&quot;</span>, name)  </span><br><span class="line">      <span class="keyword">return</span>  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">      fmt.Println(name, <span class="string">&quot;send request&quot;</span>)  </span><br><span class="line">      time.Sleep(<span class="number">1</span> * time.Second)  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  stop = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)  </span><br><span class="line">  <span class="keyword">go</span> reqTask(<span class="string">&quot;worker&quot;</span>)  </span><br><span class="line">  time.Sleep(<span class="number">3</span> * time.Second)  </span><br><span class="line">  stop &lt;- <span class="literal">true</span>  </span><br><span class="line">  time.Sleep(<span class="number">3</span> * time.Second)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// worker send request  </span></span><br><span class="line"><span class="comment">// worker send request  </span></span><br><span class="line"><span class="comment">// worker send request  </span></span><br><span class="line"><span class="comment">// stop worker  </span></span><br></pre></td></tr></table></figure><p>更复杂的场景如何做并发控制呢？Go 语言提供了 Context 标准库可以解决这类场景的问题，Context 的作用和它的名字很像，上下文，即子协程的下上文。Context 有两个主要的功能：</p><ul><li>通知子协程退出（正常退出，超时退出等）；</li><li>传递必要的参数。</li></ul><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p><code>context.WithCancel()</code> 创建可取消的 Context 对象，即可以主动通知子协程退出。</p><h3 id="2-1-控制单个协程"><a href="#2-1-控制单个协程" class="headerlink" title="2.1 控制单个协程"></a><a href="https://geektutu.com/post/quick-go-context.html#2-1-%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AA%E5%8D%8F%E7%A8%8B" title="2.1 控制单个协程"></a>2.1 控制单个协程</h3><p>使用 Context 改写上述的例子，效果与 <code>select+chan</code> 相同。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20  </p><p>func reqTask(ctx context.Context, name string) {<br> for {<br> select {<br> case &lt;-ctx.Done():<br> fmt.Println(“stop”, name)<br> return<br> default:<br> fmt.Println(name, “send request”)<br> time.Sleep(1 * time.Second)<br> }<br> }<br>}  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithCancel(context.Background())<br> go reqTask(ctx, “worker1”)<br> time.Sleep(3 * time.Second)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><ul><li><code>context.Backgroud()</code> 创建根 Context，通常在 main 函数、初始化和测试代码中创建，作为顶层 Context。</li><li><code>context.WithCancel(parent)</code> 创建可取消的子 Context，同时返回函数 <code>cancel</code>。</li><li>在子协程中，使用 select 调用 <code>&lt;-ctx.Done()</code> 判断是否需要退出。</li><li>主协程中，调用 <code>cancel()</code> 函数通知子协程退出。</li></ul><h3 id="2-2-控制多个协程"><a href="#2-2-控制多个协程" class="headerlink" title="2.2 控制多个协程"></a><a href="https://geektutu.com/post/quick-go-context.html#2-2-%E6%8E%A7%E5%88%B6%E5%A4%9A%E4%B8%AA%E5%8D%8F%E7%A8%8B" title="2.2 控制多个协程"></a>2.2 控制多个协程</h3><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithCancel(context.Background())  </p><p> go reqTask(ctx, “worker1”)<br> go reqTask(ctx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><p>为每个子协程传递相同的上下文 <code>ctx</code> 即可，调用 <code>cancel()</code> 函数后该 Context 控制的所有子协程都会退出。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8  </p><p>worker1 send request<br>worker2 send request<br>worker1 send request<br>worker2 send request<br>worker1 send request<br>worker2 send request<br>stop worker1<br>stop worker2  </p><h2 id="3-context-WithValue"><a href="#3-context-WithValue" class="headerlink" title="3 context.WithValue"></a><a href="https://geektutu.com/post/quick-go-context.html#3-context-WithValue" title="3 context.WithValue"></a>3 context.WithValue</h2><p>如果需要往子协程中传递参数，可以使用 <code>context.WithValue()</code>。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27  </p><p>type Options struct{ Interval time.Duration }  </p><p>func reqTask(ctx context.Context, name string) {<br> for {<br> select {<br> case &lt;-ctx.Done():<br> fmt.Println(“stop”, name)<br> return<br> default:<br> fmt.Println(name, “send request”)<br> op :&#x3D; ctx.Value(“options”).(*Options)<br> time.Sleep(op.Interval * time.Second)<br> }<br> }<br>}  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithCancel(context.Background())<br> vCtx :&#x3D; context.WithValue(ctx, “options”, &amp;Options{1})  </p><p> go reqTask(vCtx, “worker1”)<br> go reqTask(vCtx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><ul><li><code>context.WithValue()</code> 创建了一个基于 <code>ctx</code> 的子 Context，并携带了值 <code>options</code>。</li><li>在子协程中，使用 <code>ctx.Value(&quot;options&quot;)</code> 获取到传递的值，读取&#x2F;修改该值。</li></ul><h2 id="4-context-WithTimeout"><a href="#4-context-WithTimeout" class="headerlink" title="4 context.WithTimeout"></a><a href="https://geektutu.com/post/quick-go-context.html#4-context-WithTimeout" title="4 context.WithTimeout"></a>4 context.WithTimeout</h2><p>如果需要控制子协程的执行时间，可以使用 <code>context.WithTimeout</code> 创建具有超时通知机制的 Context 对象。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithTimeout(context.Background(), 2*time.Second)<br> go reqTask(ctx, “worker1”)<br> go reqTask(ctx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> fmt.Println(“before cancel”)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><p><code>WithTimeout()</code>的使用与 <code>WithCancel()</code> 类似，多了一个参数，用于设置超时时间。执行结果如下：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7  </p><p>worker2 send request<br>worker1 send request<br>worker1 send request<br>worker2 send request<br>stop worker2<br>stop worker1<br>before cancel  </p><p>因为超时时间设置为 2s，但是 main 函数中，3s 后才会调用 <code>cancel()</code>，因此，在调用 <code>cancel()</code> 函数前，子协程因为超时已经退出了。</p><h2 id="5-context-WithDeadline"><a href="#5-context-WithDeadline" class="headerlink" title="5 context.WithDeadline"></a><a href="https://geektutu.com/post/quick-go-context.html#5-context-WithDeadline" title="5 context.WithDeadline"></a>5 context.WithDeadline</h2><p>超时退出可以控制子协程的最长执行时间，那 <code>context.WithDeadline()</code> 则可以控制子协程的最迟退出时间。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23  </p><p>func reqTask(ctx context.Context, name string) {<br> for {<br> select {<br> case &lt;-ctx.Done():<br> fmt.Println(“stop”, name, ctx.Err())<br> return<br> default:<br> fmt.Println(name, “send request”)<br> time.Sleep(1 * time.Second)<br> }<br> }<br>}  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithDeadline(context.Background(), time.Now().Add(1*time.Second))<br> go reqTask(ctx, “worker1”)<br> go reqTask(ctx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> fmt.Println(“before cancel”)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><ul><li><code>WithDeadline</code> 用于设置截止时间。在这个例子中，将截止时间设置为1s后，<code>cancel()</code> 函数在 3s 后调用，因此子协程将在调用 <code>cancel()</code> 函数前结束。</li><li>在子协程中，可以通过 <code>ctx.Err()</code> 获取到子协程退出的错误原因。</li></ul><p>运行结果如下：</p><p>1<br>2<br>3<br>4<br>5  </p><p>worker2 send request<br>worker1 send request<br>stop worker2 context deadline exceeded<br>stop worker1 context deadline exceeded<br>before cancel  </p><p>可以看到，子协程 <code>worker1</code> 和 <code>worker2</code> 均是因为截止时间到了而退出。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> go </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang语言面试题 - 基本原理</title>
      <link href="/interview/go/golang101-2/"/>
      <url>/interview/go/golang101-2/</url>
      
        <content type="html"><![CDATA[<h4 id="1-golang-文件初始化的顺序"><a href="#1-golang-文件初始化的顺序" class="headerlink" title="1. golang 文件初始化的顺序"></a>1. golang 文件初始化的顺序</h4><p>init() 函数是 Go 程序初始化的一部分。由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。<br>总结顺序如下：<br><strong>import –&gt; const –&gt; var –&gt; init() &#x2F; init2() –&gt; main()</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  &#123;  </span><br><span class="line"> fmt.Println(<span class="string">&quot;init1:&quot;</span>, a)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  &#123;  </span><br><span class="line"> fmt.Println(<span class="string">&quot;init2:&quot;</span>, a)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>  </span><br><span class="line"><span class="keyword">const</span> b = <span class="number">100</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"> fmt.Println(<span class="string">&quot;main:&quot;</span>, a)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 执行结果  </span></span><br><span class="line"><span class="comment">// init1: 10  </span></span><br><span class="line"><span class="comment">// init2: 10  </span></span><br><span class="line"><span class="comment">// main: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// init2: 10  </span></span><br><span class="line"><span class="comment">// init1: 10  </span></span><br><span class="line"><span class="comment">// main: 10</span></span><br></pre></td></tr></table></figure><h4 id="2-interface-如何比较"><a href="#2-interface-如何比较" class="headerlink" title="2. interface 如何比较"></a>2. interface 如何比较</h4><p>Golang 中， interface 内部包含了两个字段，类型 T 和值 V ，interface 之间可以用 &#x3D;&#x3D; 或 !&#x3D; 进行比较。两个 interface 之间可能包含以下两种情况：</p><ol><li>两个都是 nil （对应的 T 和 V 都为 unset 的状态）</li><li>T 相同，且 V 相同</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;  </span><br><span class="line">  UserName <span class="type">string</span>  <span class="string">`json:user_name`</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> UserFace <span class="keyword">interface</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="comment">// 实际比较的是两个结构体的地址</span></span><br><span class="line">  <span class="keyword">var</span> u1, u2 UserFace = &amp;User&#123;<span class="string">&quot;Tom&quot;</span>&#125;, &amp;User&#123;<span class="string">&quot;Tom&quot;</span>&#125;  </span><br><span class="line">  <span class="comment">// 比较两个结构体</span></span><br><span class="line">  <span class="keyword">var</span> u3, u4 UserFace = User&#123;<span class="string">&quot;Tom&quot;</span>&#125;, User&#123;<span class="string">&quot;Tom&quot;</span>&#125;  </span><br><span class="line">  fmt.Println(u1 == u2) <span class="comment">// false  </span></span><br><span class="line">  fmt.Println(u3 == u4) <span class="comment">// true  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-interface-和-nil"><a href="#3-interface-和-nil" class="headerlink" title="3. interface 和 nil"></a>3. interface 和 nil</h4><p>上边讲了 interface 包含两个字段，那么一个 nil 的空结构体和 nil 是否真的相等呢？可以看下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> p *<span class="type">int</span> = <span class="literal">nil</span>  </span><br><span class="line">  <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = p  </span><br><span class="line">  fmt.Println(i == p) <span class="comment">// true  </span></span><br><span class="line">  fmt.Println(p == <span class="literal">nil</span>) <span class="comment">// true  </span></span><br><span class="line">  fmt.Println(i == <span class="literal">nil</span>) <span class="comment">// false  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 nil 非 interface 的值 p 赋给 i 的时候，i 实际上是 (T&#x3D;*int, V&#x3D;nil)。当二者相比较时，Go 会将 p 先转换成 interface 类型的再去比较，此时二者等价。<br>p 与 nil 是直接比较的值，因此二者也等价。<br>i 与 nil  比较时，会将 nil 转换为接口 (T&#x3D;nil, V&#x3D;nil)，与 i (T&#x3D;*int, V&#x3D;nil) 不相等，因此  i !&#x3D; nil</p><h4 id="4-GC-初步理解"><a href="#4-GC-初步理解" class="headerlink" title="4. GC 初步理解"></a>4. GC 初步理解</h4><h4 id="6-Gin-框架简介"><a href="#6-Gin-框架简介" class="headerlink" title="6. Gin 框架简介"></a>6. Gin 框架简介</h4><h4 id="7-反射的原理"><a href="#7-反射的原理" class="headerlink" title="7. 反射的原理"></a>7. 反射的原理</h4><h4 id="10-oom-？"><a href="#10-oom-？" class="headerlink" title="10. oom ？"></a>10. oom ？</h4><h4 id="11-内存管理方式"><a href="#11-内存管理方式" class="headerlink" title="11. 内存管理方式"></a>11. 内存管理方式</h4><h4 id="13-GRPC-以及-protobuf-协议优化"><a href="#13-GRPC-以及-protobuf-协议优化" class="headerlink" title="13. GRPC 以及 protobuf 协议优化"></a>13. GRPC 以及 protobuf 协议优化</h4><p>gRPC的核心概念包括：</p><p>RPC(Remote Procedure Call，远程过程调用)：gRPC提供了一种简单的RPC机制，允许客户端和服务器之间无缝通信。客户端通过调用本地方法，实际上是在远程服务器上执行方法，并将结果返回给客户端。<br>Protocol Buffers：gRPC使用Protocol Buffers作为数据序列化和传输格式。Protocol Buffers是一种轻量级、高效的数据结构序列化库，可以在多种编程语言之间实现无缝通信。<br>HTTP&#x2F;2：gRPC使用HTTP&#x2F;2作为传输协议，利用HTTP&#x2F;2的多路复用、流控制、压缩等特性，实现低延迟、高吞吐量的通信。</p><p>RPC调用：gRPC的RPC调用过程可以分为以下步骤：</p><p>客户端通过Protocol Buffers序列化请求数据，并使用HTTP&#x2F;2发送请求。<br>服务器接收请求，使用Protocol Buffers反序列化请求数据。<br>服务器执行RPC方法，并将结果序列化为Protocol Buffers格式。<br>服务器使用HTTP&#x2F;2发送响应给客户端。<br>客户端使用Protocol Buffers反序列化响应数据，并处理结果。</p><h4 id="14-golang-压测-pprof，火焰图"><a href="#14-golang-压测-pprof，火焰图" class="headerlink" title="14. golang 压测 pprof，火焰图"></a>14. golang 压测 pprof，火焰图</h4>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang语言面试题 - 常见题</title>
      <link href="/interview/go/golang101-3/"/>
      <url>/interview/go/golang101-3/</url>
      
        <content type="html"><![CDATA[<p>下面会给出网上收集的字节系 Golang 语言常见的面试题，按照热度排序哦</p><h4 id="简述-slice-的底层原理，slice-和数组的区别是什么？"><a href="#简述-slice-的底层原理，slice-和数组的区别是什么？" class="headerlink" title="简述 slice 的底层原理，slice 和数组的区别是什么？"></a>简述 slice 的底层原理，slice 和数组的区别是什么？</h4><p>slice 是数组的引用，额外包括两个字段，长度 len 和容量 cap<br>slice支持扩容，本质上是再申请一块内存，将老数据复制过去，更新引用地址</p><h4 id="简单介绍-GMP-模型以及该模型的优点-困难"><a href="#简单介绍-GMP-模型以及该模型的优点-困难" class="headerlink" title="简单介绍 GMP 模型以及该模型的优点  困难"></a>简单介绍 GMP 模型以及该模型的优点  困难</h4><h4 id="简述-Golang-垃圾回收的机制-中等"><a href="#简述-Golang-垃圾回收的机制-中等" class="headerlink" title="简述 Golang 垃圾回收的机制  中等"></a>简述 Golang 垃圾回收的机制  中等</h4><p>Golang 采用的垃圾回收机制是三色标记法，分为白色（未标记）、灰色（标记中）、黑色（已标记）。<br>回收流程为：<br>    1. STW，从根节点出发，将根节点标记为黑色，将能达到的所有节点标记为灰色，然后将所有能达到的子节点加入队列<br>    2. 并发遍历队列中的节点，标记为黑色，且继续寻找其子节点标记为灰色并加入队列<br>    3. 直到队列中所有可达节点均遍历完毕，那么剩下的白色节点就是不可达的节点，可以回收掉<br>在实际使用过程中，如果在标记过程中，节点指针被用户操作改变，可能会标记失败被错误的清除掉，因此 Go 又引入了写屏障</p><p>一次完整的 GC 分为四个阶段：</p><ul><li>标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)，开启辅助 GC （mutator assist），统计 root 对象的任务数量</li><li>使用三色标记法标记（Marking, 并发）</li><li>标记结束(Mark Termination，需 STW)，关闭写屏障。</li><li>清理(Sweeping, 并发)</li></ul><p>GC 调优</p><ol><li>减少使用string类型中的 ‘+’（此种方式每次拼接都会申请一段新的内存空间），推荐使用 strings.Builder （类似切片的扩容机制）</li><li>小对象复用，尽量减少声明局部变量，小对象可以加入结构体来复用，方便 GC 扫描</li></ol><h4 id="协程与进程，线程的区别是什么？协程有什么优势？"><a href="#协程与进程，线程的区别是什么？协程有什么优势？" class="headerlink" title="协程与进程，线程的区别是什么？协程有什么优势？"></a>协程与进程，线程的区别是什么？协程有什么优势？</h4><p>Goroutines是可以同时运行的函数与方法。Goroutines 可以被认为是轻量级的线程。 与线程相比，创建 Goroutine 的开销很小。 Go应用程序同时运行数千个 Goroutine 是非常常见的做法。</p><ul><li>进程: 进程是具有一定独立功能的程序，进程是系统资源分配和调度的最小单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</li><li>线程: 线程是进程的一个实体,线程是内核态,而且是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</li><li>协程: 协程是一种用户态的轻量级线程，协程的调度完全是由用户来控制的。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</li></ul><h4 id="简述-defer-的执行顺序-中等"><a href="#简述-defer-的执行顺序-中等" class="headerlink" title="简述 defer 的执行顺序  中等"></a>简述 defer 的执行顺序  中等</h4><ol><li>多个 defer 的执行顺序为“后进先出”；</li><li>所有函数在执行 RET 返回指令之前，都会先检查是否存在 defer 语句，若存在则先逆序调用 defer 语句进行收尾工作再退出返回；</li><li>匿名返回值是在 return 执行时被声明，有名返回值则是在函数声明的同时被声明，因此在 defer 语句中只能访问有名返回值，而不能直接访问匿名返回值；</li><li>return 其实应该包含前后两个步骤：第一步是给返回值赋值（若为有名返回值则直接赋值，若为匿名返回值则先声明再赋值）；第二步是调用 RET 返回指令并传入返回值，而 RET 则会检查 defer 是否存在，若存在就先逆序插播 defer 语句，最后 RET 携带返回值退出函数；</li><li>defer 声明时会先确定函数参数，推迟执行的仅仅是函数体</li></ol><h4 id="Golang-有哪些优缺点、错误处理有什么优缺点？"><a href="#Golang-有哪些优缺点、错误处理有什么优缺点？" class="headerlink" title="Golang 有哪些优缺点、错误处理有什么优缺点？"></a>Golang 有哪些优缺点、错误处理有什么优缺点？</h4><p>优点：</p><ol><li>简洁、高效、安全</li><li>并发处理能力强</li><li>静态类型和编译型</li><li>丰富的标准库</li><li>跨平台和可移植性</li><li>强大的性能</li><li>垃圾回收机制<br>劣势:</li><li>泛型编程支持不足</li><li>错误处理方式可能不同</li></ol><p>采用错误返回方式，错误是一种内置类型，可以使用 error 类型来定义。而异常（panic）也可以通过 recover() 函数转换为 error来处理。优点是简单直观，一般与主体程序分离。可能的缺点是，需要在调用链中做好收集和处理，如果漏处理可能会有问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">panic</span> := <span class="built_in">recover</span>(); <span class="built_in">panic</span> != <span class="literal">nil</span> &#123;  </span><br><span class="line">      err = DumpStack(<span class="built_in">panic</span>)  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>两次 GC 周期重叠会引发什么问题，GC 触发机制是什么样的？  简单</p><p>Golang 的协程通信方式有哪些？  中等<br>channel 分为有缓冲和无缓冲，有缓冲的满不能存空不能取，都会阻塞；无缓冲的不存就不能取，阻塞<br>sync.waitgroup 控制协程完成时间，多用于等待一批协程完成<br>context 可以传值 context.withvalue；控制多个协程的生命周期，超时控制，取消信号等</p><p>△ 4次</p><p>简述 Golang 的伪抢占式调度  中等</p><p>△ 4次</p><p>什么是 goroutine 泄漏  简单</p><p>△ 4次</p><p>groutinue 什么时候会被挂起？  简单</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang语言面试题 - 基础语法</title>
      <link href="/interview/go/golang101-1/"/>
      <url>/interview/go/golang101-1/</url>
      
        <content type="html"><![CDATA[<h4 id="1-和-的区别？"><a href="#1-和-的区别？" class="headerlink" title="1.  = 和 := 的区别？"></a>1.  <code>=</code> 和 <code>:=</code> 的区别？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo <span class="type">int</span>  </span><br><span class="line">foo = <span class="number">10</span> </span><br><span class="line"><span class="comment">// 等价于  </span></span><br><span class="line">foo := <span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="2-指针的作用"><a href="#2-指针的作用" class="headerlink" title="2. 指针的作用"></a>2. 指针的作用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x =  <span class="number">5</span>  </span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> = &amp;x  </span><br><span class="line">fmt.Printf(<span class="string">&quot;x = %d&quot;</span>,  *p) <span class="comment">// x 可以用 *p 访问</span></span><br><span class="line"><span class="comment">//  `*` 运算符，也称为解引用运算符，用于访问地址中的值。</span></span><br><span class="line"><span class="comment">//  `＆`运算符，也称为地址运算符，用于返回变量的地址。</span></span><br></pre></td></tr></table></figure><h4 id="3-Go-有异常类型么？"><a href="#3-Go-有异常类型么？" class="headerlink" title="3. Go 有异常类型么？"></a>3. Go 有异常类型么？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go 只有错误类型</span></span><br><span class="line">f, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">  log.Fatal(err)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-协程和线程和进程的区别？"><a href="#4-协程和线程和进程的区别？" class="headerlink" title="4. 协程和线程和进程的区别？"></a>4. 协程和线程和进程的区别？</h4><p>Goroutines是可以同时运行的函数与方法。Goroutines 可以被认为是轻量级的线程。 与线程相比，创建 Goroutine 的开销很小。 Go应用程序同时运行数千个 Goroutine 是非常常见的做法。<br>并发掌握，goroutine和channel声明与使用！</p><h4 id="5-拼接字符串"><a href="#5-拼接字符串" class="headerlink" title="5. 拼接字符串"></a>5. 拼接字符串</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串是只读的，也就意味着每次修改操作都会创建一个新的字符串</span></span><br><span class="line">a := <span class="string">&quot;a&quot;</span></span><br><span class="line">b := <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="keyword">var</span> str1 <span class="type">string</span></span><br><span class="line">str1 += a</span><br><span class="line">str1 += b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用 `strings.Builder`，最小化内存拷贝次数。</span></span><br><span class="line"><span class="keyword">var</span> str strings.Builder  </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;  </span><br><span class="line">  str.WriteString(<span class="string">&quot;a&quot;</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">fmt.Println(str.String())</span><br></pre></td></tr></table></figure><h4 id="6-什么是-rune-类型"><a href="#6-什么是-rune-类型" class="headerlink" title="6. 什么是 rune 类型"></a>6. 什么是 rune 类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Go 语言中，字符串的底层表示是 byte (8 bit) 序列，而非 rune (32 bit) 序列。例如下面的例子中 `语` 和 `言` 使用 UTF-8 编码后各占 3 个 byte，因此 `len(&quot;Go语言&quot;)` 等于 8，当然我们也可以将字符串转换为 rune 序列。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(<span class="string">&quot;Go语言&quot;</span>)) <span class="comment">// 8  </span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>([]<span class="type">rune</span>(<span class="string">&quot;Go语言&quot;</span>))) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h4 id="7-判断-map-结构中是否包含某个-key-的方法"><a href="#7-判断-map-结构中是否包含某个-key-的方法" class="headerlink" title="7. 判断 map 结构中是否包含某个 key 的方法"></a>7. 判断 map 结构中是否包含某个 key 的方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok 为 true 代表有这个 key，且 val 是这个 key 的值</span></span><br><span class="line"><span class="keyword">if</span> val, ok := map_[<span class="string">&quot;key&quot;</span>]; ok &#123;  </span><br><span class="line">  <span class="comment">//do something  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-defer-的执行顺序"><a href="#8-defer-的执行顺序" class="headerlink" title="8. defer 的执行顺序"></a>8. defer 的执行顺序</h4><p>多个 defer 语句，遵从后进先出(Last In First Out，LIFO)的原则，最后声明的 defer 语句，最先得到执行。<br>panic 需要等defer 结束后才会向上传递。出现panic恐慌时候，会先按照defer的后入先出的顺序执行，最后才会执行panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">  i := <span class="number">0</span>  </span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;defer1&quot;</span>)  </span><br><span class="line">  &#125;()  </span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    i += <span class="number">1</span>  </span><br><span class="line">    fmt.Println(<span class="string">&quot;defer2&quot;</span>)  </span><br><span class="line">  &#125;()  </span><br><span class="line">  <span class="keyword">return</span> i  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  fmt.Println(<span class="string">&quot;return&quot;</span>, test())  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// defer2  </span></span><br><span class="line"><span class="comment">// defer1  </span></span><br><span class="line"><span class="comment">// return 0</span></span><br></pre></td></tr></table></figure><p>defer 在 return 语句之后执行，但在函数真正退出之前，defer 可以修改返回值。我们可以注意到前一个例子的返回值并没有被修改（注意：只有被预先定义的返回值才能被 defer 语句修改）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> (i <span class="type">int</span>) &#123;  </span><br><span class="line">  i = <span class="number">0</span>  </span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    i += <span class="number">1</span>  </span><br><span class="line">    fmt.Println(<span class="string">&quot;defer2&quot;</span>)  </span><br><span class="line">  &#125;()  </span><br><span class="line">  <span class="keyword">return</span> i  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  fmt.Println(<span class="string">&quot;return&quot;</span>, test())  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// defer2  </span></span><br><span class="line"><span class="comment">// return 1</span></span><br></pre></td></tr></table></figure><h4 id="9-tag的用法？"><a href="#9-tag的用法？" class="headerlink" title="9. tag的用法？"></a>9. tag的用法？</h4><p>tag 是 struct 结构的注解，不同的框架或者工具可以通过反射获取到某个字段的属性，增加语义<br>例如下方例子定义了 struct 结构字段和 json 结构的映射关系</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;encoding/json&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;  </span><br><span class="line">  Name <span class="type">string</span> <span class="string">`json:&quot;user_name&quot;`</span>  </span><br><span class="line">  Id   <span class="type">string</span> <span class="string">`json:&quot;user_id&quot;`</span>  </span><br><span class="line">  Age  <span class="type">int</span>    <span class="string">`json:&quot;-&quot;`</span>  <span class="comment">// json 忽略</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  buf, _ := json.Marshal(Stu&#123;<span class="string">&quot;Bishop&quot;</span>, <span class="string">&quot;1001&quot;</span>, <span class="number">18</span>&#125;)  </span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, buf)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-Golang-如何判断两个列表（slice）结构等价"><a href="#10-Golang-如何判断两个列表（slice）结构等价" class="headerlink" title="10. Golang 如何判断两个列表（slice）结构等价"></a>10. Golang 如何判断两个列表（slice）结构等价</h4><p>可以使用反射 reflect.DeepEqual(a, b) 来判断，但是此种方法比较影响性能，我们这里还是通过基础遍历的方法来完成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceAEqurlSliceB</span><span class="params">(a, b []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">  <span class="comment">// 等长</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b) &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判空</span></span><br><span class="line">  <span class="keyword">if</span> (a == <span class="literal">nil</span>) != (b == <span class="literal">nil</span>) &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  b = b[:<span class="built_in">len</span>(a)]  </span><br><span class="line">  <span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;  </span><br><span class="line"><span class="keyword">if</span> v != b[i] &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-如何标识枚举值（enums）"><a href="#11-如何标识枚举值（enums）" class="headerlink" title="11. 如何标识枚举值（enums）"></a>11. 如何标识枚举值（enums）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Level <span class="type">int32</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> (  </span><br><span class="line">  Level1 Level = <span class="literal">iota</span>  </span><br><span class="line">  Level2  </span><br><span class="line">  Level3 </span><br><span class="line">  Level4 </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  fmt.Println(Level1, Level2, Level3, Level4) <span class="comment">// 0, 1, 2, 3  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-空-struct-结构的一些用法"><a href="#12-空-struct-结构的一些用法" class="headerlink" title="12. 空 struct{} 结构的一些用法"></a>12. 空 struct{} 结构的一些用法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本体是一个空结构体</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(<span class="keyword">struct</span>&#123;&#125;&#123;&#125;)) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用作占位符使用</span></span><br><span class="line"><span class="keyword">type</span> Set <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  set := <span class="built_in">make</span>(Set)  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, item := <span class="keyword">range</span> []<span class="type">string</span>&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125; &#123;  </span><br><span class="line">set[item] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  fmt.Println(<span class="built_in">len</span>(set)) <span class="comment">// 3  </span></span><br><span class="line">  <span class="keyword">if</span> _, ok := set[<span class="string">&quot;A&quot;</span>]; ok &#123;  </span><br><span class="line">fmt.Println(<span class="string">&quot;A exists&quot;</span>) <span class="comment">// A exists  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用作传递信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    &lt;-ch  </span><br><span class="line">    <span class="comment">// do something  </span></span><br><span class="line">  &#125;()  </span><br><span class="line">  ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  </span><br><span class="line">  <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="13-声明结构体方法"><a href="#13-声明结构体方法" class="headerlink" title="13. 声明结构体方法"></a>13. 声明结构体方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Lamp <span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Lamp)</span></span> On() &#123;  </span><br><span class="line"> <span class="built_in">println</span>(<span class="string">&quot;On&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Lamp)</span></span> Off() &#123;  </span><br><span class="line"> <span class="built_in">println</span>(<span class="string">&quot;Off&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-make-和-new"><a href="#14-make-和-new" class="headerlink" title="14. make 和 new"></a>14. make 和 new</h4><ol><li>make 仅用来分配及初始化类型为 slice、map、chan 的数据。new 可分配任意类型的数据.</li><li>new 分配返回的是指针，即类型 *Type。make 返回引用，即 Type.</li><li>new 分配的空间被清零, make 分配空间后，会进行初始化.<br>一个例子<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i *<span class="type">int</span></span><br><span class="line">i = <span class="built_in">new</span>(<span class="type">int</span>) <span class="comment">// 分配内存地址并返回指向改地址的指针，同时置为类型的0值</span></span><br><span class="line">*i = <span class="number">10</span></span><br><span class="line">fmt.Println(*i) <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="15-代码输出啥相关题"><a href="#15-代码输出啥相关题" class="headerlink" title="15. 代码输出啥相关题"></a>15. 代码输出啥相关题</h4><h5 id="1"><a href="#1" class="headerlink" title="(1)"></a>(1)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">uint</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">uint</span> = <span class="number">2</span></span><br><span class="line">    fmt.Println(a-b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2^32-1 or 2^64-1 根据操作系统位数有不同结果</span></span><br></pre></td></tr></table></figure><p>强类型语言，计算结果也是 uint 类型，1-2 可以转换为 0-1 ，计算机中按照 0 + -1 来计算，-1 通常表示为补码，即所有位数都是1的一个数，即当前系统可表示的最大数</p><h5 id="2"><a href="#2" class="headerlink" title="(2)"></a>(2)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;A: &quot;</span>, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;B: &quot;</span>, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考点：<strong>go执行的随机性和闭包</strong><br>解答：谁也不知道执行后打印的顺序是什么样的，所以只能说是随机数字。但是<code>A:</code>均为输出10，<code>B:</code>从0~9输出(顺序不定)。第一个go func中i是外部for的一个变量，地址不变化。遍历完成后，最终i&#x3D;10。故go func执行时，i的值始终是10。<br>第二个go func中i是函数参数，与外部for中的i完全是两个变量。尾部(i)将发生值拷贝，go func内部指向值拷贝地址。</p><h5 id="3"><a href="#3" class="headerlink" title="(3)"></a>(3)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span></span> ShowA() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;showA&quot;</span>)</span><br><span class="line">    p.ShowB()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span></span> ShowB() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;showB&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">    People</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Teacher)</span></span> ShowB() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;teacher showB&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := Teacher&#123;&#125;</span><br><span class="line">    t.ShowA()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shwoA</span></span><br><span class="line"><span class="comment">// showB</span></span><br></pre></td></tr></table></figure><p>考点：<strong>go的组合继承</strong><br>解答：这是Golang的组合模式，可以实现OOP的继承。被组合的类型People所包含的方法虽然升级成了外部类型Teacher这个组合类型的方法（一定要是匿名字段），但它们的方法(ShowA())调用时接受者并没有发生变化。此时People类型并不知道自己会被什么类型组合，当然也就无法调用方法时去使用未知的组合者Teacher类型的功能。</p><h5 id="4"><a href="#4" class="headerlink" title="(4)"></a>(4)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    int_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">    string_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">    int_chan &lt;- <span class="number">1</span></span><br><span class="line">    string_chan &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> value := &lt;-int_chan:</span><br><span class="line">        fmt.Println(value)</span><br><span class="line">    <span class="keyword">case</span> value := &lt;-string_chan:</span><br><span class="line">        <span class="built_in">panic</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考点：<strong>select随机性</strong><br>解答： select会随机选择一个可用通用做收发操作。所以代码是有肯触发异常，也有可能不会。单个chan如果无缓冲时，将会阻塞。但结合 select可以在多个chan间等待执行。有三点原则： </p><ul><li>select 中只要有一个case能return，则立刻执行。 </li><li>当如果同一时间有多个case均能return则伪随机方式抽取任意一个执行。</li><li>如果没有一个case能return则可以执行”default”块。<h5 id="5"><a href="#5" class="headerlink" title="(5)"></a>(5)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)  </span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  </span><br><span class="line">    fmt.Println(s) <span class="comment">// [0,0,0,0,0,1,2,3] </span></span><br><span class="line">  </span><br><span class="line">    s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)  </span><br><span class="line">    s2 = <span class="built_in">append</span>(s2, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  </span><br><span class="line">    fmt.Println(s2)  <span class="comment">// [1,2,3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意 make 会给定义的长度分配初值<h5 id="6"><a href="#6" class="headerlink" title="(6)"></a>(6)</h5>map线程安全</li></ul><h4 id="16-如何理解go语言中的interface"><a href="#16-如何理解go语言中的interface" class="headerlink" title="16. 如何理解go语言中的interface?"></a>16. 如何理解go语言中的interface?</h4><ol><li>interface是方法申明的集合</li><li>任何类型的对象实现了在interface接口中声明的全部方法，则表明该类型实现了该接口</li><li>interface可以作为一种数据类型，实现了该接口的任何对象都可以给对应的接口类型变量赋值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义一个数据写入器</span></span><br><span class="line"><span class="keyword">type</span> DataWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">WriteData(data <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义文件结构，用于实现DataWriter</span></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现DataWriter接口的WriteData方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *file)</span></span> WriteData(data <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// 模拟写入数据</span></span><br><span class="line">fmt.Println(<span class="string">&quot;WriteData:&quot;</span>, data)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口可以作为数据类型传递，体现2，3</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cprint</span><span class="params">(writer DataWriter)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Cprint&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 实例化file</span></span><br><span class="line">f := <span class="built_in">new</span>(file)</span><br><span class="line"><span class="comment">// 声明一个DataWriter的接口</span></span><br><span class="line"><span class="keyword">var</span> writer DataWriter</span><br><span class="line"><span class="comment">// 将接口赋值f，也就是*file类型</span></span><br><span class="line">writer = f</span><br><span class="line"><span class="comment">// 使用DataWriter接口进行数据写入</span></span><br><span class="line">err := writer.WriteData(<span class="string">&quot;data&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;writeData err!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">Cprint(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="17-Go-语言是如何实现切片扩容的？"><a href="#17-Go-语言是如何实现切片扩容的？" class="headerlink" title="17. Go 语言是如何实现切片扩容的？"></a>17. Go 语言是如何实现切片扩容的？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  arr := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>) </span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++ &#123; </span><br><span class="line">    fmt.Println(<span class="string">&quot;len为&quot;</span>, <span class="built_in">len</span>(arr), <span class="string">&quot;cap为&quot;</span>, <span class="built_in">cap</span>(arr)) </span><br><span class="line">    arr = <span class="built_in">append</span>(arr, i) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看下结果<br>依次是 0,1,2,4,8,16,32,64,128,256,512,1024<br>但到了1024之后,就变成了 1024,1280,1696,2304<br>每次都是扩容了四分之一左右</p><h4 id="18-数组和切片"><a href="#18-数组和切片" class="headerlink" title="18. 数组和切片"></a>18. 数组和切片</h4><p>golang 中存在两种函数传入方式：值类型和引用类型<br>值类型只改变当前作用域的值，在该作用域外部不会生效；引用类型改变当前地址对应的值，在作用域外部生效。可以参考下边的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组 值类型</span></span><br><span class="line"><span class="comment">// 切片 引用类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeArray</span><span class="params">(x [3]<span class="type">int</span>)</span></span> &#123;x[<span class="number">0</span>] = <span class="number">123</span>&#125; <span class="comment">// 定义为数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(x []<span class="type">int</span>)</span></span> &#123;x[<span class="number">0</span>] = <span class="number">123</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  x1 := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;x1 original-&gt;&quot;</span>, x1)</span><br><span class="line">  changeArray(x)</span><br><span class="line">  fmt.Println(<span class="string">&quot;x1 current-&gt;&quot;</span>. x1)</span><br><span class="line"></span><br><span class="line">  x := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;x2 -&gt;&quot;</span>, x)</span><br><span class="line">  changeSlice(x)</span><br><span class="line">  fmt.Println(<span class="string">&quot;x2 -&gt;&quot;</span>. x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x1 -&gt; [1,2,3]</span></span><br><span class="line"><span class="comment">// x2 -&gt; [1,2,3]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="19-go-通过切片模拟栈和队列"><a href="#19-go-通过切片模拟栈和队列" class="headerlink" title="19. go 通过切片模拟栈和队列"></a>19. go 通过切片模拟栈和队列</h4><p>栈</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建栈</span></span><br><span class="line">stack:=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">// push压入</span></span><br><span class="line">stack=<span class="built_in">append</span>(stack,<span class="number">10</span>)</span><br><span class="line"><span class="comment">// pop弹出</span></span><br><span class="line">v:=stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">stack=stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"><span class="comment">// 检查栈空</span></span><br><span class="line"><span class="built_in">len</span>(stack)==<span class="number">0</span></span><br></pre></td></tr></table></figure><p>队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建队列</span></span><br><span class="line">queue:=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">// enqueue入队</span></span><br><span class="line">queue=<span class="built_in">append</span>(queue,<span class="number">10</span>)</span><br><span class="line"><span class="comment">// dequeue出队</span></span><br><span class="line">v:=queue[<span class="number">0</span>]</span><br><span class="line">queue=queue[<span class="number">1</span>:]</span><br><span class="line"><span class="comment">// 长度0为空</span></span><br><span class="line"><span class="built_in">len</span>(queue)==<span class="number">0</span></span><br></pre></td></tr></table></figure><p>注意点</p><ul><li>参数传递，只能修改，不能新增或者删除原始数据</li><li>默认 s&#x3D;s[0:len(s)]，取下限不取上限，数学表示为：[</li></ul><h4 id="20-字典"><a href="#20-字典" class="headerlink" title="20.字典"></a>20.字典</h4><p>基本用法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line">m:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">// 设置kv</span></span><br><span class="line">m[<span class="string">&quot;hello&quot;</span>]=<span class="number">1</span></span><br><span class="line"><span class="comment">// 删除k</span></span><br><span class="line"><span class="built_in">delete</span>(m,<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> k,v:=<span class="keyword">range</span> m&#123;</span><br><span class="line">    <span class="built_in">println</span>(k,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点</p><ul><li>map 键需要可比较，不能为 slice、map、function</li><li>map 值都有默认值，可以直接操作默认值，如：m[age]++ 值由 0 变为 1</li><li>比较两个 map 需要遍历，其中的 kv 是否相同，因为有默认值关系，所以需要检查 val 和 ok 两个值</li></ul><h4 id="21-标准库"><a href="#21-标准库" class="headerlink" title="21.标准库"></a>21.标准库</h4><p>sort</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int排序</span></span><br><span class="line">sort.Ints([]<span class="type">int</span>&#123;&#125;)</span><br><span class="line"><span class="comment">// 字符串排序</span></span><br><span class="line">sort.Strings([]<span class="type">string</span>&#123;&#125;)</span><br><span class="line"><span class="comment">// 自定义排序</span></span><br><span class="line">sort.Slice(s,<span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="type">int</span>)</span></span><span class="type">bool</span>&#123;<span class="keyword">return</span> s[i]&lt;s[j]&#125;)</span><br></pre></td></tr></table></figure><p>math</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int32 最大最小值</span></span><br><span class="line">math.MaxInt32 <span class="comment">// 实际值：1&lt;&lt;31-1</span></span><br><span class="line">math.MinInt32 <span class="comment">// 实际值：-1&lt;&lt;31</span></span><br><span class="line"><span class="comment">// int64 最大最小值（int默认是int64）</span></span><br><span class="line">math.MaxInt64</span><br><span class="line">math.MinInt64</span><br></pre></td></tr></table></figure><p>copy</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除a[i]，可以用 copy 将i+1到末尾的值覆盖到i,然后末尾-1</span></span><br><span class="line"><span class="built_in">copy</span>(a[i:],a[i+<span class="number">1</span>:])</span><br><span class="line">a=a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// make创建长度，则通过索引赋值</span></span><br><span class="line">a:=<span class="built_in">make</span>([]<span class="type">int</span>,n)</span><br><span class="line">a[n]=x</span><br><span class="line"><span class="comment">// make长度为0，则通过append()赋值</span></span><br><span class="line">a:=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">a=<span class="built_in">append</span>(a,x)</span><br></pre></td></tr></table></figure><h4 id="22-常用技巧"><a href="#22-常用技巧" class="headerlink" title="22.常用技巧"></a>22.常用技巧</h4><p>类型转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// byte转数字</span></span><br><span class="line">s=<span class="string">&quot;12345&quot;</span>  <span class="comment">// s[0] 类型是byte</span></span><br><span class="line">num:=<span class="type">int</span>(s[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line">str:=<span class="type">string</span>(s[<span class="number">0</span>]) <span class="comment">// &quot;1&quot;</span></span><br><span class="line">b:=<span class="type">byte</span>(num+<span class="string">&#x27;0&#x27;</span>) <span class="comment">// &#x27;1&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d%s%c\n&quot;</span>, num, str, b) <span class="comment">// 111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转数字</span></span><br><span class="line">num,_:=strconv.Atoi()</span><br><span class="line">str:=strconv.Itoa()</span><br></pre></td></tr></table></figure><p>读取标准输入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>断言</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> f, ok := w.(*os.File); ok &#123;</span><br><span class="line">    <span class="comment">// ...use f...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥锁常用语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mu      sync.Mutex <span class="comment">// guards balance</span></span><br><span class="line">    balance <span class="type">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    balance = balance + amount</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    b := balance</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读写锁 “多读单写”锁（multiple readers, single writer lock）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line"><span class="keyword">var</span> balance <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mu.RLock() <span class="comment">// readers lock</span></span><br><span class="line">    <span class="keyword">defer</span> mu.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync.Once 惰性初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br><span class="line"><span class="comment">// Concurrency-safe.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line">    loadIconsOnce.Do(loadIcons)</span><br><span class="line">    <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo建站（三）GitHub</title>
      <link href="/blog/build-blog/hexo101-3/"/>
      <url>/blog/build-blog/hexo101-3/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到建站记录的第二部分：部署到 github page</p><h2 id="GitHub页面"><a href="#GitHub页面" class="headerlink" title="GitHub页面"></a>GitHub页面</h2><p>这里假设已经注册过了Github帐户，如果没有，可以去<a href="https://github.com/">Github</a>注册。</p><p>注册好了后，登录Github,创建仓库：点击右上角的+号，选择new repository:<br><img src="https://t2.picb.cc/2022/02/21/fpUdSF.jpg" alt="git"></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo建站（二）butterfly</title>
      <link href="/blog/build-blog/hexo101-2/"/>
      <url>/blog/build-blog/hexo101-2/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到建站记录的第二部分：butterfly 主题的安装与初始化</p><h2 id="主题安装与使用"><a href="#主题安装与使用" class="headerlink" title="主题安装与使用"></a>主题安装与使用</h2><p>下载主题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">git <span class="built_in">clone</span> -b master https://gitee.com/immyw/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>修改站点配置文件 _config.yml ,把主题修改为 Butterfly</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">Butterfly</span></span><br></pre></td></tr></table></figure><p>为了后续方便配置，需要在当前目录 blog&#x2F; 创建 _config.butterfly.yml 文件，并将根目录下的 _config.yml 文件内容复制进去。更多的主题配置信息可以等待之后的文章~</p><p>尝试执行以下指令,以查看应用主题后的效果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">#清除旧的内容</span></span><br><span class="line">hexo g <span class="comment">#生成发布用的静态页面</span></span><br></pre></td></tr></table></figure><p>本地查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s <span class="comment"># hexo server</span></span><br></pre></td></tr></table></figure><p>执行完该命令可以去 <a href="localhost:4000">localhost:4000</a> 查看效果</p><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><h4 id="case1-："><a href="#case1-：" class="headerlink" title="case1 ："></a>case1 ：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ERROR TypeError: /data/blog/themes/butterfly/layout/includes/head.pug:40  </span><br><span class="line">38|  </span><br><span class="line">39| !=favicon_tag(theme.favicon || config.favicon)</span><br><span class="line"></span><br><span class="line">&gt; 40| <span class="built_in">link</span>(rel=<span class="string">&quot;canonical&quot;</span> href=urlNoIndex())  </span><br><span class="line">&gt; 41|  </span><br><span class="line">&gt; 42| //- 預解析  </span><br><span class="line">&gt; 43| !=partial(<span class="string">&#x27;includes/head/preconnect&#x27;</span>, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span><br><span class="line"></span><br><span class="line">prettyUrls is not a <span class="keyword">function</span>  </span><br><span class="line">at Object. (/data/blog/themes/butterfly/scripts/helpers/page.js:58:10)  </span><br><span class="line">at <span class="built_in">eval</span> (<span class="built_in">eval</span> at wrap (/data/blog/node_modules/pug-runtime/wrap.js:6:10), :89:77)  </span><br><span class="line">at template (<span class="built_in">eval</span> at wrap (/data/blog/node_modules/pug-runtime/wrap.js:6:10), :4603:215)  </span><br><span class="line">at _View._compiled (/data/blog/node_modules/hexo/lib/theme/view.js:136:50)  </span><br><span class="line">at _View.render (/data/blog/node_modules/hexo/lib/theme/view.js:39:17)  </span><br><span class="line">at /data/blog/node_modules/hexo/lib/hexo/index.js:64:21  </span><br><span class="line">at tryCatcher (/data/blog/node_modules/bluebird/js/release/util.js:16:23)  </span><br><span class="line">at /data/blog/node_modules/bluebird/js/release/method.js:15:34  </span><br><span class="line">at RouteStream._read (/data/blog/node_modules/hexo/lib/hexo/router.js:47:5)  </span><br><span class="line">at RouteStream.Readable.read (_stream_readable.js:479:10)  </span><br><span class="line">at resume_ (_stream_readable.js:966:12)  </span><br><span class="line">at processTicksAndRejections (internal/process/task_queues.js:80:21) &#123;  </span><br><span class="line">path: <span class="string">&#x27;/data/blog/themes/butterfly/layout/includes/head.pug&#x27;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>解决方案</p><ol><li>优先确认 themes&#x2F;butterfly 中有相关的文件内容</li><li>尝试执行如下命令： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br><span class="line"><span class="built_in">rm</span> -rf node_modules</span><br><span class="line"><span class="built_in">rm</span> -rf package-lock.json</span><br><span class="line">npm install</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure></li></ol><h4 id="case2："><a href="#case2：" class="headerlink" title="case2："></a>case2：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TypeError: /Users/blog/themes/butterfly/layout/includes/widget/index.pug:33</span><br><span class="line">    31|       !=partial(<span class="string">&#x27;includes/widget/card_tags&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line">    32|       !=partial(<span class="string">&#x27;includes/widget/card_archives&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line">  &gt; 33|       !=partial(<span class="string">&#x27;includes/widget/card_webinfo&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line">    34|       !=partial(<span class="string">&#x27;includes/widget/card_bottom_self&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line">/Users/blog/themes/butterfly/layout/includes/widget/card_webinfo.pug:18</span><br><span class="line">    16|         .webinfo-item</span><br><span class="line">    17|           .item-name=_p(<span class="string">&#x27;aside.card_webinfo.site_wordcount&#x27;</span>) + <span class="string">&quot; :&quot;</span></span><br><span class="line">  &gt; 18|           .item-count=totalcount(site)</span><br><span class="line">    19|       <span class="keyword">if</span> theme.busuanzi.site_uv</span><br><span class="line">    20|         .webinfo-item</span><br><span class="line">    21|           .item-name= _p(<span class="string">&#x27;aside.card_webinfo.site_uv_name&#x27;</span>) + <span class="string">&quot; :&quot;</span></span><br><span class="line"></span><br><span class="line">totalcount is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p>请检查是否安裝了wordcount插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><h4 id="case3："><a href="#case3：" class="headerlink" title="case3："></a>case3：</h4><p>如果你沒有 pug 以及 stylus 的渲染器会报错</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extends includes/layout.pug block content include ./includes/mixins/post-ui</span><br><span class="line">.pug <span class="comment">#recent-posts.recent-posts +postUI include includes/pagination.pug</span></span><br></pre></td></tr></table></figure><p>解决方案</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h4 id="case4："><a href="#case4：" class="headerlink" title="case4："></a>case4：</h4><p>hexo本地测试运行重启后页面空白，且提示 : </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN No layout: index.html</span><br></pre></td></tr></table></figure><p>可以参考 case1 &amp; case2 ，即 hexo generate 没有成功</p><h4 id="case5："><a href="#case5：" class="headerlink" title="case5："></a>case5：</h4><p>尝试 hexo deploy 发布的时候失败，显示如下，没有反应</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INFO  Validating config</span><br><span class="line">INFO</span><br><span class="line">  ===================================================================</span><br><span class="line"></span><br><span class="line">      <span class="comment">#####  #    # ##### ##### ###### #####  ###### #      #   #</span></span><br><span class="line">      <span class="comment">#    # #    #   #     #   #      #    # #      #       # #</span></span><br><span class="line">      <span class="comment">#####  #    #   #     #   #####  #    # #####  #        #</span></span><br><span class="line">      <span class="comment">#    # #    #   #     #   #      #####  #      #        #</span></span><br><span class="line">      <span class="comment">#    # #    #   #     #   #      #   #  #      #        #</span></span><br><span class="line">      <span class="comment">#####   ####    #     #   ###### #    # #      ######   #</span></span><br><span class="line"></span><br><span class="line">                            4.1.0</span><br><span class="line">  ===================================================================</span><br></pre></td></tr></table></figure><p>解决方案：deploy 参数需要配置到 _config.yml 文件中。<br><strong>注意：冒号后面需要一个空格</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repo:</span> <span class="string">git@github.com:yourname/yourname.github.io.git</span></span><br><span class="line"><span class="comment"># 推荐使用Git链接，使用http模式还会存在需要填写 用户名和邮箱的情况</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>更多问题请参考 <a href="https://butterfly.js.org/posts/98d20436/">butterfly</a> 官方文档中的解答</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo建站（一）hexo</title>
      <link href="/blog/build-blog/hexo101-1/"/>
      <url>/blog/build-blog/hexo101-1/</url>
      
        <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>终于俺也有自己的 blog 了，下面就整个 hexo 建站和主题 butterfly 的配置分几个部分给大家做个小小的总结</p><p>欢迎来到建站记录的第一部分：hexo 的安装</p><h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><p>官网地址：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p><h4 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h4><p>1.node<br>    首先去 <a href="http://nodejs.cn/download/">node.js</a> 的官网下载最新的稳定版本，我这里选择的是 mac 版本的<br>2.npm<br>    包管理工具</p><h4 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo</span><br></pre></td></tr></table></figure><p>记得这里需要使用管理员权限安装</p><p>初始化 hexo 至某个文件夹</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>这个文件夹就是自己将来管理文章的地方</p><p>工程配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>进入刚才初始化的 blog 文件夹</p><p>浏览器调试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generage</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>也可以如下简写</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>必备插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save <span class="comment"># hexo 渲染必备</span></span><br><span class="line">npm install hexo-server --save <span class="comment"># hexo 本地启动</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install --save hexo-wordcount <span class="comment"># wordcount 插件</span></span><br><span class="line">npm install hexo-butterfly-artitalk --save <span class="comment"># artitalk 插件</span></span><br><span class="line">npm install hexo-generator-feed --save <span class="comment"># RSS 插件</span></span><br><span class="line">npm install hexo-auto-category --save <span class="comment"># 自动根据目录生成categories</span></span><br></pre></td></tr></table></figure><p>自动生成 categories 详情和配置方法具体可以参考 <a href="https://github.com/xu-song/hexo-auto-category">auto-category</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/uncategorized/hello-world/"/>
      <url>/uncategorized/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
