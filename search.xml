<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Golang并发编程</title>
      <link href="/golang/concurrency/go-sync/"/>
      <url>/golang/concurrency/go-sync/</url>
      
        <content type="html"><![CDATA[<h3 id="go-并发控制"><a href="#go-并发控制" class="headerlink" title="go 并发控制"></a>go 并发控制</h3><p>实际生产中，WaitGroup 和 Channel 是常见的 2 种并发控制的方式。<br>如果有一系列任务，需要这些任务全部完成以后才能继续执行，WaitGroup 非常适合于这类场景，例如下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doTask</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">  time.Sleep(time.Duration(n))  </span><br><span class="line">  fmt.Printf(<span class="string">&quot;Task %d Done\n&quot;</span>, n)  </span><br><span class="line">  wg.Done()  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;  </span><br><span class="line">    wg.Add(<span class="number">1</span>)  </span><br><span class="line">    <span class="keyword">go</span> doTask(i + <span class="number">1</span>)  </span><br><span class="line">  &#125;  </span><br><span class="line">  wg.Wait()  </span><br><span class="line">  fmt.Println(<span class="string">&quot;All Task Done&quot;</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Task 3 Done  </span></span><br><span class="line"><span class="comment">// Task 1 Done  </span></span><br><span class="line"><span class="comment">// Task 2 Done  </span></span><br><span class="line"><span class="comment">// All Task Done  </span></span><br></pre></td></tr></table></figure><p><code>wg.Wait()</code> 会等待所有的子任务全部完成，所有子协程结束后，才会执行 <code>wg.Wait()</code> 后面的代码。<br>WaitGroup 只能等待子任务全部完成才能执行下一步，那么如果我们想要在主进程中通知子协程退出呢？这种场景下，可以使用 <code>select + chan</code> 机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stop <span class="keyword">chan</span> <span class="type">bool</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reqTask</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;  </span><br><span class="line">  <span class="keyword">for</span> &#123;  </span><br><span class="line">    <span class="keyword">select</span> &#123;  </span><br><span class="line">      <span class="keyword">case</span> &lt;-stop:  </span><br><span class="line">      fmt.Println(<span class="string">&quot;stop&quot;</span>, name)  </span><br><span class="line">      <span class="keyword">return</span>  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">      fmt.Println(name, <span class="string">&quot;send request&quot;</span>)  </span><br><span class="line">      time.Sleep(<span class="number">1</span> * time.Second)  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  stop = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)  </span><br><span class="line">  <span class="keyword">go</span> reqTask(<span class="string">&quot;worker&quot;</span>)  </span><br><span class="line">  time.Sleep(<span class="number">3</span> * time.Second)  </span><br><span class="line">  stop &lt;- <span class="literal">true</span>  </span><br><span class="line">  time.Sleep(<span class="number">3</span> * time.Second)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// worker send request  </span></span><br><span class="line"><span class="comment">// worker send request  </span></span><br><span class="line"><span class="comment">// worker send request  </span></span><br><span class="line"><span class="comment">// stop worker  </span></span><br></pre></td></tr></table></figure><p>更复杂的场景如何做并发控制呢？Go 语言提供了 Context 标准库可以解决这类场景的问题，Context 的作用和它的名字很像，上下文，即子协程的下上文。Context 有两个主要的功能：</p><ul><li>通知子协程退出（正常退出，超时退出等）；</li><li>传递必要的参数。</li></ul><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p><code>context.WithCancel()</code> 创建可取消的 Context 对象，即可以主动通知子协程退出。</p><h3 id="2-1-控制单个协程"><a href="#2-1-控制单个协程" class="headerlink" title="2.1 控制单个协程"></a><a href="https://geektutu.com/post/quick-go-context.html#2-1-%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AA%E5%8D%8F%E7%A8%8B" title="2.1 控制单个协程"></a>2.1 控制单个协程</h3><p>使用 Context 改写上述的例子，效果与 <code>select+chan</code> 相同。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20  </p><p>func reqTask(ctx context.Context, name string) {<br> for {<br> select {<br> case &lt;-ctx.Done():<br> fmt.Println(“stop”, name)<br> return<br> default:<br> fmt.Println(name, “send request”)<br> time.Sleep(1 * time.Second)<br> }<br> }<br>}  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithCancel(context.Background())<br> go reqTask(ctx, “worker1”)<br> time.Sleep(3 * time.Second)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><ul><li><code>context.Backgroud()</code> 创建根 Context，通常在 main 函数、初始化和测试代码中创建，作为顶层 Context。</li><li><code>context.WithCancel(parent)</code> 创建可取消的子 Context，同时返回函数 <code>cancel</code>。</li><li>在子协程中，使用 select 调用 <code>&lt;-ctx.Done()</code> 判断是否需要退出。</li><li>主协程中，调用 <code>cancel()</code> 函数通知子协程退出。</li></ul><h3 id="2-2-控制多个协程"><a href="#2-2-控制多个协程" class="headerlink" title="2.2 控制多个协程"></a><a href="https://geektutu.com/post/quick-go-context.html#2-2-%E6%8E%A7%E5%88%B6%E5%A4%9A%E4%B8%AA%E5%8D%8F%E7%A8%8B" title="2.2 控制多个协程"></a>2.2 控制多个协程</h3><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithCancel(context.Background())  </p><p> go reqTask(ctx, “worker1”)<br> go reqTask(ctx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><p>为每个子协程传递相同的上下文 <code>ctx</code> 即可，调用 <code>cancel()</code> 函数后该 Context 控制的所有子协程都会退出。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8  </p><p>worker1 send request<br>worker2 send request<br>worker1 send request<br>worker2 send request<br>worker1 send request<br>worker2 send request<br>stop worker1<br>stop worker2  </p><h2 id="3-context-WithValue"><a href="#3-context-WithValue" class="headerlink" title="3 context.WithValue"></a><a href="https://geektutu.com/post/quick-go-context.html#3-context-WithValue" title="3 context.WithValue"></a>3 context.WithValue</h2><p>如果需要往子协程中传递参数，可以使用 <code>context.WithValue()</code>。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27  </p><p>type Options struct{ Interval time.Duration }  </p><p>func reqTask(ctx context.Context, name string) {<br> for {<br> select {<br> case &lt;-ctx.Done():<br> fmt.Println(“stop”, name)<br> return<br> default:<br> fmt.Println(name, “send request”)<br> op :&#x3D; ctx.Value(“options”).(*Options)<br> time.Sleep(op.Interval * time.Second)<br> }<br> }<br>}  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithCancel(context.Background())<br> vCtx :&#x3D; context.WithValue(ctx, “options”, &amp;Options{1})  </p><p> go reqTask(vCtx, “worker1”)<br> go reqTask(vCtx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><ul><li><code>context.WithValue()</code> 创建了一个基于 <code>ctx</code> 的子 Context，并携带了值 <code>options</code>。</li><li>在子协程中，使用 <code>ctx.Value(&quot;options&quot;)</code> 获取到传递的值，读取&#x2F;修改该值。</li></ul><h2 id="4-context-WithTimeout"><a href="#4-context-WithTimeout" class="headerlink" title="4 context.WithTimeout"></a><a href="https://geektutu.com/post/quick-go-context.html#4-context-WithTimeout" title="4 context.WithTimeout"></a>4 context.WithTimeout</h2><p>如果需要控制子协程的执行时间，可以使用 <code>context.WithTimeout</code> 创建具有超时通知机制的 Context 对象。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithTimeout(context.Background(), 2*time.Second)<br> go reqTask(ctx, “worker1”)<br> go reqTask(ctx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> fmt.Println(“before cancel”)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><p><code>WithTimeout()</code>的使用与 <code>WithCancel()</code> 类似，多了一个参数，用于设置超时时间。执行结果如下：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7  </p><p>worker2 send request<br>worker1 send request<br>worker1 send request<br>worker2 send request<br>stop worker2<br>stop worker1<br>before cancel  </p><p>因为超时时间设置为 2s，但是 main 函数中，3s 后才会调用 <code>cancel()</code>，因此，在调用 <code>cancel()</code> 函数前，子协程因为超时已经退出了。</p><h2 id="5-context-WithDeadline"><a href="#5-context-WithDeadline" class="headerlink" title="5 context.WithDeadline"></a><a href="https://geektutu.com/post/quick-go-context.html#5-context-WithDeadline" title="5 context.WithDeadline"></a>5 context.WithDeadline</h2><p>超时退出可以控制子协程的最长执行时间，那 <code>context.WithDeadline()</code> 则可以控制子协程的最迟退出时间。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23  </p><p>func reqTask(ctx context.Context, name string) {<br> for {<br> select {<br> case &lt;-ctx.Done():<br> fmt.Println(“stop”, name, ctx.Err())<br> return<br> default:<br> fmt.Println(name, “send request”)<br> time.Sleep(1 * time.Second)<br> }<br> }<br>}  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithDeadline(context.Background(), time.Now().Add(1*time.Second))<br> go reqTask(ctx, “worker1”)<br> go reqTask(ctx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> fmt.Println(“before cancel”)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><ul><li><code>WithDeadline</code> 用于设置截止时间。在这个例子中，将截止时间设置为1s后，<code>cancel()</code> 函数在 3s 后调用，因此子协程将在调用 <code>cancel()</code> 函数前结束。</li><li>在子协程中，可以通过 <code>ctx.Err()</code> 获取到子协程退出的错误原因。</li></ul><p>运行结果如下：</p><p>1<br>2<br>3<br>4<br>5  </p><p>worker2 send request<br>worker1 send request<br>stop worker2 context deadline exceeded<br>stop worker1 context deadline exceeded<br>before cancel  </p><p>可以看到，子协程 <code>worker1</code> 和 <code>worker2</code> 均是因为截止时间到了而退出。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang语言面试题 - 基本原理</title>
      <link href="/interview/go/golang101-2/"/>
      <url>/interview/go/golang101-2/</url>
      
        <content type="html"><![CDATA[<h4 id="1-golang-文件初始化的顺序"><a href="#1-golang-文件初始化的顺序" class="headerlink" title="1. golang 文件初始化的顺序"></a>1. golang 文件初始化的顺序</h4><p>init() 函数是 Go 程序初始化的一部分。由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。<br>总结顺序如下：<br><strong>import –&gt; const –&gt; var –&gt; init() &#x2F; init2() –&gt; main()</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  &#123;  </span><br><span class="line"> fmt.Println(<span class="string">&quot;init1:&quot;</span>, a)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  &#123;  </span><br><span class="line"> fmt.Println(<span class="string">&quot;init2:&quot;</span>, a)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>  </span><br><span class="line"><span class="keyword">const</span> b = <span class="number">100</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"> fmt.Println(<span class="string">&quot;main:&quot;</span>, a)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 执行结果  </span></span><br><span class="line"><span class="comment">// init1: 10  </span></span><br><span class="line"><span class="comment">// init2: 10  </span></span><br><span class="line"><span class="comment">// main: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// init2: 10  </span></span><br><span class="line"><span class="comment">// init1: 10  </span></span><br><span class="line"><span class="comment">// main: 10</span></span><br></pre></td></tr></table></figure><h4 id="2-interface-如何比较"><a href="#2-interface-如何比较" class="headerlink" title="2. interface 如何比较"></a>2. interface 如何比较</h4><p>Golang 中， interface 内部包含了两个字段，类型 T 和值 V ，interface 之间可以用 &#x3D;&#x3D; 或 !&#x3D; 进行比较。两个 interface 之间可能包含以下两种情况：</p><ol><li>两个都是 nil （对应的 T 和 V 都为 unset 的状态）</li><li>T 相同，且 V 相同</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;  </span><br><span class="line">  UserName <span class="type">string</span>  <span class="string">`json:user_name`</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> UserFace <span class="keyword">interface</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="comment">// 实际比较的是两个结构体的地址</span></span><br><span class="line">  <span class="keyword">var</span> u1, u2 UserFace = &amp;User&#123;<span class="string">&quot;Tom&quot;</span>&#125;, &amp;User&#123;<span class="string">&quot;Tom&quot;</span>&#125;  </span><br><span class="line">  <span class="comment">// 比较两个结构体</span></span><br><span class="line">  <span class="keyword">var</span> u3, u4 UserFace = User&#123;<span class="string">&quot;Tom&quot;</span>&#125;, User&#123;<span class="string">&quot;Tom&quot;</span>&#125;  </span><br><span class="line">  fmt.Println(u1 == u2) <span class="comment">// false  </span></span><br><span class="line">  fmt.Println(u3 == u4) <span class="comment">// true  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-interface-和-nil"><a href="#3-interface-和-nil" class="headerlink" title="3. interface 和 nil"></a>3. interface 和 nil</h4><p>上边讲了 interface 包含两个字段，那么一个 nil 的空结构体和 nil 是否真的相等呢？可以看下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> p *<span class="type">int</span> = <span class="literal">nil</span>  </span><br><span class="line">  <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = p  </span><br><span class="line">  fmt.Println(i == p) <span class="comment">// true  </span></span><br><span class="line">  fmt.Println(p == <span class="literal">nil</span>) <span class="comment">// true  </span></span><br><span class="line">  fmt.Println(i == <span class="literal">nil</span>) <span class="comment">// false  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 nil 非 interface 的值 p 赋给 i 的时候，i 实际上是 (T&#x3D;*int, V&#x3D;nil)。当二者相比较时，Go 会将 p 先转换成 interface 类型的再去比较，此时二者等价。<br>p 与 nil 是直接比较的值，因此二者也等价。<br>i 与 nil  比较时，会将 nil 转换为接口 (T&#x3D;nil, V&#x3D;nil)，与 i (T&#x3D;*int, V&#x3D;nil) 不相等，因此  i !&#x3D; nil</p><h4 id="4-GC-初步理解"><a href="#4-GC-初步理解" class="headerlink" title="4. GC 初步理解"></a>4. GC 初步理解</h4><p>最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count)，Go 语言 采用的是标记清除算法。1.5 版本以后在此基础上使用了三色标记法和写屏障技术，提高了效率。</p><p>标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p><ul><li>标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；</li><li>清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。</li></ul><p>标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW，这也是 GC 算法优化的重点），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。</p><p>三色标记算法将程序中的对象分成白色、黑色和灰色三类。</p><ul><li>白色：不确定对象。</li><li>灰色：存活对象，子对象待处理。</li><li>黑色：存活对象。</li></ul><p>标记开始时，所有内存加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入待扫描队列（灰色集合）；使用并发的 goroutine 扫描队列，取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入队列。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。</p><p>三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。</p><p>三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A (黑) -&gt; B (灰) -&gt; C (白) -&gt; D (白)  </span><br></pre></td></tr></table></figure><p>正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A (黑) -&gt; B (灰) -&gt; C (白)   </span><br><span class="line"> ↓  </span><br><span class="line">D (白)  </span><br></pre></td></tr></table></figure><p>为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，这个计数会拦截将白色指针插入黑色对象的操作，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。</p><p>一次完整的 GC 分为四个阶段：</p><ul><li>标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)，开启辅助 GC （mutator assist），统计 root 对象的任务数量</li><li>使用三色标记法标记（Marking, 并发）</li><li>标记结束(Mark Termination，需 STW)，关闭写屏障。</li><li>清理(Sweeping, 并发)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang语言面试题 - 基础语法</title>
      <link href="/interview/go/golang101-1/"/>
      <url>/interview/go/golang101-1/</url>
      
        <content type="html"><![CDATA[<h4 id="1-和-的区别？"><a href="#1-和-的区别？" class="headerlink" title="1.  = 和 := 的区别？"></a>1.  <code>=</code> 和 <code>:=</code> 的区别？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo <span class="type">int</span>  </span><br><span class="line">foo = <span class="number">10</span> </span><br><span class="line"><span class="comment">// 等价于  </span></span><br><span class="line">foo := <span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="2-指针的作用"><a href="#2-指针的作用" class="headerlink" title="2. 指针的作用"></a>2. 指针的作用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x =  <span class="number">5</span>  </span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> = &amp;x  </span><br><span class="line">fmt.Printf(<span class="string">&quot;x = %d&quot;</span>,  *p) <span class="comment">// x 可以用 *p 访问</span></span><br><span class="line"><span class="comment">//  `*` 运算符，也称为解引用运算符，用于访问地址中的值。</span></span><br><span class="line"><span class="comment">//  `＆`运算符，也称为地址运算符，用于返回变量的地址。</span></span><br></pre></td></tr></table></figure><h4 id="3-Go-有异常类型么？"><a href="#3-Go-有异常类型么？" class="headerlink" title="3. Go 有异常类型么？"></a>3. Go 有异常类型么？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go 只有错误类型</span></span><br><span class="line">f, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">  log.Fatal(err)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-啥是协程（goroutine）"><a href="#4-啥是协程（goroutine）" class="headerlink" title="4. 啥是协程（goroutine）"></a>4. 啥是协程（goroutine）</h4><p>Goroutines是可以同时运行的函数与方法。Goroutines 可以被认为是轻量级的线程。 与线程相比，创建 Goroutine 的开销很小。 Go应用程序同时运行数千个 Goroutine 是非常常见的做法。</p><h4 id="5-拼接字符串"><a href="#5-拼接字符串" class="headerlink" title="5. 拼接字符串"></a>5. 拼接字符串</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串是只读的，也就意味着每次修改操作都会创建一个新的字符串</span></span><br><span class="line">a := <span class="string">&quot;a&quot;</span></span><br><span class="line">b := <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="keyword">var</span> str1 <span class="type">string</span></span><br><span class="line">str1 += a</span><br><span class="line">str1 += b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用 `strings.Builder`，最小化内存拷贝次数。</span></span><br><span class="line"><span class="keyword">var</span> str strings.Builder  </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;  </span><br><span class="line">  str.WriteString(<span class="string">&quot;a&quot;</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">fmt.Println(str.String())</span><br></pre></td></tr></table></figure><h4 id="6-什么是-rune-类型"><a href="#6-什么是-rune-类型" class="headerlink" title="6. 什么是 rune 类型"></a>6. 什么是 rune 类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Go 语言中，字符串的底层表示是 byte (8 bit) 序列，而非 rune (32 bit) 序列。例如下面的例子中 `语` 和 `言` 使用 UTF-8 编码后各占 3 个 byte，因此 `len(&quot;Go语言&quot;)` 等于 8，当然我们也可以将字符串转换为 rune 序列。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(<span class="string">&quot;Go语言&quot;</span>)) <span class="comment">// 8  </span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>([]<span class="type">rune</span>(<span class="string">&quot;Go语言&quot;</span>))) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h4 id="7-判断-map-结构中是否包含某个-key-的方法"><a href="#7-判断-map-结构中是否包含某个-key-的方法" class="headerlink" title="7. 判断 map 结构中是否包含某个 key 的方法"></a>7. 判断 map 结构中是否包含某个 key 的方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok 为 true 代表有这个 key，且 val 是这个 key 的值</span></span><br><span class="line"><span class="keyword">if</span> val, ok := map_[<span class="string">&quot;key&quot;</span>]; ok &#123;  </span><br><span class="line">  <span class="comment">//do something  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-defer-的执行顺序"><a href="#8-defer-的执行顺序" class="headerlink" title="8. defer 的执行顺序"></a>8. defer 的执行顺序</h4><p>多个 defer 语句，遵从后进先出(Last In First Out，LIFO)的原则，最后声明的 defer 语句，最先得到执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">  i := <span class="number">0</span>  </span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;defer1&quot;</span>)  </span><br><span class="line">  &#125;()  </span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    i += <span class="number">1</span>  </span><br><span class="line">    fmt.Println(<span class="string">&quot;defer2&quot;</span>)  </span><br><span class="line">  &#125;()  </span><br><span class="line">  <span class="keyword">return</span> i  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  fmt.Println(<span class="string">&quot;return&quot;</span>, test())  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// defer2  </span></span><br><span class="line"><span class="comment">// defer1  </span></span><br><span class="line"><span class="comment">// return 0</span></span><br></pre></td></tr></table></figure><p>defer 在 return 语句之后执行，但在函数真正退出之前，defer 可以修改返回值。我们可以注意到前一个例子的返回值并没有被修改（注意：只有被预先定义的返回值才能被 defer 语句修改）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> (i <span class="type">int</span>) &#123;  </span><br><span class="line">  i = <span class="number">0</span>  </span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    i += <span class="number">1</span>  </span><br><span class="line">    fmt.Println(<span class="string">&quot;defer2&quot;</span>)  </span><br><span class="line">  &#125;()  </span><br><span class="line">  <span class="keyword">return</span> i  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  fmt.Println(<span class="string">&quot;return&quot;</span>, test())  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// defer2  </span></span><br><span class="line"><span class="comment">// return 1</span></span><br></pre></td></tr></table></figure><h4 id="9-tag的用法？"><a href="#9-tag的用法？" class="headerlink" title="9. tag的用法？"></a>9. tag的用法？</h4><p>tag 是 struct 结构的注解，不同的框架或者工具可以通过反射获取到某个字段的属性，增加语义<br>例如下方例子定义了 struct 结构字段和 json 结构的映射关系</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;encoding/json&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;  </span><br><span class="line">  Name <span class="type">string</span> <span class="string">`json:&quot;user_name&quot;`</span>  </span><br><span class="line">  Id   <span class="type">string</span> <span class="string">`json:&quot;user_id&quot;`</span>  </span><br><span class="line">  Age  <span class="type">int</span>    <span class="string">`json:&quot;-&quot;`</span>  <span class="comment">// json 忽略</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  buf, _ := json.Marshal(Stu&#123;<span class="string">&quot;Bishop&quot;</span>, <span class="string">&quot;1001&quot;</span>, <span class="number">18</span>&#125;)  </span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, buf)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-Golang-如何判断两个列表（slice）结构等价"><a href="#10-Golang-如何判断两个列表（slice）结构等价" class="headerlink" title="10. Golang 如何判断两个列表（slice）结构等价"></a>10. Golang 如何判断两个列表（slice）结构等价</h4><p>可以使用反射 reflect.DeepEqual(a, b) 来判断，但是此种方法比较影响性能，我们这里还是通过基础遍历的方法来完成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceAEqurlSliceB</span><span class="params">(a, b []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">  <span class="comment">// 等长</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b) &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判空</span></span><br><span class="line">  <span class="keyword">if</span> (a == <span class="literal">nil</span>) != (b == <span class="literal">nil</span>) &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  b = b[:<span class="built_in">len</span>(a)]  </span><br><span class="line">  <span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;  </span><br><span class="line"><span class="keyword">if</span> v != b[i] &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-如何标识枚举值（enums）"><a href="#11-如何标识枚举值（enums）" class="headerlink" title="11. 如何标识枚举值（enums）"></a>11. 如何标识枚举值（enums）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Level <span class="type">int32</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> (  </span><br><span class="line">  Level1 Level = <span class="literal">iota</span>  </span><br><span class="line">  Level2  </span><br><span class="line">  Level3 </span><br><span class="line">  Level4 </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  fmt.Println(Level1, Level2, Level3, Level4) <span class="comment">// 0, 1, 2, 3  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-空-struct-结构的一些用法"><a href="#12-空-struct-结构的一些用法" class="headerlink" title="12. 空 struct{} 结构的一些用法"></a>12. 空 struct{} 结构的一些用法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本体是一个空结构体</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(<span class="keyword">struct</span>&#123;&#125;&#123;&#125;)) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用作占位符使用</span></span><br><span class="line"><span class="keyword">type</span> Set <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  set := <span class="built_in">make</span>(Set)  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, item := <span class="keyword">range</span> []<span class="type">string</span>&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125; &#123;  </span><br><span class="line">set[item] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  fmt.Println(<span class="built_in">len</span>(set)) <span class="comment">// 3  </span></span><br><span class="line">  <span class="keyword">if</span> _, ok := set[<span class="string">&quot;A&quot;</span>]; ok &#123;  </span><br><span class="line">fmt.Println(<span class="string">&quot;A exists&quot;</span>) <span class="comment">// A exists  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用作传递信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    &lt;-ch  </span><br><span class="line">    <span class="comment">// do something  </span></span><br><span class="line">  &#125;()  </span><br><span class="line">  ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  </span><br><span class="line">  <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="13-声明结构体方法"><a href="#13-声明结构体方法" class="headerlink" title="13. 声明结构体方法"></a>13. 声明结构体方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Lamp <span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Lamp)</span></span> On() &#123;  </span><br><span class="line"> <span class="built_in">println</span>(<span class="string">&quot;On&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Lamp)</span></span> Off() &#123;  </span><br><span class="line"> <span class="built_in">println</span>(<span class="string">&quot;Off&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo建站（三）GitHub</title>
      <link href="/blog/build-blog/hexo101-3/"/>
      <url>/blog/build-blog/hexo101-3/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到建站记录的第二部分：部署到 github page</p><h2 id="GitHub页面"><a href="#GitHub页面" class="headerlink" title="GitHub页面"></a>GitHub页面</h2><p>这里假设已经注册过了Github帐户，如果没有，可以去<a href="https://github.com/">Github</a>注册。</p><p>注册好了后，登录Github,创建仓库：点击右上角的+号，选择new repository:<br><img src="https://t2.picb.cc/2022/02/21/fpUdSF.jpg" alt="git"></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> butterfly </tag>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo建站（二）butterfly</title>
      <link href="/blog/build-blog/hexo101-2/"/>
      <url>/blog/build-blog/hexo101-2/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到建站记录的第二部分：butterfly 主题的安装与初始化</p><h2 id="主题安装与使用"><a href="#主题安装与使用" class="headerlink" title="主题安装与使用"></a>主题安装与使用</h2><p>下载主题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">git <span class="built_in">clone</span> -b master https://gitee.com/immyw/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>修改站点配置文件 _config.yml ,把主题修改为 Butterfly</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">Butterfly</span></span><br></pre></td></tr></table></figure><p>为了后续方便配置，需要在当前目录 blog&#x2F; 创建 _config.butterfly.yml 文件，并将根目录下的 _config.yml 文件内容复制进去。更多的主题配置信息可以等待之后的文章~</p><p>尝试执行以下指令,以查看应用主题后的效果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">#清除旧的内容</span></span><br><span class="line">hexo g <span class="comment">#生成发布用的静态页面</span></span><br></pre></td></tr></table></figure><p>本地查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s <span class="comment"># hexo server</span></span><br></pre></td></tr></table></figure><p>执行完该命令可以去 <a href="localhost:4000">localhost:4000</a> 查看效果</p><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><h4 id="case1-："><a href="#case1-：" class="headerlink" title="case1 ："></a>case1 ：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ERROR TypeError: /data/blog/themes/butterfly/layout/includes/head.pug:40  </span><br><span class="line">38|  </span><br><span class="line">39| !=favicon_tag(theme.favicon || config.favicon)</span><br><span class="line"></span><br><span class="line">&gt; 40| <span class="built_in">link</span>(rel=<span class="string">&quot;canonical&quot;</span> href=urlNoIndex())  </span><br><span class="line">&gt; 41|  </span><br><span class="line">&gt; 42| //- 預解析  </span><br><span class="line">&gt; 43| !=partial(<span class="string">&#x27;includes/head/preconnect&#x27;</span>, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span><br><span class="line"></span><br><span class="line">prettyUrls is not a <span class="keyword">function</span>  </span><br><span class="line">at Object. (/data/blog/themes/butterfly/scripts/helpers/page.js:58:10)  </span><br><span class="line">at <span class="built_in">eval</span> (<span class="built_in">eval</span> at wrap (/data/blog/node_modules/pug-runtime/wrap.js:6:10), :89:77)  </span><br><span class="line">at template (<span class="built_in">eval</span> at wrap (/data/blog/node_modules/pug-runtime/wrap.js:6:10), :4603:215)  </span><br><span class="line">at _View._compiled (/data/blog/node_modules/hexo/lib/theme/view.js:136:50)  </span><br><span class="line">at _View.render (/data/blog/node_modules/hexo/lib/theme/view.js:39:17)  </span><br><span class="line">at /data/blog/node_modules/hexo/lib/hexo/index.js:64:21  </span><br><span class="line">at tryCatcher (/data/blog/node_modules/bluebird/js/release/util.js:16:23)  </span><br><span class="line">at /data/blog/node_modules/bluebird/js/release/method.js:15:34  </span><br><span class="line">at RouteStream._read (/data/blog/node_modules/hexo/lib/hexo/router.js:47:5)  </span><br><span class="line">at RouteStream.Readable.read (_stream_readable.js:479:10)  </span><br><span class="line">at resume_ (_stream_readable.js:966:12)  </span><br><span class="line">at processTicksAndRejections (internal/process/task_queues.js:80:21) &#123;  </span><br><span class="line">path: <span class="string">&#x27;/data/blog/themes/butterfly/layout/includes/head.pug&#x27;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>解决方案</p><ol><li>优先确认 themes&#x2F;butterfly 中有相关的文件内容</li><li>尝试执行如下命令： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br><span class="line"><span class="built_in">rm</span> -rf node_modules</span><br><span class="line"><span class="built_in">rm</span> -rf package-lock.json</span><br><span class="line">npm install</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure></li></ol><h4 id="case2："><a href="#case2：" class="headerlink" title="case2："></a>case2：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TypeError: /Users/blog/themes/butterfly/layout/includes/widget/index.pug:33</span><br><span class="line">    31|       !=partial(<span class="string">&#x27;includes/widget/card_tags&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line">    32|       !=partial(<span class="string">&#x27;includes/widget/card_archives&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line">  &gt; 33|       !=partial(<span class="string">&#x27;includes/widget/card_webinfo&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line">    34|       !=partial(<span class="string">&#x27;includes/widget/card_bottom_self&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line">/Users/blog/themes/butterfly/layout/includes/widget/card_webinfo.pug:18</span><br><span class="line">    16|         .webinfo-item</span><br><span class="line">    17|           .item-name=_p(<span class="string">&#x27;aside.card_webinfo.site_wordcount&#x27;</span>) + <span class="string">&quot; :&quot;</span></span><br><span class="line">  &gt; 18|           .item-count=totalcount(site)</span><br><span class="line">    19|       <span class="keyword">if</span> theme.busuanzi.site_uv</span><br><span class="line">    20|         .webinfo-item</span><br><span class="line">    21|           .item-name= _p(<span class="string">&#x27;aside.card_webinfo.site_uv_name&#x27;</span>) + <span class="string">&quot; :&quot;</span></span><br><span class="line"></span><br><span class="line">totalcount is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p>请检查是否安裝了wordcount插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><h4 id="case3："><a href="#case3：" class="headerlink" title="case3："></a>case3：</h4><p>如果你沒有 pug 以及 stylus 的渲染器会报错</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extends includes/layout.pug block content include ./includes/mixins/post-ui</span><br><span class="line">.pug <span class="comment">#recent-posts.recent-posts +postUI include includes/pagination.pug</span></span><br></pre></td></tr></table></figure><p>解决方案</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h4 id="case4："><a href="#case4：" class="headerlink" title="case4："></a>case4：</h4><p>hexo本地测试运行重启后页面空白，且提示 : </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN No layout: index.html</span><br></pre></td></tr></table></figure><p>可以参考 case1 &amp; case2 ，即 hexo generate 没有成功</p><h4 id="case5："><a href="#case5：" class="headerlink" title="case5："></a>case5：</h4><p>尝试 hexo deploy 发布的时候失败，显示如下，没有反应</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INFO  Validating config</span><br><span class="line">INFO</span><br><span class="line">  ===================================================================</span><br><span class="line"></span><br><span class="line">      <span class="comment">#####  #    # ##### ##### ###### #####  ###### #      #   #</span></span><br><span class="line">      <span class="comment">#    # #    #   #     #   #      #    # #      #       # #</span></span><br><span class="line">      <span class="comment">#####  #    #   #     #   #####  #    # #####  #        #</span></span><br><span class="line">      <span class="comment">#    # #    #   #     #   #      #####  #      #        #</span></span><br><span class="line">      <span class="comment">#    # #    #   #     #   #      #   #  #      #        #</span></span><br><span class="line">      <span class="comment">#####   ####    #     #   ###### #    # #      ######   #</span></span><br><span class="line"></span><br><span class="line">                            4.1.0</span><br><span class="line">  ===================================================================</span><br></pre></td></tr></table></figure><p>解决方案：deploy 参数需要配置到 _config.yml 文件中。<br><strong>注意：冒号后面需要一个空格</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repo:</span> <span class="string">git@github.com:yourname/yourname.github.io.git</span></span><br><span class="line"><span class="comment"># 推荐使用Git链接，使用http模式还会存在需要填写 用户名和邮箱的情况</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>更多问题请参考 <a href="https://butterfly.js.org/posts/98d20436/">butterfly</a> 官方文档中的解答</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo建站（一）hexo</title>
      <link href="/blog/build-blog/hexo101-1/"/>
      <url>/blog/build-blog/hexo101-1/</url>
      
        <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>终于俺也有自己的 blog 了，下面就整个 hexo 建站和主题 butterfly 的配置分几个部分给大家做个小小的总结</p><p>欢迎来到建站记录的第一部分：hexo 的安装</p><h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><p>官网地址：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p><h4 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h4><p>1.node<br>    首先去 <a href="http://nodejs.cn/download/">node.js</a> 的官网下载最新的稳定版本，我这里选择的是 mac 版本的<br>2.npm<br>    包管理工具</p><h4 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo</span><br></pre></td></tr></table></figure><p>记得这里需要使用管理员权限安装</p><p>初始化 hexo 至某个文件夹</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>这个文件夹就是自己将来管理文章的地方</p><p>工程配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>进入刚才初始化的 blog 文件夹</p><p>浏览器调试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generage</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>也可以如下简写</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>必备插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save <span class="comment"># hexo 渲染必备</span></span><br><span class="line">npm install hexo-server --save <span class="comment"># hexo 本地启动</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install --save hexo-wordcount <span class="comment"># wordcount 插件</span></span><br><span class="line">npm install hexo-butterfly-artitalk --save <span class="comment"># artitalk 插件</span></span><br><span class="line">npm install hexo-generator-feed --save <span class="comment"># RSS 插件</span></span><br><span class="line">npm install hexo-auto-category --save <span class="comment"># 自动根据目录生成categories</span></span><br></pre></td></tr></table></figure><p>自动生成 categories 详情和配置方法具体可以参考 <a href="https://github.com/xu-song/hexo-auto-category">auto-category</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/uncategorized/hello-world/"/>
      <url>/uncategorized/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
