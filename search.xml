<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试官101</title>
      <link href="/interview/%E9%9D%A2%E8%AF%95%E5%AE%98/interviewer101/"/>
      <url>/interview/%E9%9D%A2%E8%AF%95%E5%AE%98/interviewer101/</url>
      
        <content type="html"><![CDATA[<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a><strong>面试</strong></h3><h4 id="算法能力-一题5-10min"><a href="#算法能力-一题5-10min" class="headerlink" title="算法能力 一题5-10min :"></a>算法能力 一题5-10min :</h4><ol><li>题目：仅出现一次的数</li><li>题目：连续固定区间最大值<br>给你一个数组 nums 和一个大小为 k的区间。这个区间可以从数组的最左侧不断移动到数组的最右侧。每个移动区间固定有 k 个数字。这个区间每次只向右移动一位。<br>让你返回移动过程中，这些固定区间中的最大值。</li></ol><p>样例输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br></pre></td></tr></table></figure><p>样例输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,3,5,5,6,7]</span><br></pre></td></tr></table></figure><p>样例解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">移动情况 最大值</span><br><span class="line"></span><br><span class="line">[1 3 -1] -3 5 3 6 7 3</span><br><span class="line"></span><br><span class="line">1 [3 -1 -3] 5 3 6 7 3</span><br><span class="line"></span><br><span class="line">1 3 [-1 -3 5] 3 6 7 5</span><br><span class="line"></span><br><span class="line">1 3 -1 [-3 5 3] 6 7 5</span><br><span class="line"></span><br><span class="line">1 3 -1 -3 [5 3 6] 7 6</span><br><span class="line"></span><br><span class="line">1 3 -1 -3 5 [3 6 7] 7</span><br></pre></td></tr></table></figure><ol start="3"><li>拓展</li></ol><p>样例输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,5,3,6,7], t = 5</span><br><span class="line">k = 2</span><br><span class="line">k = 3</span><br><span class="line">k = 4</span><br><span class="line">k = 5</span><br><span class="line">k = 6</span><br></pre></td></tr></table></figure><p>样例输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 3 -1 5 5 6 7</span><br><span class="line">3 3 5 5 6 7</span><br><span class="line">3 5 5 6 7</span><br><span class="line">5 5 6 7</span><br><span class="line">5 6 7</span><br></pre></td></tr></table></figure><h4 id="基础能力"><a href="#基础能力" class="headerlink" title="基础能力"></a>基础能力</h4><h6 id="Go八股"><a href="#Go八股" class="headerlink" title="Go八股"></a>Go八股</h6><p><a href="https://www.topgoer.cn/docs/gomianshiti/gomianshiti-1dd225t6esqld">https://www.topgoer.cn/docs/gomianshiti/gomianshiti-1dd225t6esqld</a></p><h6 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h6><ol><li><p>Redis是单线程的，但Redis为什么这么快？</p><ul><li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</li><li>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li><li>使用多路I&#x2F;O复用模型，非阻塞IO；这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程</li><li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</li></ul></li><li><p>缓存穿透和雪崩的解决方案</p></li><li><p>请简述Reids的删除策略</p><ul><li>定时删除：在设置键的过期时间的同时，创建一个定时任务，当键达到过期时间时，立即执行对键的删除操作</li><li>惰性删除：放任键过期不管，但在每次从键空间获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，如果没有过期，就返回该键</li><li>定期删除：每隔一点时间，程序就对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li></ul><ol start="3"><li>索引的构建流程？</li><li>b树，b+树区别，MongoDB为什么选用b树</li></ol></li></ol><h6 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h6><ol><li>CPU三级缓存</li><li>进程与线程<ul><li>进程: 进程是具有一定独立功能的程序，进程是系统资源分配和调度的最小单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</li><li>线程: 线程是进程的一个实体,线程是内核态,而且是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</li><li>协程: 协程是一种用户态的轻量级线程，协程的调度完全是由用户来控制的。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</li></ul></li></ol><h6 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h6><ol><li><p>创建索引的规则：最左匹配，区分度等</p></li><li><p>索引失效的情况</p><ul><li>未遵循最佳左前缀规则导致索引失效</li><li>计算、函数、类型转换(自动或手动)导致索引失效</li><li>范围条件右边列索引失效</li><li>不等于(!&#x3D;)会导致索引失效</li><li>is null可以用到索引，is not null不能用到索引</li><li>like以通配符%开头索引失效</li><li>or 前的列建立了索引 or后面的列没有建立索引 会导致索引失效</li><li>不同字符集进行比较前需要进行转换，会导致索引失效</li></ul></li><li><p>数据的存储方式： B+树</p><ul><li>非叶子节点不存储数据，只存索引（冗余），这样可以保证存放更多的索引</li><li>叶子节点存储所有索引字段</li><li>叶子节点用指针连接，提高区间访问性能<br> ![[Pasted image 20221201183525.png]]</li></ul></li><li><p>大数据量级的mysql，如何分库分表？解决方案？</p></li><li><p>网络这些可以挑一两个主题聊。</p></li><li><p>自我介绍，告知规则与流程：两个部分：算法题 &amp; 聊一聊基础问题</p></li><li><p>先介绍下自己；主要技能，常用语言，工作经历简单叙述</p></li><li><p>项目：支付相关，幂等？</p></li><li><p>发过去在线文档</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试官 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试官 </tag>
            
            <tag> 初学者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-连续固定区间最大值</title>
      <link href="/interview/%E9%9D%A2%E8%AF%95%E5%AE%98/maximum-of-segments/"/>
      <url>/interview/%E9%9D%A2%E8%AF%95%E5%AE%98/maximum-of-segments/</url>
      
        <content type="html"><![CDATA[<h1 id="连续固定区间最大值"><a href="#连续固定区间最大值" class="headerlink" title="连续固定区间最大值"></a>连续固定区间最大值</h1><ul><li>涉及知识点：堆，栈、双指针、滑动窗口，双向队列、线段树，树状数组, dp 等。</li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>nums</code> 和一个大小为 <code>k</code>的区间。这个区间可以从数组的最左侧不断移动到数组的最右侧。每个移动区间固定有 <code>k</code> 个数字。这个区间每次只向右移动一位。</p><p>让你返回移动过程中，这些固定区间中的最大值。</p><p>样例输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br></pre></td></tr></table></figure><p>样例输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,3,5,5,6,7]</span><br></pre></td></tr></table></figure><p>样例解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">          移动情况              最大值</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果候选人询问到数据范围，可提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.size() &lt;= 10^5</span><br><span class="line">-10^4 &lt;= nums[i] &lt;= 10^4</span><br><span class="line">1 &lt;= k &lt;= nums.size()</span><br></pre></td></tr></table></figure><h2 id="思路描述"><a href="#思路描述" class="headerlink" title="思路描述"></a>思路描述</h2><h3 id="思路-1：暴力滑动-O-n-2"><a href="#思路-1：暴力滑动-O-n-2" class="headerlink" title="思路 1：暴力滑动 O(n^2)"></a>思路 1：暴力滑动 O(n^2)</h3><p>暴力进行滑动窗口， 每次遍历当前窗口内的元素取最大值。</p><p>参考代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">find_maximum_of_sgements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + k &lt;= nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(*<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>() + i, nums.<span class="built_in">begin</span>() + i + k));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度 <code>O(n * k)～O(n^2)</code></li><li>空间复杂度 <code>O(n - k + 1)</code></li></ul><p><strong>这个是暴力解，非正确解，只能给 2 分，可提示次优解和最优解</strong></p><blockquote><p>优化提示 1：可以优化到低于 O(n^2) 的吗？比如 O(nlogn)，O(nlogk), 甚至是线性 O(n) 的做法。</p></blockquote><blockquote><p>优化提示 2：可以想到用一些可以维护极值的数据结构做吗？</p></blockquote><blockquote><p>优化提示 3：那如果拆分成子问题，快速求连续区间的最大值，你怎么做才会有带 log 的时间复杂度？</p></blockquote><p><strong>提示后，候选人还是不会。可换题。</strong></p><h3 id="思路-2：堆-O-nlogk"><a href="#思路-2：堆-O-nlogk" class="headerlink" title="思路 2：堆 O(nlogk)"></a>思路 2：堆 O(nlogk)</h3><p>维护一个大小为 <code>k</code> 的堆，向堆中插入一个元素(单个操作时间复杂度 <code>O(logk)</code>), 将数据不断 <code>push</code> 进堆，每次取结果都将 <code>top</code> 的数取出来就是序列答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">find_maximum_of_segments</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  priority_queue&lt; pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; pq;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">      pq.<span class="built_in">push</span>(&#123;nums[i],i&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = k;i &lt; nums.<span class="built_in">size</span>(); i++) &#123; </span><br><span class="line">      <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>() &amp;&amp; pq.<span class="built_in">top</span>().second &lt;= (i - k)) &#123;</span><br><span class="line">          pq.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      pq.<span class="built_in">push</span>(&#123;nums[i],i&#125;);</span><br><span class="line">      res.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().first);   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<code>O(nlogk)</code>, 候选人有可能写成<code>O(nlogn)</code>, 但问题不大。</li><li>空间复杂度：<code>O(k)</code>。</li></ul><p><strong>这个是正确解，但非最优解，可给 3 分，通过。</strong></p><h3 id="思路-3：双向队列-O-n"><a href="#思路-3：双向队列-O-n" class="headerlink" title="思路 3：双向队列 O(n)"></a>思路 3：双向队列 O(n)</h3><p>可以维护一个双向队列，这个队列是递减的。队列用来保存可能是最大值的数字的 <code>index</code>。<br>当前窗口最大值的 <code>index</code> 在队首，当窗口滑动时，会进入一个新值，出去一个旧值，不断更新给出当前窗口的最大值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">find_maximum_of_segments</span>(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> k) &#123;</span><br><span class="line">  deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">      <span class="comment">// 新元素入队时, 比队尾元素大的话则替代队尾元素</span></span><br><span class="line">      <span class="keyword">while</span>(!que.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[que.<span class="built_in">back</span>()])&#123;</span><br><span class="line">          que.<span class="built_in">pop_back</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 检查队首的 index 是否在窗口内，不在则出队</span></span><br><span class="line">      <span class="keyword">if</span>(!que.<span class="built_in">empty</span>() &amp;&amp; que.<span class="built_in">front</span>() &lt; i - k + <span class="number">1</span>) &#123;</span><br><span class="line">          que.<span class="built_in">pop_front</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      que.<span class="built_in">push_back</span>(i);</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= k <span class="number">-1</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(nums[que.<span class="built_in">front</span>()]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<code>O(n)</code>。</li><li>空间复杂度：<code>O(k)</code>。</li></ul><p><strong>这个是正确解，最优解，可给 4 分，通过。</strong></p><h3 id="思路-4：dynamic-programming"><a href="#思路-4：dynamic-programming" class="headerlink" title="思路 4：dynamic programming"></a>思路 4：dynamic programming</h3><p>先将数组分割成有 <code>k</code> 个元素的块。<br>建立数组 <code>left</code>,其中 <code>left[j]</code> 是从块的开始到下标 <code>j</code> 最大的元素，方向： <code>左-&gt;右</code>。<br>数组 <code>right</code>，其中 <code>right[j]</code> 是从块的结尾到下标 <code>j</code> 最大的元素，方向： <code>右-&gt;左</code>。</p><p>从左到右遍历数组，建立数组 <code>left</code>。</p><p>从右到左遍历数组，建立数组 <code>right</code>。</p><p>因为一个窗口 <code>[i, i + k - 1]</code> 最多跨越两个块，所以求窗口中的最大值就是求这个窗口跨越的块中的最大值，<br>可以知道，无论是跨越 1 个块也好，2 个块也好，计算处于边界的 <code>i</code> 和 <code>i + k - 1</code> 对应的值即可。</p><p><code>right[i]</code> 表示从块的结尾到下标 <code>j</code> 的最大的元素。</p><p><code>left[i + k - 1]</code> 表示从块的开始到下标 <code>i + k - 1</code> 的最大的元素。</p><p>这两个范围刚好是整个窗口。</p><p>所以窗口的最大值是 <code>max(right[i], left[i + k - 1])</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">find_maximum_of_segments</span>(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> k) &#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">right</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="type">int</span> max_num;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i % k == <span class="number">0</span>)&#123;</span><br><span class="line">          max_num = nums[i];</span><br><span class="line">      &#125;</span><br><span class="line">      max_num = <span class="built_in">max</span>(max_num, nums[i]);</span><br><span class="line">      left[i] = max_num;</span><br><span class="line">  &#125;</span><br><span class="line">  max_num = nums[n - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i % k == k - <span class="number">1</span>)&#123;</span><br><span class="line">          max_num = nums[i];</span><br><span class="line">      &#125;</span><br><span class="line">      max_num = <span class="built_in">max</span>(max_num, nums[i]);</span><br><span class="line">      right[i] = max_num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - k; i ++)&#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(<span class="built_in">max</span>(right[i], left[i + k - <span class="number">1</span>]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个是正确解，最优解，但比较难想到。可给 5 分，通过。</strong></p><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<code>O(n)</code>。</li><li>空间复杂度：<code>O(n)</code>。</li></ul><h2 id="其他思路参考"><a href="#其他思路参考" class="headerlink" title="其他思路参考"></a>其他思路参考</h2><p>以下解法比较特殊，而且编码比较复杂，如果真的有候选人在面试中写了，可以考虑给 5 分。</p><h3 id="思路-4-线段树-segment-tree"><a href="#思路-4-线段树-segment-tree" class="headerlink" title="思路 4: 线段树 (segment tree)"></a>思路 4: 线段树 (segment tree)</h3><p>比较裸的线段树维护极值的做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;tree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushUp</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">  tree[rt] = <span class="built_in">max</span>(tree[<span class="number">1</span> &lt;&lt; rt], tree[<span class="number">1</span> &lt;&lt; rt | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l,<span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">    tree[rt] = nums[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span> &lt;&lt; rt, l, mid, nums);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span> &lt;&lt; rt | <span class="number">1</span>, mid + <span class="number">1</span>, r, nums);</span><br><span class="line">  <span class="built_in">pushUp</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l &gt; r) &#123;</span><br><span class="line">    <span class="keyword">return</span> INT_MIN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(l &gt; qr || r &lt; ql) &#123;</span><br><span class="line">    <span class="keyword">return</span> INT_MIN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// [ql [l, r] qr]</span></span><br><span class="line">  <span class="keyword">if</span>(l &gt;= ql &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">      <span class="keyword">return</span> tree[rt];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> left_val = <span class="built_in">query</span>(<span class="number">1</span> &lt;&lt; rt, l, mid, ql, qr);</span><br><span class="line">  <span class="type">int</span> right_val = <span class="built_in">query</span>(<span class="number">1</span> &lt;&lt; rt | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(left_val, right_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">find_maximum_of_segments</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">0</span> || n &lt; k) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  tree.<span class="built_in">resize</span>(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, nums);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + k - <span class="number">1</span> &lt; n; i++) &#123;</span><br><span class="line">      <span class="type">int</span> val = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, i, i + k - <span class="number">1</span>);</span><br><span class="line">      res.<span class="built_in">push_back</span>(val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<ul><li>建树：<code>O(n)</code>。</li><li>查询：<code>O(logn)</code></li></ul></li><li>空间复杂度：<code>O(3 * n)</code>。</li></ul><h3 id="思路-5：树状数组-fenwick-tree"><a href="#思路-5：树状数组-fenwick-tree" class="headerlink" title="思路 5：树状数组 (fenwick tree)"></a>思路 5：树状数组 (fenwick tree)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;val;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;tmp;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_VAL = <span class="number">1e5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">    val[x] = v;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">    <span class="type">int</span> lx = <span class="built_in">lowbit</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; lx; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      val[x] = <span class="built_in">max</span>(val[x], val[x - i]);</span><br><span class="line">    &#125;</span><br><span class="line">    x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(r &gt;= l) &#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;r = &quot; &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">    ans = <span class="built_in">max</span>(tmp[r - <span class="number">1</span>], ans);</span><br><span class="line">    r--;</span><br><span class="line">    <span class="keyword">while</span>(r &gt;= l + <span class="built_in">lowbit</span>(r))&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(val[r], ans);</span><br><span class="line">        r -= <span class="built_in">lowbit</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">find_maximum_of_segments</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  n = nums.<span class="built_in">size</span>();</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">0</span> || n &lt; k) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  val.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> num = nums[i] + MAX_VAL;</span><br><span class="line">    tmp.<span class="built_in">push_back</span>(num);</span><br><span class="line">    <span class="built_in">update</span>(i + <span class="number">1</span>, num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + k - <span class="number">1</span> &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> max_val = <span class="built_in">query</span>(i + <span class="number">1</span>, i + k);</span><br><span class="line">    res.<span class="built_in">push_back</span>(max_val - MAX_VAL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<ul><li>建树：<code>O(n)</code>。</li><li>查询：<code>O(logn)</code></li></ul></li><li>空间复杂度：<code>O(3 * n)</code>。</li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>如果遇到水平比较高的候选人，比如具有 OI 或者 ACM 经历且实力比较强的候选人。</p><p>候选人只需要口述解法即可。</p><p>可将上面题目改编成：</p><p>题意不变，同样是给你一个数组 <code>nums = [1,3,-1,-3,5,3,6,7]</code> 和 一个 <code>t</code>, <code>t</code> 代表查询次数。<br>即存在多组查询，每次查询给你不一样的 <code>k</code>, 让你输出每个查询区间为 <code>k</code> 的区间的答案序列。</p><p>数据范围：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.size() &lt;= 10^5</span><br><span class="line">-10^4 &lt;= nums[i] &lt;= 10^4</span><br><span class="line">1 &lt;= k &lt;= nums.size()</span><br><span class="line">1 &lt;= t &lt;= 10^3</span><br></pre></td></tr></table></figure><p>样例输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,5,3,6,7], t = 5</span><br><span class="line">k = 2</span><br><span class="line">k = 3</span><br><span class="line">k = 4</span><br><span class="line">k = 5</span><br><span class="line">k = 6</span><br></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 3 -1 5 5 6 7</span><br><span class="line">3 3 5 5 6 7 </span><br><span class="line">3 5 5 6 7 </span><br><span class="line">5 5 6 7 </span><br><span class="line">5 6 7</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h3><p>这种属于比较经典的 RMQ (Range Minimum&#x2F;Maximum Query) 问题。</p><p>可以使用一种数据结构 <code>Sparse Tables</code> 来解决。</p><p>该数据结构可在 <code>O(nlogn)</code> 内完成数据预处理， 在 <code>O(1)</code> 内完成查询。</p><ul><li>时间复杂度：<ul><li>预处理：<code>O(nlogn)</code>。</li><li>查询：<code>O(1)</code></li></ul></li><li>空间复杂度：<code>O(nlogn)</code>。</li></ul><p>代码参考：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> M;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">(vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;&amp;dp, vector&lt;<span class="type">int</span>&gt;&amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">          dp[i][j] = <span class="built_in">max</span>(dp[i][j<span class="number">-1</span>], dp[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;&amp;dp, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> k = (<span class="type">int</span>) (<span class="built_in">log</span>(r - l + <span class="number">1</span>) / <span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(dp[l][k], dp[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_maximum_of_segments</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  M = (<span class="type">int</span>) (<span class="built_in">log</span>(n) / <span class="built_in">log</span>(<span class="number">2</span>)) + <span class="number">1</span>; </span><br><span class="line">  vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(M + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">  <span class="built_in">prepare</span>(dp, nums);</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + k - <span class="number">1</span> &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(<span class="built_in">query</span>(dp, i, i + k - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: res) &#123;</span><br><span class="line">      cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试官 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-移掉K位数字</title>
      <link href="/interview/%E9%9D%A2%E8%AF%95%E5%AE%98/remove-the-k-digit/"/>
      <url>/interview/%E9%9D%A2%E8%AF%95%E5%AE%98/remove-the-k-digit/</url>
      
        <content type="html"><![CDATA[<h1 id="移掉K位数字-leetcode-402"><a href="#移掉K位数字-leetcode-402" class="headerlink" title="移掉K位数字-leetcode-402"></a>移掉K位数字-leetcode-402</h1><ul><li>涉及知识点：贪心,栈</li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。  </p><p>注意:  </p><ul><li>num 的长度小于 10002 且 ≥ k。  </li><li>num 不会包含任何前导零。</li></ul><p>输入&#x2F;输出示例：  </p><p>Example 1:  </p><p>Input:   </p><pre><code>num = &quot;1432219&quot;, k = 3  </code></pre><p>Output:   </p><pre><code>&quot;1219&quot;  </code></pre><p>Explanation: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。  </p><p>Example 2:  </p><p>Input:   </p><pre><code>num = &quot;10200&quot;, k = 1  </code></pre><p>Output:   </p><pre><code>&quot;200&quot;  </code></pre><p>Explanation: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。  </p><p>Example 3:  </p><p>Input:   </p><pre><code>num = &quot;10&quot;, k = 2  </code></pre><p>Output:   </p><pre><code>&quot;0&quot;  </code></pre><p>Explanation: 从原数字移除所有的数字，剩余为空就是0。  </p><h2 id="思路描述"><a href="#思路描述" class="headerlink" title="思路描述"></a>思路描述</h2><h2 id="思路-0"><a href="#思路-0" class="headerlink" title="思路 0"></a>思路 0</h2><p>详细描述：思路，从左到右，找第一个比后面大的字符，删除，清零，k次扫描。  </p><ul><li>时间复杂度：o(n*k)  </li><li>空间复杂度：o(1)</li></ul><p>代码：  </p><pre><code class="java">class Solution &#123;      public String removeKdigits(String num, int k) &#123;        if (num.length() == k) return &quot;0&quot;;        StringBuilder s = new StringBuilder(num);        for (int i = 0; i &lt; k; i++) &#123;            int idx = 0;            for (int j = 1; j &lt; s.length() &amp;&amp; s.charAt(j) &gt;= s.charAt(j - 1); j++) idx = j;            s.delete(idx, idx + 1);            while (s.length() &gt; 1 &amp;&amp; s.charAt(0) == &#39;0&#39;) s.delete(0, 1);        &#125;        return s.toString();    &#125;&#125;  </code></pre><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h3><p>详细描述：在一定的范围内逐步选取最小的数字。<br>  </p><ol><li>在第一次循环中，num &#x3D; 1432219, k&#x3D;3，此时我们要删去k&#x3D;3个数字，保留n-k&#x3D;7-3&#x3D;4个数字。  </li><li>最终要挑选4个字符，那么我们先来挑选 千位 的字符，，由于挑选完千位后还需要挑选百位，十位，个位这三个位置的字符，所以千位能选择的范围只能在1432之间,因为要留出末尾的219这三个字符供百位、十位、个位 去挑选。  </li><li>1432中最小的值是1，所以千位的值选好了，就是1，接下来就是从千位后面的432219中去挑选百位值，可以发现挑选每一位的值是一个递归的过程。  </li><li>start &#x3D; 0, end &#x3D; k。也就是要在[start,end]中选取一个最小的进行保留，返回最小数字的下标minIndex。而在下次循环中，start &#x3D; minIndex+1, end++ ，也就是在[start,end]中选择下一个最小的数字。以此类推，直至所有数字都选取完毕。</li></ol><p>注意：当返回的下标minIndex及后面的字符串的长度 &#x3D; 还需要保留的字符串的长度的时候，直接返回  </p><ul><li>时间复杂度：o(n*k)  </li><li>空间复杂度：o(1)</li></ul><p>代码：  </p><pre><code class="go">func removeKdigits(num string, k int) string &#123;      if 0 == k &#123;        return num    &#125;    if k == len(num) &#123;        return &quot;0&quot;    &#125;    result := &quot;&quot;    i := len(num)-k    for &#123;        if i == 0 &#123;            break        &#125;        minIndex := 0        for  j := 0; j &lt; len(num)-(i-1); j++ &#123;            if num[j] &lt; num[minIndex] &#123;                minIndex = j            &#125;        &#125;        // 优化        if len(num)- minIndex == i &#123;            result = result + num[minIndex:]            break        &#125;        result += num[minIndex:minIndex+1]        num = num[minIndex+1:]        i--    &#125;    // 前导0    ans := strings.TrimLeft(result, &quot;0&quot;)    if ans == &quot;&quot; &#123;        ans = &quot;0&quot;    &#125;    return ans&#125;    </code></pre><h3 id="思路2-贪心-单调栈（一般可用-栈、队列、双端队列、双指针-实现）"><a href="#思路2-贪心-单调栈（一般可用-栈、队列、双端队列、双指针-实现）" class="headerlink" title="思路2: 贪心 + 单调栈（一般可用 栈、队列、双端队列、双指针 实现）"></a>思路2: 贪心 + 单调栈（一般可用 栈、队列、双端队列、双指针 实现）</h3><p>详细描述：  </p><ul><li><p>遍历字符串，逐个入栈,若新来的比栈顶小，则栈顶出栈 ,出栈相当于移除动作，需次数并与 k 比较，别删多了  </p></li><li><p>移除头部零有 ‘0’,全空，return “0”,构建字符串，顺序返回整个单调栈元素.  </p></li><li><p>时间复杂度：o(n+k)  </p></li><li><p>空间复杂度：o(n)</p></li></ul><p>代码：  </p><pre><code class="go">func removeKdigits(num string, k int) string &#123;      stack := []byte&#123;&#125;        for i := range num &#123;        digit := num[i]        for k &gt; 0 &amp;&amp; len(stack) &gt; 0 &amp;&amp; digit &lt; stack[len(stack)-1] &#123;            stack = stack[:len(stack)-1]            k--                &#125;        stack = append(stack, digit)     &#125;    stack = stack[:len(stack)-k]    ans := strings.TrimLeft(string(stack), &quot;0&quot;)    if ans == &quot;&quot; &#123;        ans = &quot;0&quot;        &#125;    return ans&#125;  </code></pre><h4 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h4><ul><li>提出思路0，能正确分析时空复杂度(2分)  </li><li>提出思路1，能正确分析时空复杂度(3分)  </li><li>提出思路2，能正确分析时空复杂度(4分)  </li><li>bugfree且代码简洁(5分)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试官 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-仅出现一次的元素</title>
      <link href="/interview/%E9%9D%A2%E8%AF%95%E5%AE%98/single-numbers/"/>
      <url>/interview/%E9%9D%A2%E8%AF%95%E5%AE%98/single-numbers/</url>
      
        <content type="html"><![CDATA[<h1 id="仅出现一次的元素"><a href="#仅出现一次的元素" class="headerlink" title="仅出现一次的元素"></a>仅出现一次的元素</h1><ul><li>涉及知识点：散列表、位运算</li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>（英文）<br>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.  </p><p>For example:  </p><p>Given nums &#x3D; [1, 2, 1, 3, 2, 5], return [3, 5].  </p><p>Note:  </p><ol><li>The order of the result is not important. So in the above example, [5, 3] is also correct.</li></ol><p>（中文）<br>给定一个整数数组，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出仅出现一次的那两个元素。要求时间复杂度在O(N)内。  </p><p>示例输入:  </p><pre><code>[1, 2, 1, 3, 2, 5]  </code></pre><p>示例输出：  </p><pre><code>[3, 5]  </code></pre><h2 id="思路描述"><a href="#思路描述" class="headerlink" title="思路描述"></a>思路描述</h2><h3 id="思路1：排序-遍历"><a href="#思路1：排序-遍历" class="headerlink" title="思路1：排序+遍历"></a>思路1：排序+遍历</h3><p>对序列排序，后遍历所有元素，通过相邻元素是否有相同值来判断是否满足条件，输出。  </p><p>常规排序方案的时空复杂度如下：  </p><ul><li>时间复杂度 <code>O(N*log(N))</code>  </li><li>空间复杂度 <code>O(1)</code></li></ul><p>此时解法不满足要求，可给到2分，若能给出计数排序（时间复杂度O(N)）法，可给到3分。  </p><h3 id="思路2：散列表-遍历"><a href="#思路2：散列表-遍历" class="headerlink" title="思路2：散列表+遍历"></a>思路2：散列表+遍历</h3><p>遍历每个元素，使用散列表存储元素值到数量的映射关系，再遍历散列表找出其中value为1的key，输出。  </p><p>该方案的时空复杂度分析如下：  </p><ul><li>时间复杂度 <code>O(N)</code>  </li><li>空间复杂度 <code>O(N)</code></li></ul><p>此时为次优解，可延伸提问对散列表的理解（如遍历结果是否有序，两个元素输出顺序是否确定），回答正确可给到4分  </p><h3 id="思路3：位运算"><a href="#思路3：位运算" class="headerlink" title="思路3：位运算"></a>思路3：位运算</h3><p>遍历元素，使用异或运算可消除相同的元素，得到所求两个元素的异或结果，从中找出二进制为1的最低位数字，再遍历一次，求出其中一个元素，再与前面结果异或得到另一个元素，输出。  </p><p>该方案的时空复杂度分析如下：  </p><ul><li>时间复杂度 <code>O(N)</code>  </li><li>空间复杂度 <code>O(1)</code></li></ul><p>此为最优解，可给到5分  </p><h2 id="解法示例"><a href="#解法示例" class="headerlink" title="解法示例"></a>解法示例</h2><p><a href="./single-numbers/sortSolution.go">排序+遍历</a>  </p><p><a href="./single-numbers/hashSolution.go">hash+遍历</a>  </p><p><a href="./single-numbers/bitSolution.go">位运算</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试官 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/%E8%BD%AF%E5%AE%9E%E5%8A%9B/1/"/>
      <url>/%E8%BD%AF%E5%AE%9E%E5%8A%9B/1/</url>
      
        <content type="html"><![CDATA[<h1 id="软实力"><a href="#软实力" class="headerlink" title="软实力"></a>软实力</h1><h2 id="主动性，责任心"><a href="#主动性，责任心" class="headerlink" title="主动性，责任心"></a>主动性，责任心</h2><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>主动推进自己参与的每一个项目，将自己看作是每一个项目的负责人，以项目负责人的角度去看待事情，一方面能够让自己更好的做事情，另一方面也能培养自己的项目推动能力</p><h3 id="个人事务"><a href="#个人事务" class="headerlink" title="个人事务"></a>个人事务</h3><p>转介绍相关链路很长，用户从看到第三方广告开始，到最终成为忠实用户</p><h2 id="抗压能力–》有所进步，还需加强"><a href="#抗压能力–》有所进步，还需加强" class="headerlink" title="抗压能力–》有所进步，还需加强"></a>抗压能力–》有所进步，还需加强</h2><p>这一点我最初做的不够好，现在相对而言已经做的不错，总体经验如下</p><p><strong>学会区分事情的轻重缓急，不那么紧急的事情就先放着，不去理会，集中精神解决掉紧急的事情，然后以平和的心态去解决那些不紧急的</strong></p><p>可能说起来简单，但是具体如何实施，还是要自己多经历</p><h2 id="沟通能力–》在沟通中的谦逊没有问题，一向是自己错了就是错了不找接口，但是有时候事情多了，语气会急躁，有所注意和改进，还需要继续努力"><a href="#沟通能力–》在沟通中的谦逊没有问题，一向是自己错了就是错了不找接口，但是有时候事情多了，语气会急躁，有所注意和改进，还需要继续努力" class="headerlink" title="沟通能力–》在沟通中的谦逊没有问题，一向是自己错了就是错了不找接口，但是有时候事情多了，语气会急躁，有所注意和改进，还需要继续努力"></a>沟通能力–》在沟通中的谦逊没有问题，一向是自己错了就是错了不找接口，但是有时候事情多了，语气会急躁，有所注意和改进，还需要继续努力</h2><h3 id="保证沟通的高效性"><a href="#保证沟通的高效性" class="headerlink" title="保证沟通的高效性"></a>保证沟通的高效性</h3><p>低效的沟通不仅会让你烦，也会让沟通对象感到烦，当发现打字已经说不清楚事情的时候可以考虑直接语音，或者直接当面对接。</p><h3 id="沟通过程保持谦逊和平和"><a href="#沟通过程保持谦逊和平和" class="headerlink" title="沟通过程保持谦逊和平和"></a>沟通过程保持谦逊和平和</h3><h4 id="方案沟通"><a href="#方案沟通" class="headerlink" title="方案沟通"></a>方案沟通</h4><p>与他人沟通过程中难免有所争执，要能明确的从对方的角度思考，对方说的一些解决方案你可能一开始不认可，但是别人既然这么说了就一定有他这么说的原因，可以先问清楚，是不是有什么历史遗留问题或者业务场景，导致他要采用你不认可的方案，如果发现确实是对方思考不周，然后可以提供自己的想法，互相沟通，总会达成一致。</p><h4 id="接受自己不足"><a href="#接受自己不足" class="headerlink" title="接受自己不足"></a>接受自己不足</h4><p>不要有自己绝对不能犯错的思想，有时候明明是你的问题或者就是你能力不足没有思考到一些东西，被同事当面指出，这时候要保持谦逊的心，不要硬抗，这没有任何意义，错了就是错了，没有想到就是没有想到，接受别人的指责，然后反省进步即可，硬抗对他人对自己都不是一个好的方式。</p><h1 id="一些好的工作习惯和建议"><a href="#一些好的工作习惯和建议" class="headerlink" title="一些好的工作习惯和建议"></a>一些好的工作习惯和建议</h1><p><strong>1.事事有回音</strong></p><p>这一点很多鸡汤文都有写，但是真的很重要，所以在此放在第一个强调。</p><p>交给你的任务，你做到哪一步，一定要让给你布置的人心里有数，或者说你打算什么时候做完，也一定要给一个deadline，若是长久没有回音，或者最后出了岔子，难免就会留下不靠谱的印象。</p><p><strong>2.跟事情要跟到底</strong></p><p>让你跟一件事情，就要跟到底，中间如果遇到阻碍发现事情没有进展，就要想办法去解决，如果实在解决不了，就要跟向你布置任务的人主动沟通，最起码我们组内达成共识得出一个结论。</p><p><strong>3.不只是完成任务</strong></p><p> 以高标准要求自己，在完成任务的同时能否做的更好，或者说给我的方案是这样，我能否想出更好的方案，在这样的思考中自己的能力也会有所提升。</p><p><strong>4.高效</strong></p><p>一个任务，他花费多少时间，大家心里一般都有数，如果这个任务一般只花费一天，结果你做了两天，三天还没有做好，那一定是你的问题，还有的情况是因为其他事情多，所以设置了deadline，但是出现一拖再拖，到了deadline还继续往下拖的情况，那最起码也是你对自己时间规划不清楚所造成的问题，哪怕自己加班也不能出现因为自己导致项目block的情况，这是我对我自己的要求。</p><p><strong>5.团队配合</strong></p><p>不要怕问问题，但是要问对的问题。</p><p>当出现了问题，一定要先判定问题的范畴，是技术问题，还是非技术问题。</p><p>技术问题当然要靠自己搜资料和想办法解决，但是可以分情况给自己一个时间限制，比如我手上还有很多事情，我已经花了一个小时，还是解决不了这个问题，但是我这边该做的都做了，实在找不到问题了，问了避免浪费时间可以考虑求助一下资深同事或者自己组内的leader。</p><p>非技术问题，可能是我们公司的组件，或者相关的技术规范导致，是一种你知道了就知道了，不知道就无法解决的问题，完全没有下手思路，这种问题可以给自己的时间限制少一些，比如10分钟，当然在提问之前也要确定自己把该做的排查都做了，然后去问一下知道的人。</p><p>于我们组而言，大家都是比较平和的人，所以不要怕问问题，但是也不要问浪费大家时间的低级问题。</p><p><strong>6.不当传话筒</strong></p><p>组内负责的服务很多，有的业务不了解每个人负责的范畴会出现问错人的情况，如果这个问题你恰好也知道可以协助做答，不过作答后也要跟业务明确负责这问题的人其实是谁，不让以后所有这些问题都可能会先问你，如果你不清楚，就不要做传话筒，可以直接拉群或者直接告诉业务方应该问谁，不要转发问题，这样业务方跟问题负责人的沟通中就多加了一层你，有时候业务方对服务了解不清楚，问的问题本身就不正确，你还协助传达，那就是在浪费所有人的时间。</p>]]></content>
      
      
      <categories>
          
          <category> 软实力 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>startup</title>
      <link href="/golang/go-design-pattern/startup/"/>
      <url>/golang/go-design-pattern/startup/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含 23 种常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记</li><li>一些基础原则和思想</li></ul><h3 id="“好”代码的几个标准"><a href="#“好”代码的几个标准" class="headerlink" title="“好”代码的几个标准"></a>“好”代码的几个标准</h3><ol><li>如何评价代码质量的高低？<br>代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁等，这些词汇是从不同的维度去评价代码质量的。它们之间有互相作用，并不是独立的，比如，代码的可读性好、可扩展性好就意味着代码的可维护性好。代码质量高低是一个综合各种因素得到的结论。我们并不能通过单一的维度去评价一段代码的好坏。</li><li>最常用的评价标准有哪几个？<br>最常用到几个评判代码质量的标准是：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。</li><li>如何才能写出高质量的代码？<br>要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等等</li></ol>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper</title>
      <link href="/interview/zookeeper/"/>
      <url>/interview/zookeeper/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是-zookeeper-？"><a href="#1-什么是-zookeeper-？" class="headerlink" title="1. 什么是 zookeeper ？"></a>1. 什么是 zookeeper ？</h3><h3 id="2-什么是强、弱、最终一致性"><a href="#2-什么是强、弱、最终一致性" class="headerlink" title="2. 什么是强、弱、最终一致性"></a>2. 什么是强、弱、最终一致性</h3><h3 id="3-ZooKeeper-快速领导选举是如何实现的？"><a href="#3-ZooKeeper-快速领导选举是如何实现的？" class="headerlink" title="3. ZooKeeper 快速领导选举是如何实现的？"></a>3. ZooKeeper 快速领导选举是如何实现的？</h3><h3 id="4-如何通过两阶段提交来保证一致性"><a href="#4-如何通过两阶段提交来保证一致性" class="headerlink" title="4. 如何通过两阶段提交来保证一致性"></a>4. 如何通过两阶段提交来保证一致性</h3><h3 id="5-观察者节点的作用"><a href="#5-观察者节点的作用" class="headerlink" title="5. 观察者节点的作用"></a>5. 观察者节点的作用</h3><h3 id="6-为什么建议使用奇数台机器来构建集群？"><a href="#6-为什么建议使用奇数台机器来构建集群？" class="headerlink" title="6. 为什么建议使用奇数台机器来构建集群？"></a>6. 为什么建议使用奇数台机器来构建集群？</h3><h3 id="7-为什么会出现脑裂问题？"><a href="#7-为什么会出现脑裂问题？" class="headerlink" title="7. 为什么会出现脑裂问题？"></a>7. 为什么会出现脑裂问题？</h3>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GMP 原理与调度</title>
      <link href="/golang/concurrency/gmp/"/>
      <url>/golang/concurrency/gmp/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>M(machine): 代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。<br>P(processor): 表示逻辑processor，是线程M的执行的上下文。<br>G(goroutine): 调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。</p><h1 id="1-GMP-原理与调度"><a href="#1-GMP-原理与调度" class="headerlink" title="1. GMP 原理与调度"></a>1. GMP 原理与调度</h1><h3 id="1-1-1-一、Golang-“调度器”-的由来？"><a href="#1-1-1-一、Golang-“调度器”-的由来？" class="headerlink" title="1.1.1 一、Golang “调度器” 的由来？"></a>1.1.1 一、Golang “调度器” 的由来？</h3><h4 id="1-单进程时代不需要调度器"><a href="#1-单进程时代不需要调度器" class="headerlink" title="(1) 单进程时代不需要调度器"></a>(1) 单进程时代不需要调度器</h4><p>我们知道，一切的软件都是跑在操作系统上，真正用来干活 (计算) 的是 CPU。早期的操作系统每个程序就是一个进程，知道一个程序运行完，才能进行下一个进程，就是 “单进程时代”<br>一切的程序只能串行发生。<br>早期的单进程操作系统，面临 2 个问题：</p><ol><li><p>单一的执行流程，计算机只能一个任务一个任务处理。</p></li><li><p>进程阻塞所带来的 CPU 时间浪费。</p></li></ol><p>那么能不能有多个进程来宏观一起来执行多个任务呢？</p><p>后来操作系统就具有了最早的并发能力：多进程并发，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把 CPU 利用起来，CPU 就不浪费了。</p><h4 id="2-多进程-x2F-线程时代有了调度器需求"><a href="#2-多进程-x2F-线程时代有了调度器需求" class="headerlink" title="(2) 多进程 &#x2F; 线程时代有了调度器需求"></a>(2) 多进程 &#x2F; 线程时代有了调度器需求</h4><p><img src="https://s3.bmp.ovh/imgs/2022/02/921c521bed752387.jpg" alt="image"><br>在多进程 &#x2F; 多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞 cpu 可以立刻切换到其他进程中去执行，而且调度 cpu 的算法可以保证在运行的进程都可以被分配到 cpu 的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。</p><p>但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU 虽然利用起来了，但如果进程过多，CPU 有很大的一部分都被用来进行进程调度了。</p><p>怎么才能提高 CPU 的利用率呢？</p><p>但是对于 Linux 操作系统来讲，cpu 对进程的态度和线程的态度是一样的。<br><img src="https://s3.bmp.ovh/imgs/2022/02/bad5998d362c5be9.jpg" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> GMP </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-mutex</title>
      <link href="/golang/concurrency/go-mutex/"/>
      <url>/golang/concurrency/go-mutex/</url>
      
        <content type="html"><![CDATA[<h3 id="lock逻辑："><a href="#lock逻辑：" class="headerlink" title="lock逻辑："></a>lock逻辑：</h3><ol><li>第一次上锁的时候，直接走第一步<strong>CAS</strong>上锁，成功返回</li><li><strong>Mutex</strong>已经被另一个<strong>g</strong>上锁，那么<strong>state</strong>的<strong>g</strong>等待数+1，更新当前的锁状态，然后就进入队列，等待被唤醒，等到另个<strong>g</strong>调用了<strong>Unlock</strong>方法之后，当前<strong>g</strong>被唤醒，然后设置<strong>awoken&#x3D;true</strong>，再执行一遍<strong>for</strong>循环，此时<strong>locked</strong>位就是未上锁状态（0），<strong>new</strong>就是代表上锁，然后清除<strong>woken</strong>位，然后再<strong>CAS</strong>更新<strong>new</strong>到<strong>state</strong>上，因为之前的锁是未上锁状态，那么就代表抢锁成功，<strong>break</strong>，返回</li><li>和第二种一样，只不过，在<strong>CAS</strong>更新<strong>new</strong>到<strong>state</strong>上时，有其他<strong>g</strong>先改掉了<strong>state</strong>的值，那么就继续for循环，然后重复到第二种情况。</li></ol><h3 id="自旋锁："><a href="#自旋锁：" class="headerlink" title="自旋锁："></a>自旋锁：</h3><p>简单概括一下，就是为了解决锁粒度非常小的时候，给系统带来的不必要的调度开销<br>不过自旋要先满足几个条件<br>首先程序要跑在多核的机器上，然后GOMAXPROCS要大于1，并且此时有至少一个P的local runq是空的，才能进入到自旋的状态</p><p>自旋是一种多线程同步机制，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真。在多核的 CPU 上，自旋可以避免 Goroutine 的切换，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 Goroutine 进入自旋的条件非常苛刻</p><p>当<strong>Mutex</strong>已经上锁的时候，当前<strong>G</strong>在满足自旋条件下，进入自旋状态，在自旋中，其他<strong>G</strong>解锁了<strong>Mutex</strong>，那么当前<strong>G</strong>就设置了<strong>woken</strong>标记位，这样其他<strong>G</strong>在<strong>Unlock</strong>的时候就不会去等待队列里面唤醒<strong>G</strong>了，然后当前<strong>G</strong>就顺理成章的抢到了锁</p><p>这样自旋锁在锁粒度非常小的场景下的能对其性能带来一定的优化。</p><p>引入自旋锁之后，又带来了一个问题。就是<strong>G</strong>等待队列的<strong>长尾问题</strong>。因为从等待队列里面被唤醒，然后再去抢锁，对本身就在执行的<strong>G</strong>来说，被唤醒的<strong>G</strong>其实是很难抢过当前执行的<strong>G</strong>的，这样的话，等待队列里面的<strong>G</strong>，就会被饿死(长时间获取不到锁)，这样对等待队列的<strong>G</strong>来说其实是不公平的。</p><h3 id="饥饿模式"><a href="#饥饿模式" class="headerlink" title="饥饿模式"></a>饥饿模式</h3><p>简单概括一下，就是解决了等待G队列的长尾问题<br>饥饿模式下，直接由unlock把锁交给等待队列中排在第一位的G，同时，饥饿模式下，新进来的G不会参与抢锁也不会进入自旋状态，会直接进入等待队列的尾部。<br>饥饿模式的触发条件，当一个G等待锁时间超过1毫秒时，Mutex切换到饥饿模式<br>饥饿模式的取消条件，当一个G获取到锁且在等待队列的末尾，或者这个G获取锁的等待时间在1ms内，那么Mutex切换回正常模式</p><p>带来的改变</p><p>Mutex.state的倒数第三位，变成了mutexStarving标记位，0表示正常模式，1表示饥饿模式，与此同时，支持的最大等待G数量从230个 变成了229个</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> mutex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang模拟面试题01</title>
      <link href="/interview/log/simulation01/"/>
      <url>/interview/log/simulation01/</url>
      
        <content type="html"><![CDATA[<ol><li><p>channel实现原理</p></li><li><p>Mutex 是悲观还是乐观锁（什么是乐观锁）</p></li><li><p>Mutex 有几种模式（饥饿和互斥）</p></li><li><p>Mutex 自旋锁？</p></li><li><p>goroutine 模型 和抢占时机</p><p><a href="https://www.bilibili.com/video/BV19r4y1w7Nx/?spm_id_from=333.788.recommend_more_video.6">https://www.bilibili.com/video/BV19r4y1w7Nx/?spm_id_from&#x3D;333.788.recommend_more_video.6</a></p></li><li><p>GC 原理</p></li><li><p>go内存分配，哪些对象分配在堆上，哪些分配在栈上（大对象小对象）</p></li><li><p>OOM</p></li><li><p>signal信号（64种）</p></li><li><p>Go Micro</p></li><li><p>CPU三级缓存，加载固定长度到cache，连续的地址空间</p></li><li><p>多核CPU如何保持cache不冲突（MESI）</p></li><li><p>rune 和 uint 超出位数后计算</p></li></ol><p>小厂01</p><ol><li>mutex有几种锁？<ol><li>互斥锁mutex</li><li>读写互斥锁rwmutex</li></ol></li><li>协程和线程？见golang101-1 .4</li><li>channel的作用？用法？<ol><li>控制并发数，一般结合 waitgroup</li><li>控制协程退出等</li></ol></li><li>tidb基础</li><li>gc流程 原理 golang101-2.4</li><li>线程与进程</li><li>slice 和 map 线程安全否</li><li>使用go遇到的挑战？</li><li>postgre？分布式缓存？</li><li>框架grpc相关</li><li>统计协程数量<ol><li>runtime.NumGoroutine()</li></ol></li><li>为什么转go<ol><li>微服务，上云</li><li>k8s</li><li>大量，分布式</li></ol></li></ol><p>ihandy</p><ol><li>项目</li><li>gc</li><li>redis 持久化</li><li>channel，context</li><li>mutex使用</li><li>gmp</li><li>进程线程协程</li></ol><p>数獨科技：多业务或者多方数据不出库，怎样模型化使用这些数据 tob</p><ol><li>项目<ol><li>最拿手的哪个？</li><li>技术点不是特别突出</li><li>任务系统要讲明白对用户和运营的两套接口模式，以及相关的缓存实现方案和刷新机制</li><li>广告系统要讲明白具体提升了哪些效率</li><li>什么维度的缓存key，等</li></ol></li><li>管理<ol><li>时间分配</li><li>需求评审大概流程和内容</li></ol></li><li>字符串相加</li><li>kafka ：topic， partition和consumer的关系， replica<ol><li>consumer的负载分配等</li><li>组内每个消费者对应一个partition，partition多的话由consumer承接，其中一个或几个接受的量会多；消费者多的话，多出partition的会处于空闲状态</li></ol></li></ol><p>中物联讯</p><ol><li>项目</li></ol><p>字节国际支付</p><ol><li>项目</li><li>redis 持久化</li><li>求根号2<ol><li>卡算法题了你敢信，菜逼</li><li>去把课程中的题每个至少来两遍才够的！！！！！！</li></ol></li></ol><p>循环调度：银行 or 销售的提效工具，通话质量模型 tob</p><ol><li>http + 协程，怎么调度的？是否涉及用户态和核心态的切换？</li><li>索引的构建流程？</li><li>b树，b+树区别，MongoDB为什么选用b树</li><li>gmp调度流程</li><li>redis 哪些命令? 时间复杂度是 o(n)</li><li>kafka 持久化？</li><li>kafka partition数量根据哪些信息确定的？<ol><li>回答：consumer的数量</li><li>答案：？</li></ol></li></ol><p>umu</p><ol><li>mysql 聚合索引和XX索引</li><li>redis 各种数据类型的底层结构</li></ol><p>自己总结：<br>并发，缓存，高可用，grpc，gc，gmp，mutex，channel，context等<br>http，redis，mysql，zookeeper，raft<br>乐观锁悲观锁？<br>cas？</p><p>集度基础服务开发</p><ol><li>grpc通信问题</li><li>grpc限流，熔断相关</li><li>golang 底层，写了就会问，channel实现方式，slice实现方式</li><li>如何做限流，redis请求锁的过期时间为什么，如果有人一直持有锁怎么办？</li><li>延时队列的实现方案</li><li>golang的gc</li><li>redis 锁的实现方案？</li><li>算法：判断二叉树是否对称</li><li>逃逸分析</li></ol><p>刷题：<br>剑指offer<br>算法训练营<br>简单题*3<br>中等题*4</p><p>Tik Tok二面<br>1.介绍数据库索引？<br>    数据库索引是一种数据结构，用于提高数据库查询效率。它通过创建特定的数据结构（如B树、B+树）来存储数据的有序副本，以便更快地定位和检索数据。<br>2.为什么把二叉查找树变成多路平衡查找树就能减少磁盘IO？为什么树的高度决定了磁盘的IO次数？如果查找某一个数据，用二叉查找树和用B+树的时间复杂度分别是多少?<br>3.B+树的叶子结点的默认大小是多少？如果把B树的非叶子结点只存放指针,那B树是不是就和B+树一样了呢？<br>4.除了二叉树，B+树，B树这些索引，还有什么常见的存储数据结构适合做索引呢？<br>    哈希索引和全文索引也常用于数据库索引。<br>5.为什么InnoDB不用哈希做索引，用哈希和用B+树有什么区别？<br>    哈希索引适用于等值查询，而B+树索引支持范围查询和排序。InnoDB使用B+树索引，因为它支持更多的查询类型。<br>6.Redis里面有序集合用的索引？介绍一下跳跃表，与哈希的区别？<br>    跳跃表是一种有序数据结构，用于实现有序集合。与哈希表相比，跳跃表支持有序性和范围查询。<br>7.MySQL事务隔离级别有哪些，会产生哪些问题，MySQL默认的隔离级别是什么<br>    MySQL的事务隔离级别包括读未提交、读已提交、可重复读和串行化。不同的隔离级别可能导致脏读、不可重复读和幻读等问题。MySQL默认的隔离级别是可重复读。<br>8.MySQL如何实现可重复读？MVCC的底层原理？<br>9.看你用过palsuar，也用过Kafka，那你说一下这两者不一样的地方？或者设计上有哪些不一样？<br>    Pulsar和Kafka都是消息中间件，但它们的架构和设计有所不同。例如，Pulsar支持多租户、多数据中心复制和动态消息路由等特性，而Kafka则更加专注于高吞吐量和低延迟。<br>14.说说两者底层存储消息方式的区别？<br>15.为什么这两者要这么设计？<br>17.Redis如何实现高可用和高可靠的？<br>    Redis实现高可用通常通过主从复制和哨兵或集群模式。哨兵负责监控节点健康，并在主节点失败时自动切换到从节点。集群模式支持数据分片和节点自动发现，提高了可用性和可扩展性。<br>18.Redis的主从复制是同步的还是异步的？异步和同步的优缺点？<br>    Redis的主从复制是异步的。异步复制提高了性能，但可能导致数据不一致性和数据丢失。<br>19.了解go吗，说说协程，为什么要用协程？<br>    协程是一种轻量级的线程，由Go语言原生支持。协程的优点包括低开销、高并发和简单易用，使得编写并发程序变得更加简单和高效。<br>20.为什么多线程访问共享资源需要加锁处理？<br>    多线程并发访问共享资源可能导致数据竞态和不一致性。加锁能够保证数据的原子性和一致性，从而确保线程安全。<br>21.说说可见性，为什么一个线程看不到另外一个线程的修改？<br>    线程的可见性指的是一个线程对共享变量的修改能够被其他线程立即看到。在多线程编程中，由于CPU的优化、缓存以及编译器的优化，可能导致线程之间的数据不一致。为了确保线程安全和正确性，我们需要解决这个问题。多线程对同一共享变量做修改时，某个线程修改后的新值可能不会立即更新到主内存，其他线程可能仍旧读到该变量旧值。<br>    使用锁保证同一时刻只有一个线程访问共享变量；<br>    对变量访问使用原子操作<br>23.让你设计一个任务调度器的类，add一个task，指定这个task的执行时间，可以add很多任务，但每个task执行的时间又各不相同，你如何实现，用什么数据结构？<br>    可以使用优先队列（如最小堆）来存储任务，并按照执行时间进行排序。每次调度器检查时，都会选择最早的任务执行。<br>24.优先队列的实现原理？<br>25.算法题：二叉树的完全性检验？</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 实录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/golang/go-design-pattern/gda-create/singleton/"/>
      <url>/golang/go-design-pattern/gda-create/singleton/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含 23 种常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记</li><li><strong>课程:</strong> <a href="https://time.geekbang.org/column/article/194035">41 | 单例模式（上为什么说支持懒加载的双重检测不比饿汉式更优？</a></li><li>**RoadMap: 02&#x2F;28 **持续更新中，预计一周更新 2 ~ 3 种设计模式，预计到 202010 月底前更新完成</li></ul>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 创建型模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang201</title>
      <link href="/golang/advanced-tutorial/golang201/"/>
      <url>/golang/advanced-tutorial/golang201/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 进阶教程笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>channel</title>
      <link href="/golang/concurrency/go-channel/"/>
      <url>/golang/concurrency/go-channel/</url>
      
        <content type="html"><![CDATA[<h2 id="channel-101"><a href="#channel-101" class="headerlink" title="channel 101"></a>channel 101</h2><h3 id="1-引子"><a href="#1-引子" class="headerlink" title="1. 引子"></a>1. 引子</h3><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。</p><p>如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h4><h2 id="channel-底层原理"><a href="#channel-底层原理" class="headerlink" title="channel 底层原理"></a>channel 底层原理</h2><ul><li><code>buf</code>是有缓冲的channel所特有的结构，用来存储缓存数据。是个循环链表 （为啥是循环链表？普通数组不行吗，普通数组地址和容量固定更适合指定的空间。需要pop 掉元素，普通数组需要全部都前移）</li><li><code>sendx</code>和<code>recvx</code>用于记录<code>buf</code>这个循环链表中的<del>发送或者接收的</del>index</li><li><code>lock</code>是个互斥锁。</li><li><code>recvq</code>和<code>sendq</code>分别是接收(&lt;-channel)或者发送(channel &lt;- xxx)的goroutine抽象出来的结构体(sudog)的队列。是个双向链表</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="type">uint</span>  <span class="comment">// 队列中的总元素个数 </span></span><br><span class="line">dataqsiz <span class="type">uint</span>  <span class="comment">// 环形队列大小，即可存放元素的个数 </span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// 环形队列指针 </span></span><br><span class="line">elemsize <span class="type">uint16</span>  <span class="comment">//每个元素的大小 </span></span><br><span class="line">closed   <span class="type">uint32</span>  <span class="comment">//标识关闭状态 </span></span><br><span class="line">elemtype *_type <span class="comment">// 元素类型 </span></span><br><span class="line">sendx    <span class="type">uint</span>   <span class="comment">// 发送索引，元素写入时存放到队列中的位置</span></span><br><span class="line">recvx    <span class="type">uint</span>   <span class="comment">// 接收索引，元素从队列的该位置读出</span></span><br><span class="line">recvq    waitq  <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">sendq    waitq <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex <span class="comment">//互斥锁，chan不允许并发读写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-读写流程"><a href="#1-读写流程" class="headerlink" title="1. 读写流程"></a>1. 读写流程</h4><blockquote><p>向 channel 写数据:</p><ol><li><p>若等待接收队列 recvq 不为空，则缓冲区中无数据或无缓冲区，将直接从 recvq 取出 G ，并把数据写入，最后把该 G 唤醒，结束发送过程。</p></li><li><p>若缓冲区中有空余位置，则将数据写入缓冲区，结束发送过程。</p></li><li><p>若缓冲区中没有空余位置，则将发送数据写入 G，将当前 G 加入 sendq ，进入睡眠，等待被读 goroutine 唤醒。</p></li></ol></blockquote><blockquote><p>从 channel 读数据</p><ol><li><p>若等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G ，把 G 中数据读出，最后把 G 唤醒，结束读取过程。</p></li><li><p>如果等待发送队列 sendq 不为空，说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程。</p></li><li><p>如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程。</p></li><li><p>将当前 goroutine 加入 recvq ，进入睡眠，等待被写 goroutine 唤醒。</p></li></ol></blockquote><blockquote><p>关闭 channel</p><p>1.关闭 channel 时会将 recvq 中的 G 全部唤醒，本该写入 G 的数据位置为 nil。将 sendq 中的 G 全部唤醒，但是这些 G 会 panic。</p><p>panic 出现的场景还有：</p><ul><li>关闭值为 nil 的 channel</li><li>关闭已经关闭的 channel</li><li>向已经关闭的 channel 中写数据</li></ul></blockquote><h4 id="2-创建channel"><a href="#2-创建channel" class="headerlink" title="2. 创建channel"></a>2. 创建channel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无缓冲的channel由于没有缓冲发送和接收需要同步</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)   </span><br><span class="line"><span class="comment">//有缓冲channel不要求发送和接收操作同步</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>实例化了 chan 的结构体，返回ch指针</p><h4 id="channel中发送send-ch-lt-xxx-和recv-lt-ch-接收"><a href="#channel中发送send-ch-lt-xxx-和recv-lt-ch-接收" class="headerlink" title="channel中发送send(ch &lt;- xxx)和recv(&lt;- ch)接收"></a>channel中发送send(ch &lt;- xxx)和recv(&lt;- ch)接收</h4><p>使用 mutex 加锁操作，新进先出的队列</p><h4 id="当channel缓存满后"><a href="#当channel缓存满后" class="headerlink" title="当channel缓存满后"></a>当channel缓存满后</h4><h5 id="发送满的时候"><a href="#发送满的时候" class="headerlink" title="发送满的时候"></a>发送满的时候</h5><p>当队列已满的时候，G1正在运行，当再次send操作时，会主动调用GO的调度器，让G1等待，并让出M，同时G1也会被抽象成含有G1指针和send元素的sudog结构体保存到hchan的<code>sendq</code>中等待被唤醒。</p><p>当G2 recv操作的时候，G2从缓存队列中取出数据，channel会将等待队列中的G1推出，将G1当时send的数据推到缓存中，然后调用Go的scheduler，唤醒G1，并把G1放到可运行的Goroutine队列中。</p><h5 id="接收满的时候"><a href="#接收满的时候" class="headerlink" title="接收满的时候"></a>接收满的时候</h5><p>这个时候G2会主动调用Go的调度器,让G2等待，并从让出M，让其他G去使用。 G2还会被抽象成含有G2指针和recv空元素的<code>sudog</code>结构体保存到hchan的<code>recvq</code>中等待被唤醒。此时恰好有个goroutine G1开始向channel中推送数据 <code>ch &lt;- 1</code>。 此时，非常有意思的事情发生了：G1并没有锁住channel，然后将数据放到缓存中，而是直接把数据从G1直接copy到了G2的栈中。 这种方式非常的赞！在唤醒过程中，G2无需再获得channel的锁，然后从缓存中取数据。减少了内存的copy，提高了效率。</p><h4 id="4-channel-的状态和操作方式"><a href="#4-channel-的状态和操作方式" class="headerlink" title="4. channel 的状态和操作方式"></a>4. channel 的状态和操作方式</h4><p>如下：</p><table><thead><tr><th align="left">操作</th><th align="left">nil 的 channel</th><th align="left">已关闭的 channel</th><th align="left">正常 channel</th></tr></thead><tbody><tr><td align="left">close 关闭</td><td align="left">panic</td><td align="left">panic</td><td align="left">成功</td></tr><tr><td align="left">ch &lt;- 写</td><td align="left">死锁</td><td align="left">panic</td><td align="left">阻塞或成功</td></tr><tr><td align="left">&lt;-ch 读</td><td align="left">死锁</td><td align="left">零值</td><td align="left">阻塞或成功</td></tr></tbody></table><p>channel一个类型管道，通过它可以在goroutine之间发送和接收消息。它是Golang在语言层面提供的goroutine间的通信方式。</p><p>众所周知，Go依赖于称为CSP（Communicating Sequential Processes）的并发模型，通过Channel实现这种同步模式。Go并发的核心哲学是不要通过共享内存进行通信; 相反，通过沟通分享记忆。</p><h2 id="channel-常见用法"><a href="#channel-常见用法" class="headerlink" title="channel 常见用法"></a>channel 常见用法</h2><h4 id="循环读取"><a href="#循环读取" class="headerlink" title="循环读取"></a>循环读取</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x := <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> channel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http 网络面试必备</title>
      <link href="/interview/http/"/>
      <url>/interview/http/</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP-协议和-HTTPS"><a href="#HTTP-协议和-HTTPS" class="headerlink" title="HTTP 协议和 HTTPS"></a>HTTP 协议和 HTTPS</h3><ul><li>HTTPS是加密传输协议，HTTP是名文传输协议</li><li>HTTPS需要用到SSL证书，而HTTP不用</li><li>HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO【参考：（1）为保护用户隐私安全,谷歌优先索引HTTPS网页、（2）百度开放收录https站点，https全网化势不可挡】</li><li>HTTPS标准端口443，HTTP标准端口80</li><li>HTTPS基于传输层，HTTP基于应用层</li><li>HTTPS在浏览器显示绿色安全锁，HTTP没有显示</li></ul><h3 id="TLS-x2F-SSL工作原理"><a href="#TLS-x2F-SSL工作原理" class="headerlink" title="TLS&#x2F;SSL工作原理"></a>TLS&#x2F;SSL工作原理</h3><p>对称加密：</p><ul><li>算法是公开的</li><li>通过秘钥来加密，使用相同的秘钥加密解密</li><li>des, 3des, aes</li><li>缺点：<ul><li>秘钥容易泄露</li><li>一个用户需要对应一个秘钥，服务器管理秘钥比较麻烦</li></ul></li></ul><p>非对称加密：</p><ul><li>算法公开</li><li>公钥加密，私钥解密</li><li>私钥加密，公钥解密</li><li>黑客拿到公钥和公钥加密的内容也解不了密</li><li>rsa, ecc, dh</li><li>优点：<ul><li>加密和解密使用不同的钥匙，可以传输公钥是安全的</li></ul></li><li>缺点<ul><li>加密和解密的速度比较慢</li></ul></li></ul><p>散列函数Hash：</p><ul><li>MD5，SHA1，SHA256</li><li>函数单向不可逆、对输入非常敏感、输出长度固定</li><li>散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密</li></ul><h4 id="HTTPS的握手过程"><a href="#HTTPS的握手过程" class="headerlink" title="HTTPS的握手过程"></a>HTTPS的握手过程</h4><p><img src="https://static.studygolang.com/200511/4bf1766991151c30854781c4b4455eb2.png" alt="image"><br>HTTPS的握手过程</p><ol><li>“client hello”消息：客户端通过发送”client hello”消息向服务器发起握手请求，该消息包含了客户端所支持的 TLS 版本和密码组合以供服务器进行选择，还有一个”client random”随机字符串。</li><li>“server hello”消息：服务器发送”server hello”消息对客户端进行回应，该消息包含了数字证书，服务器选择的密码组合和”server random”随机字符串。</li><li>验证：客户端对服务器发来的证书进行验证，确保对方的合法身份，验证过程可以细化为以下几个步骤：<ol><li>检查数字签名</li><li>验证证书链</li><li>检查证书的有效期</li><li>检查证书的撤回状态 (撤回代表证书已失效)</li></ol></li><li>premaster secret 字符串：客户端向服务器发送另一个随机字符串”premaster secret （预主密钥）”，这个字符串是经过服务器的公钥加密过的，只有对应的私钥才能解密。</li><li>使用私钥：服务器使用私钥解密”premaster secret”。</li><li>生成共享密钥：客户端和服务器均使用 client random，server random 和 premaster secret，并通过相同的算法生成相同的共享密钥 KEY。</li><li>客户端就绪：客户端发送经过共享密钥 KEY加密过的”finished”信号。</li><li>服务器就绪：服务器发送经过共享密钥 KEY加密过的”finished”信号。</li><li>达成安全通信：握手完成，双方使用对称加密进行安全通信。</li></ol><h4 id="HTTPS接入优化"><a href="#HTTPS接入优化" class="headerlink" title="HTTPS接入优化"></a>HTTPS接入优化</h4><ol><li>CDN接入<br>HTTPS 增加的延时主要是传输延时 RTT，RTT 的特点是节点越近延时越小，CDN 天然离用户最近，因此选择使用 CDN 作为 HTTPS 接入的入口，将能够极大减少接入延时。CDN 节点通过和业务服务器维持长连接、会话复用和链路质量优化等可控方法，极大减少 HTTPS 带来的延时。</li><li>会话缓存<br>虽然前文提到 HTTPS 即使采用会话缓存也要至少1*RTT的延时，但是至少延时已经减少为原来的一半，明显的延时优化;同时，基于会话缓存建立的 HTTPS 连接不需要服务器使用RSA私钥解密获取 Pre-master 信息，可以省去CPU 的消耗。如果业务访问连接集中，缓存命中率高，则HTTPS的接入能力讲明显提升。当前TRP平台的缓存命中率高峰时期大于30%，10k&#x2F;s的接入资源实际可以承载13k&#x2F;的接入，收效非常可观。</li><li>硬件加速<br>为接入服务器安装专用的SSL硬件加速卡，作用类似 GPU，释放 CPU，能够具有更高的 HTTPS 接入能力且不影响业务程序的。测试某硬件加速卡单卡可以提供35k的解密能力，相当于175核 CPU，至少相当于7台24核的服务器，考虑到接入服务器其它程序的开销，一张硬件卡可以实现接近10台服务器的接入能力。</li><li>远程解密<br>本地接入消耗过多的 CPU 资源，浪费了网卡和硬盘等资源，考虑将最消耗 CPU 资源的RSA解密计算任务转移到其它服务器，如此则可以充分发挥服务器的接入能力，充分利用带宽与网卡资源。远程解密服务器可以选择 CPU 负载较低的机器充当，实现机器资源复用，也可以是专门优化的高计算性能的服务器。当前也是 CDN 用于大规模HTTPS接入的解决方案之一。</li><li>SPDY&#x2F;HTTP2<br>前面的方法分别从减少传输延时和单机负载的方法提高 HTTPS 接入性能，但是方法都基于不改变 HTTP 协议的基础上提出的优化方法，SPDY&#x2F;HTTP2 利用 TLS&#x2F;SSL 带来的优势，通过修改协议的方法来提升 HTTPS 的性能，提高下载速度等。</li></ol><h4 id="https加密、解密及验证过程"><a href="#https加密、解密及验证过程" class="headerlink" title="https加密、解密及验证过程"></a>https加密、解密及验证过程</h4><ul><li>浏览器发送请求443端口（自身支持的非对称加密算法，协商）</li><li>ssl层放入公钥和服务器身份认证进行签名，保留私钥</li><li>浏览器校验公钥，和服务器身份</li><li>产生随机码，用公钥加密（此时黑客就算得到公钥也没办法对其解密出随机码）</li><li>服务器用会话密钥来对称加密传输</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
            <tag> 必看必会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>channel - goroutine</title>
      <link href="/golang/concurrency/channel-gorourine/"/>
      <url>/golang/concurrency/channel-gorourine/</url>
      
        <content type="html"><![CDATA[<h3 id="goroutine超时处理"><a href="#goroutine超时处理" class="headerlink" title="goroutine超时处理"></a>goroutine超时处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        c1 &lt;- <span class="string">&quot;result 1&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c1:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout 1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        c2 &lt;- <span class="string">&quot;result 2&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c2:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无阻塞"><a href="#无阻塞" class="headerlink" title="无阻塞"></a>无阻塞</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c2:</span><br><span class="line">    fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">    fmt.Println(<span class="string">&quot;timeout 2&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通道关闭"><a href="#通道关闭" class="headerlink" title="通道关闭"></a>通道关闭</h3><ol><li>close(channel) 关闭通道</li><li>j，more :&#x3D; &lt;- channel 如果已关闭，则more为 false</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            j, more := &lt;-jobs</span><br><span class="line">            <span class="keyword">if</span> more &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;received job&quot;</span>, j)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;received all jobs&quot;</span>)</span><br><span class="line">                done &lt;- <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++ &#123;</span><br><span class="line">        jobs &lt;- j</span><br><span class="line">        fmt.Println(<span class="string">&quot;sent job&quot;</span>, j)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(jobs)</span><br><span class="line">    fmt.Println(<span class="string">&quot;sent all jobs&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管道遍历"><a href="#管道遍历" class="headerlink" title="管道遍历"></a>管道遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    queue := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    queue &lt;- <span class="string">&quot;one&quot;</span></span><br><span class="line">    queue &lt;- <span class="string">&quot;two&quot;</span></span><br><span class="line">    <span class="built_in">close</span>(queue)</span><br><span class="line">    <span class="keyword">for</span> elem := <span class="keyword">range</span> queue &#123;</span><br><span class="line">        fmt.Println(elem)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="只读和只写管道"><a href="#只读和只写管道" class="headerlink" title="只读和只写管道"></a>只读和只写管道</h3><ul><li><code>&lt;-chan string</code> 只读</li><li><code>chan&lt;- string</code> 只写</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(jobs <span class="keyword">chan</span> <span class="type">int</span>, done <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">j, more := &lt;-jobs</span><br><span class="line"><span class="keyword">if</span> more &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;received job&quot;</span>, j)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;received all jobs&quot;</span>)</span><br><span class="line">done &lt;- <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMsg</span><span class="params">(jobs <span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++ &#123;</span><br><span class="line">jobs &lt;- j</span><br><span class="line">fmt.Println(<span class="string">&quot;sent job&quot;</span>, j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(jobs)</span><br><span class="line">fmt.Println(<span class="string">&quot;sent all jobs&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> test(jobs, done)</span><br><span class="line"><span class="keyword">go</span> sendMsg(jobs)</span><br><span class="line"></span><br><span class="line">&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制并发数"><a href="#控制并发数" class="headerlink" title="控制并发数"></a>控制并发数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">choice1()</span><br><span class="line">choice2()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">choice1</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span> ,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">time.Sleep( time.Second)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&lt;- ch</span><br><span class="line">&#125;(ch)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">choice2</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span> ,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">time.Sleep( time.Second)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&lt;- ch</span><br><span class="line">&#125;(ch)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> channel </tag>
            
            <tag> goroutine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 反射</title>
      <link href="/golang/reflect/"/>
      <url>/golang/reflect/</url>
      
        <content type="html"><![CDATA[<h3 id="Name-and-Kind"><a href="#Name-and-Kind" class="headerlink" title="Name and Kind"></a>Name and Kind</h3><p>可调用函数和含义，以及结果一览</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typeOfCat := reflect.TypeOf(cat&#123;&#125;)</span><br><span class="line">typeOfCat.Name() <span class="comment">// cat</span></span><br><span class="line">typeOfCat.Kind()  <span class="comment">// struct</span></span><br><span class="line">typeOfCat.NumField() <span class="comment">// 2 几个字段</span></span><br><span class="line">typeOfCat.Field(i) <span class="comment">//第几个字段</span></span><br><span class="line">typeOfCat.FieldByName(<span class="string">&quot;Type&quot;</span>) <span class="comment">// 找名为Type的字段</span></span><br><span class="line">typeOfCat.MethodByName(<span class="string">&quot;Start&quot;</span>) <span class="comment">// 找名为Start的方法</span></span><br><span class="line"><span class="keyword">if</span> typeofCat.Kind() == <span class="string">&quot;ptr&quot;</span>&#123;</span><br><span class="line">  res := typeOfCat.Elem()  <span class="comment">// 等价于*ptr</span></span><br><span class="line">  res.Name()</span><br><span class="line">  res.Kind()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reflect-ValueOf-和reflect-Value"><a href="#reflect-ValueOf-和reflect-Value" class="headerlink" title="reflect.ValueOf()和reflect.Value"></a>reflect.ValueOf()和reflect.Value</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">valueOfA := reflect.ValueOf(a)</span><br><span class="line"><span class="keyword">var</span> getA <span class="type">int</span> = valueOfA.Interface().(<span class="type">int</span>)</span><br><span class="line"><span class="keyword">var</span> getA2 <span class="type">int</span> = <span class="type">int</span>(valueOfA.Int())</span><br></pre></td></tr></table></figure><h3 id="通过反射获取值信息"><a href="#通过反射获取值信息" class="headerlink" title="通过反射获取值信息"></a>通过反射获取值信息</h3><h4 id="使用反射值对象包装任意值"><a href="#使用反射值对象包装任意值" class="headerlink" title="使用反射值对象包装任意值"></a>使用反射值对象包装任意值</h4><p>Go语言中，使用 reflect.ValueOf() 函数获得值的反射值对象（reflect.Value）。书写格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value := reflect.ValueOf(rawValue)</span><br></pre></td></tr></table></figure><p>reflect.ValueOf 返回 reflect.Value 类型，包含有 rawValue 的值信息。reflect.Value 与原值间可以通过值包装和值获取互相转化。reflect.Value 是一些反射操作的重要类型，如反射调用函数。</p><h4 id="从反射值对象获取被包装的值"><a href="#从反射值对象获取被包装的值" class="headerlink" title="从反射值对象获取被包装的值"></a>从反射值对象获取被包装的值</h4><p>Go语言中可以通过 reflect.Value 重新获得原始值。</p><h5 id="1-从反射值对象（reflect-Value）中获取值的方法"><a href="#1-从反射值对象（reflect-Value）中获取值的方法" class="headerlink" title="1) 从反射值对象（reflect.Value）中获取值的方法"></a>1) 从反射值对象（reflect.Value）中获取值的方法</h5><p>可以通过下面几种方法从反射值对象 reflect.Value 中获取原值，如下表所示。</p><table><thead><tr><th align="left">方法名</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="left">Interface() interface {}</td><td align="left">将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td></tr><tr><td align="left">Int() int64</td><td align="left">将值以 int 类型返回，所有有符号整型均可以此方式返回</td></tr><tr><td align="left">Uint() uint64</td><td align="left">将值以 uint 类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td align="left">Float() float64</td><td align="left">将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td align="left">Bool() bool</td><td align="left">将值以 bool 类型返回</td></tr><tr><td align="left">Bytes() []bytes</td><td align="left">将值以字节数组 []bytes 类型返回</td></tr><tr><td align="left">String() string</td><td align="left">将值以字符串类型返回</td></tr></tbody></table><h5 id="2-从反射值对象（reflect-Value）中获取值的例子"><a href="#2-从反射值对象（reflect-Value）中获取值的例子" class="headerlink" title="2) 从反射值对象（reflect.Value）中获取值的例子"></a>2) 从反射值对象（reflect.Value）中获取值的例子</h5><p>下面代码中，将整型变量中的值使用 reflect.Value 获取反射值对象（reflect.Value）。再通过 reflect.Value 的 Interface() 方法获得 interface{} 类型的原值，通过 int 类型对应的 reflect.Value 的 Int() 方法获得整型值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明整型变量a并赋初值</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">1024</span></span><br><span class="line">    <span class="comment">// 获取变量a的反射值对象</span></span><br><span class="line">    valueOfA := reflect.ValueOf(a)</span><br><span class="line">    <span class="comment">// 获取interface&#123;&#125;类型的值, 通过类型断言转换</span></span><br><span class="line">    <span class="keyword">var</span> getA <span class="type">int</span> = valueOfA.Interface().(<span class="type">int</span>)</span><br><span class="line">    <span class="comment">// 获取64位的值, 强制类型转换为int类型</span></span><br><span class="line">    <span class="keyword">var</span> getA2 <span class="type">int</span> = <span class="type">int</span>(valueOfA.Int())</span><br><span class="line">    fmt.Println(getA, getA2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代码输出如下：</span></span><br><span class="line"><span class="comment">// 1024 1024</span></span><br></pre></td></tr></table></figure><h3 id="通过reflect反射修改值"><a href="#通过reflect反射修改值" class="headerlink" title="通过reflect反射修改值"></a>通过reflect反射修改值</h3><p>判断反射值是否可以修改？CanSet()，是否能被取址CanAddr()</p><p>结构体成员中，如果字段没有被导出，即便不使用反射也可以被访问，但不能通过反射修改</p><ol><li><p>指针指向的具体元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">v := reflect.ValueOf(&amp;x)</span><br><span class="line">v = v.Elem()</span><br></pre></td></tr></table></figure></li><li><p>slice的元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">1</span>&#125;</span><br><span class="line">v := reflect.ValueOf(s)</span><br><span class="line">e := v.Index(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p>可寻址的结构体的字段(指向结构体的指针)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Orange <span class="keyword">struct</span>&#123;</span><br><span class="line">  Size <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line">a := Orange&#123;<span class="number">99</span>&#125;</span><br><span class="line">v := reflect.ValueOf(&amp;a)</span><br><span class="line">v = v.Elem()</span><br><span class="line">field = v.FieldByName(<span class="string">&quot;field&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>可寻址的数组的元素(指向数组的指针)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">1</span>&#125;</span><br><span class="line">v := reflect.ValueOf(&amp;a)</span><br><span class="line">v = v.Elem()</span><br><span class="line">vIndex = v.Index(<span class="number">0</span>)</span><br><span class="line">vIndex.SetInt(<span class="number">1</span>)</span><br><span class="line">vIndex.SetInt(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ol><table><thead><tr><th align="left">-</th><th align="left">-</th></tr></thead><tbody><tr><td align="left">Set(x Value)</td><td align="left">将值设置为传入的反射值对象的值</td></tr><tr><td align="left">Setlnt(x int64)</td><td align="left">使用 int64 设置值。当值的类型不是 int、int8、int16、 int32、int64 时会发生宕机</td></tr><tr><td align="left">SetUint(x uint64)</td><td align="left">使用 uint64 设置值。当值的类型不是 uint、uint8、uint16、uint32、uint64 时会发生宕机</td></tr><tr><td align="left">SetFloat(x float64)</td><td align="left">使用 float64 设置值。当值的类型不是 float32、float64 时会发生宕机</td></tr><tr><td align="left">SetBool(x bool)</td><td align="left">使用 bool 设置值。当值的类型不是 bod 时会发生宕机</td></tr><tr><td align="left">SetBytes(x []byte)</td><td align="left">设置字节数组 []bytes值。当值的类型不是 []byte 时会发生宕机</td></tr><tr><td align="left">SetString(x string)</td><td align="left">设置字符串值。当值的类型不是 string 时会发生宕机</td></tr></tbody></table><h3 id="通过类型信息创建实例"><a href="#通过类型信息创建实例" class="headerlink" title="通过类型信息创建实例"></a>通过类型信息创建实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">typeOfA := reflect.TypeOf(a)</span><br><span class="line">aIns := reflect.New(typeOfA) <span class="comment">// 等价于 new(int)</span></span><br><span class="line">fmt.Println(aIns.Type(), aIns.Kind())</span><br></pre></td></tr></table></figure><h3 id="Go语言结构体标签（Struct-Tag）"><a href="#Go语言结构体标签（Struct-Tag）" class="headerlink" title="Go语言结构体标签（Struct Tag）"></a>Go语言结构体标签（Struct Tag）</h3><h4 id="结构体标签的格式"><a href="#结构体标签的格式" class="headerlink" title="结构体标签的格式"></a>结构体标签的格式</h4><p>tag 格式：<code>json:&quot;type&quot; id:&quot;100&quot;</code></p><p>注意：</p><ol><li>key:“value” 冒号后没有空格</li><li>两个key之间，一个空格，多一个都不行</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Type <span class="type">int</span> <span class="string">`json:&quot;type&quot; id:&quot;100&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从结构体标签中获取值"><a href="#从结构体标签中获取值" class="headerlink" title="从结构体标签中获取值"></a>从结构体标签中获取值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeOfCat := reflect.TypeOf(cat&#123;&#125;)</span><br><span class="line">catType = typeOfCat.FieldByName(<span class="string">&quot;Type&quot;</span>)</span><br><span class="line">catType.Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><h4 id="动态调用函数（无参数）"><a href="#动态调用函数（无参数）" class="headerlink" title="动态调用函数（无参数）"></a>动态调用函数（无参数）</h4><ol><li>直接<code>reflect.Valueof</code></li><li><code>MethodByName</code></li><li>调用<code>Call</code>方法</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Do&quot;</span></span><br><span class="line">    t := &amp;T&#123;&#125;</span><br><span class="line">    reflect.ValueOf(t).MethodByName(name).Call(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Do() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态调用函数（有参数）"><a href="#动态调用函数（有参数）" class="headerlink" title="动态调用函数（有参数）"></a>动态调用函数（有参数）</h4><ol><li>创建<code>reflect.Value</code>切片</li><li><code>reflect.Valueof(t).MethodByName(string)</code> 调用Call方法传入参数</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Do&quot;</span></span><br><span class="line">    t := &amp;T&#123;&#125;</span><br><span class="line">    a := reflect.ValueOf(<span class="number">1111</span>)</span><br><span class="line">    b := reflect.ValueOf(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    in := []reflect.Value&#123;a, b&#125;</span><br><span class="line">    reflect.ValueOf(t).MethodByName(name).Call(in)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Do(a <span class="type">int</span>, b <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span> + b, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接收返回值"><a href="#接收返回值" class="headerlink" title="接收返回值"></a>接收返回值</h4><ol><li>返回<code>[]reflect.Value</code></li><li>调用<code>Interface()</code>方法，转为<code>interface&#123;&#125;</code>类型</li><li>断言类型</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Do&quot;</span></span><br><span class="line">    t := &amp;T&#123;&#125;</span><br><span class="line">    ret := reflect.ValueOf(t).MethodByName(name).Call(<span class="literal">nil</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;strValue: %[1]v\nerrValue: %[2]v\nstrType: %[1]T\nerrType: %[2]T&quot;</span>, ret[<span class="number">0</span>], ret[<span class="number">1</span>].Interface().(<span class="type">error</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Do() (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>, errors.New(<span class="string">&quot;new error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Tag解析"><a href="#Tag解析" class="headerlink" title="Tag解析"></a>Tag解析</h4><ol><li><code>reflect.Typeof</code>有<code>NumField</code>，Field根据序号索取，取其中的tag</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;</span><br><span class="line">Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Age <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := T&#123;&#125;</span><br><span class="line">tt := reflect.TypeOf(a)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;tt.NumField();i++&#123;</span><br><span class="line">fmt.Println(tt.Field(i).Name)</span><br><span class="line">fmt.Println(tt.Field(i).Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">fmt.Println(tt.Field(i).Tag.Lookup(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">fmt.Println(tt.Field(i).Type)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过kind（）处理不同分支"><a href="#通过kind（）处理不同分支" class="headerlink" title="通过kind（）处理不同分支"></a>通过kind（）处理不同分支</h4><ol><li><code>reflect.Typeof().Kind()</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := <span class="number">1</span></span><br><span class="line">a := reflect.TypeOf(t)</span><br><span class="line"><span class="keyword">switch</span> a.Kind() &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.String:</span><br><span class="line">fmt.Println(<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> reflect.Int:</span><br><span class="line">fmt.Println(<span class="string">&quot;int&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断结构体是否实现接口"><a href="#判断结构体是否实现接口" class="headerlink" title="判断结构体是否实现接口"></a>判断结构体是否实现接口</h4><ol><li>将<code>nil</code>强转为接口指针类型，通过<code>reflect.Typeof().Elem</code>获取其接口类型</li><li><code>reflect.Typeof</code>调用方法<code>Implements</code>来判断</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IT <span class="keyword">interface</span> &#123;</span><br><span class="line">test1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">A <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> test1() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := &amp;T&#123;&#125;</span><br><span class="line">elem := reflect.TypeOf((*IT)(<span class="literal">nil</span>)).Elem()</span><br><span class="line"><span class="keyword">if</span> reflect.TypeOf(t).Implements(elem) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接通过接口强转判断</p><ol><li>将类型转换为 <code>reflect.Value</code></li><li>将<code>reflect.Value</code>调用Interface()方法转为接口类型</li><li>类型断言</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ITester <span class="keyword">interface</span> &#123;</span><br><span class="line">test1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">A <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u := &amp;User&#123;&#125;</span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line">val, ok := v.Interface().(ITester)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Support Interface&quot;</span>, val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> reflect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础知识</title>
      <link href="/interview/elementary/"/>
      <url>/interview/elementary/</url>
      
        <content type="html"><![CDATA[<h3 id="多核-CPU-Cache-如何保持一致？"><a href="#多核-CPU-Cache-如何保持一致？" class="headerlink" title="多核 CPU Cache 如何保持一致？"></a>多核 CPU Cache 如何保持一致？</h3><p>MESI</p><h3 id="CAP-原理"><a href="#CAP-原理" class="headerlink" title="CAP 原理"></a>CAP 原理</h3><h3 id="大表-Join-小表优化，如何处理数据倾斜"><a href="#大表-Join-小表优化，如何处理数据倾斜" class="headerlink" title="大表 Join 小表优化，如何处理数据倾斜"></a>大表 Join 小表优化，如何处理数据倾斜</h3><h3 id="讲一下最大堆和最小堆"><a href="#讲一下最大堆和最小堆" class="headerlink" title="讲一下最大堆和最小堆"></a>讲一下最大堆和最小堆</h3><h3 id="happen-before-的规则"><a href="#happen-before-的规则" class="headerlink" title="happen-before 的规则"></a>happen-before 的规则</h3>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试算法题总结</title>
      <link href="/interview/inter-alg101/"/>
      <url>/interview/inter-alg101/</url>
      
        <content type="html"><![CDATA[<h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><p>更多加分点： 加权等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> LoadBalancer <span class="keyword">struct</span> &#123;</span><br><span class="line">    client []*Client</span><br><span class="line">    size <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLB</span><span class="params">(size <span class="type">int32</span>)</span></span> *LoadBalalcer &#123;</span><br><span class="line">    lb := &amp;LoadBalancer&#123;client: <span class="built_in">make</span>([]*Client, size), size: size&#125;</span><br><span class="line">    lb.client = <span class="built_in">append</span>(lb.client, &amp;Client&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> lb</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LoadBalancer)</span></span> getClient() *Client &#123;</span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">    x := rand.Int31n(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">return</span> m.client[x &amp; m.size]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Client)</span></span> Do &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Do&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    lb := NewLB(<span class="number">4</span>)</span><br><span class="line">    lb.getClient().Do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用反射调用函数"><a href="#利用反射调用函数" class="headerlink" title="利用反射调用函数"></a>利用反射调用函数</h3><p>实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span></span> Drive &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Driving&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    car := Car&#123;&#125;</span><br><span class="line">    val := reflect.ValueOf(&amp;car)</span><br><span class="line">    f := value.MethodByName(<span class="string">&quot;Drive&quot;</span>)</span><br><span class="line">    f.Call([]reflect.Value&#123;&#125;)  <span class="comment">// Drive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给定三个函数-cat-dog-fish-，每个函数启动一个-goroutine-，要求按照顺序打印100次"><a href="#给定三个函数-cat-dog-fish-，每个函数启动一个-goroutine-，要求按照顺序打印100次" class="headerlink" title="给定三个函数 cat dog fish ，每个函数启动一个 goroutine ，要求按照顺序打印100次"></a>给定三个函数 cat dog fish ，每个函数启动一个 goroutine ，要求按照顺序打印100次</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintCat</span><span class="params">(fishCH,catCH <span class="keyword">chan</span> <span class="type">bool</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> waitgroup.Done()</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(catCH)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt;<span class="number">100</span>;i++&#123;</span><br><span class="line">&lt;-fishCH</span><br><span class="line">fmt.Println(<span class="string">&quot;cat ...&quot;</span>)</span><br><span class="line">catCH &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintDog</span><span class="params">(catCH,dogCH <span class="keyword">chan</span> <span class="type">bool</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> waitgroup.Done()</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(dogCH)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt;<span class="number">100</span>;i++&#123;</span><br><span class="line">&lt;-catCH</span><br><span class="line">fmt.Println(<span class="string">&quot;dog ...&quot;</span>)</span><br><span class="line">dogCH&lt;-<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintFish</span><span class="params">(dogCH,fishCH <span class="keyword">chan</span> <span class="type">bool</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> waitgroup.Done()</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(fishCH)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt;<span class="number">100</span>;i++&#123;</span><br><span class="line">&lt;-dogCH</span><br><span class="line">fmt.Println(<span class="string">&quot;fish ...&quot;</span>)</span><br><span class="line">fishCH&lt;-<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> waitgroup sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">catCH := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>,<span class="number">1</span>)</span><br><span class="line">dogCH := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>,<span class="number">1</span>)</span><br><span class="line">fishCH := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>,<span class="number">1</span>)</span><br><span class="line">fishCH &lt;- <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> PrintFish(dogCH,fishCH)</span><br><span class="line"><span class="keyword">go</span> PrintDog(catCH,dogCH)</span><br><span class="line"><span class="keyword">go</span> PrintCat(fishCH,catCH)</span><br><span class="line"></span><br><span class="line">waitgroup.Add(<span class="number">3</span>)</span><br><span class="line">waitgroup.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽奖问题"><a href="#抽奖问题" class="headerlink" title="抽奖问题"></a>抽奖问题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定如下结构</span></span><br><span class="line"><span class="comment">// map中，key代表名称，value代表成交单数</span></span><br><span class="line"><span class="keyword">var</span> users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span> = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>&#123;</span><br><span class="line">  <span class="string">&quot;a&quot;</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="string">&quot;b&quot;</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="string">&quot;c&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&quot;d&quot;</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="string">&quot;f&quot;</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-随机抽奖"><a href="#1-随机抽奖" class="headerlink" title="1. 随机抽奖"></a>1. 随机抽奖</h5><p>从 map 中随机选取用户中奖<br>思路：将用户理解为一个个格子，从中选取一个格子中奖</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAwardUserName</span><span class="params">(users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>)</span></span> (name <span class="type">string</span>) &#123;</span><br><span class="line">  sizeOfUsers := <span class="built_in">len</span>(users)</span><br><span class="line">  award_index := rand.Intn(sizeOfUsers)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> index <span class="type">int</span></span><br><span class="line">  <span class="keyword">for</span> u_name, _ := <span class="keyword">range</span> users &#123;</span><br><span class="line">    <span class="keyword">if</span> index == award_index &#123;</span><br><span class="line">      name = u_name</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span> = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>&#123;</span><br><span class="line">    <span class="string">&quot;a&quot;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="string">&quot;b&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">&quot;c&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;d&quot;</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="string">&quot;e&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&quot;f&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rand.Seed(time.Now().Unix())</span><br><span class="line">  <span class="comment">// 抽奖1次</span></span><br><span class="line">  name := GetAwardUserName(users)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;user: %s jack point&quot;</span>, name)</span><br><span class="line">  <span class="comment">// 抽奖1000次</span></span><br><span class="line">  award_stat := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i += <span class="number">1</span> &#123;</span><br><span class="line">    name := GetAwardUserName(users)</span><br><span class="line">    <span class="keyword">if</span> count, ok := award_stat[name]; ok &#123;</span><br><span class="line">      award_stat[name] = count + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      award_stat[name] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> name, count := <span class="keyword">range</span> award_stat &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;user: %s, award count: %d\n&quot;</span>, name, count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方抽奖代码复杂度为 O(n) ，可以结合二分查找优化为 O(logN)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAwardGenerator</span><span class="params">(users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>)</span></span> (generator <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sum_num <span class="type">int64</span></span><br><span class="line">  name_arr := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(users))</span><br><span class="line">  offset_arr := <span class="built_in">make</span>([]<span class="type">int64</span>, <span class="built_in">len</span>(users))</span><br><span class="line">  <span class="keyword">var</span> index <span class="type">int</span></span><br><span class="line">  <span class="keyword">for</span> u_name, num := <span class="keyword">range</span> users &#123;</span><br><span class="line">    name_arr[index] = u_name</span><br><span class="line">    offset_arr[index] = sum_num</span><br><span class="line">    sum_num += num</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  generator = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    award_num := rand.Int63n(sum_num)</span><br><span class="line">    <span class="keyword">return</span> name_arr[binary_search(offset_arr, award_num)]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binary_search</span><span class="params">(nums []<span class="type">int64</span>, target <span class="type">int64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  start, end := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">  <span class="keyword">for</span> start &lt;= end &#123;</span><br><span class="line">    mid := start + (end-start)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">      end = mid - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">      <span class="keyword">if</span> mid+<span class="number">1</span> == <span class="built_in">len</span>(nums) &#123; <span class="comment">// 最后一名中奖</span></span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> nums[mid+<span class="number">1</span>] &gt; target &#123;</span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line">      &#125;</span><br><span class="line">      start = mid + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mid</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-加权抽奖"><a href="#2-加权抽奖" class="headerlink" title="2. 加权抽奖"></a>2. 加权抽奖</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个也是我们常规概率抽奖的实现方案</span></span><br><span class="line"><span class="comment">// 前置逻辑需要做好并发相关的处理，包括异常状态处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAwardGenerator</span><span class="params">(users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> sum_num <span class="type">int64</span></span><br><span class="line">  name_arr := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(users))</span><br><span class="line">  <span class="keyword">for</span> u_name, num := <span class="keyword">range</span> users &#123;</span><br><span class="line">    sum_num += num</span><br><span class="line">    name_arr = <span class="built_in">append</span>(name_arr, u_name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> generator <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span></span><br><span class="line">  generator = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    award_num := rand.Int63n(sum_num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> offset_num <span class="type">int64</span></span><br><span class="line">    <span class="keyword">for</span> _, u_name := <span class="keyword">range</span> name_arr &#123;</span><br><span class="line">      offset_num += users[u_name]</span><br><span class="line">      <span class="keyword">if</span> award_num &lt; offset_num &#123;</span><br><span class="line">        <span class="keyword">return</span> u_name</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缺省返回，正常情况下，不会运行到此处</span></span><br><span class="line">    <span class="keyword">return</span> name_arr[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个消息队列"><a href="#实现一个消息队列" class="headerlink" title="实现一个消息队列"></a>实现一个消息队列</h3><p>核心：切片 + 锁</p><h3 id="字符串相加-https-leetcode-cn-com-problems-add-s"><a href="#字符串相加-https-leetcode-cn-com-problems-add-s" class="headerlink" title="[字符串相加](https://leetcode-cn.com/problems/add-s"></a>[字符串相加](<a href="https://leetcode-cn.com/problems/add-s">https://leetcode-cn.com/problems/add-s</a></h3><p>trings&#x2F;)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStrings</span><span class="params">(num1 <span class="type">string</span>, num2 <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">add := <span class="number">0</span></span><br><span class="line">ans := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i, j := <span class="built_in">len</span>(num1) - <span class="number">1</span>, <span class="built_in">len</span>(num2) - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>; i, j = i - <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">x = <span class="type">int</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> j &gt;= <span class="number">0</span> &#123;</span><br><span class="line">y = <span class="type">int</span>(num2[j] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">result := x + y + add</span><br><span class="line">ans = strconv.Itoa(result%<span class="number">10</span>) + ans</span><br><span class="line">add = result / <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求根号2的值"><a href="#求根号2的值" class="headerlink" title="求根号2的值"></a>求根号2的值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找法求近似值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;  </span><br><span class="line">    l, r := <span class="type">float64</span>(<span class="number">0</span>), <span class="type">float64</span>(x)  </span><br><span class="line">    <span class="keyword">for</span> r-l &gt; <span class="number">1e-7</span> &#123;  </span><br><span class="line">        mid := l + (r - l) / <span class="number">2</span>  </span><br><span class="line"><span class="keyword">if</span> mid * mid &lt;= <span class="type">float64</span>(x) &#123;  </span><br><span class="line">            l = mid  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            r = mid  </span><br><span class="line">&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> r  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 牛顿迭代</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">&#125;  </span><br><span class="line">    C, x0 := <span class="type">float64</span>(x), <span class="type">float64</span>(x)  </span><br><span class="line">    <span class="keyword">for</span> &#123;  </span><br><span class="line">        xi := <span class="number">0.5</span> * (x0 + C/x0)  </span><br><span class="line">        <span class="keyword">if</span> math.Abs(x0 - xi) &lt; <span class="number">1e-7</span> &#123;  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">&#125;  </span><br><span class="line">        x0 = xi  </span><br><span class="line">&#125;  </span><br><span class="line">    <span class="keyword">return</span> x0  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> check(root, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(p, q *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &amp;&amp; q == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> || q == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p.Val == q.Val &amp;&amp; check(p.Left, q.Right) &amp;&amp; check(p.Right, q.Left) </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 算法 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>raft</title>
      <link href="/research/distribution/raft101/"/>
      <url>/research/distribution/raft101/</url>
      
        <content type="html"><![CDATA[<p><a href="https://raft.github.io/">一个劲爆的链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 研究所 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 101 </tag>
            
            <tag> raft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>paxos 论文翻译</title>
      <link href="/research/distribution/paxos-original/"/>
      <url>/research/distribution/paxos-original/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 研究所 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mongodb 面试必备</title>
      <link href="/interview/db/mongodb101/"/>
      <url>/interview/db/mongodb101/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 必看必会 </tag>
            
            <tag> mongo </tag>
            
            <tag> nosql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql 面试必备</title>
      <link href="/interview/db/mysql101/"/>
      <url>/interview/db/mysql101/</url>
      
        <content type="html"><![CDATA[<h1 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h1><h2 id="ACID-特性"><a href="#ACID-特性" class="headerlink" title="ACID 特性"></a>ACID 特性</h2><ul><li><p>**原子性(Atomicity)**：事务是一个不可分割的单位，因此在一个事务里的所有操作要么全部生效，要么全部不生效。</p></li><li><p>**一致性(Consistency)**：也可以理解为是预期状态的正确性，即从一个正确的状态到另一个正确的状态，这里的状态往往是由业务来定义的。比如转账中的一个扣钱一个加钱，是我们规定的一个数据流转，那么执行前的账户余额和转账后的账户余额就得满足加减特性，这就是所谓的业务正确。题外话：银行家舍入 —— 四舍六入五考虑，五后非零则进一，五后皆零看奇偶，奇进偶舍不连续。</p></li><li><p>**隔离性(Isolation)**：事务并发执行时，各个事务之间相互影响的程度。</p></li><li><p>**持久化(Durability)**：通过日志等手段，只要我们的事务提交成功了，那么就意味着这次的数据操作是成功的。即使下次重启了程序，也不会丢失此处的操作结果。</p></li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul><li><p><strong>未提交读：</strong> 即所谓的脏读，事务读取的数据可能是另一个事务已修改但还没提交的，这部分数据有可能产生回滚。导致后续的操作依赖了无效的数据。</p></li><li><p><strong>已提交读：</strong> 如果想防止脏读，就需要等待其他事务提交后再进行读取操作。</p></li><li><p><strong>可重复读：</strong> 已提交读的隔离级别考虑到了数据回滚的无效性，却无法阻止事务的多次提交。比如事务 A 不断的对表进行修改提交，那么事务 B 就会在不同的时间点读取到不同的数据。为了让事务 B 在执行期间读取的数据都是一致的，就有了可重复读的隔离级别，即事务 B 在执行期间，其他事务不得进行修改操作。</p></li><li><p><strong>可串行化：</strong> 上面的可重复读隔离级别保证了事务执行期间读取的一致性。然而这里并不包括插入、删除操作。即会出现读多读少数据的情况，这种现象叫做幻读。为了解决幻读，只得进行串行化执行事务，才能互不影响。而此时的事务并发性是最低的</p></li></ul><h1 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h1><h2 id="Mysql-的索引分类"><a href="#Mysql-的索引分类" class="headerlink" title="Mysql 的索引分类"></a>Mysql 的索引分类</h2><ul><li><p><strong>从数据结构划分：</strong> B+ 树、hash 索引、全文索引</p></li><li><p><strong>从物理结构划分：</strong> 聚集索引、非聚集索引</p></li><li><p><strong>从逻辑用户划分：</strong> 主键、唯一索引、复合索引、普通单列索引</p></li></ul><h2 id="聚集索引、非聚集索引、主建的区别"><a href="#聚集索引、非聚集索引、主建的区别" class="headerlink" title="聚集索引、非聚集索引、主建的区别"></a>聚集索引、非聚集索引、主建的区别</h2><ul><li><p>聚集索引：在索引的叶子节点直接存 data 数据, 使用的是物理排序，一个表只能有一个字段设置了聚集索引（因为物理排序规则只能有一个），允许有 null 的数据存在，数据也不一定是唯一的。实现方案是B+树</p></li><li><p>主建：唯一标识某行记录，不允许有 null 的数据，要求数据必须唯一。在设置某个字段为主建时，数据库一般会自动在这个主建上建立一个唯一索引，并且如果之前表没有创建过聚集索引，还会在这个主建上建立一个聚集索引。自增Id强制设定为主键索引，这是为了b+tree和分页。这棵树的非叶子结点上存的都是主键，那如果一个表没有主键会怎么样？在innodb中，如果一个表没有主键，那默认会找建了唯一索引的列，如果也没有，则会生成一个隐形的字段作为主键！</p></li><li><p>非聚集索引：索引的叶子节点存的是数据域的记录指针，需要跳转查找。排序规则是逻辑排序，因此可以有多个非聚集索引存在。非聚集索引的存储结构与聚集索引是一样的，不同的是在叶子结点的数据部分存的不再是具体的数据，而数据的聚集索引的key。所以通过非聚集索引查找的过程是先找到该索引key对应的聚集索引的key，然后再拿聚集索引的key到主键索引树上查找对应的数据，这个过程称为<strong>回表</strong>！</p></li></ul><h2 id="有哪些情况会让索引失效？"><a href="#有哪些情况会让索引失效？" class="headerlink" title="有哪些情况会让索引失效？"></a>有哪些情况会让索引失效？</h2><ul><li><p>在 where 字段 上使用了函数或其他隐式转换</p></li><li><p>Like 模糊查询，开头使用了 “%”，例如 like ‘%hello%’</p></li><li><p>where 条件里使用了 or</p></li><li><p>建立了复合索引，但 where 条件里使用的是第二个字段的搜索</p></li></ul><h2 id="最左匹配原则是指？"><a href="#最左匹配原则是指？" class="headerlink" title="最左匹配原则是指？"></a>最左匹配原则是指？</h2><p>mysql 建立联合索引后，是按最左匹配原则来筛选记录的，即检索数据是从联合索引的第一个字段来筛选的。如果 where 里的条件只有第二个字段，那么将无法应用到索引。</p><h2 id="索引的底层数据结构-B-树是怎么样的？"><a href="#索引的底层数据结构-B-树是怎么样的？" class="headerlink" title="索引的底层数据结构 B+ 树是怎么样的？"></a>索引的底层数据结构 B+ 树是怎么样的？</h2><p>B+ 树是二叉搜索树的一个扩充，是多路搜索树。它只在叶子节点存储具体的数据或者数据的指向指针，而非叶子节点存放索引数据。这样可以降低磁盘 IO，还能充分利用磁盘的预读功能，批量的加载索引数据。</p><p><img src="https://static001.geekbang.org/infoq/46/467603fbd92fdada63040ebad9b7f628.png"></p><h2 id="b-树-b-树-b-树的区别"><a href="#b-树-b-树-b-树的区别" class="headerlink" title="b 树 b+树 b-树的区别"></a>b 树 b+树 b-树的区别</h2><ul><li><p>b 树就是 b-树， 国外叫 b-tree, 也就是 b 树。</p></li><li><p>b-tree 是在非叶子节点存放了数据，在查询索引时，只要找到索引值也就可以找到数据了，这样可以提前终止搜索。但每个节点就得存储索引值+数据值，占用的页空间会比较大，需要的磁盘 io 次数也会变多，即使是不需要关心的数据也会被预加载出来，浪费性能。</p></li><li><p>b+树是将索引值存在非叶子节点，数据值存在叶子节点，这样可以压缩树的高度，减少磁盘 io。</p></li></ul><h2 id="为什么不能在重复率高，例如性别字段上建立索引？"><a href="#为什么不能在重复率高，例如性别字段上建立索引？" class="headerlink" title="为什么不能在重复率高，例如性别字段上建立索引？"></a>为什么不能在重复率高，例如<code>性别</code>字段上建立索引？</h2><p>对于性别这种索引， 由于重复率高，对于 B+树(多路搜索树)来讲，得遍历多条路径，搜索代价大。还不如全表扫描，这样不需要维护索引，降低开销。</p><h2 id="Mysql-的-hash-索引是怎么样，有什么优缺点？"><a href="#Mysql-的-hash-索引是怎么样，有什么优缺点？" class="headerlink" title="Mysql 的 hash 索引是怎么样，有什么优缺点？"></a>Mysql 的 hash 索引是怎么样，有什么优缺点？</h2><p>hash 索引将列通过 hash 运算得到 hash code，然后将 hash code 跟数据行的指针地址关联在一起，下次查找时只需查找对应 hash code 的数据行地址即可。</p><p>hash 索引非常的紧凑，查找速度很快，适用于内存存储引擎的应用。不过它只能精确查询，不支持范围查找，也不能直接进行排序。限制还是挺多的。</p><p><img src="https://static001.geekbang.org/infoq/12/12bc94c294080d240a165e97e0a5f75e.png"></p><h2 id="Mysql-的全文索引"><a href="#Mysql-的全文索引" class="headerlink" title="Mysql 的全文索引"></a>Mysql 的全文索引</h2><p>全文索引主要是用于文档查找，像我们可能会从多篇文章中查找包含某些词语的文章，这时就可以使用全文索引了。虽然 like 也可以使用，但是效率太低了。全文索引在接收到文档时，会对它进行分词处理，以获取到关键词。然后会将关键词和属于这个文档的 id 关联起来。下次查找，就会先到关键词列表里找到关联的文档 id ，最后利用文档 id 去查找到文档数据。</p><h1 id="3-日志"><a href="#3-日志" class="headerlink" title="3. 日志"></a>3. 日志</h1><h2 id="日志类别"><a href="#日志类别" class="headerlink" title="日志类别"></a>日志类别</h2><ul><li><p><strong>binlog：</strong> 二进制日志，记录了数据库对数据的修改记录，包括了 DDL：例如表的创建，数据更新等。但并不包括 select 这些查询语句。binlog 日志是属于逻辑语句的记录，可用于主从数据库的同步。</p></li><li><p><strong>relay log：</strong> 中继日志，用于主从备份恢复使用的。有主服务器的 binlog 逻辑操作语句，以及当前的恢复位置。</p></li><li><p><strong>慢查询日志：</strong> 记录在 mysql 里执行时间超过预期值的耗时语句</p></li><li><p><strong>redo log：</strong> redo log 是对加载到内存数据页的修改结果的记录，和 binlog 不同的是，binlog 记录的是逻辑操作语句，偏向于过程记录。而 redo log 是一个数据页的修改日志，偏向于结果的记录。</p></li><li><p><strong>undo log：</strong> 回滚日志主要用于回滚数据，和 redo log 不一样的是，undo log 是逻辑日志，是一种相反操作的记录，比如在回滚时，如果是 insert 操作时，则会逆向为 delete，delete 操作时，逆向为 insert 操作，更新则恢复到当时的版本数据。</p></li></ul><h2 id="redo-log-相关概念：writepos、checkpoint、prepare、commit"><a href="#redo-log-相关概念：writepos、checkpoint、prepare、commit" class="headerlink" title="redo log 相关概念：writepos、checkpoint、prepare、commit"></a>redo log 相关概念：writepos、checkpoint、prepare、commit</h2><p>redo log 是用来记录当前数据页的修改情况，由于性能问题，每次修改并不会实时同步到硬盘。而是先在内存中修改，然后将修改情况记录到 redo 里，再定时的去将 redo 刷新到硬盘里。因此，redo log 有 2 个位置，一个是 writepos，自己写日志的位置；另一个是 checkpoint，是定时的将数据页同步到硬盘的位置。</p><p>redo log 在写 binlog 日志前会先记录 redo log，记录完后标记为 prepare 状态。当 binlog 也写入完成后，才将 redo log 标记为 commit 状态。只有当 redo log 是 commit 状态时，事务才能真正的 commit。这样能防止主从节点根据 binlog 同步有可能事务不一致的情况。</p><h1 id="4-Mysql-里的锁"><a href="#4-Mysql-里的锁" class="headerlink" title="4. Mysql 里的锁"></a>4. Mysql 里的锁</h1><h2 id="Mysql-里的锁有哪些？"><a href="#Mysql-里的锁有哪些？" class="headerlink" title="Mysql 里的锁有哪些？"></a>Mysql 里的锁有哪些？</h2><h3 id="乐观-x2F-悲观锁"><a href="#乐观-x2F-悲观锁" class="headerlink" title="乐观&#x2F;悲观锁"></a>乐观&#x2F;悲观锁</h3><ul><li><p>乐观锁：在读取数据时会假设各个事务互不影响，它们会处理好属于自己的那部分数据。如果在更新数据时，发现有其他事务修改了属于自己的数据，则会回滚之前的一切操作。</p></li><li><p>悲观锁：采取了先获取锁再访问的保守策略，如果已经有其他事务获取了锁，则必须等待锁释放才能继续。</p></li></ul><h3 id="共享-x2F-排它锁"><a href="#共享-x2F-排它锁" class="headerlink" title="共享&#x2F;排它锁"></a>共享&#x2F;排它锁</h3><ul><li><p>共享锁：又称读锁，当前事务在读取时，允许其他事务并发读取，但不允许其他事务上排它锁，必须等自己释放了才能继续。</p></li><li><p>排它锁：又称写锁，在写锁占有时，如果其他事务想上读写锁，则得排队等待。</p></li></ul><h3 id="表锁-x2F-行锁"><a href="#表锁-x2F-行锁" class="headerlink" title="表锁&#x2F;行锁"></a>表锁&#x2F;行锁</h3><ul><li><p>表锁：在操作数据时，直接将整张表锁住，操作粒度很大，很容易让其他事务在等待，但不会产生死锁。</p></li><li><p>行锁：针对的是行记录的并发控制，锁粒度很细，能支持高并发，但是不排除会有死锁情况产生。在 mysql 里行锁依赖索引实现，如果没有索引存在，则会直接进行表锁！</p></li></ul><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><ul><li><p>记录锁：只锁住某一条记录。当对唯一索引(包括主键)进行精确查询时，会使用记录锁。</p></li><li><p>间隙锁：当使用范围查询时，会对符合条件的区间数据上锁。在涉及到普通索引（即不是唯一索引）的查询时，都会使用间隙锁。</p></li><li><p>Next-key 锁：临建锁，可以理解为 记录锁 + 间隙锁。当对唯一索引进行范围查找或对唯一索引进行查找但结果不存在时（可以理解为锁住不存在的记录），会使用临建锁。</p></li></ul><p>上面的间隙锁、临建锁有效的防止了事务幻读情况产生，避免了在查找期间有数据新增或删除。</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>表锁的一种，它仅仅表示一种操作意向。当我们使用粒度比较小的行锁时，在检测是否有锁时，需要一行一行的检查，效率较低。有了意向锁之后，则不需一行一行的排查，只需检测对应的意向锁即可。</p><h2 id="事务里锁的应用是怎么样的？"><a href="#事务里锁的应用是怎么样的？" class="headerlink" title="事务里锁的应用是怎么样的？"></a>事务里锁的应用是怎么样的？</h2><h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>可重复读使用的是 MVCC 快照，所以在读取数据时大多数时候不需要使用锁。</p><p>但使用了 <code>UPDATE</code>, <code>DELETE</code>，或 <code>SELECT with FOR UPDATE（排它锁） 或 FOR SHARE（共享锁）</code>，则会根据下面的情况来使用锁：</p><ul><li><p>在唯一索引上精确查找某条记录时，使用记录锁</p></li><li><p>对于其他的搜索，InnoDB 将会锁定扫描到的索引范围，使用间隙锁或临建锁来<strong>防止幻读</strong>的产生</p></li></ul><h3 id="读提交"><a href="#读提交" class="headerlink" title="读提交"></a>读提交</h3><p>也是使用 MVCC 机制来读取数据，不过在使用 <code>UPDATE</code>, <code>DELETE</code>，或 <code>SELECT with FOR UPDATE（排它锁） 或 FOR SHARE（共享锁）</code>时和上面的机制不一样，当存储引擎将筛选到的记录交给 mysql server 层后，会对不相干的数据进行解锁，所以不会涉及间隙锁或临建锁。它们只会在做外键约束检查和重复键检查时使用到。由于间隙锁的禁用，可能会<strong>出现幻读</strong>现象。</p><h3 id="未提交读"><a href="#未提交读" class="headerlink" title="未提交读"></a>未提交读</h3><p>在 mysql 的 innodb 存储引擎里做 <code>SELECT</code>操作不会做任何锁动作，如果是 myisam 存储引擎，则会上共享锁。如果使用<code>UPDATE</code>, <code>DELETE</code>，或 <code>SELECT with FOR UPDATE（排它锁） 或 FOR SHARE（共享锁）</code>则和读提交一样的原则。</p><h3 id="可序列化读"><a href="#可序列化读" class="headerlink" title="可序列化读"></a>可序列化读</h3><p>可序列化读在使用 select 时，一般会自动的转化为 SELECT … FOR SHARE（共享锁），以保证读写序列化。</p><h2 id="lock-in-share-mode-和-for-update-里间隙锁什么时候会应用？"><a href="#lock-in-share-mode-和-for-update-里间隙锁什么时候会应用？" class="headerlink" title="lock in share mode 和 for update 里间隙锁什么时候会应用？"></a>lock in share mode 和 for update 里间隙锁什么时候会应用？</h2><ul><li><p>lock in share mode, for update 如果 where 条件是非索引类的，则不会加间隙锁；</p></li><li><p>lock in share mode, for update 如果 where 条件是主键类的，并且找不到记录时会加间隙锁；如果找到记录了则会将间隙锁给释放了。比如 where 主键 &#x3D; 3 能找到记录时则不会加间隙锁，找不到时会在该数据的前后叶子节点间加间隙锁；此时假如记录里只有 1，8，9，则会在 1, 8 之间加间隙锁</p></li><li><p>lock in share mode, for update 如果 where 条件是非聚集索引类的，会加间隙锁，即使找不到记录。</p></li></ul><h2 id="锁超时的配置"><a href="#锁超时的配置" class="headerlink" title="锁超时的配置"></a>锁超时的配置</h2><p>当 mysql 获取锁超时时候，如果系统变量 innodb_rollback_on_timeout 为 off ,则当前事务只会回滚最后一条 sql, 所以建议设置 innodb_rollback_on_timeout 为 on, 这样在获取锁超时时可以回滚全部 sql。</p><h1 id="5-MVCC-是指什么？"><a href="#5-MVCC-是指什么？" class="headerlink" title="5. MVCC 是指什么？"></a>5. MVCC 是指什么？</h1><p>MVCC 即<strong>多版本并发控制</strong>，它利用了 undo log 会在数据修改时保留上一个修改记录指针的特点，使得每个事务对数据的修改能有自己的历史版本追溯，就像镜像备份一样。当进行读操作时，如果有其他写操作的事务并发进行，那么此时可以根据事务的隔离级别选择读取最新版本亦或自己之前版本的数据。MVCC 不需要加锁的，它能提高事务的并发处理能力。</p><h1 id="6-mysql-的复制技术"><a href="#6-mysql-的复制技术" class="headerlink" title="6. mysql 的复制技术"></a>6. mysql 的复制技术</h1><ul><li><p>全同步复制：只有等所有的 slave 节点将同步的日志写入 relay log，并且响应 ack 确认后，此次的事务才会提交。数据完整性高，但性能低</p></li><li><p>半同步复制：只要有一个 salve 节点响应 ack 后就可以认为同步成功，但细分为了两种，一种是 <code>AFTER_COMMIT</code>：先在主库提交事务, 然后同步从库, 等待从库的 ack 确认. 才告诉客户端是否 Ok。另一种是 <code>AFTER_SYNC</code>：主库先不提交事务, 只有从库 有 replay log ,回复了 ack 后才进行提交事务。后面一种数据一致性较高</p></li><li><p>异步复制：一旦有需要复制的就通知 slave, 但不会等待确认成功才进行后续操作。</p></li></ul><h1 id="7-存储引擎"><a href="#7-存储引擎" class="headerlink" title="7. 存储引擎"></a>7. 存储引擎</h1><h2 id="Mysql-存储引擎有哪些以及特点？"><a href="#Mysql-存储引擎有哪些以及特点？" class="headerlink" title="Mysql 存储引擎有哪些以及特点？"></a>Mysql 存储引擎有哪些以及特点？</h2><ul><li><p><strong>InnoDB：</strong> 它是 mysql 的默认存储引擎，能够实现 ACID 特性的事务，并且能提交、回滚、恢复数据，能很好的保障用户数据。同时支持了行级锁、聚集索引以及外键约束，是一个完善的存储引擎。</p></li><li><p><strong>MyISAM：</strong> 是 mysql 最开始的存储引擎，占用空间小，能快速存储，但不支持事务，提供了基于表级别的锁粒度，适用于配置或只读功能的应用程序。</p></li><li><p><strong>Memory：</strong> 数据都是存在内存里的，能提供快速访问，不过应该较少人使用，毕竟一旦断电数据也就丢失了。</p></li><li><p><strong>CSV：</strong> 带有逗号分隔值的文本文件，没有索引存在。但是兼容性很好，可以跟其他的程序交换数据。</p></li></ul><h2 id="myisam-存储引擎和-innodb-的区别"><a href="#myisam-存储引擎和-innodb-的区别" class="headerlink" title="myisam 存储引擎和 innodb 的区别"></a>myisam 存储引擎和 innodb 的区别</h2><ul><li><p>innoDB 支持事务，myisam 不支持</p></li><li><p>innoDB 支持行锁，myisam 不支持，只能到表锁</p></li><li><p>innoDB 支持外键，myisam 不支持</p></li><li><p>innoDB 不支持全文索引，myisam 支持</p></li><li><p>innoDB 支持聚集索引 和 非聚集索引；myISAM 只支持非聚集索引，该索引存的是数据域的记录指针，还得跳转查找。</p></li></ul><h1 id="8-Mysql-的三层架构"><a href="#8-Mysql-的三层架构" class="headerlink" title="8. Mysql 的三层架构"></a>8. Mysql 的三层架构</h1><ul><li><p><strong>连接层：</strong> 主要负责连接池、通信协议、认证授权等；</p></li><li><p><strong>SQL 层：</strong> 这一层是 mysql 的大脑，通过一系列组件得到数据操作的最优解。</p></li><li><p><strong>存储层：</strong> 负责数据的存储、检索。</p></li><li><p><img src="https://static001.geekbang.org/infoq/7b/7b8895802bcf0c023f64a3ed741c1e46.pngc_center"></p></li></ul><h1 id="9-执行计划是什么？怎么看？"><a href="#9-执行计划是什么？怎么看？" class="headerlink" title="9. 执行计划是什么？怎么看？"></a>9. 执行计划是什么？怎么看？</h1><p>执行计划是 mysql 根据我们的查询语句进行一系列的分析后得到的优化方案。我们可以通过执行计划来获取执行过程。</p><p>执行计划的获取：</p><p><code>explain select 语句</code>  </p><p><img src="https://static001.geekbang.org/infoq/da/da4a15afe4d3bf624e33a136db3eac93.png"></p><p>涉及的字段含义如下：</p><ul><li><p>id： 该 SELECT 标识符</p></li><li><p>select_type： 该 SELECT 类型</p></li><li><p>table： 输出行的表</p></li><li><p>partitions： 匹配的分区</p></li><li><p>type： 联接类型</p></li><li><p>possible_keys： 可供选择的可能索引</p></li><li><p>key： 实际选择的索引</p></li><li><p>key_len： 所选密钥的长度</p></li><li><p>ref： 与索引比较的列</p></li><li><p>rows： 估计要检查的行数</p></li><li><p>filtered： 按表条件过滤的行百分比</p></li><li><p>Extra： 附加信息</p></li></ul><p>其中，有个 type 字段，它的含义大概如下：</p><ul><li><p>eq_ref： 使用到了 UNIQUE 或 PRIMARY KEY 索引</p></li><li><p>ref： 显示索引的哪一列被使用了</p></li><li><p>ref_or_null： 对 Null 进行了索引优化</p></li><li><p>range： 索引范围检索</p></li><li><p>index： 索引扫描</p></li><li><p>unique_subquery： 使用了 in 子查询，里面涉及了主键字段</p></li><li><p>index_subquery： 使用了 in 子查询，里面涉及了非唯一索引</p></li><li><p>fulltext： 全文索引</p></li><li><p>all： 全表扫描数据</p></li></ul><p>从上面大概就能分析出索引的使用情况了，如果是 all，那就是没有用到索引了。</p><h1 id="10-SQL-注入的现象是？"><a href="#10-SQL-注入的现象是？" class="headerlink" title="10. SQL 注入的现象是？"></a>10. SQL 注入的现象是？</h1><p>在拼接 SQL 语句时，直接使用客户端传递过来的值拼接，如果客户端传来包含 <code>or 1=1</code> 类似的语句，那么就会筛选到非预期的结果，进而达到欺骗服务器的效果。</p><p>解决方案是使用现在数据库提供的预编译（prepare）和查询参数绑定功能，例如使用占位符 <code>?</code>，然后将带有占位符的 SQL 语句交给数据库编译，这样数据库就能知道要执行的是哪些语句，条件值又是哪些，而不会混杂在一起。</p><h1 id="11-UNION-和-UNION-ALL-的区别？"><a href="#11-UNION-和-UNION-ALL-的区别？" class="headerlink" title="11. UNION 和 UNION ALL 的区别？"></a>11. UNION 和 UNION ALL 的区别？</h1><ul><li><p>UNION ALL：将所有的数据联合起来，即使有重复数据</p></li><li><p>UNION：会合并重复数据</p></li></ul><h1 id="12-为什么尽量使用自增-ID，而不是-UUID？"><a href="#12-为什么尽量使用自增-ID，而不是-UUID？" class="headerlink" title="12. 为什么尽量使用自增 ID，而不是 UUID？"></a>12. 为什么尽量使用自增 ID，而不是 UUID？</h1><p>自增 ID 是由有序的，而 UUID 是无序的，如果该字段作为索引，那么就会很容易打破 B+ 树的平衡，进而不断的在进行磁盘数据页的调整，导致性能下降</p><h1 id="13-分库分表有哪些？有什么优缺点？"><a href="#13-分库分表有哪些？有什么优缺点？" class="headerlink" title="13. 分库分表有哪些？有什么优缺点？"></a>13. 分库分表有哪些？有什么优缺点？</h1><ul><li><p>分库：从业务角度进行切分</p></li><li><p>分表：将数据根据一定的规则落在多张表上。比如按时间范围来切分，或者通过对 ID 进行 Hash 来路由到对应的表上。</p></li></ul><p>分库分表后使得数据不再集中到一张表上，但也带来了维护以及其他处理问题。比如原来的事务变为分布式事务；原来的 join 操作将要变为在应用层序做过滤；还有数据的后续迁移、扩容规划等。</p><h1 id="14-内连接、外连接区别"><a href="#14-内连接、外连接区别" class="headerlink" title="14. 内连接、外连接区别"></a>14. 内连接、外连接区别</h1><ul><li><p>内连接：只有符合条件的记录才会出现在结果集里</p></li><li><p>外连接：其结果集中不仅包含符合连接条件的行，还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。</p></li></ul><h1 id="15-常见的数据库优化"><a href="#15-常见的数据库优化" class="headerlink" title="15. 常见的数据库优化"></a>15. 常见的数据库优化</h1><ul><li><p>对经常出现在 where 条件里，并且数据重复率不高的字段建立索引</p></li><li><p>使用 JOIN 来代替子查询；</p></li><li><p>能使用 in 就不使用 or，前者能命中索引，后者会让索引失效</p></li><li><p>避免在 where 字段上计算，例如 where a &#x2F; 3 &#x3D; 1，这样会让索引失效；避免在 where 字段上使用 NULL 值的判断</p></li><li><p>打开慢查询日志配置，有针对性的分析响应缓慢的语句。</p></li></ul><h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="sql的执行顺序"><a href="#sql的执行顺序" class="headerlink" title="sql的执行顺序"></a>sql的执行顺序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from on where group by having select distinct order by limit</span><br></pre></td></tr></table></figure><h3 id="一条SQL更新语句执行顺序"><a href="#一条SQL更新语句执行顺序" class="headerlink" title="一条SQL更新语句执行顺序"></a>一条SQL更新语句执行顺序</h3><p>通过分析器分析，执行和查询语句一样。然后写redo log(是个循环日志文件。写完redo log同步到内存中，适当时机更新到磁盘中) 和 binary log，与redo log 采取二阶段事务提交</p><h3 id="事务隔离级别，怎么选择，为什么"><a href="#事务隔离级别，怎么选择，为什么" class="headerlink" title="事务隔离级别，怎么选择，为什么"></a>事务隔离级别，怎么选择，为什么</h3><h4 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h4><p>会读到未提交的事务，脏读，不可重复读，幻读</p><p>幻读：指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的数据行。</p><h4 id="不可重复读（rc）"><a href="#不可重复读（rc）" class="headerlink" title="不可重复读（rc）"></a>不可重复读（rc）</h4><p>别的事务提交，而能直接读到别的事务提交的结果，和别的事务提交之前的不一样，所以不可重复读</p><h4 id="可重复读-rr"><a href="#可重复读-rr" class="headerlink" title="可重复读(rr)"></a>可重复读(rr)</h4><p>读取是从快照中读取，即使别的事务提交仍读的是旧的</p><h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><p>锁表，别人读的时候，你不能干任何事情</p><h4 id="使用RC为默认隔离级别"><a href="#使用RC为默认隔离级别" class="headerlink" title="使用RC为默认隔离级别"></a>使用RC为默认隔离级别</h4><p>innodb默认为RR隔离级别，是由于历史原因binary log同步的原因，默认使用的是statement记录操作语句（是以commit的顺序为记录）。就会出现主从不一致的情况。</p><ol><li>在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多！</li><li>在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行</li><li>在RC隔离级别下，半一致性读(semi-consistent)特性增加了update操作的并发性！</li></ol><p>在RC级别下，不可重复读问题需要解决么？<br>不用解决，这个问题是可以接受的！毕竟你数据都已经提交了，读出来本身就没有太大问题！Oracle的默认隔离级别就是RC，你们改过Oracle的默认隔离级别么？</p><p>在RC级别下，主从复制用什么binlog格式？<br>OK,在该隔离级别下，用的binlog为row格式，是基于行的复制！Innodb的创始人也是建议binlog使用该格式！</p><h3 id="说说你了解的索引"><a href="#说说你了解的索引" class="headerlink" title="说说你了解的索引"></a>说说你了解的索引</h3><p>聚簇索引，使用的是B+ 树类型。</p><p>主键索引，存放的是value和索引</p><p>其余的只存放索引，需要回表查询。因为叶子节点只存放索引。</p><p>索引类型：</p><ol><li>主键索引</li><li>唯一索引</li><li>普通索引</li><li>联合索引</li></ol><p>explain中的字段</p><ul><li><p>id</p><ul><li>id 相同的情况下，执行顺序由上而下</li><li>如果是子查询，id 越大，越先执行</li><li>小表驱动大表</li></ul></li><li><p>select_type</p><ul><li>simple 简单的查询不包含子查询或者union</li><li>primary 主查询，最后加载</li><li>subquery 子查询</li><li>derived 衍生的临时表</li><li>union<ul><li>若第二个select出现在union之后，则标记为union</li><li>若union包含在from子句的子查询中，则外层select标记为derived</li></ul></li><li>union result 从union表获取结果的select<ul><li>两个union合并的select</li></ul></li></ul></li><li><p>table 哪张表</p></li><li><p>type</p><ul><li>从最好到最差依次<ul><li>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all</li><li>system 只有一条记录的单表，系统表</li><li>const 相当于primary key 或 unique 等于一个数值 where id &#x3D;1</li><li>eq_ref 唯一索引 t1.id&#x3D;t2.id</li><li>ref 普通索引，非唯一值</li><li>range 只检索给定范围的行，使用一个索引来选择行</li><li>index 遍历所有索引</li><li>all 全表扫描，需要优化</li></ul></li></ul></li><li><p>possible_keys，key</p><ul><li>可能用到的索引和实际用到的索引</li><li>覆盖索引不会显示在possible_keys上，只会显示在key中</li></ul></li><li><p>key_len</p><ul><li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</li><li>同样的查询结果，长度越少越好</li></ul></li><li><p>ref</p><ul><li>显示索引的哪一列被使用,如果可能的话，是一个常量，哪些列或常量被用于查找索引列上的值</li><li>const 常量</li><li>test1.t1.id</li></ul></li><li><p>rows</p><ul><li>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数</li><li>理论上影响了多少行</li></ul></li><li><p>extra</p><ul><li>不适合在其他列中显示但是十分重要的额外信息</li><li>using filesort<ul><li>mysql 无法利用索引完成的排序，文件排序</li></ul></li><li>using temporary<ul><li>对查询结果，使用了临时表 order by ,group by</li><li>最好使用覆盖索引，不要产生临时表</li></ul></li><li>using index<ul><li>表示相应的select 操作中使用了覆盖索引</li><li>同时出现using where ，表明索引被用来执行索引键值的查找</li><li>没出现using where，表明索引用来读取数据而非执行查找动作</li></ul></li><li>using where<ul><li>使用了 where</li></ul></li><li>using join buffer<ul><li>join 多，而使用了缓冲区</li></ul></li><li>impossible where<ul><li>where子句的值是false</li></ul></li></ul></li><li><p>两表加索引</p><ul><li>左连接<ul><li>加子表上，主表的数据全部都要，加了索引也没用，子表不一定都要，可以加索引优化</li><li>sql执行的顺序为 from on join 其中 on就是可以用到索引的地方</li></ul></li><li>右连接相反</li><li>join 语句的优化<ul><li>尽可能减少join语句的Nestedloop的循环总次数，永远用小结果集驱动大结果集</li><li>优先优化NestedLoop的内层循环</li><li>保证Join语句中被驱动表上Join条件字段已经被索引</li><li>当无法保证被驱动表的Join条件字段被索引且内存资源充足的前提下，不要太吝啬JoinBuffer的设置</li></ul></li></ul></li><li><p>索引失效的情况：</p><ul><li>全值匹配我最爱</li><li>违背最左前缀原则</li><li>跳过索引中的列</li><li>某列属于联合索引，对该列进行范围查询，值使用部分索引，该列右边的列无法使用索引</li><li>!&#x3D;,is null,is not null</li><li>like以通配符开头<ul><li>解决%like% 索引时不能失效的方法</li><li>使用覆盖索引可以解决</li></ul></li><li>用or连接条件</li><li>不在索引列上做任何操作（计算，函数，自动or手动类型转换，会导致索引失效而转向全表扫描）</li><li>尽量使用覆盖索引</li><li>字符串不加单引号索引失效</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 必看必会 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis面试必备</title>
      <link href="/interview/db/redis101/"/>
      <url>/interview/db/redis101/</url>
      
        <content type="html"><![CDATA[<h2 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><h3 id="1-分布式系统中常用的缓存方案有哪些？"><a href="#1-分布式系统中常用的缓存方案有哪些？" class="headerlink" title="1. 分布式系统中常用的缓存方案有哪些？"></a>1. 分布式系统中常用的缓存方案有哪些？</h3><ul><li>客户端缓存：页面和浏览器缓存，app 缓存，h5 缓存，localStorage，sessionStorage</li><li>CDN：内容存储&#x3D;数据存储，内容分发&#x3D;负载均衡</li><li>Nginx 缓存： 静态资源</li><li>服务端缓存：本地缓存，外部缓存</li><li>数据库缓存：持久缓存（mybatis，hibernate 多级缓存），mysql 查询缓存</li><li>操作系统缓存：page cache，buffer cache</li></ul><h3 id="2-常见的缓存淘汰算法"><a href="#2-常见的缓存淘汰算法" class="headerlink" title="2. 常见的缓存淘汰算法"></a>2. 常见的缓存淘汰算法</h3><ul><li>FIFO - 先进先出</li><li>LRU - 最近最少使用</li><li>LFU - 最不经常使用</li></ul><h3 id="3-Redis-如何配置-Key-的过期时间？他的实现原理是什么？"><a href="#3-Redis-如何配置-Key-的过期时间？他的实现原理是什么？" class="headerlink" title="3. Redis 如何配置 Key 的过期时间？他的实现原理是什么？"></a>3. Redis 如何配置 Key 的过期时间？他的实现原理是什么？</h3><ul><li>Expire or SETNX</li><li>原理：<ul><li>定期删除：每隔一段时间，执行一次删除过期 Key 的操作（批量脚本）</li><li>懒汉式删除：每当使用 get，getset 等指令去获取数据时，判断 key 是否过期，过期的话就先删除再操作</li><li>redis 同时使用两者，平衡执行频率和执行时长</li></ul></li></ul><h3 id="4-Redis-线程模型，单线程为什么快？"><a href="#4-Redis-线程模型，单线程为什么快？" class="headerlink" title="4. Redis 线程模型，单线程为什么快？"></a>4. Redis 线程模型，单线程为什么快？</h3><ul><li>基于 Reactor 开发了网络时间处理器 - 文件事件处理器，采用 IO 多路复用监听多个 Socket</li><li>纯内存操作、核心基于非阻塞的 IO 多路复用机制、单线程避免了多线程反复上下文切换的性能问题</li></ul><h3 id="5-redis-的常见结构及应用场景"><a href="#5-redis-的常见结构及应用场景" class="headerlink" title="5. redis 的常见结构及应用场景"></a>5. redis 的常见结构及应用场景</h3><ul><li>string<ul><li>id&#x2F;id_info 缓存  </li><li>计数器  </li><li>setnx 分布式锁 </li><li>分布式ID</li></ul></li><li>list<ul><li>当队列用，最近100个购买用户信息  </li><li>当栈用  </li><li>非实时分页列表，比如小时榜，日榜，周榜</li><li>存储微博、微信公众号等消息流数据</li></ul></li><li>hash<ul><li>相比string获取单个字段节省 序列化与反序列化操作</li></ul></li><li>set<ul><li>取交、并、差集  </li><li>点赞、收藏、关注等…</li></ul></li><li>sorted set<ul><li>排行榜功能，实时分页列表，实时榜单等</li></ul></li></ul><h3 id="6-redis-集群方案"><a href="#6-redis-集群方案" class="headerlink" title="6. redis 集群方案"></a>6. redis 集群方案</h3><ul><li>主从模式</li><li>哨兵模式<ul><li>概念<ul><li>集群监控：监控主从是否正常</li><li>消息通知：故障通知</li><li>故障转移：主挂了，移到从身上</li><li>配置中心：通知 client 新的 master 地址</li></ul></li><li>本身也是分布式的，具体方案：<ul><li>通常3个哨兵实例来保证健壮性</li><li>即使哨兵自己挂了，还是可以正常工作</li><li>不保证数据领丢失，可以说主从结构就不保证</li><li>判断故障需要用<code>分布式选举</code>获得大部分哨兵统一才行</li></ul></li></ul></li><li>Redis cluster：服务端 Sharding 计数。采用槽的概念，一共16384个槽，请求发送至任意节点<ul><li>方案说明<ul><li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽（哈希值）区间的数据</li><li>每份数据分片会存储在多个互为主从的多节点上</li><li>数据先写入主节点，再<code>阻塞</code>同步至从节点</li><li>同一分片之间不保证强一致性</li><li>扩容时需要把旧节点数据也迁移一部分至新节点</li></ul></li><li>gossip 协议，多主多从</li></ul></li></ul><h3 id="7-redis-持久化方案"><a href="#7-redis-持久化方案" class="headerlink" title="7. redis 持久化方案"></a>7. redis 持久化方案</h3><ol><li>RDB：Redis Database<br>指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作是 fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，使用二进制压缩存储。<br>优点：</li></ol><ul><li>整个 redis 只包含一个文件 dump.rdb，方便持久化</li><li>容灾性好，易于备份</li><li>性能最大化，使用子进程处理，保证主进程 IO 吞吐，保证了 redis 的高性能</li><li>相对于数据集大时，比 AOF 的启动效率更高<br>缺点：</li><li>数据安全性低，因为会有间隔时间，所以如果间隔期间出现故障，无法保证期间的数据正常备份</li><li>当数据集较大时，子进程长期占用 CPU，会导致服务中断时间延长至秒级</li></ul><ol start="2"><li>AOF：Append Only File<br>以日志的形式记录服务器处理的每个读写操作，以文本的方式详细记录，可以查看历史操作记录<br>优点：</li></ol><ul><li>数据安全：每秒同步、每修改同步、不同步3中策略。每秒同步可以理解为类似1s间隔的 RDB ，可能也会出现丢失的情况；每修改同步可以认为是同步持久化，不会丢失</li><li>通过 append 方式追加新的操作，不惧宕机，可以使用 redis-check-aof 工具来解决一致性的问题。</li><li>rewrite 模式可以定期对 AOF 文件重写，合并相关操作，以达到压缩存储的目的<br>缺点</li><li>AOF 文件较大，恢复速度慢</li><li>数据集大的情况下，启动比 RDB 慢</li><li>运行效率 AOF &lt; RDB</li></ul><p>4.x版本后，把重写方式变成 RDB 直接放到 AOF 文件的头部，比以前版本更快</p><ol start="3"><li>主从同步</li></ol><ul><li>全量复制：<ul><li>主节点通过 bgsave 命令 fork 子进程进行 rdb 持久化，过程非常消耗CPU，内存，硬盘io</li><li>主节点将rdb文件通过网络发给从节点，消耗带宽</li><li>从节点清空数据，使用rdb文件载入，整个过程阻塞，无法响应命令</li></ul></li><li>部分复制：<ul><li>复制偏移量，双方都要维护</li><li>复制积压缓冲区：定长FIFO的队列作为缓冲区</li></ul></li></ul><h3 id="8-Redis-的过期键的删除策略"><a href="#8-Redis-的过期键的删除策略" class="headerlink" title="8. Redis 的过期键的删除策略"></a>8. Redis 的过期键的删除策略</h3><ol><li>惰性过期：访问一个 key 的时候才判断这个 key 是否已经过期，该策略可以最大化的节省 CPU 资源，但是对内存不友好，会存在大量的过期 key 没有被再次访问，从而不会被清除，占用内存</li><li>定期过期：每隔一定的时间，扫描数据库中一定量的 expire 字典中的 key，并清除其中已经过期的 key。该策略是前两者的一个折中方案，通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使内存和 CPU 达到最优平衡</li><li>二种策略同时生效</li></ol><h3 id="9-描述下缓存穿透、击穿、雪崩，以及解决方案"><a href="#9-描述下缓存穿透、击穿、雪崩，以及解决方案" class="headerlink" title="9. 描述下缓存穿透、击穿、雪崩，以及解决方案"></a>9. 描述下缓存穿透、击穿、雪崩，以及解决方案</h3><p>数据库是架构的瓶颈，要尽量保证有效请求到达数据库，可以酌情放大链路上前置位置的复杂度和成本<br>c client；redis ； db&#x2F;mysql</p><p>穿透：缓存和db中都找不到该数据 &#x3D; db中无数据，redis无数据，大量并发，请求打到db层<br>解法：接口层增加鉴权，业务层增加有效请求判断；返回空 &amp;&amp; 增加短效的空缓存；布隆过滤器；业务加互斥锁</p><p>击穿：热点key过期 or key从来没有被访问过 &#x3D; db中有数据，大量并发，redis无缓存，请求打到db层<br>解法：热点数据永不过期；互斥锁（挡住大量重复的并发请求）</p><p>雪崩：N个key的都过期了（没有被缓存到） &#x3D; db中有，大量并发，redis无缓存，请求打到db层<br>解法：缓存数据设置随机过期时间；增加缓存失效标记位；缓存预热；互斥锁</p><p>流程： 请求redis，查不到 –&gt; 大家抢锁 O（1） –&gt; 抢上的查db，并更新缓存 O（1） –&gt; 没抢上的重复请求Redis ，拿到数据<br>延伸问题：多个等待的请求，是blocking的轻量级进程，不参与cpu及内核调度，注意处理线程池即可</p><ul><li>sorted set  <ul><li>实时分页列表，如实时榜单</li></ul></li></ul><ul><li>一般就是当缓存用</li><li>单线程模型</li><li>目的是服务无状态：session，token等；分布式锁</li><li>无锁化？</li></ul><h3 id="2-单线程还是多线程？"><a href="#2-单线程还是多线程？" class="headerlink" title="2. 单线程还是多线程？"></a>2. 单线程还是多线程？</h3><ul><li>工作线程都是单线程：<ul><li>操作是原子的单指令 pipeline</li><li>事务 vs pipeline ：事务执行期间是原子的；执行失败就是失败，其他指令继续执行，没有回滚 –&gt; redis 少使用事务 &amp;&amp; 事务内的指令少 + 快</li></ul></li><li>6.x+版本出现了 io 多线程</li></ul><hr><ul><li>详细理解 io 多线程 ：内核，网络通信（懂了再说）</li><li>单线程，满足 redis 的串行原子；io 多线程以后，把输入&#x2F;输出放到线程中并行，好处是：执行时间快；更好的压榨系统及硬件的资源</li></ul><h3 id="3-redis-存在线程安全的问题么？为什么？"><a href="#3-redis-存在线程安全的问题么？为什么？" class="headerlink" title="3. redis 存在线程安全的问题么？为什么？"></a>3. redis 存在线程安全的问题么？为什么？</h3><ul><li>参考问题2，redis核心是单线程串行，业务使用的时候需要自行保障线程安全</li></ul><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><h3 id="5-缓存如何回收？"><a href="#5-缓存如何回收？" class="headerlink" title="5. 缓存如何回收？"></a>5. 缓存如何回收？</h3><p>后台轮询，分批分阶段的删除过期key<br>请求的时候判断是否需要过期<br>尽量吧内存无用的空间收回来</p><h3 id="6-缓存如何淘汰的？"><a href="#6-缓存如何淘汰的？" class="headerlink" title="6. 缓存如何淘汰的？"></a>6. 缓存如何淘汰的？</h3><p>内存空间不足<br>淘汰机制<br>lru，lfu，random，ttl<br>全空间<br>设置了过期时间的key的集合中</p><h3 id="7-如何进行缓存预热？"><a href="#7-如何进行缓存预热？" class="headerlink" title="7. 如何进行缓存预热？"></a>7. 如何进行缓存预热？</h3><p>提前加载数据（很难判断哪些是真正的热数据，常常会出现缓存失败的情况）<br>开发逻辑上要应对差集数据造成的 击穿，穿透，雪崩</p><h3 id="8-数据库和缓存不一致如何解决？"><a href="#8-数据库和缓存不一致如何解决？" class="headerlink" title="8. 数据库和缓存不一致如何解决？"></a>8. 数据库和缓存不一致如何解决？</h3><p>恶心点的使用事务，但是意义不大，场景多为读多写极少，仅仅在秀肌肉<br>业务写db，然后redis更新缓存<br>业务写到消息队列中，redis和db同时消费数据，同时更新<br>redis缓存，更倾向于允许稍微的时差<br>总思路是减少db操作<br>落地的话，canal</p><h3 id="9-redis-主从不一致如何解决？"><a href="#9-redis-主从不一致如何解决？" class="headerlink" title="9. redis 主从不一致如何解决？"></a>9. redis 主从不一致如何解决？</h3><p>redis 默认弱一致性，主从异步同步<br>分布式锁不能用主从，可以用单实例、分片集群、redlock –&gt; redisson<br>配置中可以配置同步因子，总趋向于强一致性</p><h3 id="10-redis-持久化原理"><a href="#10-redis-持久化原理" class="headerlink" title="10. redis 持久化原理"></a>10. redis 持久化原理</h3><p>当前线程阻塞服务<br>后台异步进程完成持久化</p><h3 id="11-并发超量，redis-崩溃后如何处理？"><a href="#11-并发超量，redis-崩溃后如何处理？" class="headerlink" title="11. 并发超量，redis 崩溃后如何处理？"></a>11. 并发超量，redis 崩溃后如何处理？</h3><p>雪崩击穿穿透处理方案</p><h3 id="12-为啥使用setnx"><a href="#12-为啥使用setnx" class="headerlink" title="12. 为啥使用setnx"></a>12. 为啥使用setnx</h3><p>原子，不存在即创建<br>分布式锁，用 set k v nx ex 不存在，过期时间，避免死锁</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 必看必会 </tag>
            
            <tag> 并发 </tag>
            
            <tag> raft </tag>
            
            <tag> nosql </tag>
            
            <tag> redis </tag>
            
            <tag> 哨兵 </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang并发编程</title>
      <link href="/golang/concurrency/go-sync/"/>
      <url>/golang/concurrency/go-sync/</url>
      
        <content type="html"><![CDATA[<h3 id="go-并发控制"><a href="#go-并发控制" class="headerlink" title="go 并发控制"></a>go 并发控制</h3><p>实际生产中，WaitGroup 和 Channel 是常见的 2 种并发控制的方式。<br>如果有一系列任务，需要这些任务全部完成以后才能继续执行，WaitGroup 非常适合于这类场景，例如下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doTask</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">  time.Sleep(time.Duration(n))  </span><br><span class="line">  fmt.Printf(<span class="string">&quot;Task %d Done\n&quot;</span>, n)  </span><br><span class="line">  wg.Done()  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;  </span><br><span class="line">    wg.Add(<span class="number">1</span>)  </span><br><span class="line">    <span class="keyword">go</span> doTask(i + <span class="number">1</span>)  </span><br><span class="line">  &#125;  </span><br><span class="line">  wg.Wait()  </span><br><span class="line">  fmt.Println(<span class="string">&quot;All Task Done&quot;</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Task 3 Done  </span></span><br><span class="line"><span class="comment">// Task 1 Done  </span></span><br><span class="line"><span class="comment">// Task 2 Done  </span></span><br><span class="line"><span class="comment">// All Task Done  </span></span><br></pre></td></tr></table></figure><p><code>wg.Wait()</code> 会等待所有的子任务全部完成，所有子协程结束后，才会执行 <code>wg.Wait()</code> 后面的代码。<br>WaitGroup 只能等待子任务全部完成才能执行下一步，那么如果我们想要在主进程中通知子协程退出呢？这种场景下，可以使用 <code>select + chan</code> 机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stop <span class="keyword">chan</span> <span class="type">bool</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reqTask</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;  </span><br><span class="line">  <span class="keyword">for</span> &#123;  </span><br><span class="line">    <span class="keyword">select</span> &#123;  </span><br><span class="line">      <span class="keyword">case</span> &lt;-stop:  </span><br><span class="line">      fmt.Println(<span class="string">&quot;stop&quot;</span>, name)  </span><br><span class="line">      <span class="keyword">return</span>  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">      fmt.Println(name, <span class="string">&quot;send request&quot;</span>)  </span><br><span class="line">      time.Sleep(<span class="number">1</span> * time.Second)  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  stop = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)  </span><br><span class="line">  <span class="keyword">go</span> reqTask(<span class="string">&quot;worker&quot;</span>)  </span><br><span class="line">  time.Sleep(<span class="number">3</span> * time.Second)  </span><br><span class="line">  stop &lt;- <span class="literal">true</span>  </span><br><span class="line">  time.Sleep(<span class="number">3</span> * time.Second)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// worker send request  </span></span><br><span class="line"><span class="comment">// worker send request  </span></span><br><span class="line"><span class="comment">// worker send request  </span></span><br><span class="line"><span class="comment">// stop worker  </span></span><br></pre></td></tr></table></figure><p>更复杂的场景如何做并发控制呢？Go 语言提供了 Context 标准库可以解决这类场景的问题，Context 的作用和它的名字很像，上下文，即子协程的下上文。Context 有两个主要的功能：</p><ul><li>通知子协程退出（正常退出，超时退出等）；</li><li>传递必要的参数。</li></ul><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p><code>context.WithCancel()</code> 创建可取消的 Context 对象，即可以主动通知子协程退出。</p><h3 id="2-1-控制单个协程"><a href="#2-1-控制单个协程" class="headerlink" title="2.1 控制单个协程"></a><a href="https://geektutu.com/post/quick-go-context.html#2-1-%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AA%E5%8D%8F%E7%A8%8B" title="2.1 控制单个协程"></a>2.1 控制单个协程</h3><p>使用 Context 改写上述的例子，效果与 <code>select+chan</code> 相同。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20  </p><p>func reqTask(ctx context.Context, name string) {<br> for {<br> select {<br> case &lt;-ctx.Done():<br> fmt.Println(“stop”, name)<br> return<br> default:<br> fmt.Println(name, “send request”)<br> time.Sleep(1 * time.Second)<br> }<br> }<br>}  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithCancel(context.Background())<br> go reqTask(ctx, “worker1”)<br> time.Sleep(3 * time.Second)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><ul><li><code>context.Backgroud()</code> 创建根 Context，通常在 main 函数、初始化和测试代码中创建，作为顶层 Context。</li><li><code>context.WithCancel(parent)</code> 创建可取消的子 Context，同时返回函数 <code>cancel</code>。</li><li>在子协程中，使用 select 调用 <code>&lt;-ctx.Done()</code> 判断是否需要退出。</li><li>主协程中，调用 <code>cancel()</code> 函数通知子协程退出。</li></ul><h3 id="2-2-控制多个协程"><a href="#2-2-控制多个协程" class="headerlink" title="2.2 控制多个协程"></a><a href="https://geektutu.com/post/quick-go-context.html#2-2-%E6%8E%A7%E5%88%B6%E5%A4%9A%E4%B8%AA%E5%8D%8F%E7%A8%8B" title="2.2 控制多个协程"></a>2.2 控制多个协程</h3><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithCancel(context.Background())  </p><p> go reqTask(ctx, “worker1”)<br> go reqTask(ctx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><p>为每个子协程传递相同的上下文 <code>ctx</code> 即可，调用 <code>cancel()</code> 函数后该 Context 控制的所有子协程都会退出。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8  </p><p>worker1 send request<br>worker2 send request<br>worker1 send request<br>worker2 send request<br>worker1 send request<br>worker2 send request<br>stop worker1<br>stop worker2  </p><h2 id="3-context-WithValue"><a href="#3-context-WithValue" class="headerlink" title="3 context.WithValue"></a><a href="https://geektutu.com/post/quick-go-context.html#3-context-WithValue" title="3 context.WithValue"></a>3 context.WithValue</h2><p>如果需要往子协程中传递参数，可以使用 <code>context.WithValue()</code>。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27  </p><p>type Options struct{ Interval time.Duration }  </p><p>func reqTask(ctx context.Context, name string) {<br> for {<br> select {<br> case &lt;-ctx.Done():<br> fmt.Println(“stop”, name)<br> return<br> default:<br> fmt.Println(name, “send request”)<br> op :&#x3D; ctx.Value(“options”).(*Options)<br> time.Sleep(op.Interval * time.Second)<br> }<br> }<br>}  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithCancel(context.Background())<br> vCtx :&#x3D; context.WithValue(ctx, “options”, &amp;Options{1})  </p><p> go reqTask(vCtx, “worker1”)<br> go reqTask(vCtx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><ul><li><code>context.WithValue()</code> 创建了一个基于 <code>ctx</code> 的子 Context，并携带了值 <code>options</code>。</li><li>在子协程中，使用 <code>ctx.Value(&quot;options&quot;)</code> 获取到传递的值，读取&#x2F;修改该值。</li></ul><h2 id="4-context-WithTimeout"><a href="#4-context-WithTimeout" class="headerlink" title="4 context.WithTimeout"></a><a href="https://geektutu.com/post/quick-go-context.html#4-context-WithTimeout" title="4 context.WithTimeout"></a>4 context.WithTimeout</h2><p>如果需要控制子协程的执行时间，可以使用 <code>context.WithTimeout</code> 创建具有超时通知机制的 Context 对象。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithTimeout(context.Background(), 2*time.Second)<br> go reqTask(ctx, “worker1”)<br> go reqTask(ctx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> fmt.Println(“before cancel”)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><p><code>WithTimeout()</code>的使用与 <code>WithCancel()</code> 类似，多了一个参数，用于设置超时时间。执行结果如下：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7  </p><p>worker2 send request<br>worker1 send request<br>worker1 send request<br>worker2 send request<br>stop worker2<br>stop worker1<br>before cancel  </p><p>因为超时时间设置为 2s，但是 main 函数中，3s 后才会调用 <code>cancel()</code>，因此，在调用 <code>cancel()</code> 函数前，子协程因为超时已经退出了。</p><h2 id="5-context-WithDeadline"><a href="#5-context-WithDeadline" class="headerlink" title="5 context.WithDeadline"></a><a href="https://geektutu.com/post/quick-go-context.html#5-context-WithDeadline" title="5 context.WithDeadline"></a>5 context.WithDeadline</h2><p>超时退出可以控制子协程的最长执行时间，那 <code>context.WithDeadline()</code> 则可以控制子协程的最迟退出时间。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23  </p><p>func reqTask(ctx context.Context, name string) {<br> for {<br> select {<br> case &lt;-ctx.Done():<br> fmt.Println(“stop”, name, ctx.Err())<br> return<br> default:<br> fmt.Println(name, “send request”)<br> time.Sleep(1 * time.Second)<br> }<br> }<br>}  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithDeadline(context.Background(), time.Now().Add(1*time.Second))<br> go reqTask(ctx, “worker1”)<br> go reqTask(ctx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> fmt.Println(“before cancel”)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><ul><li><code>WithDeadline</code> 用于设置截止时间。在这个例子中，将截止时间设置为1s后，<code>cancel()</code> 函数在 3s 后调用，因此子协程将在调用 <code>cancel()</code> 函数前结束。</li><li>在子协程中，可以通过 <code>ctx.Err()</code> 获取到子协程退出的错误原因。</li></ul><p>运行结果如下：</p><p>1<br>2<br>3<br>4<br>5  </p><p>worker2 send request<br>worker1 send request<br>stop worker2 context deadline exceeded<br>stop worker1 context deadline exceeded<br>before cancel  </p><p>可以看到，子协程 <code>worker1</code> 和 <code>worker2</code> 均是因为截止时间到了而退出。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang语言面试题 - 基本原理</title>
      <link href="/interview/go/golang101-2/"/>
      <url>/interview/go/golang101-2/</url>
      
        <content type="html"><![CDATA[<h4 id="1-golang-文件初始化的顺序"><a href="#1-golang-文件初始化的顺序" class="headerlink" title="1. golang 文件初始化的顺序"></a>1. golang 文件初始化的顺序</h4><p>init() 函数是 Go 程序初始化的一部分。由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。<br>总结顺序如下：<br><strong>import –&gt; const –&gt; var –&gt; init() &#x2F; init2() –&gt; main()</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  &#123;  </span><br><span class="line"> fmt.Println(<span class="string">&quot;init1:&quot;</span>, a)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  &#123;  </span><br><span class="line"> fmt.Println(<span class="string">&quot;init2:&quot;</span>, a)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>  </span><br><span class="line"><span class="keyword">const</span> b = <span class="number">100</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"> fmt.Println(<span class="string">&quot;main:&quot;</span>, a)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 执行结果  </span></span><br><span class="line"><span class="comment">// init1: 10  </span></span><br><span class="line"><span class="comment">// init2: 10  </span></span><br><span class="line"><span class="comment">// main: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// init2: 10  </span></span><br><span class="line"><span class="comment">// init1: 10  </span></span><br><span class="line"><span class="comment">// main: 10</span></span><br></pre></td></tr></table></figure><h4 id="2-interface-如何比较"><a href="#2-interface-如何比较" class="headerlink" title="2. interface 如何比较"></a>2. interface 如何比较</h4><p>Golang 中， interface 内部包含了两个字段，类型 T 和值 V ，interface 之间可以用 &#x3D;&#x3D; 或 !&#x3D; 进行比较。两个 interface 之间可能包含以下两种情况：</p><ol><li>两个都是 nil （对应的 T 和 V 都为 unset 的状态）</li><li>T 相同，且 V 相同</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;  </span><br><span class="line">  UserName <span class="type">string</span>  <span class="string">`json:user_name`</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> UserFace <span class="keyword">interface</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="comment">// 实际比较的是两个结构体的地址</span></span><br><span class="line">  <span class="keyword">var</span> u1, u2 UserFace = &amp;User&#123;<span class="string">&quot;Tom&quot;</span>&#125;, &amp;User&#123;<span class="string">&quot;Tom&quot;</span>&#125;  </span><br><span class="line">  <span class="comment">// 比较两个结构体</span></span><br><span class="line">  <span class="keyword">var</span> u3, u4 UserFace = User&#123;<span class="string">&quot;Tom&quot;</span>&#125;, User&#123;<span class="string">&quot;Tom&quot;</span>&#125;  </span><br><span class="line">  fmt.Println(u1 == u2) <span class="comment">// false  </span></span><br><span class="line">  fmt.Println(u3 == u4) <span class="comment">// true  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-interface-和-nil"><a href="#3-interface-和-nil" class="headerlink" title="3. interface 和 nil"></a>3. interface 和 nil</h4><p>上边讲了 interface 包含两个字段，那么一个 nil 的空结构体和 nil 是否真的相等呢？可以看下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> p *<span class="type">int</span> = <span class="literal">nil</span>  </span><br><span class="line">  <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = p  </span><br><span class="line">  fmt.Println(i == p) <span class="comment">// true  </span></span><br><span class="line">  fmt.Println(p == <span class="literal">nil</span>) <span class="comment">// true  </span></span><br><span class="line">  fmt.Println(i == <span class="literal">nil</span>) <span class="comment">// false  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 nil 非 interface 的值 p 赋给 i 的时候，i 实际上是 (T&#x3D;*int, V&#x3D;nil)。当二者相比较时，Go 会将 p 先转换成 interface 类型的再去比较，此时二者等价。<br>p 与 nil 是直接比较的值，因此二者也等价。<br>i 与 nil  比较时，会将 nil 转换为接口 (T&#x3D;nil, V&#x3D;nil)，与 i (T&#x3D;*int, V&#x3D;nil) 不相等，因此  i !&#x3D; nil</p><h4 id="4-GC-初步理解"><a href="#4-GC-初步理解" class="headerlink" title="4. GC 初步理解"></a>4. GC 初步理解</h4><p>最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count)，Go 语言 采用的是标记清除算法。1.5 版本以后在此基础上使用了三色标记法和写屏障技术，提高了效率。</p><p>标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p><ul><li>标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；</li><li>清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。</li></ul><p>标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW，这也是 GC 算法优化的重点），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。</p><p>三色标记算法将程序中的对象分成白色、黑色和灰色三类。</p><ul><li>白色：不确定对象。</li><li>灰色：存活对象，子对象待处理。</li><li>黑色：存活对象。</li></ul><p>标记开始时，所有内存加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入待扫描队列（灰色集合）；使用并发的 goroutine 扫描队列，取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入队列。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。</p><p>三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。</p><p>三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A (黑) -&gt; B (灰) -&gt; C (白) -&gt; D (白)  </span><br></pre></td></tr></table></figure><p>正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A (黑) -&gt; B (灰) -&gt; C (白)   </span><br><span class="line"> ↓  </span><br><span class="line">D (白)  </span><br></pre></td></tr></table></figure><p>为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，这个计数会拦截将白色指针插入黑色对象的操作，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。</p><p>一次完整的 GC 分为四个阶段：</p><ul><li>标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)，开启辅助 GC （mutator assist），统计 root 对象的任务数量</li><li>使用三色标记法标记（Marking, 并发）</li><li>标记结束(Mark Termination，需 STW)，关闭写屏障。</li><li>清理(Sweeping, 并发)</li></ul><h4 id="5-GMP-模型，go-协程"><a href="#5-GMP-模型，go-协程" class="headerlink" title="5. GMP 模型，go 协程"></a>5. GMP 模型，go 协程</h4><h4 id="6-Gin-框架简介"><a href="#6-Gin-框架简介" class="headerlink" title="6. Gin 框架简介"></a>6. Gin 框架简介</h4><h4 id="7-反射的原理"><a href="#7-反射的原理" class="headerlink" title="7. 反射的原理"></a>7. 反射的原理</h4><h4 id="8-Go-mutex-锁机制"><a href="#8-Go-mutex-锁机制" class="headerlink" title="8. Go mutex 锁机制"></a>8. Go mutex 锁机制</h4><p>例如：map 协程不安全，需要读写锁<br>Mutex 几种状态<br><code>mutexLocked</code> — 表示互斥锁的锁定状态；<br><code>mutexWoken</code> — 表示从正常模式被从唤醒；<br><code>mutexStarving</code> — 当前的互斥锁进入饥饿状态；<br><code>waitersCount</code> — 当前互斥锁上等待的 Goroutine 个数；</p><h4 id="9-Channel-优点和相关的坑"><a href="#9-Channel-优点和相关的坑" class="headerlink" title="9. Channel 优点和相关的坑"></a>9. Channel 优点和相关的坑</h4><h4 id="10-oom-？"><a href="#10-oom-？" class="headerlink" title="10. oom ？"></a>10. oom ？</h4><h4 id="11-内存管理方式"><a href="#11-内存管理方式" class="headerlink" title="11. 内存管理方式"></a>11. 内存管理方式</h4><h4 id="12-GC-触发时机"><a href="#12-GC-触发时机" class="headerlink" title="12. GC 触发时机"></a>12. GC 触发时机</h4><p>使用系统监控，该触发条件由 <code>runtime.forcegcperiod</code> 变量控制，默认为 2 分 钟。当超过两分钟没有产生任何 GC 时，强制触发 GC。 使用步调（Pacing）算法，其核心思想是控制内存增长的比例。如 Go 的 GC 是一种比例 GC, 下一次 GC 结束时的堆大小和上一次 GC <code>存活</code>堆大小成比例.</p><h4 id="13-GRPC-以及-protobuf-协议优化"><a href="#13-GRPC-以及-protobuf-协议优化" class="headerlink" title="13. GRPC 以及 protobuf 协议优化"></a>13. GRPC 以及 protobuf 协议优化</h4><p>gRPC的核心概念包括：</p><p>RPC(Remote Procedure Call，远程过程调用)：gRPC提供了一种简单的RPC机制，允许客户端和服务器之间无缝通信。客户端通过调用本地方法，实际上是在远程服务器上执行方法，并将结果返回给客户端。<br>Protocol Buffers：gRPC使用Protocol Buffers作为数据序列化和传输格式。Protocol Buffers是一种轻量级、高效的数据结构序列化库，可以在多种编程语言之间实现无缝通信。<br>HTTP&#x2F;2：gRPC使用HTTP&#x2F;2作为传输协议，利用HTTP&#x2F;2的多路复用、流控制、压缩等特性，实现低延迟、高吞吐量的通信。</p><p>RPC调用：gRPC的RPC调用过程可以分为以下步骤：</p><p>客户端通过Protocol Buffers序列化请求数据，并使用HTTP&#x2F;2发送请求。<br>服务器接收请求，使用Protocol Buffers反序列化请求数据。<br>服务器执行RPC方法，并将结果序列化为Protocol Buffers格式。<br>服务器使用HTTP&#x2F;2发送响应给客户端。<br>客户端使用Protocol Buffers反序列化响应数据，并处理结果。</p><h4 id="14-golang-压测-pprof，火焰图"><a href="#14-golang-压测-pprof，火焰图" class="headerlink" title="14. golang 压测 pprof，火焰图"></a>14. golang 压测 pprof，火焰图</h4>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang语言面试题 - 基础语法</title>
      <link href="/interview/go/golang101-1/"/>
      <url>/interview/go/golang101-1/</url>
      
        <content type="html"><![CDATA[<h4 id="1-和-的区别？"><a href="#1-和-的区别？" class="headerlink" title="1.  = 和 := 的区别？"></a>1.  <code>=</code> 和 <code>:=</code> 的区别？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo <span class="type">int</span>  </span><br><span class="line">foo = <span class="number">10</span> </span><br><span class="line"><span class="comment">// 等价于  </span></span><br><span class="line">foo := <span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="2-指针的作用"><a href="#2-指针的作用" class="headerlink" title="2. 指针的作用"></a>2. 指针的作用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x =  <span class="number">5</span>  </span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> = &amp;x  </span><br><span class="line">fmt.Printf(<span class="string">&quot;x = %d&quot;</span>,  *p) <span class="comment">// x 可以用 *p 访问</span></span><br><span class="line"><span class="comment">//  `*` 运算符，也称为解引用运算符，用于访问地址中的值。</span></span><br><span class="line"><span class="comment">//  `＆`运算符，也称为地址运算符，用于返回变量的地址。</span></span><br></pre></td></tr></table></figure><h4 id="3-Go-有异常类型么？"><a href="#3-Go-有异常类型么？" class="headerlink" title="3. Go 有异常类型么？"></a>3. Go 有异常类型么？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go 只有错误类型</span></span><br><span class="line">f, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">  log.Fatal(err)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-协程和线程和进程的区别？"><a href="#4-协程和线程和进程的区别？" class="headerlink" title="4. 协程和线程和进程的区别？"></a>4. 协程和线程和进程的区别？</h4><p>Goroutines是可以同时运行的函数与方法。Goroutines 可以被认为是轻量级的线程。 与线程相比，创建 Goroutine 的开销很小。 Go应用程序同时运行数千个 Goroutine 是非常常见的做法。<br>并发掌握，goroutine和channel声明与使用！</p><ul><li>进程: 进程是具有一定独立功能的程序，进程是系统资源分配和调度的最小单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</li><li>线程: 线程是进程的一个实体,线程是内核态,而且是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</li></ul><p>****协程: 协程是一种用户态的轻量级线程，协程的调度完全是由用户来控制的。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p><h4 id="5-拼接字符串"><a href="#5-拼接字符串" class="headerlink" title="5. 拼接字符串"></a>5. 拼接字符串</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串是只读的，也就意味着每次修改操作都会创建一个新的字符串</span></span><br><span class="line">a := <span class="string">&quot;a&quot;</span></span><br><span class="line">b := <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="keyword">var</span> str1 <span class="type">string</span></span><br><span class="line">str1 += a</span><br><span class="line">str1 += b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用 `strings.Builder`，最小化内存拷贝次数。</span></span><br><span class="line"><span class="keyword">var</span> str strings.Builder  </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;  </span><br><span class="line">  str.WriteString(<span class="string">&quot;a&quot;</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">fmt.Println(str.String())</span><br></pre></td></tr></table></figure><h4 id="6-什么是-rune-类型"><a href="#6-什么是-rune-类型" class="headerlink" title="6. 什么是 rune 类型"></a>6. 什么是 rune 类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Go 语言中，字符串的底层表示是 byte (8 bit) 序列，而非 rune (32 bit) 序列。例如下面的例子中 `语` 和 `言` 使用 UTF-8 编码后各占 3 个 byte，因此 `len(&quot;Go语言&quot;)` 等于 8，当然我们也可以将字符串转换为 rune 序列。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(<span class="string">&quot;Go语言&quot;</span>)) <span class="comment">// 8  </span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>([]<span class="type">rune</span>(<span class="string">&quot;Go语言&quot;</span>))) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h4 id="7-判断-map-结构中是否包含某个-key-的方法"><a href="#7-判断-map-结构中是否包含某个-key-的方法" class="headerlink" title="7. 判断 map 结构中是否包含某个 key 的方法"></a>7. 判断 map 结构中是否包含某个 key 的方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok 为 true 代表有这个 key，且 val 是这个 key 的值</span></span><br><span class="line"><span class="keyword">if</span> val, ok := map_[<span class="string">&quot;key&quot;</span>]; ok &#123;  </span><br><span class="line">  <span class="comment">//do something  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-defer-的执行顺序"><a href="#8-defer-的执行顺序" class="headerlink" title="8. defer 的执行顺序"></a>8. defer 的执行顺序</h4><p>多个 defer 语句，遵从后进先出(Last In First Out，LIFO)的原则，最后声明的 defer 语句，最先得到执行。<br>panic 需要等defer 结束后才会向上传递。出现panic恐慌时候，会先按照defer的后入先出的顺序执行，最后才会执行panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">  i := <span class="number">0</span>  </span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;defer1&quot;</span>)  </span><br><span class="line">  &#125;()  </span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    i += <span class="number">1</span>  </span><br><span class="line">    fmt.Println(<span class="string">&quot;defer2&quot;</span>)  </span><br><span class="line">  &#125;()  </span><br><span class="line">  <span class="keyword">return</span> i  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  fmt.Println(<span class="string">&quot;return&quot;</span>, test())  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// defer2  </span></span><br><span class="line"><span class="comment">// defer1  </span></span><br><span class="line"><span class="comment">// return 0</span></span><br></pre></td></tr></table></figure><p>defer 在 return 语句之后执行，但在函数真正退出之前，defer 可以修改返回值。我们可以注意到前一个例子的返回值并没有被修改（注意：只有被预先定义的返回值才能被 defer 语句修改）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> (i <span class="type">int</span>) &#123;  </span><br><span class="line">  i = <span class="number">0</span>  </span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    i += <span class="number">1</span>  </span><br><span class="line">    fmt.Println(<span class="string">&quot;defer2&quot;</span>)  </span><br><span class="line">  &#125;()  </span><br><span class="line">  <span class="keyword">return</span> i  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  fmt.Println(<span class="string">&quot;return&quot;</span>, test())  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// defer2  </span></span><br><span class="line"><span class="comment">// return 1</span></span><br></pre></td></tr></table></figure><h4 id="9-tag的用法？"><a href="#9-tag的用法？" class="headerlink" title="9. tag的用法？"></a>9. tag的用法？</h4><p>tag 是 struct 结构的注解，不同的框架或者工具可以通过反射获取到某个字段的属性，增加语义<br>例如下方例子定义了 struct 结构字段和 json 结构的映射关系</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;encoding/json&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;  </span><br><span class="line">  Name <span class="type">string</span> <span class="string">`json:&quot;user_name&quot;`</span>  </span><br><span class="line">  Id   <span class="type">string</span> <span class="string">`json:&quot;user_id&quot;`</span>  </span><br><span class="line">  Age  <span class="type">int</span>    <span class="string">`json:&quot;-&quot;`</span>  <span class="comment">// json 忽略</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  buf, _ := json.Marshal(Stu&#123;<span class="string">&quot;Bishop&quot;</span>, <span class="string">&quot;1001&quot;</span>, <span class="number">18</span>&#125;)  </span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, buf)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-Golang-如何判断两个列表（slice）结构等价"><a href="#10-Golang-如何判断两个列表（slice）结构等价" class="headerlink" title="10. Golang 如何判断两个列表（slice）结构等价"></a>10. Golang 如何判断两个列表（slice）结构等价</h4><p>可以使用反射 reflect.DeepEqual(a, b) 来判断，但是此种方法比较影响性能，我们这里还是通过基础遍历的方法来完成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceAEqurlSliceB</span><span class="params">(a, b []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">  <span class="comment">// 等长</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b) &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判空</span></span><br><span class="line">  <span class="keyword">if</span> (a == <span class="literal">nil</span>) != (b == <span class="literal">nil</span>) &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  b = b[:<span class="built_in">len</span>(a)]  </span><br><span class="line">  <span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;  </span><br><span class="line"><span class="keyword">if</span> v != b[i] &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-如何标识枚举值（enums）"><a href="#11-如何标识枚举值（enums）" class="headerlink" title="11. 如何标识枚举值（enums）"></a>11. 如何标识枚举值（enums）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Level <span class="type">int32</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> (  </span><br><span class="line">  Level1 Level = <span class="literal">iota</span>  </span><br><span class="line">  Level2  </span><br><span class="line">  Level3 </span><br><span class="line">  Level4 </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  fmt.Println(Level1, Level2, Level3, Level4) <span class="comment">// 0, 1, 2, 3  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-空-struct-结构的一些用法"><a href="#12-空-struct-结构的一些用法" class="headerlink" title="12. 空 struct{} 结构的一些用法"></a>12. 空 struct{} 结构的一些用法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本体是一个空结构体</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(<span class="keyword">struct</span>&#123;&#125;&#123;&#125;)) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用作占位符使用</span></span><br><span class="line"><span class="keyword">type</span> Set <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  set := <span class="built_in">make</span>(Set)  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, item := <span class="keyword">range</span> []<span class="type">string</span>&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125; &#123;  </span><br><span class="line">set[item] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  fmt.Println(<span class="built_in">len</span>(set)) <span class="comment">// 3  </span></span><br><span class="line">  <span class="keyword">if</span> _, ok := set[<span class="string">&quot;A&quot;</span>]; ok &#123;  </span><br><span class="line">fmt.Println(<span class="string">&quot;A exists&quot;</span>) <span class="comment">// A exists  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用作传递信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    &lt;-ch  </span><br><span class="line">    <span class="comment">// do something  </span></span><br><span class="line">  &#125;()  </span><br><span class="line">  ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  </span><br><span class="line">  <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="13-声明结构体方法"><a href="#13-声明结构体方法" class="headerlink" title="13. 声明结构体方法"></a>13. 声明结构体方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Lamp <span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Lamp)</span></span> On() &#123;  </span><br><span class="line"> <span class="built_in">println</span>(<span class="string">&quot;On&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Lamp)</span></span> Off() &#123;  </span><br><span class="line"> <span class="built_in">println</span>(<span class="string">&quot;Off&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-map-和-new"><a href="#14-map-和-new" class="headerlink" title="14. map 和 new"></a>14. map 和 new</h4><ol><li>make 仅用来分配及初始化类型为 slice、map、chan 的数据。new 可分配任意类型的数据.</li><li>new 分配返回的是指针，即类型 *Type。make 返回引用，即 Type.</li><li>new 分配的空间被清零, make 分配空间后，会进行初始化.<br>一个例子<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i *<span class="type">int</span></span><br><span class="line">i = <span class="built_in">new</span>(<span class="type">int</span>) <span class="comment">// 分配内存地址并返回指向改地址的指针，同时置为类型的0值</span></span><br><span class="line">*i = <span class="number">10</span></span><br><span class="line">fmt.Println(*i) <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="15-代码输出啥相关题"><a href="#15-代码输出啥相关题" class="headerlink" title="15. 代码输出啥相关题"></a>15. 代码输出啥相关题</h4><h5 id="1"><a href="#1" class="headerlink" title="(1)"></a>(1)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">uint</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">uint</span> = <span class="number">2</span></span><br><span class="line">    fmt.Println(a-b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2^32-1 or 2^64-1 根据操作系统位数有不同结果</span></span><br></pre></td></tr></table></figure><p>强类型语言，计算结果也是 uint 类型，1-2 可以转换为 0-1 ，计算机中按照 0 + -1 来计算，-1 通常表示为补码，即所有位数都是1的一个数，即当前系统可表示的最大数</p><h5 id="2"><a href="#2" class="headerlink" title="(2)"></a>(2)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;A: &quot;</span>, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;B: &quot;</span>, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考点：<strong>go执行的随机性和闭包</strong><br>解答：谁也不知道执行后打印的顺序是什么样的，所以只能说是随机数字。但是<code>A:</code>均为输出10，<code>B:</code>从0~9输出(顺序不定)。第一个go func中i是外部for的一个变量，地址不变化。遍历完成后，最终i&#x3D;10。故go func执行时，i的值始终是10。<br>第二个go func中i是函数参数，与外部for中的i完全是两个变量。尾部(i)将发生值拷贝，go func内部指向值拷贝地址。</p><h5 id="3"><a href="#3" class="headerlink" title="(3)"></a>(3)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span></span> ShowA() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;showA&quot;</span>)</span><br><span class="line">    p.ShowB()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span></span> ShowB() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;showB&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">    People</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Teacher)</span></span> ShowB() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;teacher showB&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := Teacher&#123;&#125;</span><br><span class="line">    t.ShowA()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shwoA</span></span><br><span class="line"><span class="comment">// showB</span></span><br></pre></td></tr></table></figure><p>考点：<strong>go的组合继承</strong><br>解答：这是Golang的组合模式，可以实现OOP的继承。被组合的类型People所包含的方法虽然升级成了外部类型Teacher这个组合类型的方法（一定要是匿名字段），但它们的方法(ShowA())调用时接受者并没有发生变化。此时People类型并不知道自己会被什么类型组合，当然也就无法调用方法时去使用未知的组合者Teacher类型的功能。</p><h5 id="4"><a href="#4" class="headerlink" title="(4)"></a>(4)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    int_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">    string_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">    int_chan &lt;- <span class="number">1</span></span><br><span class="line">    string_chan &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> value := &lt;-int_chan:</span><br><span class="line">        fmt.Println(value)</span><br><span class="line">    <span class="keyword">case</span> value := &lt;-string_chan:</span><br><span class="line">        <span class="built_in">panic</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考点：<strong>select随机性</strong><br>解答： select会随机选择一个可用通用做收发操作。所以代码是有肯触发异常，也有可能不会。单个chan如果无缓冲时，将会阻塞。但结合 select可以在多个chan间等待执行。有三点原则： </p><ul><li>select 中只要有一个case能return，则立刻执行。 </li><li>当如果同一时间有多个case均能return则伪随机方式抽取任意一个执行。</li><li>如果没有一个case能return则可以执行”default”块。<h5 id="5"><a href="#5" class="headerlink" title="(5)"></a>(5)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)  </span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  </span><br><span class="line">    fmt.Println(s) <span class="comment">// [0,0,0,0,0,1,2,3] </span></span><br><span class="line">  </span><br><span class="line">    s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)  </span><br><span class="line">    s2 = <span class="built_in">append</span>(s2, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  </span><br><span class="line">    fmt.Println(s2)  <span class="comment">// [1,2,3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意 make 会给定义的长度分配初值<h5 id="6"><a href="#6" class="headerlink" title="(6)"></a>(6)</h5>map线程安全</li></ul><h4 id="16-如何理解go语言中的interface"><a href="#16-如何理解go语言中的interface" class="headerlink" title="16. 如何理解go语言中的interface?"></a>16. 如何理解go语言中的interface?</h4><ol><li>interface是方法申明的集合</li><li>任何类型的对象实现了在interface接口中声明的全部方法，则表明该类型实现了该接口</li><li>interface可以作为一种数据类型，实现了该接口的任何对象都可以给对应的接口类型变量赋值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义一个数据写入器</span></span><br><span class="line"><span class="keyword">type</span> DataWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">WriteData(data <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义文件结构，用于实现DataWriter</span></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现DataWriter接口的WriteData方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *file)</span></span> WriteData(data <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// 模拟写入数据</span></span><br><span class="line">fmt.Println(<span class="string">&quot;WriteData:&quot;</span>, data)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口可以作为数据类型传递，体现2，3</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cprint</span><span class="params">(writer DataWriter)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Cprint&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 实例化file</span></span><br><span class="line">f := <span class="built_in">new</span>(file)</span><br><span class="line"><span class="comment">// 声明一个DataWriter的接口</span></span><br><span class="line"><span class="keyword">var</span> writer DataWriter</span><br><span class="line"><span class="comment">// 将接口赋值f，也就是*file类型</span></span><br><span class="line">writer = f</span><br><span class="line"><span class="comment">// 使用DataWriter接口进行数据写入</span></span><br><span class="line">err := writer.WriteData(<span class="string">&quot;data&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;writeData err!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">Cprint(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="17-Go-语言是如何实现切片扩容的？"><a href="#17-Go-语言是如何实现切片扩容的？" class="headerlink" title="17. Go 语言是如何实现切片扩容的？"></a>17. Go 语言是如何实现切片扩容的？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  arr := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>) </span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++ &#123; </span><br><span class="line">    fmt.Println(<span class="string">&quot;len为&quot;</span>, <span class="built_in">len</span>(arr), <span class="string">&quot;cap为&quot;</span>, <span class="built_in">cap</span>(arr)) </span><br><span class="line">    arr = <span class="built_in">append</span>(arr, i) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看下结果<br>依次是 0,1,2,4,8,16,32,64,128,256,512,1024<br>但到了1024之后,就变成了 1024,1280,1696,2304<br>每次都是扩容了四分之一左右</p><h4 id="18-数组和切片"><a href="#18-数组和切片" class="headerlink" title="18. 数组和切片"></a>18. 数组和切片</h4><p>golang 中存在两种函数传入方式：值类型和引用类型<br>值类型只改变当前作用域的值，在该作用域外部不会生效；引用类型改变当前地址对应的值，在作用域外部生效。可以参考下边的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组 值类型</span></span><br><span class="line"><span class="comment">// 切片 引用类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeArray</span><span class="params">(x [3]<span class="type">int</span>)</span></span> &#123;x[<span class="number">0</span>] = <span class="number">123</span>&#125; <span class="comment">// 定义为数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(x []<span class="type">int</span>)</span></span> &#123;x[<span class="number">0</span>] = <span class="number">123</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  x1 := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;x1 original-&gt;&quot;</span>, x1)</span><br><span class="line">  changeArray(x)</span><br><span class="line">  fmt.Println(<span class="string">&quot;x1 current-&gt;&quot;</span>. x1)</span><br><span class="line"></span><br><span class="line">  x := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;x2 -&gt;&quot;</span>, x)</span><br><span class="line">  changeSlice(x)</span><br><span class="line">  fmt.Println(<span class="string">&quot;x2 -&gt;&quot;</span>. x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x1 -&gt; [1,2,3]</span></span><br><span class="line"><span class="comment">// x2 -&gt; [1,2,3]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="19"><a href="#19" class="headerlink" title="19."></a>19.</h4>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo建站（三）GitHub</title>
      <link href="/blog/build-blog/hexo101-3/"/>
      <url>/blog/build-blog/hexo101-3/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到建站记录的第二部分：部署到 github page</p><h2 id="GitHub页面"><a href="#GitHub页面" class="headerlink" title="GitHub页面"></a>GitHub页面</h2><p>这里假设已经注册过了Github帐户，如果没有，可以去<a href="https://github.com/">Github</a>注册。</p><p>注册好了后，登录Github,创建仓库：点击右上角的+号，选择new repository:<br><img src="https://t2.picb.cc/2022/02/21/fpUdSF.jpg" alt="git"></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo建站（二）butterfly</title>
      <link href="/blog/build-blog/hexo101-2/"/>
      <url>/blog/build-blog/hexo101-2/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到建站记录的第二部分：butterfly 主题的安装与初始化</p><h2 id="主题安装与使用"><a href="#主题安装与使用" class="headerlink" title="主题安装与使用"></a>主题安装与使用</h2><p>下载主题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">git <span class="built_in">clone</span> -b master https://gitee.com/immyw/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>修改站点配置文件 _config.yml ,把主题修改为 Butterfly</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">Butterfly</span></span><br></pre></td></tr></table></figure><p>为了后续方便配置，需要在当前目录 blog&#x2F; 创建 _config.butterfly.yml 文件，并将根目录下的 _config.yml 文件内容复制进去。更多的主题配置信息可以等待之后的文章~</p><p>尝试执行以下指令,以查看应用主题后的效果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">#清除旧的内容</span></span><br><span class="line">hexo g <span class="comment">#生成发布用的静态页面</span></span><br></pre></td></tr></table></figure><p>本地查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s <span class="comment"># hexo server</span></span><br></pre></td></tr></table></figure><p>执行完该命令可以去 <a href="localhost:4000">localhost:4000</a> 查看效果</p><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><h4 id="case1-："><a href="#case1-：" class="headerlink" title="case1 ："></a>case1 ：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ERROR TypeError: /data/blog/themes/butterfly/layout/includes/head.pug:40  </span><br><span class="line">38|  </span><br><span class="line">39| !=favicon_tag(theme.favicon || config.favicon)</span><br><span class="line"></span><br><span class="line">&gt; 40| <span class="built_in">link</span>(rel=<span class="string">&quot;canonical&quot;</span> href=urlNoIndex())  </span><br><span class="line">&gt; 41|  </span><br><span class="line">&gt; 42| //- 預解析  </span><br><span class="line">&gt; 43| !=partial(<span class="string">&#x27;includes/head/preconnect&#x27;</span>, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span><br><span class="line"></span><br><span class="line">prettyUrls is not a <span class="keyword">function</span>  </span><br><span class="line">at Object. (/data/blog/themes/butterfly/scripts/helpers/page.js:58:10)  </span><br><span class="line">at <span class="built_in">eval</span> (<span class="built_in">eval</span> at wrap (/data/blog/node_modules/pug-runtime/wrap.js:6:10), :89:77)  </span><br><span class="line">at template (<span class="built_in">eval</span> at wrap (/data/blog/node_modules/pug-runtime/wrap.js:6:10), :4603:215)  </span><br><span class="line">at _View._compiled (/data/blog/node_modules/hexo/lib/theme/view.js:136:50)  </span><br><span class="line">at _View.render (/data/blog/node_modules/hexo/lib/theme/view.js:39:17)  </span><br><span class="line">at /data/blog/node_modules/hexo/lib/hexo/index.js:64:21  </span><br><span class="line">at tryCatcher (/data/blog/node_modules/bluebird/js/release/util.js:16:23)  </span><br><span class="line">at /data/blog/node_modules/bluebird/js/release/method.js:15:34  </span><br><span class="line">at RouteStream._read (/data/blog/node_modules/hexo/lib/hexo/router.js:47:5)  </span><br><span class="line">at RouteStream.Readable.read (_stream_readable.js:479:10)  </span><br><span class="line">at resume_ (_stream_readable.js:966:12)  </span><br><span class="line">at processTicksAndRejections (internal/process/task_queues.js:80:21) &#123;  </span><br><span class="line">path: <span class="string">&#x27;/data/blog/themes/butterfly/layout/includes/head.pug&#x27;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>解决方案</p><ol><li>优先确认 themes&#x2F;butterfly 中有相关的文件内容</li><li>尝试执行如下命令： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br><span class="line"><span class="built_in">rm</span> -rf node_modules</span><br><span class="line"><span class="built_in">rm</span> -rf package-lock.json</span><br><span class="line">npm install</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure></li></ol><h4 id="case2："><a href="#case2：" class="headerlink" title="case2："></a>case2：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TypeError: /Users/blog/themes/butterfly/layout/includes/widget/index.pug:33</span><br><span class="line">    31|       !=partial(<span class="string">&#x27;includes/widget/card_tags&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line">    32|       !=partial(<span class="string">&#x27;includes/widget/card_archives&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line">  &gt; 33|       !=partial(<span class="string">&#x27;includes/widget/card_webinfo&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line">    34|       !=partial(<span class="string">&#x27;includes/widget/card_bottom_self&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line">/Users/blog/themes/butterfly/layout/includes/widget/card_webinfo.pug:18</span><br><span class="line">    16|         .webinfo-item</span><br><span class="line">    17|           .item-name=_p(<span class="string">&#x27;aside.card_webinfo.site_wordcount&#x27;</span>) + <span class="string">&quot; :&quot;</span></span><br><span class="line">  &gt; 18|           .item-count=totalcount(site)</span><br><span class="line">    19|       <span class="keyword">if</span> theme.busuanzi.site_uv</span><br><span class="line">    20|         .webinfo-item</span><br><span class="line">    21|           .item-name= _p(<span class="string">&#x27;aside.card_webinfo.site_uv_name&#x27;</span>) + <span class="string">&quot; :&quot;</span></span><br><span class="line"></span><br><span class="line">totalcount is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p>请检查是否安裝了wordcount插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><h4 id="case3："><a href="#case3：" class="headerlink" title="case3："></a>case3：</h4><p>如果你沒有 pug 以及 stylus 的渲染器会报错</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extends includes/layout.pug block content include ./includes/mixins/post-ui</span><br><span class="line">.pug <span class="comment">#recent-posts.recent-posts +postUI include includes/pagination.pug</span></span><br></pre></td></tr></table></figure><p>解决方案</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h4 id="case4："><a href="#case4：" class="headerlink" title="case4："></a>case4：</h4><p>hexo本地测试运行重启后页面空白，且提示 : </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN No layout: index.html</span><br></pre></td></tr></table></figure><p>可以参考 case1 &amp; case2 ，即 hexo generate 没有成功</p><h4 id="case5："><a href="#case5：" class="headerlink" title="case5："></a>case5：</h4><p>尝试 hexo deploy 发布的时候失败，显示如下，没有反应</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INFO  Validating config</span><br><span class="line">INFO</span><br><span class="line">  ===================================================================</span><br><span class="line"></span><br><span class="line">      <span class="comment">#####  #    # ##### ##### ###### #####  ###### #      #   #</span></span><br><span class="line">      <span class="comment">#    # #    #   #     #   #      #    # #      #       # #</span></span><br><span class="line">      <span class="comment">#####  #    #   #     #   #####  #    # #####  #        #</span></span><br><span class="line">      <span class="comment">#    # #    #   #     #   #      #####  #      #        #</span></span><br><span class="line">      <span class="comment">#    # #    #   #     #   #      #   #  #      #        #</span></span><br><span class="line">      <span class="comment">#####   ####    #     #   ###### #    # #      ######   #</span></span><br><span class="line"></span><br><span class="line">                            4.1.0</span><br><span class="line">  ===================================================================</span><br></pre></td></tr></table></figure><p>解决方案：deploy 参数需要配置到 _config.yml 文件中。<br><strong>注意：冒号后面需要一个空格</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repo:</span> <span class="string">git@github.com:yourname/yourname.github.io.git</span></span><br><span class="line"><span class="comment"># 推荐使用Git链接，使用http模式还会存在需要填写 用户名和邮箱的情况</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>更多问题请参考 <a href="https://butterfly.js.org/posts/98d20436/">butterfly</a> 官方文档中的解答</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo建站（一）hexo</title>
      <link href="/blog/build-blog/hexo101-1/"/>
      <url>/blog/build-blog/hexo101-1/</url>
      
        <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>终于俺也有自己的 blog 了，下面就整个 hexo 建站和主题 butterfly 的配置分几个部分给大家做个小小的总结</p><p>欢迎来到建站记录的第一部分：hexo 的安装</p><h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><p>官网地址：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p><h4 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h4><p>1.node<br>    首先去 <a href="http://nodejs.cn/download/">node.js</a> 的官网下载最新的稳定版本，我这里选择的是 mac 版本的<br>2.npm<br>    包管理工具</p><h4 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo</span><br></pre></td></tr></table></figure><p>记得这里需要使用管理员权限安装</p><p>初始化 hexo 至某个文件夹</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>这个文件夹就是自己将来管理文章的地方</p><p>工程配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>进入刚才初始化的 blog 文件夹</p><p>浏览器调试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generage</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>也可以如下简写</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>必备插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save <span class="comment"># hexo 渲染必备</span></span><br><span class="line">npm install hexo-server --save <span class="comment"># hexo 本地启动</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install --save hexo-wordcount <span class="comment"># wordcount 插件</span></span><br><span class="line">npm install hexo-butterfly-artitalk --save <span class="comment"># artitalk 插件</span></span><br><span class="line">npm install hexo-generator-feed --save <span class="comment"># RSS 插件</span></span><br><span class="line">npm install hexo-auto-category --save <span class="comment"># 自动根据目录生成categories</span></span><br></pre></td></tr></table></figure><p>自动生成 categories 详情和配置方法具体可以参考 <a href="https://github.com/xu-song/hexo-auto-category">auto-category</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/uncategorized/hello-world/"/>
      <url>/uncategorized/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
