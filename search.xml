<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Follow 认证</title>
      <link href="/something/follow/"/>
      <url>/something/follow/</url>
      
        <content type="html"><![CDATA[<p>This message is used to verify that this feed (feedId:61681496545347584) belongs to me (userId:57309722915578880). Join me in enjoying the next generation information browser <a href="https://follow.is/">https://follow.is</a>.</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>初识 chromedp</title>
      <link href="/something/chromedp-101/"/>
      <url>/something/chromedp-101/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近工作碰到了一些自动化的需求，要求可以自动化的上传文件。调研了 <a href="https://pkg.go.dev/github.com/chromedp/chromedp#section-readme">chromedp package - github.com&#x2F;chromedp&#x2F;chromedp - Go Packages</a>  和 <a href="https://pkg.go.dev/github.com/tebeka/selenium">selenium package - github.com&#x2F;tebeka&#x2F;selenium - Go Packages</a> 这两个库，最终根据场景选择了和 chrome 浏览器更适配的 chromedp。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/chromedp/chromedp</span><br></pre></td></tr></table></figure><p>顺便可以去 <a href="https://github.com/chromedp">GitHub-chromedp</a> 上找到源码看看官方样例~<br>目前官方给出的样例如下：</p><p>The following examples are currently available:</p><table><thead><tr><th>Example</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://github.com/chromedp/examples/tree/master/click">click</a></td><td>use a selector to click on an element</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/cookie">cookie</a></td><td>set a HTTP cookie on requests</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/download_file">download_file</a></td><td>do headless file downloads</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/download_image">download_image</a></td><td>do headless image downloads</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/emulate">emulate</a></td><td>emulate a specific device such as an iPhone</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/eval">eval</a></td><td>evaluate javascript and retrieve the result</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/fast">fast</a></td><td>extract and render data from a page</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/forecast">forecast</a></td><td>extract and render data from a page</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/geoip">geoip</a></td><td>extract and render data from a page</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/headers">headers</a></td><td>add extra HTTP headers to browser requests</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/keys">keys</a></td><td>send key events to an element</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/latlon">latlon</a></td><td>retrieve the latitude&#x2F;longitude from google maps, using the browser’s target events</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/logic">logic</a></td><td>more complex logic beyond simple actions</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/multi">multi</a></td><td>use headless-shell and a container (Docker, Podman, other)</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/pdf">pdf</a></td><td>capture a pdf of a page</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/proxy">proxy</a></td><td>authenticate a proxy server which requires authentication</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/remote">remote</a></td><td>connect to an existing Chrome DevTools instance using a remote WebSocket URL</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/screenshot">screenshot</a></td><td>take a screenshot of a specific element and of the entire browser viewport</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/submit">submit</a></td><td>fill out and submit a form</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/subtree">subtree</a></td><td>populate and travel a subtree of the DOM</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/text">text</a></td><td>从选中的 element 中提取 text 文本</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/upload">upload</a></td><td>以表单的形式上传一个文件</td></tr><tr><td><a href="https://github.com/chromedp/examples/tree/master/visible">visible</a></td><td>等待某个 element 完全加载。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>请根据场景设计缓存方案</title>
      <link href="/research/design-prob/design-a-cache-sync/"/>
      <url>/research/design-prob/design-a-cache-sync/</url>
      
        <content type="html"><![CDATA[<h2 id="有ABC三个请求，都是-uid-纬度的请求；分别涉及到配置-1，2，3；2，3，5；3，4，6。现在要求怎样在配置更新后及时将相关的请求缓存重置？"><a href="#有ABC三个请求，都是-uid-纬度的请求；分别涉及到配置-1，2，3；2，3，5；3，4，6。现在要求怎样在配置更新后及时将相关的请求缓存重置？" class="headerlink" title="有ABC三个请求，都是 uid 纬度的请求；分别涉及到配置 1，2，3；2，3，5；3，4，6。现在要求怎样在配置更新后及时将相关的请求缓存重置？"></a>有ABC三个请求，都是 uid 纬度的请求；分别涉及到配置 1，2，3；2，3，5；3，4，6。现在要求怎样在配置更新后及时将相关的请求缓存重置？</h2><ol><li>可以将配置变化的 binlog 加入消息队列</li><li>配置关联的请求前缀提前存入 redis</li><li>请求缓存的 key 做拆分：前缀为 2 中提到的前缀，以前缀为 key 存 uid 和 缓存更新时间到 zset 中。另 前缀 + uid 单独存储某个用户某个请求具体的缓存内容</li><li>当消息队列消费到配置变化时：获取该配置关联的请求桶前缀，将请求桶中时间小于当前时间的 uid 取出，并从桶中清除；将前缀和相关待过期 uid 组合获取真正缓存的 key，将其过期 or 删除。</li></ol><h2 id="如何保证缓存和db的数据一致性"><a href="#如何保证缓存和db的数据一致性" class="headerlink" title="如何保证缓存和db的数据一致性"></a>如何保证缓存和db的数据一致性</h2><p>cache aside pattern<br>读请求：先读缓存-&gt;缓存命中，返回数据-&gt;缓存失败，读DB-&gt;更新缓存<br>写请求：先更新DB-&gt;再更新缓存 额外记录DB变更，比如1s内是否有 db:table:column 产生了修改，这样在读到相关缓存时，可以先判断这个 变更 缓存是否有内容。</p><p>如果相邻时间窗口内没有更新操作，那么认为当前读到的缓存时相对最新的；如果相邻时间窗口内有更新操作，那么需要将此次读到的内容丢弃，重读DB，并删除 or 更新缓存。</p>]]></content>
      
      
      <categories>
          
          <category> 研究所 </category>
          
          <category> 场景设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>请设计一个限流器</title>
      <link href="/research/design-prob/design-a-rate-limiter/"/>
      <url>/research/design-prob/design-a-rate-limiter/</url>
      
        <content type="html"><![CDATA[<h2 id="要求做一个限流器，限流范围是-10-千万qps，要求限流精度-99-，可以指定接口做限流配置"><a href="#要求做一个限流器，限流范围是-10-千万qps，要求限流精度-99-，可以指定接口做限流配置" class="headerlink" title="要求做一个限流器，限流范围是 10-千万qps，要求限流精度 99% ，可以指定接口做限流配置"></a>要求做一个限流器，限流范围是 10-千万qps，要求限流精度 99% ，可以指定接口做限流配置</h2><p>要实现一个具有高效限流和高精度的限流器，可以使用令牌桶（Token Bucket）算法。令牌桶算法能够处理高吞吐量的请求，同时具有较高的精度。</p><p>以下是一个使用 Go 语言实现的限流器示例，包含以下特性：</p><ol><li><strong>令牌桶算法</strong>：用于控制请求的速率。</li><li><strong>接口限流配置</strong>：可以指定不同的接口进行限流配置。</li><li><strong>高吞吐量支持</strong>：支持 10 到千万 QPS 的范围。</li><li><strong>高精度</strong>：限流精度 99%。</li></ol><h3 id="Go-语言实现限流器"><a href="#Go-语言实现限流器" class="headerlink" title="Go 语言实现限流器"></a>Go 语言实现限流器</h3><p>首先，我们定义一个 <code>RateLimiter</code> 结构体，使用令牌桶算法来实现限流器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RateLimiter implements a token bucket rate limiter.</span></span><br><span class="line"><span class="keyword">type</span> RateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">rate         <span class="type">int</span>           <span class="comment">// tokens generated per second</span></span><br><span class="line">burst        <span class="type">int</span>           <span class="comment">// max tokens in the bucket</span></span><br><span class="line">tokens       <span class="type">int</span>           <span class="comment">// current available tokens</span></span><br><span class="line">lastRefill   time.Time     <span class="comment">// last refill time</span></span><br><span class="line">mu           sync.Mutex    <span class="comment">// mutex for concurrent access</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewRateLimiter creates a new RateLimiter.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRateLimiter</span><span class="params">(rate <span class="type">int</span>, burst <span class="type">int</span>)</span></span> *RateLimiter &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;RateLimiter&#123;</span><br><span class="line">rate:       rate,</span><br><span class="line">burst:      burst,</span><br><span class="line">tokens:     burst,</span><br><span class="line">lastRefill: time.Now(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow checks if a request can proceed and decrements the token count.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *RateLimiter)</span></span> Allow() <span class="type">bool</span> &#123;</span><br><span class="line">rl.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rl.mu.Unlock()</span><br><span class="line"></span><br><span class="line">now := time.Now()</span><br><span class="line">elapsed := now.Sub(rl.lastRefill).Seconds()</span><br><span class="line">rl.tokens += <span class="type">int</span>(elapsed * <span class="type">float64</span>(rl.rate))</span><br><span class="line"><span class="keyword">if</span> rl.tokens &gt; rl.burst &#123;</span><br><span class="line">rl.tokens = rl.burst</span><br><span class="line">&#125;</span><br><span class="line">rl.lastRefill = now</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rl.tokens &gt; <span class="number">0</span> &#123;</span><br><span class="line">rl.tokens--</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RateLimiterManager <span class="keyword">struct</span> &#123;</span><br><span class="line">limiters <span class="keyword">map</span>[<span class="type">string</span>]*RateLimiter</span><br><span class="line">mu       sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewRateLimiterManager creates a new RateLimiterManager.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRateLimiterManager</span><span class="params">()</span></span> *RateLimiterManager &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;RateLimiterManager&#123;</span><br><span class="line">limiters: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*RateLimiter),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetRateLimiter returns the RateLimiter for a given endpoint.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *RateLimiterManager)</span></span> GetRateLimiter(endpoint <span class="type">string</span>, rate <span class="type">int</span>, burst <span class="type">int</span>) *RateLimiter &#123;</span><br><span class="line">manager.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> manager.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> limiter, exists := manager.limiters[endpoint]; exists &#123;</span><br><span class="line"><span class="keyword">return</span> limiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">limiter := NewRateLimiter(rate, burst)</span><br><span class="line">manager.limiters[endpoint] = limiter</span><br><span class="line"><span class="keyword">return</span> limiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example usage</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">manager := NewRateLimiterManager()</span><br><span class="line">endpoint := <span class="string">&quot;/api/test&quot;</span></span><br><span class="line">rate := <span class="number">1000000</span>   <span class="comment">// 1 million QPS</span></span><br><span class="line">burst := <span class="number">1000000</span>  <span class="comment">// burst capacity</span></span><br><span class="line"></span><br><span class="line">limiter := manager.GetRateLimiter(endpoint, rate, burst)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line"><span class="comment">// Process request</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;Request allowed&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Reject request</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;Request rejected&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><ol><li><strong>RateLimiter 结构体</strong>：包含速率（rate）、突发容量（burst）、当前令牌数（tokens）以及上次补充令牌的时间（lastRefill）。</li><li><strong>NewRateLimiter 函数</strong>：用于创建一个新的限流器实例。</li><li><strong>Allow 方法</strong>：检查请求是否可以通过，并相应地减少令牌数量。通过计算时间间隔来补充令牌。</li><li><strong>RateLimiterManager 结构体</strong>：用于管理不同接口的限流器。</li><li><strong>NewRateLimiterManager 函数</strong>：创建一个新的限流器管理器实例。</li><li><strong>GetRateLimiter 方法</strong>：获取指定接口的限流器，如果不存在则创建一个新的限流器。</li></ol><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>在 <code>main</code> 函数中，创建了一个限流器管理器，并为 <code>/api/test</code> 接口设置了限流参数。然后模拟 100 个请求，检查请求是否被允许。</p><p>这个限流器实现可以处理高吞吐量的请求，并且具有限流精度。你可以根据需要调整速率和突发容量，以适应不同的 QPS 范围。</p>]]></content>
      
      
      <categories>
          
          <category> 研究所 </category>
          
          <category> 场景设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>给定数字组成的比目标数字小的最大值</title>
      <link href="/interview/juan/bytedance-common-alg/smaller-largest-num-in-given-digits/"/>
      <url>/interview/juan/bytedance-common-alg/smaller-largest-num-in-given-digits/</url>
      
        <content type="html"><![CDATA[<p>给定一个目标数 n，给定一组数组 nums，求由 nums 组成的比 n 小的最大数。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 23112, nums = [2, 4, 9]输出：0</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">   <span class="string">&quot;sort&quot;</span>   <span class="string">&quot;strconv&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxLessThanN</span><span class="params">(target <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;  </span><br><span class="line">   targetStr := strconv.Itoa(target)  </span><br><span class="line">   <span class="keyword">var</span> targetNums []<span class="type">int</span>  </span><br><span class="line">   <span class="keyword">for</span> i, _ := <span class="keyword">range</span> targetStr &#123;  </span><br><span class="line">      targetNums = <span class="built_in">append</span>(targetNums, <span class="type">int</span>(targetStr[i]-<span class="string">&#x27;0&#x27;</span>))  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// Sort A in descending order  </span></span><br><span class="line">   sort.Sort(sort.Reverse(sort.IntSlice(nums)))  </span><br><span class="line">   ASet := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)  </span><br><span class="line">   <span class="keyword">for</span> _, a := <span class="keyword">range</span> nums &#123;  </span><br><span class="line">      ASet[a] = <span class="literal">true</span>  </span><br><span class="line">   &#125;  </span><br><span class="line">   length := <span class="built_in">len</span>(targetNums)  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;  </span><br><span class="line">      currentDigit := targetNums[i]  </span><br><span class="line">      largestLess, found := findLargestLessThan(currentDigit, nums)  </span><br><span class="line">  </span><br><span class="line">      <span class="keyword">if</span> found &#123;  </span><br><span class="line">         <span class="comment">// Replace the current digit with the largest less than itself  </span></span><br><span class="line">         targetNums[i] = largestLess  </span><br><span class="line">         <span class="comment">// Fill the rest of the digits with the largest in A  </span></span><br><span class="line">         <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; length; j++ &#123;  </span><br><span class="line">            targetNums[j] = nums[<span class="number">0</span>]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">break</span>  </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> !ASet[currentDigit] &#123;  </span><br><span class="line">         <span class="comment">// If current digit is not in A and we cannot find a smaller digit, backtrack  </span></span><br><span class="line">         <span class="keyword">for</span> i &gt;= <span class="number">0</span> &amp;&amp; !ASet[targetNums[i]] &#123;  </span><br><span class="line">            i--  </span><br><span class="line">         &#125;  </span><br><span class="line">  </span><br><span class="line">         <span class="keyword">if</span> i &lt; <span class="number">0</span> &#123;  </span><br><span class="line">            <span class="comment">// If no valid digit was found, return the largest possible number with one less digit  </span></span><br><span class="line">            result := <span class="number">0</span>  </span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; length<span class="number">-1</span>; j++ &#123;  </span><br><span class="line">               result = result*<span class="number">10</span> + nums[<span class="number">0</span>]  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> result  </span><br><span class="line">         &#125;  </span><br><span class="line">  </span><br><span class="line">         <span class="comment">// Replace the found digit with the largest less than itself and fill the rest  </span></span><br><span class="line">         largestLess, _ = findLargestLessThan(targetNums[i], nums)  </span><br><span class="line">         targetNums[i] = largestLess  </span><br><span class="line">         <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; length; j++ &#123;  </span><br><span class="line">            targetNums[j] = nums[<span class="number">0</span>]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">break</span>  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// Convert the runes back to an integer  </span></span><br><span class="line">   <span class="keyword">for</span> _, n := <span class="keyword">range</span> targetNums &#123;  </span><br><span class="line">      result = result*<span class="number">10</span> + n  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> result  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// findLargestLessThan finds the largest digit in A that is less than the given digitfunc findLargestLessThan(digit int, A []int) (int, bool) &#123;  </span></span><br><span class="line">   <span class="keyword">for</span> _, a := <span class="keyword">range</span> A &#123;  </span><br><span class="line">      <span class="keyword">if</span> a &lt; digit &#123;  </span><br><span class="line">         <span class="keyword">return</span> a, <span class="literal">true</span>  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   n := <span class="number">23121</span>  </span><br><span class="line">   A := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>&#125;  </span><br><span class="line">   fmt.Println(findMaxLessThanN(n, A)) <span class="comment">// Output: 22999  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><ol><li><strong>findLargestLessThan</strong>: 一个辅助函数，用于找到集合 A 中小于给定数字的最大数字。</li><li><strong>findMaxLessThanN</strong>: 主要函数，根据给定数字 n 和集合 A，逐位处理，找到满足条件的最大数字。<ul><li>将 n 转换为字符串以便逐位处理。</li><li>对集合 A 进行排序，并构建一个快速查找的集合 ASet。</li><li>从高位开始逐位处理 n，如果找到可以替换的数字则进行替换，并将后续位设为集合 A 中最大的数字。</li><li>如果无法替换当前位，进行回溯处理，找到可以替换的前一位。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.150 逆波兰表达式求值</title>
      <link href="/interview/juan/neet150/stack/leet-150-valid-parentheses1/"/>
      <url>/interview/juan/neet150/stack/leet-150-valid-parentheses1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></p><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p><p>请你计算该表达式。返回一个表示表达式值的整数。</p><p><strong>注意：</strong></p><ul><li>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</li><li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li><li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li><li>表达式中不含除零运算。</li><li>输入是一个根据逆波兰表示法表示的算术表达式。</li><li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li></ul><p><strong>示例 1：</strong></p><pre><code>输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]输出：9解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]输出：6解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]输出：22解释：该算式转化为常见的中缀算术表达式为：  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= tokens.length &lt;= 104</code></li><li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li></ul><p><strong>逆波兰表达式：</strong></p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul><li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li><li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + *</code> 也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li></ul><p>根据题意可知：栈中应当只有数字；表达式认为都是合法的，暂时不需要完备性校验</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evalRPN</span><span class="params">(tokens []<span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">stack := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, token := <span class="keyword">range</span> tokens &#123;</span><br><span class="line">val, err := strconv.Atoi(token)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, val)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">num1, num2 := stack[<span class="built_in">len</span>(stack)<span class="number">-2</span>], stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-2</span>]</span><br><span class="line"><span class="keyword">switch</span> token &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">stack = <span class="built_in">append</span>(stack, num1 + num2)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">stack = <span class="built_in">append</span>(stack, num1 - num2)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">stack = <span class="built_in">append</span>(stack, num1 * num2)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">stack = <span class="built_in">append</span>(stack, num1 / num2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stack[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.84 柱状图中最大的矩形</title>
      <link href="/interview/juan/neet150/stack/leet-84-largest-rectangle-in-histogram/"/>
      <url>/interview/juan/neet150/stack/leet-84-largest-rectangle-in-histogram/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></p><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg"></p><pre><code>输入：heights = [2,1,5,6,2,3]输出：10解释：最大的矩形为图中红色区域，面积为 10</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg"></p><pre><code>输入： heights = [2,4]输出： 4</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= heights.length &lt;=105</code></li><li><code>0 &lt;= heights[i] &lt;= 104</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.155 最小栈</title>
      <link href="/interview/juan/neet150/stack/leet-155-min-stack/"/>
      <url>/interview/juan/neet150/stack/leet-155-min-stack/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></p><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素val推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li></ul><p><strong>示例 1:</strong></p><pre><code>输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.</code></pre><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= val &lt;= 231 - 1</code></li><li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li><li><code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>最多被调用 <code>3 * 104</code> 次</li></ul><p>题目已经给好了大致的方法，因此定义结构和函数具体内容即可：</p><ol><li>根据要求需要常数级检索最小元素，因此一般单独字段直接存即可；</li><li>又因为 stack 先进后出的性质，在 pop 操作后，为了保证 getMin 扔能正确执行，还应该更新最小值，因此还应该记录每次 push 的时候当时最小值的更新现场。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">MinVal <span class="type">int</span></span><br><span class="line">Data []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MinStack &#123;</span><br><span class="line"><span class="keyword">return</span> MinStack&#123;</span><br><span class="line">Data: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">MinVal: <span class="number">-1</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Push(val <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(this.Data) == <span class="number">0</span> &#123;</span><br><span class="line">this.Data = <span class="built_in">append</span>(this.Data, <span class="number">0</span>)</span><br><span class="line">this.MinVal = val</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">diff := val - this.MinVal</span><br><span class="line"><span class="keyword">if</span> diff &lt; <span class="number">0</span> &#123;</span><br><span class="line">this.MinVal = val</span><br><span class="line">&#125;</span><br><span class="line">this.Data = <span class="built_in">append</span>(this.Data, diff)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Pop() &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(this.Data) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">diff := this.Data[<span class="built_in">len</span>(this.Data)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> diff &lt; <span class="number">0</span> &#123;</span><br><span class="line">this.MinVal = this.MinVal - diff</span><br><span class="line">&#125;</span><br><span class="line">this.Data = this.Data[:<span class="built_in">len</span>(this.Data)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Top() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(this.Data) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">diff := this.Data[<span class="built_in">len</span>(this.Data)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> diff &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> this.MinVal</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> this.MinVal + diff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> GetMin() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> this.MinVal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">* obj := Constructor();</span></span><br><span class="line"><span class="comment">* obj.Push(val);</span></span><br><span class="line"><span class="comment">* obj.Pop();</span></span><br><span class="line"><span class="comment">* param_3 := obj.Top();</span></span><br><span class="line"><span class="comment">* param_4 := obj.GetMin();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.572 另一棵树的子树</title>
      <link href="/interview/juan/neet150/trees/leet-572-subtree-of-another-tree/"/>
      <url>/interview/juan/neet150/trees/leet-572-subtree-of-another-tree/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></p><p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。<code>tree</code> 也可以看做它自身的一棵子树。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg"></p><pre><code>输入：root = [3,4,5,1,2], subRoot = [4,1,2]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg"></p><pre><code>输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]输出：false</code></pre><p><strong>提示：</strong></p><ul><li><code>root</code> 树上的节点数量范围是 <code>[1, 2000]</code></li><li><code>subRoot</code> 树上的节点数量范围是 <code>[1, 1000]</code></li><li><code>-104 &lt;= root.val &lt;= 104</code></li><li><code>-104 &lt;= subRoot.val &lt;= 104</code></li></ul><p>第一种方法：先深度优先 || 先序遍历主树，直到找到和 subRoot 相同值的节点，再以此为起点与 subRoot 做比较。属于暴力深搜的一种。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubtree</span><span class="params">(s *TreeNode, t *TreeNode)</span></span> <span class="type">bool</span> &#123; </span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> check(s, t) || isSubtree(s.Left, t) || isSubtree(s.Right, t) </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(a, b *TreeNode)</span></span> <span class="type">bool</span> &#123; </span><br><span class="line"><span class="keyword">if</span> a == <span class="literal">nil</span> &amp;&amp; b == <span class="literal">nil</span> &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> a == <span class="literal">nil</span> || b == <span class="literal">nil</span> &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a.Val == b.Val &#123; </span><br><span class="line"><span class="keyword">return</span> check(a.Left, b.Left) &amp;&amp; check(a.Right, b.Right) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>第二种方法：利用树的性质，将空子树补全，这样能得到唯一的一个先序遍历结果，然后判断 subRoot 的遍历结果是否是 root 遍历结果的子串，即可确认是否是题目要求的子树。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubtree</span><span class="params">(s *TreeNode, t *TreeNode)</span></span> <span class="type">bool</span> &#123; </span><br><span class="line">maxEle := math.MinInt32 </span><br><span class="line">getMaxElement(s, &amp;maxEle) </span><br><span class="line">getMaxElement(t, &amp;maxEle) </span><br><span class="line">lNull := maxEle + <span class="number">1</span></span><br><span class="line">rNull := maxEle + <span class="number">2</span></span><br><span class="line">sl, tl := getDfsOrder(s, []<span class="type">int</span>&#123;&#125;, lNull, rNull), getDfsOrder(t, []<span class="type">int</span>&#123;&#125;, lNull, rNull) </span><br><span class="line"><span class="keyword">return</span> kmp(sl, tl) </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kmp</span><span class="params">(s, t []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; </span><br><span class="line">sLen, tLen := <span class="built_in">len</span>(s), <span class="built_in">len</span>(t) </span><br><span class="line">fail := <span class="built_in">make</span>([]<span class="type">int</span>, sLen) </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; sLen; i++ &#123; </span><br><span class="line">fail[i] = <span class="number">-1</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">1</span>, <span class="number">-1</span>; i &lt; tLen; i++ &#123; </span><br><span class="line"><span class="keyword">for</span> j != <span class="number">-1</span> &amp;&amp; t[i] != t[j+<span class="number">1</span>] &#123; </span><br><span class="line">j = fail[j] </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> t[i] == t[j+<span class="number">1</span>] &#123; </span><br><span class="line">j++ </span><br><span class="line">&#125; </span><br><span class="line">fail[i] = j </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">-1</span>; i &lt; sLen; i++ &#123; </span><br><span class="line"><span class="keyword">for</span> j != <span class="number">-1</span> &amp;&amp; s[i] != t[j+<span class="number">1</span>] &#123; </span><br><span class="line">j = fail[j] </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> s[i] == t[j+<span class="number">1</span>] &#123; </span><br><span class="line">j++ </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> j == tLen - <span class="number">1</span> &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDfsOrder</span><span class="params">(t *TreeNode, list []<span class="type">int</span>, lNull, rNull <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123; </span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123; </span><br><span class="line"><span class="keyword">return</span> list </span><br><span class="line">&#125; </span><br><span class="line">list = <span class="built_in">append</span>(list, t.Val) </span><br><span class="line"><span class="keyword">if</span> t.Left != <span class="literal">nil</span> &#123; </span><br><span class="line">list = getDfsOrder(t.Left, list, lNull, rNull) </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">list = <span class="built_in">append</span>(list, lNull) </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> t.Right != <span class="literal">nil</span> &#123; </span><br><span class="line">list = getDfsOrder(t.Right, list, lNull, rNull) </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">list = <span class="built_in">append</span>(list, rNull) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> list </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMaxElement</span><span class="params">(t *TreeNode, maxEle *<span class="type">int</span>)</span></span> &#123; </span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123; </span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> t.Val &gt; *maxEle &#123; </span><br><span class="line">*maxEle = t.Val </span><br><span class="line">&#125; </span><br><span class="line">getMaxElement(t.Left, maxEle) </span><br><span class="line">getMaxElement(t.Right, maxEle) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Trees </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.50 Pow(x, n)</title>
      <link href="/uncategorized/leet-50-powx-n/"/>
      <url>/uncategorized/leet-50-powx-n/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/powx-n/">50. Pow(x, n)</a></p><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数（即，<code>xn</code> ）。</p><p><strong>示例 1：</strong></p><pre><code>输入：x = 2.00000, n = 10输出：1024.00000</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：x = 2.10000, n = 3输出：9.26100</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：x = 2.00000, n = -2输出：0.25000解释：2-2 = 1/22 = 1/4 = 0.25</code></pre><p><strong>提示：</strong></p><ul><li><code>-100.0 &lt; x &lt; 100.0</code></li><li><code>-231 &lt;= n &lt;= 231-1</code></li><li><code>n</code> 是一个整数</li><li>要么 <code>x</code> 不为零，要么 <code>n &gt; 0</code> 。</li><li><code>-104 &lt;= xn &lt;= 104</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myPow</span><span class="params">(x <span class="type">float64</span>, n <span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> quickMul(x, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span> / quickMul(x, -n)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickMul</span><span class="params">(x <span class="type">float64</span>, N <span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">ans := <span class="number">1.0</span></span><br><span class="line"><span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">x_contribute := x</span><br><span class="line"><span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line"><span class="keyword">for</span> N &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> N % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">ans *= x_contribute</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将贡献不断地平方</span></span><br><span class="line">x_contribute *= x_contribute</span><br><span class="line"><span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">N /= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.1186 删除一次得到子数组最大和</title>
      <link href="/uncategorized/leet-1186-maximum-subarray-sum-with-one-deletion/"/>
      <url>/uncategorized/leet-1186-maximum-subarray-sum-with-one-deletion/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/">1186. 删除一次得到子数组最大和</a></p><p>给你一个整数数组，返回它的某个 <strong>非空</strong> 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。</p><p>注意，删除一个元素后，子数组 <strong>不能为空</strong>。</p><p><strong>示例 1：</strong></p><pre><code>输入：arr = [1,-2,0,3]输出：4解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：arr = [1,-2,-2,3]输出：3解释：我们直接选出 [3]，这就是最大和。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：arr = [-1,-1,-1,-1]输出：-1解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。     我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 105</code></li><li><code>-104 &lt;= arr[i] &lt;= 104</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.322 零钱兑换</title>
      <link href="/interview/juan/neet150/1-d-dp/leet-322-coin-change/"/>
      <url>/interview/juan/neet150/1-d-dp/leet-322-coin-change/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></p><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><pre><code>输入：coins = `[1, 2, 5]`, amount = `11`输出：`3` 解释：11 = 5 + 5 + 1</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：coins = `[2]`, amount = `3`输出：-1</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：coins = [1], amount = 0输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> 1-D DP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.213 打家劫舍 II</title>
      <link href="/interview/juan/neet150/1-d-dp/leet-213-house-robber-ii/"/>
      <url>/interview/juan/neet150/1-d-dp/leet-213-house-robber-ii/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,2,3,1]输出：4解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。     偷窃到的最高金额 = 1 + 3 = 4 。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1,2,3]输出：3</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p>考虑第一个要不要访问，如果访问了，就是原来 3<del>n-1 的非环形版本<br>如果第一个未访问，就是原来 2</del>n-2 的非环形版本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">rob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">first, second := nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums[<span class="number">2</span>:] &#123;</span><br><span class="line">first, second = second, max(first+v, second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> second</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max(_rob(nums[:n<span class="number">-1</span>]), _rob(nums[<span class="number">1</span>:]))</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> 1-D DP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.416 分割等和子集</title>
      <link href="/interview/juan/neet150/1-d-dp/leet-416-partition-equal-subset-sum/"/>
      <url>/interview/juan/neet150/1-d-dp/leet-416-partition-equal-subset-sum/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></p><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11] 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,2,3,5]输出：false解释：数组不能分割成两个元素和相等的子集。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">if</span> n&lt;<span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">sum, max := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">sum += v</span><br><span class="line"><span class="keyword">if</span> v &gt; max &#123;</span><br><span class="line">max = v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 不能均分一半</span></span><br><span class="line"><span class="keyword">if</span> sum%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">tar := sum / <span class="number">2</span></span><br><span class="line"><span class="comment">// 如果有个元素比一半和还大，那么不可能找到</span></span><br><span class="line"><span class="keyword">if</span> max &gt; tar &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">bool</span>, n)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="keyword">range</span> dp &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, tar + <span class="number">1</span>)</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;n; i++ &#123;</span><br><span class="line">v := nums[i]</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;=tar; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j &gt;= v &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j] || dp[i<span class="number">-1</span>][j-v]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n<span class="number">-1</span>][tar]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> 1-D DP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>index</title>
      <link href="/interview/juan/neet150/arrays-hashing/index%201/"/>
      <url>/interview/juan/neet150/arrays-hashing/index%201/</url>
      
        <content type="html"><![CDATA[<p>271<br>36<br>347</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Arrays &amp; Hashing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>index</title>
      <link href="/interview/juan/neet150/backtracking/index%202/"/>
      <url>/interview/juan/neet150/backtracking/index%202/</url>
      
        <content type="html"><![CDATA[<p>78<br>90<br>131<br>17<br>51</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>index</title>
      <link href="/interview/juan/neet150/advanced-graphs/index/"/>
      <url>/interview/juan/neet150/advanced-graphs/index/</url>
      
        <content type="html"><![CDATA[<p>332<br>1584<br>743<br>778<br>269<br>787</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Advanced Graphs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>index</title>
      <link href="/interview/juan/neet150/2-d-dp/index/"/>
      <url>/interview/juan/neet150/2-d-dp/index/</url>
      
        <content type="html"><![CDATA[<p>10<br>97<br>115<br>309<br>312<br>329<br>494<br>518</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> 2-D DP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>index</title>
      <link href="/interview/juan/neet150/graphs/index%203/"/>
      <url>/interview/juan/neet150/graphs/index%203/</url>
      
        <content type="html"><![CDATA[<p>286<br>994<br>130<br>210<br>261<br>323<br>127<br>684</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Graphs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>index</title>
      <link href="/interview/juan/neet150/b-search/index%201/"/>
      <url>/interview/juan/neet150/b-search/index%201/</url>
      
        <content type="html"><![CDATA[<p>704<br>74<br>875<br>981</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>index</title>
      <link href="/interview/juan/neet150/heap-queue/index%201/"/>
      <url>/interview/juan/neet150/heap-queue/index%201/</url>
      
        <content type="html"><![CDATA[<p>703<br>1046<br>621<br>355</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Heap &amp; Priority Queue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>index</title>
      <link href="/interview/juan/neet150/linked-list/index%206/"/>
      <url>/interview/juan/neet150/linked-list/index%206/</url>
      
        <content type="html"><![CDATA[<p>138<br>287</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>index</title>
      <link href="/interview/juan/neet150/greedy/index%202/"/>
      <url>/interview/juan/neet150/greedy/index%202/</url>
      
        <content type="html"><![CDATA[<p>45<br>134<br>846<br>1899<br>763<br>678</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>index</title>
      <link href="/interview/juan/neet150/interval/index%205/"/>
      <url>/interview/juan/neet150/interval/index%205/</url>
      
        <content type="html"><![CDATA[<p>252<br>253<br>1851</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Intervals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>index</title>
      <link href="/interview/juan/neet150/math/index%207/"/>
      <url>/interview/juan/neet150/math/index%207/</url>
      
        <content type="html"><![CDATA[<p>202<br>66<br>50<br>43<br>2013</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>index</title>
      <link href="/interview/juan/neet150/bit/index%204/"/>
      <url>/interview/juan/neet150/bit/index%204/</url>
      
        <content type="html"><![CDATA[<p>136<br>7<br>371</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>index</title>
      <link href="/interview/juan/neet150/stack/index%209/"/>
      <url>/interview/juan/neet150/stack/index%209/</url>
      
        <content type="html"><![CDATA[<p>22<br>739<br>853</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.167 两数之和 II - 输入有序数组</title>
      <link href="/interview/juan/neet150/two-ptr/leet-167-two-sum-ii-input-array-is-sorted/"/>
      <url>/interview/juan/neet150/two-ptr/leet-167-two-sum-ii-input-array-is-sorted/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></p><p>给你一个下标从 <strong>1</strong> 开始的整数数组 <code>numbers</code> ，该数组已按 <strong>非递减顺序排列</strong>  ，请你从数组中找出满足相加之和等于目标数 <code>target</code> 的两个数。如果设这两个数分别是 <code>numbers[index1]</code> 和 <code>numbers[index2]</code> ，则 <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code> 。</p><p>以长度为 2 的整数数组 <code>[index1, index2]</code> 的形式返回这两个整数的下标 <code>index1</code> 和 <code>index2</code>。</p><p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p><p>你所设计的解决方案必须只使用常量级的额外空间。</p><p> </p><p><strong>示例 1：</strong></p><pre><code>输入：numbers = [_2_,_7_,11,15], target = 9输出：[1,2]解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：numbers = [_2_,3,_4_], target = 6输出：[1,3]解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：numbers = [_-1_,_0_], target = -1输出：[1,2]解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= numbers.length &lt;= 3 * 104</code></li><li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li><li><code>numbers</code> 按 <strong>非递减顺序</strong> 排列</li><li><code>-1000 &lt;= target &lt;= 1000</code></li><li><strong>仅存在一个有效答案</strong></li></ul><p>从左右两边出发，如果和比目标值小，那么左边 ++ ，如果比目标值大，那么右边 –，直到找到目标答案</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(numbers []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">low, high := <span class="number">0</span>, <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line">sum := numbers[low] + numbers[high]</span><br><span class="line"><span class="keyword">if</span> sum == target &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;low + <span class="number">1</span>, high + <span class="number">1</span>&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &lt; target &#123;</span><br><span class="line">low++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">high--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照普通 2sum 的方法，因为是有序的数组，原先普通遍历的方案可以改成 二分查找 target - num[i]</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(numbers []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(numbers); i++ &#123;</span><br><span class="line">low, high := i+<span class="number">1</span>, <span class="built_in">len</span>(numbers)<span class="number">-1</span></span><br><span class="line">nextTar := target - numbers[i]</span><br><span class="line"><span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">mid := (high-low)/<span class="number">2</span> + low</span><br><span class="line"><span class="keyword">if</span> numbers[mid] == nextTar &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;i+<span class="number">1</span>, mid+<span class="number">1</span>&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> numbers[mid] &gt; nextTar &#123;</span><br><span class="line">high = mid<span class="number">-1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">low = mid+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>index</title>
      <link href="/interview/juan/neet150/s-window/index%207%201/"/>
      <url>/interview/juan/neet150/s-window/index%207%201/</url>
      
        <content type="html"><![CDATA[<p>239</p><p>567</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet221</title>
      <link href="/uncategorized/leet221/"/>
      <url>/uncategorized/leet221/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字节跳动高频题——圆环回原点问题</title>
      <link href="/interview/juan/bytedance-common-alg/back-2-start-in-circle/"/>
      <url>/interview/juan/bytedance-common-alg/back-2-start-in-circle/</url>
      
        <content type="html"><![CDATA[<p>圆环上有10个点，编号为0~9。从0点出发，每次可以逆时针和顺时针走一步，问走n步回到0点共有多少种走法。</p><pre><code>输入: 2输出: 2解释：有2种方案。分别是0-&gt;1-&gt;0和0-&gt;9-&gt;0</code></pre><p>采用动态规划，类似 <a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a><br>走 n 步到 0 的方案数 &#x3D; 走 n-1 步到 1 的方案数 + 走 n-1 步到 9 的方案数。<br>由于本题目中有环，所以相关方程需要有取余的步骤。</p><p>dp[i][j] &#x3D; dp[i-1][(j-1+length) % length] + dp[i-1][(j+1) % length]</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backToOrigin</span><span class="params">(n)</span></span>:  </span><br><span class="line"><span class="comment">// 点的个数为10  </span></span><br><span class="line">length := <span class="number">10</span>  </span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="keyword">range</span> dp &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, length)</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;n+<span class="number">1</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;length; j++ &#123;</span><br><span class="line"><span class="comment">// dp[i][j]表示从0出发，走i步到j的方案数</span></span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][(j<span class="number">-1</span>+length)%length] + dp[i<span class="number">-1</span>][(j+<span class="number">1</span>)%length]  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.77 组合</title>
      <link href="/uncategorized/leet-77-combinations/"/>
      <url>/uncategorized/leet-77-combinations/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></p><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 4, k = 2输出：[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 1, k = 1输出：[[1]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.746 使用最小花费爬楼梯</title>
      <link href="/interview/juan/neet150/1-d-dp/leet-746-min-cost-climbing-stairs/"/>
      <url>/interview/juan/neet150/1-d-dp/leet-746-min-cost-climbing-stairs/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></p><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p><strong>示例 1：</strong></p><pre><code>输入：cost = [10,_**15**_,20]输出：15解释：你将从下标为 1 的台阶开始。- 支付 15 ，向上爬两个台阶，到达楼梯顶部。总花费为 15 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：cost = [_**1**_,100,_**1**_,1,_**1**_,100,_**1**_,_**1**_,100,_**1**_]输出：6解释：你将从下标为 0 的台阶开始。- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。- 支付 1 ，向上爬一个台阶，到达楼梯顶部。总花费为 6 。</code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= cost.length &lt;= 1000</code></li><li><code>0 &lt;= cost[i] &lt;= 999</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(cost) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(cost) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> cost[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">spent := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(cost)+<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 相当于第一步免费，可以走0步或者1步</span></span><br><span class="line">spent[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">spent[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">2</span>; i&lt;=<span class="built_in">len</span>(cost); i++ &#123;</span><br><span class="line">spent[i] = min(spent[i<span class="number">-2</span>] + cost[i<span class="number">-2</span>], spent[i<span class="number">-1</span>] + cost[i<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> spent[<span class="built_in">len</span>(cost)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> 1-D DP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet1143</title>
      <link href="/uncategorized/leet1143/"/>
      <url>/uncategorized/leet1143/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.380 O(1) 时间插入、删除和获取随机元素</title>
      <link href="/interview/juan/bytedance-common-alg/leet-380-insert-delete-getrandom-o1/"/>
      <url>/interview/juan/bytedance-common-alg/leet-380-insert-delete-getrandom-o1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/insert-delete-getrandom-o1/">380. O(1) 时间插入、删除和获取随机元素</a></p><p>实现<code>RandomizedSet</code> 类：</p><ul><li><code>RandomizedSet()</code> 初始化 <code>RandomizedSet</code> 对象</li><li><code>bool insert(int val)</code> 当元素 <code>val</code> 不存在时，向集合中插入该项，并返回 <code>true</code> ；否则，返回 <code>false</code> 。</li><li><code>bool remove(int val)</code> 当元素 <code>val</code> 存在时，从集合中移除该项，并返回 <code>true</code> ；否则，返回 <code>false</code> 。</li><li><code>int getRandom()</code> 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 <strong>相同的概率</strong> 被返回。</li></ul><p>你必须实现类的所有函数，并满足每个函数的 <strong>平均</strong> 时间复杂度为 <code>O(1)</code> 。</p><p><strong>示例：</strong></p><pre><code>输入[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;][[], [1], [2], [2], [], [1], [2], []]输出[null, true, false, true, 2, true, false, 2]解释RandomizedSet randomizedSet = new RandomizedSet();randomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。randomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。randomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。randomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。randomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。randomizedSet.insert(2); // 2 已在集合中，所以返回 false 。randomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。</code></pre><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= val &lt;= 231 - 1</code></li><li>最多调用 <code>insert</code>、<code>remove</code> 和 <code>getRandom</code> 函数 <code>2 *</code> <code>105</code> 次</li><li>在调用 <code>getRandom</code> 方法时，数据结构中 <strong>至少存在一个</strong> 元素。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RandomizedSet <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// map 中存储元素和所在的 idx</span></span><br><span class="line">MemberM <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">MemberL []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> RandomizedSet &#123;</span><br><span class="line"><span class="keyword">return</span> RandomizedSet&#123;</span><br><span class="line">MemberM: <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;,</span><br><span class="line">MemberL: []<span class="type">int</span>&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span></span> Insert(val <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := this.MemberM[val]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">this.MemberL = <span class="built_in">append</span>(this.MemberL, val)</span><br><span class="line">this.MemberM[val] = <span class="built_in">len</span>(this.MemberL)<span class="number">-1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span></span> Remove(val <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">idx, ok := this.MemberM[val]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为了保持 o1 将 list 末尾元素替换到已删除的位置</span></span><br><span class="line">last := <span class="built_in">len</span>(this.MemberL)<span class="number">-1</span></span><br><span class="line">this.MemberL[idx] = this.MemberL[last]</span><br><span class="line">this.MemberM[this.MemberL[idx]] = idx</span><br><span class="line">this.MemberL = this.MemberL[:last]</span><br><span class="line"><span class="comment">// 同时清理 map 相关内存</span></span><br><span class="line"><span class="built_in">delete</span>(this.MemberM, val)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span></span> GetRandom() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> this.MemberL[rand.Intn(<span class="built_in">len</span>(this.MemberL))]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">* obj := Constructor();</span></span><br><span class="line"><span class="comment">* param_1 := obj.Insert(val);</span></span><br><span class="line"><span class="comment">* param_2 := obj.Remove(val);</span></span><br><span class="line"><span class="comment">* param_3 := obj.GetRandom();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.114 二叉树展开为链表</title>
      <link href="/interview/juan/bytedance-common-alg/leet-114-flatten-binary-tree-to-linked-list/"/>
      <url>/interview/juan/bytedance-common-alg/leet-114-flatten-binary-tree-to-linked-list/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></p><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg"></p><pre><code>输入：root = [1,2,5,3,4,null,6]输出：[1,null,2,null,3,null,4,null,5,null,6]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [0]输出：[0]</code></pre><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p><p>注意要按照题目要求将原来树的左右更换指向，构成如图的斜树</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Left *TreeNode</span></span><br><span class="line"><span class="comment">* Right *TreeNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatten</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">nodes := preOrder(root)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(nodes); i++ &#123;</span><br><span class="line">pre, cur := nodes[i<span class="number">-1</span>], nodes[i]</span><br><span class="line">pre.Left, pre.Right = <span class="literal">nil</span>, cur</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preOrder</span><span class="params">(root *TreeNode)</span></span> []*TreeNode &#123;</span><br><span class="line">nodes := []*TreeNode&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">nodes = <span class="built_in">append</span>(nodes, root)</span><br><span class="line">nodes = <span class="built_in">append</span>(nodes, preOrder(root.Left)...)</span><br><span class="line">nodes = <span class="built_in">append</span>(nodes, preOrder(root.Right)...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.41 缺失的第一个正数</title>
      <link href="/interview/juan/bytedance-common-alg/leet-41-first-missing-positive/"/>
      <url>/interview/juan/bytedance-common-alg/leet-41-first-missing-positive/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a></p><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,0]输出：3解释：范围 [1,2] 中的数字都在数组中。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [3,4,-1,1]输出：2解释：1 在数组中，但 2 没有。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [7,8,9,11,12]输出：1解释：最小的正数 1 没有出现。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstMissingPositive</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] &lt;= <span class="number">0</span> &#123;</span><br><span class="line">nums[i] = n+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fmt.Println(nums)</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">num := abs(nums[i])</span><br><span class="line"><span class="keyword">if</span> num &lt;= n &#123;</span><br><span class="line">nums[num<span class="number">-1</span>] = <span class="number">-1</span> * abs(nums[num<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> -x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.8 字符串转换整数 (atoi)</title>
      <link href="/interview/juan/bytedance-common-alg/leet-8-string-to-integer-atoi/"/>
      <url>/interview/juan/bytedance-common-alg/leet-8-string-to-integer-atoi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></p><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数。</p><p>函数 <code>myAtoi(string s)</code> 的算法如下：</p><ol><li><strong>空格：</strong>读入字符串并丢弃无用的前导空格（<code>&quot; &quot;</code>）</li><li><strong>符号：</strong>检查下一个字符（假设还未到字符末尾）为 <code>&#39;-&#39;</code> 还是 <code>&#39;+&#39;</code>。如果两者都不存在，则假定结果为正。</li><li><strong>转换：</strong>通过跳过前置零来读取该整数，直到遇到非数字字符或到达字符串的结尾。如果没有读取数字，则结果为0。</li><li><strong>舍入：</strong>如果整数数超过 32 位有符号整数范围 <code>[−231,  231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被舍入为 <code>−231</code> ，大于 <code>231 − 1</code> 的整数应该被舍入为 <code>231 − 1</code> 。</li></ol><p>返回整数作为最终结果。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;42&quot;输出：42解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。带下划线线的字符是所读的内容，插入符号是当前读入位置。第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）         ^第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）         ^第 3 步：&quot;42&quot;（读入 &quot;42&quot;）           ^</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot; -042&quot;输出：-42解释：第 1 步：&quot;   -042&quot;（读入前导空格，但忽视掉）            ^第 2 步：&quot;   -042&quot;（读入 &#39;-&#39; 字符，所以结果应该是负数）             ^第 3 步：&quot;   -042&quot;（读入 &quot;042&quot;，在结果中忽略前导零）               ^</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;1337c0d3&quot;输出：1337解释：第 1 步：&quot;1337c0d3&quot;（当前没有读入字符，因为没有前导空格）         ^第 2 步：&quot;1337c0d3&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）         ^第 3 步：&quot;1337c0d3&quot;（读入 &quot;1337&quot;；由于下一个字符不是一个数字，所以读入停止）             ^</code></pre><p><strong>示例 4：</strong></p><pre><code>输入：s = &quot;0-1&quot;输出：0解释：第 1 步：&quot;0-1&quot; (当前没有读入字符，因为没有前导空格)         ^第 2 步：&quot;0-1&quot; (当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;)         ^第 3 步：&quot;0-1&quot; (读入 &quot;0&quot;；由于下一个字符不是一个数字，所以读入停止)          ^</code></pre><p><strong>示例 5：</strong></p><pre><code>输入：s = &quot;words and 987&quot;输出：0解释：读取在第一个非数字字符“w”处停止。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 200</code></li><li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>&#39; &#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAtoi</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> ans <span class="type">int</span></span><br><span class="line">sign := <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> MinInt32, MaxInt32 = <span class="number">-1</span> * <span class="number">1</span>&lt;&lt;<span class="number">31</span>, <span class="number">1</span>&lt;&lt;<span class="number">31</span> - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; i&lt;<span class="built_in">len</span>(s) &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>; i++ &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i&gt;=<span class="built_in">len</span>(s) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> s[i] == <span class="string">&#x27;-&#x27;</span> &#123;</span><br><span class="line">sign = <span class="number">-1</span></span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] == <span class="string">&#x27;+&#x27;</span> &#123;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> ; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> s[i]-<span class="string">&#x27;0&#x27;</span> &lt;<span class="number">0</span> || s[i]-<span class="string">&#x27;0&#x27;</span>&gt;<span class="number">9</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">ans = ans * <span class="number">10</span> + <span class="type">int</span>(s[i] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> ans * sign &lt; MinInt32 &#123;</span><br><span class="line"><span class="keyword">return</span> MinInt32</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ans * sign &gt; MaxInt32 &#123;</span><br><span class="line"><span class="keyword">return</span> MaxInt32</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> ans * sign</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.232 用栈实现队列</title>
      <link href="/interview/juan/bytedance-common-alg/leet-232-implement-queue-using-stacks/"/>
      <url>/interview/juan/bytedance-common-alg/leet-232-implement-queue-using-stacks/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></p><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p><strong>示例 1：</strong></p><pre><code>输入：[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;][[], [1], [2], [], [], []]输出：[null, null, null, 1, 1, false]解释：MyQueue myQueue = new MyQueue();myQueue.push(1); // queue is: [1]myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)myQueue.peek(); // return 1myQueue.pop(); // return 1, queue is [2]myQueue.empty(); // return false</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li></ul><p><strong>进阶：</strong></p><ul><li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li></ul><p>因为题目要求使用栈来完成，所以对于 []int 的相关操作还是要按照栈的模式来处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">inStack, outStack []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyQueue &#123;</span><br><span class="line"><span class="keyword">return</span> MyQueue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Push(x <span class="type">int</span>) &#123;</span><br><span class="line">this.inStack = <span class="built_in">append</span>(this.inStack, x)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> in2out() &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(this.inStack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">this.outStack = <span class="built_in">append</span>(this.outStack, this.inStack[<span class="built_in">len</span>(this.inStack)<span class="number">-1</span>])</span><br><span class="line">this.inStack = this.inStack[:<span class="built_in">len</span>(this.inStack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Pop() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(this.outStack) == <span class="number">0</span> &#123;</span><br><span class="line">this.in2out()</span><br><span class="line">&#125;</span><br><span class="line">x := this.outStack[<span class="built_in">len</span>(this.outStack)<span class="number">-1</span>]</span><br><span class="line">this.outStack = this.outStack[:<span class="built_in">len</span>(this.outStack)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Peek() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(this.outStack) == <span class="number">0</span> &#123;</span><br><span class="line">this.in2out()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> this.outStack[<span class="built_in">len</span>(this.outStack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Empty() <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(this.inStack) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(this.outStack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">* obj := Constructor();</span></span><br><span class="line"><span class="comment">* obj.Push(x);</span></span><br><span class="line"><span class="comment">* param_2 := obj.Pop();</span></span><br><span class="line"><span class="comment">* param_3 := obj.Peek();</span></span><br><span class="line"><span class="comment">* param_4 := obj.Empty();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.4 寻找两个正序数组的中位数</title>
      <link href="/interview/juan/neet150/b-search/leet-4-median-of-two-sorted-arrays/"/>
      <url>/interview/juan/neet150/b-search/leet-4-median-of-two-sorted-arrays/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></p><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums1 = [1,3], nums2 = [2]输出：2.00000解释：合并数组 = [1,2,3] ，中位数 2</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums1 = [1,2], nums2 = [3,4]输出：2.50000解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</code></pre><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.72 编辑距离</title>
      <link href="/interview/juan/neet150/2-d-dp/leet-72-edit-distance/"/>
      <url>/interview/juan/neet150/2-d-dp/leet-72-edit-distance/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></p><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em>  。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例 1：</strong></p><pre><code>输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&gt; rose (删除 &#39;r&#39;)rose -&gt; ros (删除 &#39;e&#39;)</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &#39;t&#39;)inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)exection -&gt; execution (插入 &#39;u&#39;)</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><p>一般来说，如果涉及两个对象之间的 dp，常规方案是一个二维 dp</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDistance</span><span class="params">(word1 <span class="type">string</span>, word2 <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">l1, l2 := <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line"><span class="keyword">if</span> l1 * l2 == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> l1 + l2</span><br><span class="line">&#125;</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">int</span>, l1+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, l2+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dp[0][0] = 0</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;l1+<span class="number">1</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;l2+<span class="number">1</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = j</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;l1; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;l2; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> word1[i] == word2[j] &#123;</span><br><span class="line">dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span> + min(dp[i+<span class="number">1</span>][j], min(dp[i][j+<span class="number">1</span>], dp[i][j]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[l1][l2]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> 2-D DP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.93 复原 IP 地址</title>
      <link href="/interview/juan/bytedance-common-alg/leet-93-restore-ip-addresses/"/>
      <url>/interview/juan/bytedance-common-alg/leet-93-restore-ip-addresses/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></p><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔。</p><ul><li>例如：<code>&quot;0.1.2.201&quot;</code> 和 <code>&quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;25525511135&quot;输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;0000&quot;输出：[&quot;0.0.0.0&quot;]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;101023&quot;输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅由数字组成</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">restoreIpAddresses</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">ans := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">segs := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">4</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>, segId, idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> segId == <span class="number">4</span> &#123;</span><br><span class="line"><span class="keyword">if</span> idx == <span class="built_in">len</span>(s) &#123;</span><br><span class="line">ip := strings.Join(segs, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">ans = <span class="built_in">append</span>(ans, ip)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 到头了没成型 4 段</span></span><br><span class="line"><span class="keyword">if</span> idx == <span class="built_in">len</span>(s) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有前导零</span></span><br><span class="line"><span class="keyword">if</span> s[idx] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">segs[segId] = <span class="string">&quot;0&quot;</span></span><br><span class="line">dfs(s, segId+<span class="number">1</span>, idx+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 常规情况</span></span><br><span class="line">cur := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j:=idx; j&lt;<span class="built_in">len</span>(s); j++ &#123;</span><br><span class="line">cur = cur * <span class="number">10</span> + <span class="type">int</span>(s[j]-<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="comment">// 比如 11153 会按照 11,111 分别截断去 dfs</span></span><br><span class="line"><span class="keyword">if</span> cur &gt;<span class="number">0</span> &amp;&amp; cur &lt;=<span class="number">255</span> &#123;</span><br><span class="line">segs[segId] = fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, cur)</span><br><span class="line">dfs(s, segId+<span class="number">1</span>, j+<span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">dfs(s, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法题：找到两个有序数组中第 k 大的数字</title>
      <link href="/interview/juan/bytedance-common-alg/find-kth-num-in-2-sorted-list/"/>
      <url>/interview/juan/bytedance-common-alg/find-kth-num-in-2-sorted-list/</url>
      
        <content type="html"><![CDATA[<p>给定两个分别有序的数组nums1，nums2，输出这两个数组总体排序后的第K小的元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthElement</span><span class="params">(nums1, nums2 []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> getKthElement <span class="function"><span class="keyword">func</span><span class="params">([]<span class="type">int</span>, []<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>  </span><br><span class="line">    getKthElement = <span class="function"><span class="keyword">func</span><span class="params">(arr1 []<span class="type">int</span>, arr2 []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">        l1, l2 := <span class="built_in">len</span>(arr1), <span class="built_in">len</span>(arr2)  </span><br><span class="line">        <span class="keyword">if</span> l1 &gt; l2 &#123;  </span><br><span class="line">            <span class="keyword">return</span> getKthElement(arr2, arr1, k)  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> l1 == <span class="number">0</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> arr2[k<span class="number">-1</span>]  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> min(arr1[<span class="number">0</span>], arr2[<span class="number">0</span>])  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        i := min(l1, k/<span class="number">2</span>)  </span><br><span class="line">        j := min(l2, k/<span class="number">2</span>)  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> arr1[i<span class="number">-1</span>] &gt; arr2[j<span class="number">-1</span>] &#123;  </span><br><span class="line">            <span class="keyword">return</span> getKthElement(arr1, arr2[j:], k-j)  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> getKthElement(arr1[i:], arr2, k-i)  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> getKthElement(nums1, nums2, k)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;  </span><br><span class="line">        <span class="keyword">return</span> b  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> a  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(findKthElement([]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;, <span class="number">4</span>))  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.82 删除排序链表中的重复元素 II</title>
      <link href="/interview/juan/bytedance-common-alg/leet-82-remove-duplicates-from-sorted-list-ii/"/>
      <url>/interview/juan/bytedance-common-alg/leet-82-remove-duplicates-from-sorted-list-ii/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></p><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg"></p><pre><code>输入：head = [1,2,3,3,4,4,5]输出：[1,2,5]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg"></p><pre><code>输入：head = [1,1,1,2,3]输出：[2,3]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序 <strong>排列</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Next *ListNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">dummy := &amp;ListNode&#123;Next: head&#125;</span><br><span class="line">cur := dummy</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> cur.Next != <span class="literal">nil</span> &amp;&amp; cur.Next.Next != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> cur.Next.Val == cur.Next.Next.Val &#123;</span><br><span class="line">x := cur.Next.Val</span><br><span class="line"><span class="keyword">for</span> cur.Next != <span class="literal">nil</span> &amp;&amp; cur.Next.Val == x &#123;</span><br><span class="line">cur.Next = cur.Next.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cur = cur.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.56 合并区间</title>
      <link href="/interview/juan/neet150/interval/leet-56-merge-intervals/"/>
      <url>/interview/juan/neet150/interval/leet-56-merge-intervals/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></p><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]输出：[[1,6],[8,10],[15,18]]解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：intervals = [[1,4],[4,5]]输出：[[1,5]]解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals [][]<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(intervals) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> intervals</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其实只按照 第一位 排序就可以了，但是考虑到 第二位 交错的情况，我觉得还是应该有序</span></span><br><span class="line">sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> intervals[i][<span class="number">0</span>] &lt; intervals[j][<span class="number">0</span>] || (intervals[i][<span class="number">0</span>] == intervals[j][<span class="number">0</span>] &amp;&amp; intervals[i][<span class="number">1</span>] &lt; intervals[j][<span class="number">1</span>])</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line">ans := [][]<span class="type">int</span>&#123;intervals[<span class="number">0</span>]&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(intervals); i++ &#123;</span><br><span class="line">cur := ans[<span class="built_in">len</span>(ans)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> cur[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>] &#123;</span><br><span class="line">ans = ans[:<span class="built_in">len</span>(ans)<span class="number">-1</span>]</span><br><span class="line">cur[<span class="number">1</span>] = max(cur[<span class="number">1</span>], intervals[i][<span class="number">1</span>])</span><br><span class="line">ans = <span class="built_in">append</span>(ans, cur)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ans = <span class="built_in">append</span>(ans, intervals[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Intervals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.142 环形链表 II</title>
      <link href="/interview/juan/bytedance-common-alg/leet-142-linked-list-cycle-ii/"/>
      <url>/interview/juan/bytedance-common-alg/leet-142-linked-list-cycle-ii/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></p><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png"></p><pre><code>输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png"></p><pre><code>输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png"></p><pre><code>输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p><p>方法1：哈希表，struct 是可比较结构，因此可以作为 map 的 key 来使用</p><p>方法2：快慢指针<br>任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍。因此，我们有</p><p>a+(n+1)b+nc&#x3D;2(a+b)  ⟹  a&#x3D;c+(n−1)(b+c)</p><p>我们会发现：从相遇点到入环点的距离加上 n−1 圈的环长，恰好等于从链表头部到入环点的距离。</p><p>因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Next *ListNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">s, f := head, head</span><br><span class="line"><span class="keyword">for</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">s = s.Next</span><br><span class="line"><span class="keyword">if</span> f.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">f = f.Next.Next</span><br><span class="line"><span class="keyword">if</span> f == s &#123;</span><br><span class="line">p := head</span><br><span class="line"><span class="keyword">for</span> p!= s &#123;</span><br><span class="line">p = p.Next</span><br><span class="line">s = s.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.912 排序数组</title>
      <link href="/interview/juan/bytedance-common-alg/leet-912-sort-an-array/"/>
      <url>/interview/juan/bytedance-common-alg/leet-912-sort-an-array/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组</a></p><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [5,2,3,1]输出：[1,2,3,5]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [5,1,1,2,0,0]输出：[0,0,1,1,2,5]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5 * 104</code></li><li><code>-5 * 104 &lt;= nums[i] &lt;= 5 * 104</code></li></ul><h3 id="冒泡排序，"><a href="#冒泡排序，" class="headerlink" title="冒泡排序，"></a>冒泡排序，</h3><p>比较交换，稳定算法，时间O(n^2), 空间O(1)<br>每一轮遍历，将该轮最大值放到后面，同时小的往前冒<br>从而形成后部是有序区<br>compare and swap </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123; </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123; </span><br><span class="line"><span class="comment">// 适当剪枝，len()-i到最后的部分都是有序区，避免再排 </span></span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">1</span>;j&lt;<span class="built_in">len</span>(nums)-i;j++ &#123; </span><br><span class="line"><span class="keyword">if</span> nums[j<span class="number">-1</span>] &gt; nums[j] &#123; </span><br><span class="line">nums[j<span class="number">-1</span>], nums[j] = nums[j], nums[j<span class="number">-1</span>] </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> nums </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>比较交换，不稳定算法，时间O(n^2)，空间O(1)<br>每一轮遍历，该轮的最小值前挪，从而形成前面部分是有序区<br>compare and swap</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123; </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123; </span><br><span class="line"><span class="comment">// 剪枝前面部分，比较后面部分</span></span><br><span class="line"><span class="keyword">for</span> j:=i+<span class="number">1</span>;j&lt;<span class="built_in">len</span>(nums);j++ &#123; </span><br><span class="line"><span class="keyword">if</span> nums[i] &gt; nums[j] &#123; </span><br><span class="line">nums[i], nums[j] = nums[j], nums[i] </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> nums </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>比较交换，稳定算法，时间O(n^2)，空间O(1)<br>0-&gt;len方向，每轮从后往前比较，相当于找到合适位置，插入进去<br>数据规模小的时候，或基本有序，效率高</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123; </span><br><span class="line">n := <span class="built_in">len</span>(nums) </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123; </span><br><span class="line">tmp := nums[i] </span><br><span class="line">j := i - <span class="number">1</span> </span><br><span class="line"><span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; tmp &#123; </span><br><span class="line"><span class="comment">//左边比右边大 </span></span><br><span class="line">nums[j+<span class="number">1</span>] = nums[j] </span><br><span class="line"><span class="comment">//右移1位 </span></span><br><span class="line">j-- </span><br><span class="line"><span class="comment">//扫描前一个数 </span></span><br><span class="line">&#125; </span><br><span class="line">nums[j+<span class="number">1</span>] = tmp </span><br><span class="line"><span class="comment">//添加到小于它的数的右边 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> nums </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>比较交换，不稳定算法，时间O(nlog2n)最坏O(n^2), 空间O(1)<br>改进插入算法<br>每一轮按照间隔插入排序，间隔依次减小，最后一次一定是1<br>主要思想： 设增量序列个数为k，则进行k轮排序。每一轮中， 按照某个增量将数据分割成较小的若干组， 每一组内部进行插入排序；各组排序完毕后， 减小增量，进行下一轮的内部排序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">gap := <span class="built_in">len</span>(nums)/<span class="number">2</span> </span><br><span class="line"><span class="keyword">for</span> gap &gt; <span class="number">0</span> &#123; </span><br><span class="line"><span class="keyword">for</span> i:=gap;i&lt;<span class="built_in">len</span>(nums);i++ &#123; </span><br><span class="line">j := i </span><br><span class="line"><span class="keyword">for</span> j-gap &gt;= <span class="number">0</span> &amp;&amp; nums[j-gap] &gt; nums[j] &#123; </span><br><span class="line">nums[j-gap], nums[j] = nums[j], nums[j-gap] </span><br><span class="line">j -= gap </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">gap /= <span class="number">2</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> nums </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>基于比较，稳定算法，时间O(nlogn)，空间O(logn) | O(n)<br>基于递归的归并-自上而下的合并，另有非递归法的归并(自下而上的合并)<br>都需要开辟一个大小为n的数组中转<br>将数组分为左右两部分，递归左右两块，最后合并，即归并<br>如在一个合并中，将两块部分的元素，遍历取较小值填入结果集<br>类似两个有序链表的合并，每次两两合并相邻的两个有序序列，直到整个序列有序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现归并算法 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123; </span><br><span class="line">merge := <span class="function"><span class="keyword">func</span><span class="params">(left, right []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123; </span><br><span class="line">res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(left)+<span class="built_in">len</span>(right)) </span><br><span class="line"><span class="keyword">var</span> l,r,i <span class="type">int</span> </span><br><span class="line"><span class="comment">// 通过遍历完成比较填入res中 </span></span><br><span class="line"><span class="keyword">for</span> l &lt; <span class="built_in">len</span>(left) &amp;&amp; r &lt; <span class="built_in">len</span>(right) &#123; </span><br><span class="line"><span class="keyword">if</span> left[l] &lt;= right[r] &#123; </span><br><span class="line">res[i] = left[l] l++ </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">res[i] = right[r] r++ </span><br><span class="line">&#125; </span><br><span class="line">i++ </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果left或者right还有剩余元素，添加到结果集的尾部 </span></span><br><span class="line"><span class="built_in">copy</span>(res[i:], left[l:]) </span><br><span class="line"><span class="built_in">copy</span>(res[i+<span class="built_in">len</span>(left)-l:], right[r:]) </span><br><span class="line"><span class="keyword">return</span> res </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sort <span class="function"><span class="keyword">func</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> </span><br><span class="line">sort = <span class="function"><span class="keyword">func</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123; </span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span> &#123; </span><br><span class="line"><span class="keyword">return</span> nums </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 拆分递归与合并 </span></span><br><span class="line"><span class="comment">// 分割点 </span></span><br><span class="line">mid := <span class="built_in">len</span>(nums)/<span class="number">2</span> </span><br><span class="line">left := sort(nums[:mid]) </span><br><span class="line">right := sort(nums[mid:]) </span><br><span class="line"><span class="keyword">return</span> merge(left, right) </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sort(nums) </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归实现归并算法 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123; </span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125; </span><br><span class="line">merge := <span class="function"><span class="keyword">func</span><span class="params">(left, right []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123; </span><br><span class="line">res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(left)+<span class="built_in">len</span>(right)) </span><br><span class="line"><span class="keyword">var</span> l,r,i <span class="type">int</span> </span><br><span class="line"><span class="comment">// 通过遍历完成比较填入res中 </span></span><br><span class="line"><span class="keyword">for</span> l &lt; <span class="built_in">len</span>(left) &amp;&amp; r &lt; <span class="built_in">len</span>(right) &#123; </span><br><span class="line"><span class="keyword">if</span> left[l] &lt;= right[r] &#123; </span><br><span class="line">res[i] = left[l] l++ </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">res[i] = right[r] r++ </span><br><span class="line">&#125; </span><br><span class="line">i++ </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果left或者right还有剩余元素，添加到结果集的尾部 </span></span><br><span class="line"><span class="built_in">copy</span>(res[i:], left[l:]) </span><br><span class="line"><span class="built_in">copy</span>(res[i+<span class="built_in">len</span>(left)-l:], right[r:]) </span><br><span class="line"><span class="keyword">return</span> res </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">i := <span class="number">1</span> </span><br><span class="line"><span class="comment">//子序列大小初始1 </span></span><br><span class="line">res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>) </span><br><span class="line"><span class="comment">// i控制每次划分的序列长度 </span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(nums) &#123; </span><br><span class="line"><span class="comment">// j根据i值执行具体的合并 </span></span><br><span class="line">j := <span class="number">0</span> </span><br><span class="line"><span class="comment">// 按顺序两两合并，j用来定位起始点 </span></span><br><span class="line"><span class="comment">// 随着序列翻倍，每次两两合并的数组大小也翻倍 </span></span><br><span class="line"><span class="keyword">for</span> j &lt; <span class="built_in">len</span>(nums) &#123; </span><br><span class="line"><span class="keyword">if</span> j+<span class="number">2</span>*i &gt; <span class="built_in">len</span>(nums) &#123; </span><br><span class="line">res = merge(nums[j:j+i], nums[j+i:]) </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">res = merge(nums[j:j+i], nums[j+i:j+<span class="number">2</span>*i]) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 通过index控制每次将合并的数据填入nums中 </span></span><br><span class="line"><span class="comment">// 重填入的次数和合并及二叉树的高度相关 </span></span><br><span class="line">index := j </span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> res &#123; </span><br><span class="line">nums[index] = v index++ </span><br><span class="line">&#125; </span><br><span class="line">j = j + <span class="number">2</span>*i </span><br><span class="line">&#125; </span><br><span class="line">i *= <span class="number">2</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> nums </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>基于比较，不稳定算法，时间平均O(nlogn)，最坏O(n^2)，空间O(logn)<br>分治思想，选主元，依次将剩余元素的小于主元放其左侧，大的放右侧<br>取主元的前半部分和后半部分进行同样处理，直至各子序列剩余一个元素结束，排序完成<br>小规模数据(n&lt;100)，由于快排用到递归，性能不如插排<br>进行排序时，可定义阈值，小规模数据用插排，往后用快排<br>golang的sort包用到了快排</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123; </span><br><span class="line"><span class="comment">// (小数，主元，大数) </span></span><br><span class="line"><span class="keyword">var</span> quick <span class="function"><span class="keyword">func</span><span class="params">(nums []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> []<span class="type">int</span> </span><br><span class="line">quick = <span class="function"><span class="keyword">func</span><span class="params">(nums []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123; </span><br><span class="line"><span class="comment">// 递归终止条件 </span></span><br><span class="line"><span class="keyword">if</span> left &gt; right &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125; </span><br><span class="line"><span class="comment">// 左右指针及主元 </span></span><br><span class="line">i, j, pivot := left, right, nums[left] </span><br><span class="line"><span class="keyword">for</span> i &lt; j &#123; </span><br><span class="line"><span class="comment">// 寻找小于主元的右边元素 </span></span><br><span class="line"><span class="keyword">for</span> i &lt; j &amp;&amp; nums[j] &gt;= pivot &#123; j-- &#125; </span><br><span class="line"><span class="comment">// 寻找大于主元的左边元素 </span></span><br><span class="line"><span class="keyword">for</span> i &lt; j &amp;&amp; nums[i] &lt;= pivot &#123; i++ &#125; </span><br><span class="line"><span class="comment">// 交换i/j下标元素 </span></span><br><span class="line">nums[i], nums[j] = nums[j], nums[i] </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 交换元素 </span></span><br><span class="line">nums[i], nums[left] = nums[left], nums[i] </span><br><span class="line">quick(nums, left, i<span class="number">-1</span>) </span><br><span class="line">quick(nums, i+<span class="number">1</span>, right) </span><br><span class="line"><span class="keyword">return</span> nums </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> quick(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>大根堆，升序排序，基于比较交换的不稳定算法，时间O(nlogn)，空间O(1)-迭代建堆<br>遍历元素时间O(n)，堆化时间O(logn)，开始建堆次数多些，后面次数少<br>1.建堆，从非叶子节点开始依次堆化，注意逆序，从下往上堆化<br>建堆流程：父节点与子节点比较，子节点大则交换父子节点，父节点索引更新为子节点，循环操作<br>2.尾部遍历操作，弹出元素，再次堆化<br>弹出元素排序流程：从最后节点开始，交换头尾元素，由于弹出，end–，再次对剩余数组元素建堆，循环操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 建堆函数，堆化 </span></span><br><span class="line"><span class="keyword">var</span> heapify <span class="function"><span class="keyword">func</span><span class="params">(nums []<span class="type">int</span>, root, end <span class="type">int</span>)</span></span> </span><br><span class="line">heapify = <span class="function"><span class="keyword">func</span><span class="params">(nums []<span class="type">int</span>, root, end <span class="type">int</span>)</span></span> &#123; </span><br><span class="line"><span class="comment">// 大顶堆堆化，堆顶值小一直下沉 </span></span><br><span class="line"><span class="keyword">for</span> &#123; </span><br><span class="line"><span class="comment">// 左孩子节点索引 </span></span><br><span class="line">child := root*<span class="number">2</span> + <span class="number">1</span> </span><br><span class="line"><span class="comment">// 越界跳出 </span></span><br><span class="line"><span class="keyword">if</span> child &gt; end &#123; <span class="keyword">return</span> &#125; </span><br><span class="line"><span class="comment">// 比较左右孩子，取大值，否则child不用++ </span></span><br><span class="line"><span class="keyword">if</span> child &lt; end &amp;&amp; nums[child] &lt;= nums[child+<span class="number">1</span>] &#123; child++ &#125; </span><br><span class="line"><span class="comment">// 如果父节点已经大于左右孩子大值，已堆化 </span></span><br><span class="line"><span class="keyword">if</span> nums[root] &gt; nums[child] &#123; <span class="keyword">return</span> &#125; </span><br><span class="line"><span class="comment">// 孩子节点大值上冒 </span></span><br><span class="line">nums[root], nums[child] = nums[child], nums[root] </span><br><span class="line"><span class="comment">// 更新父节点到子节点，继续往下比较，不断下沉 </span></span><br><span class="line">root = child </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">end := <span class="built_in">len</span>(nums)<span class="number">-1</span> </span><br><span class="line"><span class="comment">// 从最后一个非叶子节点开始堆化 </span></span><br><span class="line"><span class="keyword">for</span> i:=end/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i-- &#123; heapify(nums, i, end) &#125; </span><br><span class="line"><span class="comment">// 依次弹出元素，然后再堆化，相当于依次把最大值放入尾部 </span></span><br><span class="line"><span class="keyword">for</span> i:=end;i&gt;=<span class="number">0</span>;i-- &#123; </span><br><span class="line">nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>] </span><br><span class="line">end-- </span><br><span class="line">heapify(nums, <span class="number">0</span>, end) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> nums </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>基于哈希思想的外排稳定算法，空间换时间，时间O(n+k)<br>相当于计数排序的改进版，服从均匀分布，先将数据分到有限数量的桶中，<br>每个桶分别排序，最后将非空桶的数据拼接起来</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> bucket <span class="function"><span class="keyword">func</span><span class="params">(nums []<span class="type">int</span>, bucketSize <span class="type">int</span>)</span></span> []<span class="type">int</span> </span><br><span class="line">bucket = <span class="function"><span class="keyword">func</span><span class="params">(nums []<span class="type">int</span>, bucketSize <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123; </span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span> &#123; <span class="keyword">return</span> nums &#125; </span><br><span class="line"><span class="comment">// 获取最大最小值 </span></span><br><span class="line">minAndMax := <span class="function"><span class="keyword">func</span><span class="params">(nums []<span class="type">int</span>)</span></span> (min, max <span class="type">int</span>) &#123; </span><br><span class="line">minNum := math.MaxInt32 </span><br><span class="line">maxNum := math.MinInt32 </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123; </span><br><span class="line"><span class="keyword">if</span> nums[i] &lt; minNum &#123; minNum = nums[i] &#125; </span><br><span class="line"><span class="keyword">if</span> nums[i] &gt; maxNum &#123; maxNum = nums[i] &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> minNum, maxNum </span><br><span class="line">&#125; </span><br><span class="line">min_, max_ := minAndMax(nums) </span><br><span class="line"><span class="comment">// 定义桶 </span></span><br><span class="line"><span class="comment">// 构建计数桶 </span></span><br><span class="line">bucketCount := (max_-min_)/bucketSize + <span class="number">1</span> </span><br><span class="line">buckets := <span class="built_in">make</span>([][]<span class="type">int</span>, bucketCount) </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;bucketCount;i++ &#123; buckets[i] = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>) &#125; </span><br><span class="line"><span class="comment">// 装桶-排序过程 </span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123; </span><br><span class="line"><span class="comment">// 桶序号 </span></span><br><span class="line">bucketNum := (nums[i]-min_) / bucketSize </span><br><span class="line">buckets[bucketNum] = <span class="built_in">append</span>(buckets[bucketNum], nums[i]) </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 桶中排序 </span></span><br><span class="line"><span class="comment">// 上述装桶完成，出桶填入元素组 </span></span><br><span class="line">index := <span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span> _, bucket := <span class="keyword">range</span> buckets &#123; </span><br><span class="line">sort.Slice(bucket, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; </span><br><span class="line"><span class="keyword">return</span> bucket[i] &lt; bucket[j] </span><br><span class="line">&#125;) </span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> bucket &#123; </span><br><span class="line">nums[index] = num index++ </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nums </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 定义桶中的数量 </span></span><br><span class="line"><span class="keyword">var</span> bucketSize <span class="type">int</span> = <span class="number">2</span> </span><br><span class="line"><span class="keyword">return</span> bucket(nums, bucketSize) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>基于哈希思想的稳定外排序算法，空间换时间，时间O(n)，空间O(n)<br>数据量大时，空间占用大<br>空间换时间，通过开辟额外数据空间存储索引号记录数组的值和数组额个数<br>1.找出待排序的数组的最大值和最小值<br>2.创建数组存放各元素的出现次数，先于[min, max]之间<br>3.统计数组值的个数<br>4.反向填充数组，填充时注意,num[i]&#x3D;j+mi<br>j-前面需要略过的数的个数，两个维度，依次递增的数j++，一个是重复的数的计数j-不变</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123; <span class="keyword">return</span> nums &#125; </span><br><span class="line"><span class="comment">// 获取最大最小值 </span></span><br><span class="line">minAndMax := <span class="function"><span class="keyword">func</span><span class="params">(nums []<span class="type">int</span>)</span></span> (min,max <span class="type">int</span>) &#123; </span><br><span class="line">minNum := math.MaxInt32 </span><br><span class="line">maxNum := math.MinInt32 </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123; </span><br><span class="line"><span class="keyword">if</span> nums[i] &lt; minNum &#123; minNum = nums[i] &#125; </span><br><span class="line"><span class="keyword">if</span> nums[i] &gt; maxNum &#123; maxNum = nums[i] &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> minNum, maxNum </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">min_, max_ := minAndMax(nums) </span><br><span class="line"><span class="comment">// 中转数组存放遍历元素 </span></span><br><span class="line"><span class="comment">// 空间只需要min-max </span></span><br><span class="line">tmpNums := <span class="built_in">make</span>([]<span class="type">int</span>, max_-min_+<span class="number">1</span>) </span><br><span class="line"><span class="comment">// 遍历原数组 </span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123; </span><br><span class="line">tmpNums[nums[i]-min_]++ </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 遍历中转数组填入原数组 </span></span><br><span class="line">j := <span class="number">0</span> <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123; </span><br><span class="line"><span class="comment">// 如果对应数字cnt=0，说明可以计入下一位数字 </span></span><br><span class="line"><span class="keyword">for</span> tmpNums[j] == <span class="number">0</span> &#123; j++ &#125; </span><br><span class="line"><span class="comment">// 填入数字 </span></span><br><span class="line">nums[i] = j + min_ </span><br><span class="line"><span class="comment">// 填一个数字，对应数字cnt-- </span></span><br><span class="line">tmpNums[j]-- </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> nums </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.199 二叉树的右视图</title>
      <link href="/interview/juan/neet150/trees/leet-199-binary-tree-right-side-view/"/>
      <url>/interview/juan/neet150/trees/leet-199-binary-tree-right-side-view/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></p><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg"></p><pre><code>输入: [1,2,3,null,5,null,4]输出: [1,3,4]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [1,null,3]输出: [1,3]</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: []输出: []</code></pre><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[0,100]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p>有个比较好的方案是层序遍历后，找每层最后一个位置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Left *TreeNode</span></span><br><span class="line"><span class="comment">* Right *TreeNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rightSideView</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">levels := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">stack := []*TreeNode&#123;root&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; <span class="built_in">len</span>(stack)&gt;<span class="number">0</span>; i++ &#123;</span><br><span class="line">levels = <span class="built_in">append</span>(levels, []<span class="type">int</span>&#123;&#125;)</span><br><span class="line">q := []*TreeNode&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(stack); j++ &#123;</span><br><span class="line">nod := stack[j]</span><br><span class="line">levels[i] = <span class="built_in">append</span>(levels[i], nod.Val)</span><br><span class="line"><span class="keyword">if</span> nod.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">q = <span class="built_in">append</span>(q, nod.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> nod.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">q = <span class="built_in">append</span>(q, nod.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">stack = q</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">ans := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, l := <span class="keyword">range</span> levels &#123;</span><br><span class="line">last := l[<span class="built_in">len</span>(l)<span class="number">-1</span>]</span><br><span class="line">ans = <span class="built_in">append</span>(ans, last)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Trees </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.210 课程表 II</title>
      <link href="/interview/juan/bytedance-common-alg/leet-210-course-schedule-ii/"/>
      <url>/interview/juan/bytedance-common-alg/leet-210-course-schedule-ii/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a></p><p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code> 到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code> ，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示在选修课程 <code>ai</code> 前 <strong>必须</strong> 先选修 <code>bi</code> 。</p><ul><li>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> ，我们用一个匹配来表示：<code>[0,1]</code> 。</li></ul><p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 <strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回 <strong>一个空数组</strong> 。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]<br><strong>输出：</strong>[0,1]<br><strong>解释：</strong>总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 <code>[0,1] 。</code></p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>numCourses &#x3D; 4, prerequisites &#x3D; [[1,0],[2,0],[3,1],[3,2]]<br><strong>输出：</strong>[0,2,1,3]<br><strong>解释：</strong>总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。<br>因此，一个正确的课程顺序是 <code>[0,1,2,3]</code> 。另一个正确的排序是 <code>[0,2,1,3]</code> 。</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>numCourses &#x3D; 1, prerequisites &#x3D; []<br><strong>输出：</strong>[0]</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= numCourses &lt;= 2000</code></li><li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li><code>ai != bi</code></li><li>所有<code>[ai, bi]</code> <strong>互不相同</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findOrder</span><span class="params">(numCourses <span class="type">int</span>, prerequisites [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">edges := <span class="built_in">make</span>([][]<span class="type">int</span>, numCourses)</span><br><span class="line">visited := <span class="built_in">make</span>([]<span class="type">int</span>, numCourses)</span><br><span class="line">ans := []<span class="type">int</span>&#123;&#125; <span class="comment">// 拓扑排序是可行方案的逆序，最后还需要翻转</span></span><br><span class="line">valid := <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">  </span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(c <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">visited[c] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> edges[c] &#123;</span><br><span class="line"><span class="keyword">if</span> visited[v] == <span class="number">0</span> &#123;</span><br><span class="line">dfs(v)</span><br><span class="line"><span class="keyword">if</span> !valid &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> visited[v] == <span class="number">1</span> &#123;</span><br><span class="line">valid = <span class="literal">false</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visited[c] = <span class="number">2</span></span><br><span class="line">ans = <span class="built_in">append</span>(ans, c)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">edges[item[<span class="number">1</span>]] = <span class="built_in">append</span>(edges[item[<span class="number">1</span>]], item[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> visited[i] == <span class="number">0</span> &#123;</span><br><span class="line">dfs(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !valid &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses/<span class="number">2</span>; i++ &#123;</span><br><span class="line">ans[i], ans[numCourses<span class="number">-1</span>-i] = ans[numCourses<span class="number">-1</span>-i], ans[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.39 组合总和</title>
      <link href="/interview/juan/bytedance-common-alg/leet-39-combination-sum/"/>
      <url>/interview/juan/bytedance-common-alg/leet-39-combination-sum/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></p><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><pre><code>输入：candidates = `[2,3,6,7],` target = `7`输出：[[2,2,3],[7]]解释：2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。7 也是一个候选， 7 = 7 。仅有这两种组合。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入: candidates = [2,3,5]`,` target = 8输出: [[2,2,2,2],[2,3,3],[3,5]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入: candidates = `[2],` target = 1输出: []</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 可以尝试先排序，后面碰到比 left 更大的数会提前剪枝掉</span></span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">ans := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, left <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> left == <span class="number">0</span> &#123;</span><br><span class="line">ans = <span class="built_in">append</span>(ans, <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, path...))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> left &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i == <span class="built_in">len</span>(candidates) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 不选，走下一个</span></span><br><span class="line">dfs(i+<span class="number">1</span>, left)</span><br><span class="line">  </span><br><span class="line">path = <span class="built_in">append</span>(path, candidates[i])</span><br><span class="line">dfs(i, left - candidates[i])</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">0</span>, target)</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.2 两数相加</title>
      <link href="/interview/juan/neet150/linked-list/leet-2-add-two-numbers/"/>
      <url>/interview/juan/neet150/linked-list/leet-2-add-two-numbers/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></p><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg"></p><pre><code>输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807.</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：l1 = [0], l2 = [0]输出：[0]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1]</code></pre><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><p>本身提供的就是逆序排列，可以直接加，简单不少，不然还得先逆序再求<br>做链表题特别喜欢 dummy！！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Next *ListNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line"><span class="keyword">var</span> plus <span class="type">int</span></span><br><span class="line">dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">t, trl1, trl2 := dummy, l1, l2</span><br><span class="line"><span class="keyword">for</span> trl1 != <span class="literal">nil</span> || trl2 != <span class="literal">nil</span> &#123;</span><br><span class="line">n1, n2 := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> trl1 != <span class="literal">nil</span> &#123;</span><br><span class="line">n1 = trl1.Val</span><br><span class="line">trl1 = trl1.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> trl2 != <span class="literal">nil</span> &#123;</span><br><span class="line">n2 = trl2.Val</span><br><span class="line">trl2 = trl2.Next</span><br><span class="line">&#125;</span><br><span class="line">sum := n1 + n2 + plus</span><br><span class="line">plus = sum/<span class="number">10</span></span><br><span class="line">t.Next = &amp;ListNode&#123;Val:sum%<span class="number">10</span>, Next:<span class="literal">nil</span>&#125;</span><br><span class="line">t = t.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> plus &gt; <span class="number">0</span> &#123;</span><br><span class="line">t.Next = &amp;ListNode&#123;Val: plus&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.129 求根节点到叶节点数字之和</title>
      <link href="/interview/juan/bytedance-common-alg/leet-129-sum-root-to-leaf-numbers/"/>
      <url>/interview/juan/bytedance-common-alg/leet-129-sum-root-to-leaf-numbers/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a></p><p>给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p><p>每条从根节点到叶节点的路径都代表一个数字：</p><ul><li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。</li></ul><p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p><p><strong>叶节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg"></p><pre><code>输入：root = [1,2,3]输出：25解释：从根到叶子节点路径 `1-&gt;2` 代表数字 `12`从根到叶子节点路径 `1-&gt;3` 代表数字 `13`因此，数字总和 = 12 + 13 = `25`</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg"></p><pre><code>输入：root = [4,9,0,5,1]输出：1026解释：从根到叶子节点路径 `4-&gt;9-&gt;5` 代表数字 495从根到叶子节点路径 `4-&gt;9-&gt;1` 代表数字 491从根到叶子节点路径 `4-&gt;0` 代表数字 40因此，数字总和 = 495 + 491 + 40 = `1026`</code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 1000]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>树的深度不超过 <code>10</code></li></ul><p>根据题目递归即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Left *TreeNode</span></span><br><span class="line"><span class="comment">* Right *TreeNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumNumbers</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> getPathNum <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode, <span class="type">int</span>)</span></span></span><br><span class="line">  </span><br><span class="line">getPathNum = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, pre <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">getPathNum(node.Left, pre * <span class="number">10</span> + node.Left.Val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">getPathNum(node.Right, pre * <span class="number">10</span> + node.Right.Val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">sum += pre</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">getPathNum(root, root.Val)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.148 排序链表</title>
      <link href="/interview/juan/bytedance-common-alg/leet-148-sort-list/"/>
      <url>/interview/juan/bytedance-common-alg/leet-148-sort-list/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></p><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg"></p><pre><code>输入：head = [4,2,1,3]输出：[1,2,3,4]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg"></p><pre><code>输入：head = [-1,5,3,4,0]输出：[-1,0,3,4,5]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：head = []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><p><strong>进阶：</strong>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Next *ListNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line"><span class="keyword">return</span> sort(head, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sort</span><span class="params">(head, tail *ListNode)</span></span> *ListNode &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> head.Next == tail &#123;</span><br><span class="line"><span class="comment">// tail 放到下一段去排序</span></span><br><span class="line">head.Next = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">slow, fast := head, head</span><br><span class="line"><span class="keyword">for</span> fast != tail &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next</span><br><span class="line"><span class="keyword">if</span> fast != tail &#123;</span><br><span class="line">fast = fast.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mid := slow</span><br><span class="line"><span class="keyword">return</span> merge(sort(head, mid), sort(mid, tail))</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(h1, h2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">t, t1, t2 := dummy, h1, h2</span><br><span class="line"><span class="comment">// 注意这里是 for</span></span><br><span class="line"><span class="keyword">for</span> t1 != <span class="literal">nil</span> &amp;&amp; t2 != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> t1.Val &lt;= t2.Val &#123;</span><br><span class="line">t.Next = t1</span><br><span class="line">t1 = t1.Next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">t.Next = t2</span><br><span class="line">t2 = t2.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移动到下一节点</span></span><br><span class="line">t = t.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> t1 != <span class="literal">nil</span> &#123;</span><br><span class="line">t.Next = t1</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> t2 != <span class="literal">nil</span> &#123;</span><br><span class="line">t.Next = t2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.92 反转链表 II</title>
      <link href="/interview/juan/bytedance-common-alg/leet-92-reverse-linked-list-ii/"/>
      <url>/interview/juan/bytedance-common-alg/leet-92-reverse-linked-list-ii/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></p><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg"></p><pre><code>输入：head = [1,2,3,4,5], left = 2, right = 4输出：[1,4,3,2,5]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：head = [5], left = 1, right = 1输出：[5]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点数目为 <code>n</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>-500 &lt;= Node.val &lt;= 500</code></li><li><code>1 &lt;= left &lt;= right &lt;= n</code></li></ul><p><strong>进阶：</strong> 你可以使用一趟扫描完成反转吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Next *ListNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetween</span><span class="params">(head *ListNode, left <span class="type">int</span>, right <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">dummy := &amp;ListNode&#123;Val: <span class="number">-1</span>&#125;</span><br><span class="line">dummy.Next = head</span><br><span class="line">  </span><br><span class="line">pre := dummy</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;left<span class="number">-1</span>; i++ &#123;</span><br><span class="line">pre = pre.Next</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">cur := pre.Next</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;right-left; i++ &#123;</span><br><span class="line">nxt := cur.Next</span><br><span class="line">cur.Next = nxt.Next</span><br><span class="line">nxt.Next = pre.Next</span><br><span class="line">pre.Next = nxt</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.88 合并两个有序数组</title>
      <link href="/interview/juan/bytedance-common-alg/leet-88-merge-sorted-array/"/>
      <url>/interview/juan/bytedance-common-alg/leet-88-merge-sorted-array/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></p><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [_1_,_2_,2,_3_,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums1 = [1], m = 1, nums2 = [], n = 0输出：[1]解释：需要合并 [1] 和 [] 。合并结果是 [1] 。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums1 = [0], m = 0, nums2 = [1], n = 1输出：[1]解释：需要合并的数组是 [] 和 [1] 。合并结果是 [1] 。注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</code></pre><p><strong>提示：</strong></p><ul><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= m + n &lt;= 200</code></li><li><code>-109 &lt;= nums1[i], nums2[j] &lt;= 109</code></li></ul><p>一个很好的方案是双指针，因为 nums1 后半部分的数据实际上是空的，我们可以从后往前，找到合适的数据直接填入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="type">int</span>, m <span class="type">int</span>, nums2 []<span class="type">int</span>, n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// nums1后方的数据可以利用</span></span><br><span class="line"><span class="keyword">for</span> p1, p2, end := m<span class="number">-1</span>, n<span class="number">-1</span>, m+n<span class="number">-1</span>; p1&gt;=<span class="number">0</span> || p2&gt;=<span class="number">0</span>; end -- &#123;</span><br><span class="line"><span class="keyword">var</span> cur <span class="type">int</span></span><br><span class="line"><span class="keyword">if</span> p1 == <span class="number">-1</span> &#123; <span class="comment">// p1 先用完</span></span><br><span class="line">cur = nums2[p2]</span><br><span class="line">p2 -= <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> p2 == <span class="number">-1</span> &#123; <span class="comment">// p2 先用完</span></span><br><span class="line">cur = nums1[p1]</span><br><span class="line">p1 -= <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums1[p1] &gt; nums2[p2] &#123;</span><br><span class="line">cur = nums1[p1]</span><br><span class="line">p1 -= <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cur = nums2[p2]</span><br><span class="line">p2 -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">nums1[end] = cur</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.42 接雨水</title>
      <link href="/interview/juan/neet150/two-ptr/leet-42-trapping-rain-water/"/>
      <url>/interview/juan/neet150/two-ptr/leet-42-trapping-rain-water/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a><br>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png"></p><p><strong>输入：</strong>height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br><strong>输出：</strong>6<br><strong>解释：</strong>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>height &#x3D; [4,2,0,3,2,5]<br><strong>输出：</strong>9</p><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><p>学习思路，左右max 取最小的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(height)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">leftMax := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">leftMax[<span class="number">0</span>] = height[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;n; i++ &#123;</span><br><span class="line">leftMax[i] = max(leftMax[i<span class="number">-1</span>], height[i])</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">rightMax := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">rightMax[n<span class="number">-1</span>] = height[n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> j:=n<span class="number">-2</span>; j&gt;=<span class="number">0</span>; j-- &#123;</span><br><span class="line">rightMax[j] = max(rightMax[j+<span class="number">1</span>], height[j])</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line"><span class="comment">// 一定会 &gt;= 当前的 height</span></span><br><span class="line">ans += min(leftMax[i], rightMax[i]) - height[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.236 二叉树的最近公共祖先</title>
      <link href="/interview/juan/bytedance-common-alg/leet-236-lowest-common-ancestor-of-a-binary-tree/"/>
      <url>/interview/juan/bytedance-common-alg/leet-236-lowest-common-ancestor-of-a-binary-tree/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png"></p><pre><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出：3解释：节点 `5` 和节点 `1` 的最近公共祖先是节点 `3 。`</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png"></p><pre><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出：5解释：节点 `5` 和节点 `4` 的最近公共祖先是节点 `5 。`因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [1,2], p = 1, q = 2输出：1</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul><p>简单递归</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Left *TreeNode</span></span><br><span class="line"><span class="comment">* Right *TreeNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 终结递归条件</span></span><br><span class="line"><span class="keyword">if</span> root.Val == p.Val || root.Val == q.Val &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">left := lowestCommonAncestor(root.Left, p, q)</span><br><span class="line">right := lowestCommonAncestor(root.Right, p, q)</span><br><span class="line"><span class="comment">// 左右都有，即找到了该节点</span></span><br><span class="line"><span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左边找不到，继续从右边找</span></span><br><span class="line"><span class="keyword">if</span> left == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又：所有节点 val 均不同，可以考虑使用并查集的方法，<strong>但是我还不会！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.103 二叉树的锯齿形层序遍历</title>
      <link href="/interview/juan/bytedance-common-alg/leet-103-binary-tree-zigzag-level-order-traversal/"/>
      <url>/interview/juan/bytedance-common-alg/leet-103-binary-tree-zigzag-level-order-traversal/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg"></p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：[[3],[20,9],[15,7]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1]输出：[[1]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Left *TreeNode</span></span><br><span class="line"><span class="comment">* Right *TreeNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zigzagLevelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">que := []*TreeNode&#123;root&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(que) &gt; <span class="number">0</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(que)</span><br><span class="line">vals := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line"><span class="comment">// 掐头</span></span><br><span class="line">nod := que[<span class="number">0</span>]</span><br><span class="line">que = que[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ans) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">vals[n<span class="number">-1</span>-i] = nod.Val</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">vals[i] = nod.Val</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> nod.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">que = <span class="built_in">append</span>(que, nod.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> nod.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">que = <span class="built_in">append</span>(que, nod.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">append</span>(ans, vals)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.827 最大人工岛</title>
      <link href="/interview/juan/bytedance-common-alg/leet-827-making-a-large-island/"/>
      <url>/interview/juan/bytedance-common-alg/leet-827-making-a-large-island/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/making-a-large-island/">827. 最大人工岛</a></p><p>给你一个大小为 <code>n x n</code> 二进制矩阵 <code>grid</code> 。<strong>最多</strong> 只能将一格 <code>0</code> 变成 <code>1</code> 。</p><p>返回执行此操作后，<code>grid</code> 中最大的岛屿面积是多少？</p><p><strong>岛屿</strong> 由一组上、下、左、右四个方向相连的 <code>1</code> 形成。</p><p><strong>示例 1:</strong></p><pre><code>输入: grid = [[1, 0], [0, 1]]输出: 3解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: grid = [[1, 1], [1, 0]]输出: 4解释: 将一格0变成1，岛屿的面积扩大为 4。</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: grid = [[1, 1], [1, 1]]输出: 4解释: 没有0可以让我们变成1，面积依然为 4。</code></pre><p><strong>提示：</strong></p><ul><li><code>n == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><p>主要思路 并查集<br>将同一个岛屿的点加入并查集中，并且计算当前并查集的岛屿大小<br>然后再次遍历，更新 ans 中最大岛屿的面积。<br>遇到需要填海的 ·海· 从四个方向看有没有可联通的岛屿，将四个方向的岛屿面积，连同填海的面积 1 求和后更新 ans 中的最大面积</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestIsland</span><span class="params">(grid [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(grid)</span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line"><span class="comment">// dfs 遍历的时候会超界</span></span><br><span class="line">p, sz := <span class="built_in">make</span>([]<span class="type">int</span>, n*n + <span class="number">1</span>), <span class="built_in">make</span>([]<span class="type">int</span>, n*n + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n*n; i++ &#123;</span><br><span class="line">p[i] = i <span class="comment">// 并查集初始化</span></span><br><span class="line">sz[i] = <span class="number">1</span> <span class="comment">// 每个格子所占的面积</span></span><br><span class="line">&#125;</span><br><span class="line">dir := [][]<span class="type">int</span>&#123;</span><br><span class="line">[]<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;n; j++ &#123;</span><br><span class="line"><span class="comment">// 不合规</span></span><br><span class="line"><span class="keyword">if</span> grid[i][j] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> dir &#123;</span><br><span class="line">x, y := i + d[<span class="number">0</span>], j + d[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// 超界 or 下一个方向节点是海，都不加入并查集</span></span><br><span class="line"><span class="keyword">if</span> (x&lt;<span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;=n || y &gt;= n) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> grid[x][y] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 联通当前点 ij 和 四个方向的节点 xy。并统计面积</span></span><br><span class="line">union(p, sz, i*n + j + <span class="number">1</span>, x*n + y + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;n; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> grid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// 找到当前节点所在集合的代表元素 find(p, i*n + j + 1)</span></span><br><span class="line"><span class="comment">// 判断代表元素的 sz 面积是否是最大的，更新最大值</span></span><br><span class="line">ans = max(ans, sz[find(p, i*n + j + <span class="number">1</span>)])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 待标记节点 visited 标记是否已被尝试填海</span></span><br><span class="line">tot := <span class="number">1</span></span><br><span class="line">visited := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> dir &#123;</span><br><span class="line">x, y := i+d[<span class="number">0</span>], j+d[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// 超界</span></span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;=n || y &gt;= n) || grid[x][y] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">root := find(p, x*n + y + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> visited[root] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">tot += sz[root] <span class="comment">// 找到根节点代表的面积</span></span><br><span class="line">visited[root] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, tot)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find</span><span class="params">(p []<span class="type">int</span>, x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p[x] != x &#123;</span><br><span class="line"><span class="comment">// 路径压缩</span></span><br><span class="line">p[x] = find(p, p[x])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p[x]</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">union</span><span class="params">(p []<span class="type">int</span>, sz []<span class="type">int</span>, a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">ra, rb := find(p, a), find(p, b)</span><br><span class="line"><span class="keyword">if</span> ra == rb &#123;</span><br><span class="line"><span class="comment">// 同一联通集合</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将小面积的链接到大面积的区域</span></span><br><span class="line"><span class="keyword">if</span> sz[ra] &gt; sz[rb] &#123;</span><br><span class="line">ra, rb = rb, ra</span><br><span class="line">&#125;</span><br><span class="line">sz[rb] += sz[ra]</span><br><span class="line">p[ra] = p[rb]</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.695 岛屿的最大面积</title>
      <link href="/interview/juan/neet150/graphs/leet-695-max-area-of-island/"/>
      <url>/interview/juan/neet150/graphs/leet-695-max-area-of-island/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></p><p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> 。</p><p><strong>岛屿</strong> 是由一些相邻的 <code>1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上</strong> 相邻。你可以假设 <code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p><p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p><p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg"></p><pre><code>输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]输出：6解释：答案不应该是 `11` ，因为岛屿只能包含水平或垂直这四个方向上的 `1` 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：grid = [[0,0,0,0,0,0,0,0]]输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 50</code></li><li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><p>标准dfs，遍历到陆地加一计数即可，最后统计 max 就行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxAreaOfIsland</span><span class="params">(grid [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">visited := <span class="built_in">make</span>([][]<span class="type">bool</span>, <span class="built_in">len</span>(grid))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> visited &#123;</span><br><span class="line">visited[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>]))</span><br><span class="line">&#125;</span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(m, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 到达边界</span></span><br><span class="line"><span class="keyword">if</span> m &gt;= <span class="built_in">len</span>(grid) || n &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) || m&lt;<span class="number">0</span> || n&lt;<span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 到达岛边界</span></span><br><span class="line"><span class="keyword">if</span> grid[m][n] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 已访问的陆地跳过</span></span><br><span class="line"><span class="keyword">if</span> visited[m][n] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标记陆地访问</span></span><br><span class="line"><span class="keyword">if</span> grid[m][n] == <span class="number">1</span> &#123;</span><br><span class="line">visited[m][n] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + dfs(m<span class="number">-1</span>, n) + dfs(m+<span class="number">1</span>, n) + dfs(m, n+<span class="number">1</span>) + dfs(m, n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(grid); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(grid[<span class="number">0</span>]); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> !visited[i][j] &amp;&amp; grid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">ans = max(ans, dfs(i, j))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Graphs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.463 岛屿的周长</title>
      <link href="/interview/juan/bytedance-common-alg/leet-463-island-perimeter/"/>
      <url>/interview/juan/bytedance-common-alg/leet-463-island-perimeter/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/island-perimeter/">463. 岛屿的周长</a></p><p>给定一个 <code>row x col</code> 的二维网格地图 <code>grid</code> ，其中：<code>grid[i][j] = 1</code> 表示陆地， <code>grid[i][j] = 0</code> 表示水域。</p><p>网格中的格子 <strong>水平和垂直</strong> 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/island.png"></p><pre><code>输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]输出：16解释：它的周长是上面图片中的 16 个黄色的边</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：grid = [[1]]输出：4</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：grid = [[1,0]]输出：4</code></pre><p><strong>提示：</strong></p><ul><li><code>row == grid.length</code></li><li><code>col == grid[i].length</code></li><li><code>1 &lt;= row, col &lt;= 100</code></li><li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">islandPerimeter</span><span class="params">(grid [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">visited := <span class="built_in">make</span>([][]<span class="type">bool</span>, <span class="built_in">len</span>(grid))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> visited &#123;</span><br><span class="line">visited[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>]))</span><br><span class="line">&#125;</span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(m, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 到达边界</span></span><br><span class="line"><span class="keyword">if</span> m &gt;= <span class="built_in">len</span>(grid) || n &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) || m&lt;<span class="number">0</span> || n&lt;<span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 到达岛边界</span></span><br><span class="line"><span class="keyword">if</span> grid[m][n] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 已访问的陆地跳过</span></span><br><span class="line"><span class="keyword">if</span> visited[m][n] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标记陆地访问</span></span><br><span class="line"><span class="keyword">if</span> grid[m][n] == <span class="number">1</span> &#123;</span><br><span class="line">visited[m][n] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> dfs(m<span class="number">-1</span>, n) + dfs(m+<span class="number">1</span>, n) + dfs(m, n+<span class="number">1</span>) + dfs(m, n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(grid); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(grid[<span class="number">0</span>]); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> !visited[i][j] &amp;&amp; grid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">ans += dfs(i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.209 长度最小的子数组</title>
      <link href="/interview/juan/bytedance-common-alg/leet-209-minimum-size-subarray-sum/"/>
      <url>/interview/juan/bytedance-common-alg/leet-209-minimum-size-subarray-sum/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></p><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 </p><p><strong>子数组</strong></p><p> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 `[4,3]` 是该条件下的长度最小的子数组。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：target = 4, nums = [1,4,4]输出：1</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>进阶：</strong></p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul><p>滑动窗口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(target <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 滑</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">ans := math.MaxInt32</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line">start, end := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> end &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">sum += nums[end]</span><br><span class="line"><span class="keyword">for</span> sum &gt;= target &#123;</span><br><span class="line">ans = min(ans, end-start+<span class="number">1</span>)</span><br><span class="line">sum -= nums[start]</span><br><span class="line">start += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">end += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ans == math.MaxInt32 &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.2007 从双倍数组中还原原数组</title>
      <link href="/interview/juan/bytedance-common-alg/leet-2007-find-original-array-from-doubled-array/"/>
      <url>/interview/juan/bytedance-common-alg/leet-2007-find-original-array-from-doubled-array/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/find-original-array-from-doubled-array/">2007. 从双倍数组中还原原数组</a></p><p>一个整数数组 <code>original</code> 可以转变成一个 <strong>双倍</strong> 数组 <code>changed</code> ，转变方式为将 <code>original</code> 中每个元素 <strong>值乘以 2</strong> 加入数组中，然后将所有元素 <strong>随机打乱</strong> 。</p><p>给你一个数组 <code>changed</code> ，如果 <code>change</code> 是 <strong>双倍</strong> 数组，那么请你返回 <code>original</code>数组，否则请返回空数组。<code>original</code> 的元素可以以 <strong>任意</strong> 顺序返回。</p><p><strong>示例 1：</strong></p><pre><code>输入：changed = [1,3,4,2,6,8]输出：[1,3,4]解释：一个可能的 original 数组为 [1,3,4] :- 将 1 乘以 2 ，得到 1 * 2 = 2 。- 将 3 乘以 2 ，得到 3 * 2 = 6 。- 将 4 乘以 2 ，得到 4 * 2 = 8 。其他可能的原数组方案为 [4,3,1] 或者 [3,1,4] 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：changed = [6,3,0,1]输出：[]解释：changed 不是一个双倍数组。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：changed = [1]输出：[]解释：changed 不是一个双倍数组。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= changed.length &lt;= 105</code></li><li><code>0 &lt;= changed[i] &lt;= 105</code></li></ul><p>先排序，排序后首位一定是未双倍的元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findOriginalArray</span><span class="params">(changed []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">sort.Ints(changed)</span><br><span class="line"><span class="keyword">var</span> ans []<span class="type">int</span></span><br><span class="line">cm := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> changed &#123;</span><br><span class="line"><span class="keyword">if</span> cm[n] == <span class="number">0</span> &#123;</span><br><span class="line">cm[<span class="number">2</span>*n] += <span class="number">1</span></span><br><span class="line">ans = <span class="built_in">append</span>(ans, n)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cm[n] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> cm[n] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(cm, n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果结束后还有剩余的元素，说明不够一一对应</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(cm) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>岛屿问题</title>
      <link href="/interview/juan/%E6%A8%A1%E6%9D%BF/island-issue/"/>
      <url>/interview/juan/%E6%A8%A1%E6%9D%BF/island-issue/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/number-of-islands/">L200. 岛屿数量</a> （Easy）</li><li><a href="https://leetcode-cn.com/problems/island-perimeter/">463. 岛屿的周长</a> （Easy）</li><li><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a> （Medium）</li><li><a href="https://leetcode-cn.com/problems/making-a-large-island/">827. 最大人工岛</a> （Hard）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 模板 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.415 字符串相加</title>
      <link href="/interview/juan/bytedance-common-alg/leet-415-add-strings/"/>
      <url>/interview/juan/bytedance-common-alg/leet-415-add-strings/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/add-strings/">415. 字符串相加</a><br>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式。</p><p><strong>示例 1：</strong></p><pre><code>输入：num1 = &quot;11&quot;, num2 = &quot;123&quot;输出：&quot;134&quot;</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：num1 = &quot;456&quot;, num2 = &quot;77&quot;输出：&quot;533&quot;</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：num1 = &quot;0&quot;, num2 = &quot;0&quot;输出：&quot;0&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num1.length, num2.length &lt;= 104</code></li><li><code>num1</code> 和<code>num2</code> 都只包含数字 <code>0-9</code></li><li><code>num1</code> 和<code>num2</code> 都不包含任何前导零</li></ul><p>本质上还是学习字符串的处理方法，以及注意相关进位</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStrings</span><span class="params">(num1 <span class="type">string</span>, num2 <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">add := <span class="number">0</span></span><br><span class="line">ans := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i, j := <span class="built_in">len</span>(num1)<span class="number">-1</span>, <span class="built_in">len</span>(num2)<span class="number">-1</span>; i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span> || add != <span class="number">0</span> ; i,j = i<span class="number">-1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">x = <span class="type">int</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> j&gt;=<span class="number">0</span> &#123;</span><br><span class="line">y = <span class="type">int</span>(num2[j] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">res := x + y + add</span><br><span class="line">ans = strconv.Itoa(res % <span class="number">10</span>) + ans</span><br><span class="line">add = res / <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.31 下一个排列</title>
      <link href="/interview/juan/bytedance-common-alg/leet-31-next-permutation/"/>
      <url>/interview/juan/bytedance-common-alg/leet-31-next-permutation/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></p><p>整数数组的一个 <strong>排列</strong>  就是将其所有成员以序列或线性顺序排列。</p><ul><li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li></ul><p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><ul><li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li><li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li><li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li></ul><p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p><p>必须 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 修改，只允许使用额外常数空间。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3]输出：[1,3,2]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [3,2,1]输出：[1,2,3]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1,1,5]输出：[1,5,1]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul><p>暂时只能背解法，具体没想明白呢！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextPermutation</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line">i := n<span class="number">-2</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 从右往左，找到第一个符合条件的较小的数</span></span><br><span class="line"><span class="comment">// 此时 i+1 ~ n 必然是递减的序列数，idx 为 i ~ n-1</span></span><br><span class="line"><span class="keyword">for</span> i&gt;=<span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">i--</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> i&gt;=<span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 再从右往左，找到比刚刚较小的数稍大的数，交换二者</span></span><br><span class="line">j := n<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> j&gt;=<span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j] &#123;</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以证明 i+1 ~ n 比为降序</span></span><br><span class="line">nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 则翻转这段即可变为升序</span></span><br><span class="line">reverse(nums[i+<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(a []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, n := <span class="number">0</span>, <span class="built_in">len</span>(a); i&lt;n/<span class="number">2</span>; i++ &#123;</span><br><span class="line">a[i], a[n<span class="number">-1</span>-i] = a[n<span class="number">-1</span>-i], a[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.160 相交链表</title>
      <link href="/interview/juan/bytedance-common-alg/leet-160-intersection-of-two-linked-lists/"/>
      <url>/interview/juan/bytedance-common-alg/leet-160-intersection-of-two-linked-lists/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></p><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png"></a></p><pre><code>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at &#39;8&#39;解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</code></pre><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png"></a></p><pre><code>输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Intersected at &#39;2&#39;解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre><p><strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png"></a></p><pre><code>**输入：**intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2**输出：**null**解释：**从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。</code></pre><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><p>一个很容易理解的思路是，分别遍历两个链表长度，找到后续相同长度的节点，即可能的交点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Next *ListNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">lenA, lenB := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> la, lb *ListNode</span><br><span class="line">  </span><br><span class="line">la, lb = headA, headB</span><br><span class="line"><span class="keyword">for</span> la != <span class="literal">nil</span> &#123;</span><br><span class="line">lenA += <span class="number">1</span></span><br><span class="line">la = la.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> lb != <span class="literal">nil</span> &#123;</span><br><span class="line">lenB += <span class="number">1</span></span><br><span class="line">lb = lb.Next</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">la, lb = headA, headB</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> lenA &gt; lenB &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;lenA-lenB; i++ &#123;</span><br><span class="line">la = la.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;lenB-lenA; i++ &#123;</span><br><span class="line">lb = lb.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> la != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> la == lb &#123;</span><br><span class="line"><span class="keyword">return</span> la</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">la = la.Next</span><br><span class="line">lb = lb.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.46 全排列</title>
      <link href="/interview/juan/neet150/backtracking/leet-46-permutations/"/>
      <url>/interview/juan/neet150/backtracking/leet-46-permutations/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></p><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,1]输出：[[0,1],[1,0]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1]输出：[[1]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><p>递归 + 回溯 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">visited := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(p []<span class="type">int</span>)</span></span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(p []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(p) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line"><span class="comment">// 深入结束</span></span><br><span class="line">ans := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(p))</span><br><span class="line"><span class="comment">// 拷贝结果到 ans</span></span><br><span class="line"><span class="built_in">copy</span>(ans, p)</span><br><span class="line"><span class="comment">// 加入结果集</span></span><br><span class="line">res = <span class="built_in">append</span>(res, ans)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> visited[n] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标记访问</span></span><br><span class="line">p = <span class="built_in">append</span>(p, n)</span><br><span class="line">visited[n] = <span class="literal">true</span></span><br><span class="line">dfs(p)</span><br><span class="line"><span class="comment">// 撤销访问，以进行其他分支的搜索</span></span><br><span class="line">p = p[:<span class="built_in">len</span>(p)<span class="number">-1</span>]</span><br><span class="line">visited[n] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">dfs([]<span class="type">int</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素替换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">var</span> ans [][]<span class="type">int</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">  </span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i == n<span class="number">-1</span> &#123;</span><br><span class="line">ans = <span class="built_in">append</span>(ans, <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, nums...))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> j:=i; j&lt;n; j++ &#123;</span><br><span class="line">swap(nums, i, j) <span class="comment">// 将 nums[i] 固定在 j 位</span></span><br><span class="line">dfs(i+<span class="number">1</span>)</span><br><span class="line">swap(nums, i, j) <span class="comment">// 恢复位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">dfs(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(nums []<span class="type">int</span>, i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>求根号 X</title>
      <link href="/interview/juan/bytedance-common-alg/sqrt-x/"/>
      <url>/interview/juan/bytedance-common-alg/sqrt-x/</url>
      
        <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求近似值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;  </span><br><span class="line">   l, r := <span class="type">float64</span>(<span class="number">1</span>), x  </span><br><span class="line">   mid := (l + r) / <span class="number">2</span>  </span><br><span class="line">   <span class="keyword">for</span> mid-l &gt; <span class="number">0.000001</span> &#123;  </span><br><span class="line">      <span class="keyword">if</span> mid*mid &gt; x &#123;  </span><br><span class="line">         r = mid  </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">         l = mid  </span><br><span class="line">      &#125;  </span><br><span class="line">      mid = (l + r) / <span class="number">2</span>  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> mid  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能求整数部分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;  </span><br><span class="line">   l, r := <span class="type">float64</span>(<span class="number">0</span>), x  </span><br><span class="line">   ans := <span class="number">-1.0</span>  </span><br><span class="line">   <span class="keyword">for</span> l &lt;= r &#123;  </span><br><span class="line">      mid := l + (r-l)/<span class="number">2</span>  </span><br><span class="line">      <span class="keyword">if</span> mid*mid &gt; x &#123;  </span><br><span class="line">         r = mid - <span class="number">1</span>  </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">         ans = mid  </span><br><span class="line">         l = mid + <span class="number">1</span>  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> ans  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.215 数组中的第K个最大元素</title>
      <link href="/interview/juan/neet150/heap-queue/leet-215-kth-largest-element-in-an-array/"/>
      <url>/interview/juan/neet150/heap-queue/leet-215-kth-largest-element-in-an-array/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></p><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <strong>k</strong> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1:</strong></p><pre><code>输入: `[3,2,1,5,6,4],` k = 2输出: 5</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: `[3,2,3,1,2,4,5,5,6],` k = 4输出: 4</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p>快速选择法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">return</span> quickselect(nums, <span class="number">0</span>, n<span class="number">-1</span>, n-k)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickselect</span><span class="params">(nums []<span class="type">int</span>, l, r, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> l == r &#123;</span><br><span class="line"><span class="keyword">return</span> nums[k]</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">dummy := nums[l]</span><br><span class="line">i := l<span class="number">-1</span></span><br><span class="line">j := r+<span class="number">1</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i&lt;j &#123;</span><br><span class="line"><span class="keyword">for</span> i++; nums[i]&lt;dummy ; i++ &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> j--; nums[j]&gt;dummy ; j-- &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> i&lt;j &#123;</span><br><span class="line"><span class="comment">// swap</span></span><br><span class="line">nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> k&lt;=j &#123;</span><br><span class="line"><span class="keyword">return</span> quickselect(nums, l, j, k)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> quickselect(nums, j+<span class="number">1</span>, r, k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Heap &amp; Priority Queue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.146 LRU 缓存</title>
      <link href="/interview/juan/neet150/linked-list/leet-146-lru-cache/"/>
      <url>/interview/juan/neet150/linked-list/leet-146-lru-cache/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></p><p>请你设计并实现一个满足  <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><pre><code>输入[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4]解释LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;lRUCache.get(1);    // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;lRUCache.get(2);    // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;lRUCache.get(1);    // 返回 -1 (未找到)lRUCache.get(3);    // 返回 3lRUCache.get(4);    // 返回 4</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 10000</code></li><li><code>0 &lt;= value &lt;= 105</code></li><li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li></ul><p>没啥说的，考记忆力，考原理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">Size <span class="type">int</span></span><br><span class="line">Cap <span class="type">int</span></span><br><span class="line">Cache <span class="keyword">map</span>[<span class="type">int</span>]*Node</span><br><span class="line">head, tail *Node</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">k, v <span class="type">int</span></span><br><span class="line">pre, nxt *Node</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitNode</span><span class="params">(k, v <span class="type">int</span>)</span></span> *Node &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Node&#123;</span><br><span class="line">k: k,</span><br><span class="line">v: v,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line"><span class="comment">// 定义头尾 dummy 节点</span></span><br><span class="line">l := LRUCache&#123;</span><br><span class="line">Cap: capacity,</span><br><span class="line">head: InitNode(<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">tail: InitNode(<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">Cache: <span class="keyword">map</span>[<span class="type">int</span>]*Node&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">l.head.nxt = l.tail</span><br><span class="line">l.tail.pre = l.head</span><br><span class="line"><span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := this.Cache[key]; !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">node := this.Cache[key]</span><br><span class="line">this.move2Head(node)</span><br><span class="line"><span class="keyword">return</span> node.v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 不存在就加入，加入后判断是否超量，超量队尾 pop</span></span><br><span class="line"><span class="keyword">if</span> _, ok := this.Cache[key]; !ok &#123;</span><br><span class="line">node := InitNode(key, value)</span><br><span class="line">this.Cache[key] = node</span><br><span class="line">this.add2Head(node)</span><br><span class="line">this.Size += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> this.Size &gt; this.Cap &#123;</span><br><span class="line">removed := this.removeTail()</span><br><span class="line"><span class="built_in">delete</span>(this.Cache, removed.k)</span><br><span class="line">this.Size -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node := this.Cache[key]</span><br><span class="line"><span class="comment">// 更新 kv</span></span><br><span class="line">node.v = value</span><br><span class="line">this.move2Head(node)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> add2Head(node *Node) &#123;</span><br><span class="line"><span class="comment">// 头结点是入口节点，不算数</span></span><br><span class="line">node.pre = this.head</span><br><span class="line">node.nxt = this.head.nxt</span><br><span class="line">this.head.nxt.pre = node</span><br><span class="line">this.head.nxt = node</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> removeNode(node *Node) &#123;</span><br><span class="line">node.pre.nxt = node.nxt</span><br><span class="line">node.nxt.pre = node.pre</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> move2Head(node *Node) &#123;</span><br><span class="line">this.removeNode(node)</span><br><span class="line">this.add2Head(node)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> removeTail() *Node &#123;</span><br><span class="line">node := this.tail.pre</span><br><span class="line">this.removeNode(node)</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">* obj := Constructor(capacity);</span></span><br><span class="line"><span class="comment">* param_1 := obj.Get(key);</span></span><br><span class="line"><span class="comment">* obj.Put(key,value);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.25. K 个一组翻转链表</title>
      <link href="/interview/juan/neet150/linked-list/leet-25-reverse-nodes-in-k-group/"/>
      <url>/interview/juan/neet150/linked-list/leet-25-reverse-nodes-in-k-group/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></p><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg"></p><pre><code>输入：head = [1,2,3,4,5], k = 2输出：[2,1,4,3,5]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg"></p><pre><code>输入：head = [1,2,3,4,5], k = 3输出：[3,2,1,4,5]</code></pre><p><strong>提示：</strong></p><ul><li>链表中的节点数目为 <code>n</code></li><li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><p><strong>进阶：</strong>你可以设计一个只用 <code>O(1)</code> 额外内存空间的算法解决此问题吗？</p><p>解法： 按照题目标准解题即可，注意其中一段的翻转相关条件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Next *ListNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">poi := &amp;ListNode&#123;Next: head&#125;</span><br><span class="line">pre := poi</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">tail := pre</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;k; i++ &#123;</span><br><span class="line">tail = tail.Next</span><br><span class="line"><span class="keyword">if</span> tail == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> poi.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">next := tail.Next</span><br><span class="line">head, tail = reverse(head, tail)</span><br><span class="line">  </span><br><span class="line">pre.Next = head</span><br><span class="line">tail.Next = next</span><br><span class="line">pre = tail</span><br><span class="line">head = tail.Next</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> poi.Next</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(start, end *ListNode)</span></span> (*ListNode, *ListNode) &#123;</span><br><span class="line">pre := end.Next</span><br><span class="line">cur := start</span><br><span class="line"><span class="keyword">for</span> pre != end &#123;</span><br><span class="line">next := cur.Next</span><br><span class="line">cur.Next = pre</span><br><span class="line">pre = cur</span><br><span class="line">cur = next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> end, start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.Plus.490. 迷宫</title>
      <link href="/interview/juan/bytedance-common-alg/leet-490-the-maze/"/>
      <url>/interview/juan/bytedance-common-alg/leet-490-the-maze/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/the-maze/">Leetcode.Plus.490. 迷宫</a></p><p>由空地（用 <code>0</code> 表示）和墙（用 <code>1</code> 表示）组成的迷宫 <code>maze</code> 中有一个球。球可以途经空地向 <strong>上、下、左、右</strong> 四个方向滚动，且在遇到墙壁前不会停止滚动。当球停下时，可以选择向下一个方向滚动。</p><p>给你一个大小为 <code>m x n</code> 的迷宫 <code>maze</code> ，以及球的初始位置 <code>start</code> 和目的地 <code>destination</code> ，其中 <code>start = [startrow, startcol]</code> 且 <code>destination = [destinationrow, destinationcol]</code> 。请你判断球能否在目的地停下：如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>你可以 <strong>假定迷宫的边缘都是墙壁</strong>（参考示例）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/31/maze1-1-grid.jpg"></p><pre><code>输入：maze = [[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], start = [0,4], destination = [4,4]输出：true解释：一种可能的路径是 : 左 -&gt; 下 -&gt; 左 -&gt; 下 -&gt; 右 -&gt; 下 -&gt; 右。</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/31/maze1-2-grid.jpg"></p><pre><code>输入：maze = [[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], start = [0,4], destination = [3,2]输出：false解释：不存在能够使球停在目的地的路径。注意，球可以经过目的地，但无法在那里停驻。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：maze = [[0,0,0,0,0],[1,1,0,0,1],[0,0,0,0,0],[0,1,0,0,1],[0,1,0,0,0]], start = [4,3], destination = [0,1]输出：false</code></pre><p><strong>提示：</strong></p><ul><li><code>m == maze.length</code></li><li><code>n == maze[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>maze[i][j]</code> is <code>0</code> or <code>1</code>.</li><li><code>start.length == 2</code></li><li><code>destination.length == 2</code></li><li><code>0 &lt;= startrow, destinationrow &lt;= m</code></li><li><code>0 &lt;= startcol, destinationcol &lt;= n</code></li><li>球和目的地都在空地上，且初始时它们不在同一位置</li><li>迷宫 <strong>至少包括 2 块空地</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPath</span><span class="params">(maze [][]<span class="type">int</span>, start []<span class="type">int</span>, destination []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">m, n := <span class="built_in">len</span>(maze), <span class="built_in">len</span>(maze[<span class="number">0</span>])</span><br><span class="line">visit := <span class="built_in">make</span>([][]<span class="type">bool</span>, m)</span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> visit &#123;</span><br><span class="line">visit[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="type">int</span>)</span></span>  </span><br><span class="line">  </span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 已访问不走了</span></span><br><span class="line"><span class="keyword">if</span> visit[i][j] &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标记</span></span><br><span class="line">visit[i][j] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> i == destination[<span class="number">0</span>] &amp;&amp; j == destination[<span class="number">1</span>] &#123;</span><br><span class="line"><span class="comment">// 到达</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">up := i<span class="number">-1</span></span><br><span class="line">down := i+<span class="number">1</span></span><br><span class="line">left := j<span class="number">-1</span></span><br><span class="line">right := j+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别从四个方向走到底</span></span><br><span class="line"><span class="keyword">for</span> right &lt; n &amp;&amp; maze[i][right] == <span class="number">0</span> &#123;</span><br><span class="line">right ++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 走到底之后在前一个节点重新出发</span></span><br><span class="line">dfs(i, right<span class="number">-1</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> left&gt;=<span class="number">0</span> &amp;&amp; maze[i][left] == <span class="number">0</span> &#123;</span><br><span class="line">left --</span><br><span class="line">&#125;</span><br><span class="line">dfs(i, left+<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> up &gt;= <span class="number">0</span> &amp;&amp; maze[up][j] == <span class="number">0</span> &#123;</span><br><span class="line">up --</span><br><span class="line">&#125;</span><br><span class="line">dfs(up+<span class="number">1</span>, j)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> down &lt; m &amp;&amp; maze[down][j] == <span class="number">0</span> &#123;</span><br><span class="line">down ++</span><br><span class="line">&#125;</span><br><span class="line">dfs(down<span class="number">-1</span>, j)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">dfs(start[<span class="number">0</span>], start[<span class="number">1</span>])</span><br><span class="line"><span class="comment">// 仅标记，dfs 为添加返回值，按照逻辑验证终点是否可达即可</span></span><br><span class="line"><span class="keyword">if</span> visit[destination[<span class="number">0</span>]][destination[<span class="number">1</span>]] == <span class="literal">true</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.581 最短无序连续子数组</title>
      <link href="/interview/juan/bytedance-common-alg/leet-581-shortest-unsorted-continuous-subarray/"/>
      <url>/interview/juan/bytedance-common-alg/leet-581-shortest-unsorted-continuous-subarray/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/">Leetcode.581 最短无序连续子数组</a></p><p>给你一个整数数组 <code>nums</code> ，你需要找出一个 <strong>连续子数组</strong> ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>请你找出符合题意的 <strong>最短</strong> 子数组，并输出它的长度。</p><p><strong>示例 1：</strong></p><pre><code>**输入：**nums = [2,6,4,8,10,9,15]**输出：**5**解释：**你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</code></pre><p><strong>示例 2：</strong></p><pre><code>**输入：**nums = [1,2,3,4]**输出：**0</code></pre><p><strong>示例 3：</strong></p><pre><code>**输入：**nums = [1]**输出：**0</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(n)</code> 的解决方案吗？</p><p><strong>常规思路</strong><br>和排序后的数组进行比较即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUnsortedSubarray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> sort.IntsAreSorted(nums) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">numsSorted := <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, nums...)</span><br><span class="line">sort.Ints(numsSorted)</span><br><span class="line">left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> nums[left] == numsSorted[left] &#123;</span><br><span class="line">left++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> nums[right] == numsSorted[right] &#123;</span><br><span class="line">right--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> right - left + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一次遍历的话，先观察示例，从左往右看，数字应该是递增的，如果发现当前数字比前一个小，说明这个数字不符合条件，需要把边界更新到这里，同时更新已经遍历过的 max 数值，当某个 idx 之后，边界不再更新，根据我们设定的条件，这个 idx 右边的数应该都比 max 要大，这个 idx 比 max 要小，所以这个就是符合条件的右边界。同理，找到左边界。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUnsortedSubarray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">right, left := <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line"><span class="comment">// 注意 max 从 min起始；min 从 max 起始</span></span><br><span class="line">maxn, minn := math.MinInt64, math.MaxInt64</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] &lt; maxn &#123;</span><br><span class="line">right = i</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">maxn = nums[i]</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// i 对位的位置</span></span><br><span class="line"><span class="keyword">if</span> minn &lt; nums[n<span class="number">-1</span>-i] &#123;</span><br><span class="line">left = n<span class="number">-1</span> - i</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">minn = nums[n<span class="number">-1</span>-i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 本身有序</span></span><br><span class="line"><span class="keyword">if</span> right == <span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> right - left + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> 字节常见题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>what-happens-when</title>
      <link href="/library/what-happens-when/"/>
      <url>/library/what-happens-when/</url>
      
        <content type="html"><![CDATA[<p>What-happens-when 的中文翻译，原仓库 <a href="https://github.com/alex/what-happens-when">https://github.com/alex/what-happens-when</a></p><h2 id="按下”g”键"><a href="#按下”g”键" class="headerlink" title="按下”g”键"></a>按下”g”键</h2><p>接下来的内容介绍了物理键盘和系统中断的工作原理，但是有一部分内容却没有涉及。当你按下“g”键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。你打算输入 “google.com”，因此给出的建议并不匹配。但是输入过程中仍然有大量的代码在后台运行，你的每一次按键都会使得给出的建议更加准确。甚至有可能在你输入之前，浏览器就将 “google.com” 建议给你。</p><h2 id="回车键按下"><a href="#回车键按下" class="headerlink" title="回车键按下"></a>回车键按下</h2><p>为了从零开始，我们选择键盘上的回车键被按到最低处作为起点。在这个时刻，一个专用于回车键的电流回路被直接地或者通过电容器间接地闭合了，使得少量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。现在这个传输过程几乎都是通过通用串行总线(USB)或者蓝牙(Bluetooth)来进行的，以前是通过PS&#x2F;2或者ADB连接进行。</p><p><em>USB键盘：</em></p><ul><li>键盘的USB元件通过计算机上的USB接口与USB控制器相连接，USB接口中的第一号针为它提供了5V的电压</li><li>键码值存储在键盘内部电路一个叫做”endpoint”的寄存器内</li><li>USB控制器大概每隔10ms便查询一次”endpoint”以得到存储的键码值数据，这个最短时间间隔由键盘提供</li><li>键值码值通过USB串行接口引擎被转换成一个或者多个遵循低层USB协议的USB数据包</li><li>这些数据包通过D+针或者D-针(中间的两个针)，以最高1.5Mb&#x2F;s的速度从键盘传输至计算机。速度限制是因为人机交互设备总是被声明成”低速设备”（USB 2.0 compliance）</li><li>这个串行信号在计算机的USB控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释。之后按键的码值被传输到操作系统的硬件抽象层</li></ul><p><em>虚拟键盘（触屏设备）：</em></p><ul><li>在现代电容屏上，当用户把手指放在屏幕上时，一小部分电流从传导层的静电域经过手指传导，形成了一个回路，使得屏幕上触控的那一点电压下降，屏幕控制器产生一个中断，报告这次“点击”的坐标</li><li>然后移动操作系统通知当前活跃的应用，有一个点击事件发生在它的某个GUI部件上了，现在这个部件是虚拟键盘的按钮</li><li>虚拟键盘引发一个软中断，返回给OS一个“按键按下”消息</li><li>这个消息又返回来向当前活跃的应用通知一个“按键按下”事件</li></ul><h2 id="产生中断-非USB键盘"><a href="#产生中断-非USB键盘" class="headerlink" title="产生中断[非USB键盘]"></a>产生中断[非USB键盘]</h2><p>键盘在它的中断请求线(IRQ)上发送信号，信号会被中断控制器映射到一个中断向量，实际上就是一个整型数 。CPU使用中断描述符表(IDT)把中断向量映射到对应函数，这些函数被称为中断处理器，它们由操作系统内核提供。当一个中断到达时，CPU根据IDT和中断向量索引到对应的中断处理器，然后操作系统内核出场了。</p><h2 id="Windows-一个-WM-KEYDOWN-消息被发往应用程序"><a href="#Windows-一个-WM-KEYDOWN-消息被发往应用程序" class="headerlink" title="(Windows)一个 WM_KEYDOWN 消息被发往应用程序"></a>(Windows)一个 <code>WM_KEYDOWN</code> 消息被发往应用程序</h2><p>HID把键盘按下的事件传送给 <code>KBDHID.sys</code> 驱动，把HID的信号转换成一个扫描码(Scancode)，这里回车的扫描码是 <code>VK_RETURN(0x0d)</code>。 <code>KBDHID.sys</code> 驱动和 <code>KBDCLASS.sys</code> (键盘类驱动,keyboard class driver)进行交互，这个驱动负责安全地处理所有键盘和小键盘的输入事件。之后它又去调用 <code>Win32K.sys</code> ，在这之前有可能把消息传递给安装的第三方键盘过滤器。这些都是发生在内核模式。</p><p><code>Win32K.sys</code> 通过 <code>GetForegroundWindow()</code> API函数找到当前哪个窗口是活跃的。这个API函数提供了当前浏览器的地址栏的句柄。Windows系统的”message pump”机制调用 <code>SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam)</code> 函数， <code>lParam</code> 是一个用来指示这个按键的更多信息的掩码，这些信息包括按键重复次数（这里是0），实际扫描码（可能依赖于OEM厂商，不过通常不会是 <code>VK_RETURN</code> ），功能键（alt, shift, ctrl）是否被按下（在这里没有），以及一些其他状态。</p><p>Windows的 <code>SendMessage</code> API直接将消息添加到特定窗口句柄 <code>hWnd</code> 的消息队列中，之后赋给 <code>hWnd</code> 的主要消息处理函数 <code>WindowProc</code> 将会被调用，用于处理队列中的消息。</p><p>当前活跃的句柄 <code>hWnd</code> 实际上是一个edit control控件，这种情况下，<code>WindowProc</code> 有一个用于处理 <code>WM_KEYDOWN</code> 消息的处理器，这段代码会查看 <code>SendMessage</code> 传入的第三个参数 <code>wParam</code> ，因为这个参数是 <code>VK_RETURN</code> ，于是它知道用户按下了回车键。</p><h2 id="Mac-OS-X-一个-KeyDown-NSEvent被发往应用程序"><a href="#Mac-OS-X-一个-KeyDown-NSEvent被发往应用程序" class="headerlink" title="(Mac OS X)一个 KeyDown NSEvent被发往应用程序"></a>(Mac OS X)一个 <code>KeyDown</code> NSEvent被发往应用程序</h2><p>中断信号引发了I&#x2F;O Kit Kext键盘驱动的中断处理事件，驱动把信号翻译成键码值，然后传给OS X的 <code>WindowServer</code> 进程。然后， <code>WindowServer</code> 将这个事件通过Mach端口分发给合适的（活跃的，或者正在监听的）应用程序，这个信号会被放到应用程序的消息队列里。队列中的消息可以被拥有足够高权限的线程使用 <code>mach_ipc_dispatch</code> 函数读取到。这个过程通常是由 <code>NSApplication</code> 主事件循环产生并且处理的，通过 <code>NSEventType</code> 为 <code>KeyDown</code> 的 <code>NSEvent</code> 。</p><h2 id="GNU-x2F-Linux-Xorg-服务器监听键码值"><a href="#GNU-x2F-Linux-Xorg-服务器监听键码值" class="headerlink" title="(GNU&#x2F;Linux)Xorg 服务器监听键码值"></a>(GNU&#x2F;Linux)Xorg 服务器监听键码值</h2><p>当使用图形化的 X Server 时，X Server 会按照特定的规则把键码值再一次映射，映射成扫描码。当这个映射过程完成之后， X Server 把这个按键字符发送给窗口管理器(DWM，metacity, i3等等)，窗口管理器再把字符发送给当前窗口。当前窗口使用有关图形API把文字打印在输入框内。</p><h2 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h2><ul><li><p>浏览器通过 URL 能够知道下面的信息：</p><blockquote><ul><li><p><code>Protocol</code> “http”</p><p>  使用HTTP协议</p></li><li><p><code>Resource</code> “&#x2F;“</p><p>  请求的资源是主页(index)</p></li></ul></blockquote></li></ul><h2 id="输入的是-URL-还是搜索的关键字？"><a href="#输入的是-URL-还是搜索的关键字？" class="headerlink" title="输入的是 URL 还是搜索的关键字？"></a>输入的是 URL 还是搜索的关键字？</h2><p>当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。</p><h2 id="转换非-ASCII-的-Unicode-字符"><a href="#转换非-ASCII-的-Unicode-字符" class="headerlink" title="转换非 ASCII 的 Unicode 字符"></a>转换非 ASCII 的 Unicode 字符</h2><ul><li>浏览器检查输入是否含有不是 <code>a-z</code>， <code>A-Z</code>，<code>0-9</code>， <code>-</code> 或者 <code>.</code> 的字符</li><li>这里主机名是 <code>google.com</code> ，所以没有非ASCII的字符；如果有的话，浏览器会对主机名部分使用 <a href="https://en.wikipedia.org/wiki/Punycode">Punycode</a> 编码</li></ul><h2 id="检查-HSTS-列表"><a href="#检查-HSTS-列表" class="headerlink" title="检查 HSTS 列表"></a>检查 HSTS 列表</h2><ul><li>浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站</li><li>如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送</li><li>注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户受到 <a href="http://en.wikipedia.org/wiki/SSL_stripping">downgrade attack</a> 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。</li></ul><h2 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h2><ul><li>浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome:&#x2F;&#x2F;net-internals&#x2F;#dns）。</li><li>如果缓存中没有，就去调用 <code>gethostbyname</code> 库函数（操作系统不同函数也不同）进行查询。</li><li><code>gethostbyname</code> 函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置 <a href="https://github.com/skyline75489/what-happens-when-zh_CN/blob/master">不同的操作系统有所不同</a></li><li>如果 <code>gethostbyname</code> 没有这个域名的缓存记录，也没有在 <code>hosts</code> 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。</li><li>查询本地 DNS 服务器</li><li>如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询</li><li>如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询</li></ul><h2 id="ARP-过程"><a href="#ARP-过程" class="headerlink" title="ARP 过程"></a>ARP 过程</h2><p>要想发送 ARP（地址解析协议）广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。</p><ul><li>首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP &#x3D; MAC</li></ul><p>如果缓存没有命中：</p><ul><li>查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。</li><li>查询选择的网络接口的 MAC 地址</li><li>我们发送一个二层（ <a href="https://en.wikipedia.org/wiki/OSI_model">OSI 模型</a> 中的数据链路层）ARP 请求：</li></ul><p><code>ARP Request</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sender MAC: interface:mac:address:here</span><br><span class="line">Sender IP: interface.ip.goes.here</span><br><span class="line">Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)</span><br><span class="line">Target IP: target.ip.goes.here</span><br></pre></td></tr></table></figure><p>根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：</p><p>直连：</p><ul><li>如果我们和路由器是直接连接的，路由器会返回一个 <code>ARP Reply</code> （见下面）。</li></ul><p>集线器：</p><ul><li>如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 <code>ARP Reply</code> 。</li></ul><p>交换机：</p><ul><li>如果我们连接到了一个交换机，交换机会检查本地 CAM&#x2F;MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。</li><li>如果交换机的 MAC&#x2F;CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 ARP 请求</li><li>如果路由器也“连接”在其中，它会返回一个 <code>ARP Reply</code></li></ul><p><code>ARP Reply</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sender MAC: target:mac:address:here</span><br><span class="line">Sender IP: target.ip.goes.here</span><br><span class="line">Target MAC: interface:mac:address:here</span><br><span class="line">Target IP: interface.ip.goes.here</span><br></pre></td></tr></table></figure><p>现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了：</p><ul><li>使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议</li><li>如果本地&#x2F;ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回</li></ul><h2 id="使用套接字"><a href="#使用套接字" class="headerlink" title="使用套接字"></a>使用套接字</h2><p>当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 <code>socket</code> ，请求一个 TCP流套接字，对应的参数是 <code>AF_INET/AF_INET6</code> 和 <code>SOCK_STREAM</code> 。</p><ul><li>这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range)</li><li>TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个IP packet。</li><li>这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame 头部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。</li></ul><p>到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输：</p><ul><li><a href="http://en.wikipedia.org/wiki/IEEE_802.3">以太网</a></li><li><a href="https://en.wikipedia.org/wiki/IEEE_802.11">WiFi</a></li><li><a href="https://en.wikipedia.org/wiki/Cellular_data_communication_protocol">蜂窝数据网络</a></li></ul><p>对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个 <a href="https://en.wikipedia.org/wiki/Computer_network#Network_nodes">网络节点</a> 处理。节点的目标地址和源地址将在后面讨论。</p><p>大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个 <a href="https://en.wikipedia.org/wiki/Computer_network#Network_nodes">网络节点</a> 进行处理。</p><p>最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域(autonomous system, 缩写 AS)的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP数据报头部 time to live (TTL) 域的值每经过一个路由器就减1，如果封包的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。</p><p>上面的发送和接受过程在 TCP 连接期间会发生很多次：</p><ul><li><p>客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号</p></li><li><p>服务器端接收到 SYN 包，如果它可以建立连接：</p><ul><li>服务器端选择它自己的初始序列号</li><li>服务器端设置 SYN 位，表明自己选择了一个初始序列号</li><li>服务器端把 (客户端ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个封包</li></ul></li><li><p>客户端通过发送下面一个封包来确认这次连接：</p><ul><li>自己的序列号+1</li><li>接收端 ACK+1</li><li>设置 ACK 位</li></ul></li><li><p>数据通过下面的方式传输：</p><ul><li>当一方发送了N个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N</li><li>另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号</li></ul></li><li><p>关闭连接时：</p><ul><li>要关闭连接的一方发送一个 FIN 包</li><li>另一方确认这个 FIN 包，并且发送自己的 FIN 包</li><li>要关闭的一方使用 ACK 包来确认接收到了 FIN</li></ul></li></ul><h2 id="TLS-握手"><a href="#TLS-握手" class="headerlink" title="TLS 握手"></a>TLS 握手</h2><ul><li>客户端发送一个 <code>ClientHello</code> 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。</li><li>服务器端向客户端返回一个 <code>ServerHello</code> 消息，消息中包含了服务器端的TLS版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥</li><li>客户端根据自己的信任CA列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥</li><li>服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥</li><li>客户端发送一个 <code>Finished</code> 消息给服务器端，使用对称密钥加密这次通讯的一个散列值</li><li>服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 <code>Finished</code> 消息，也使用协商好的对称密钥加密</li><li>从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容</li></ul><h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><p>如果浏览器是 Google 出品的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。</p><p>如果浏览器使用 HTTP 协议而不支持 SPDY 协议，它会向服务器发送这样的一个请求:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: google.com</span><br><span class="line">Connection: close</span><br><span class="line">[其他头部]</span><br></pre></td></tr></table></figure><p>“其他头部”包含了一系列的由冒号分割开的键值对，它们的格式符合HTTP协议标准，它们之间由一个换行符分割开来。（这里我们假设浏览器没有违反HTTP协议标准的bug，同时假设浏览器使用 <code>HTTP/1.1</code> 协议，不然的话头部可能不包含 <code>Host</code> 字段，同时 <code>GET</code> 请求中的版本号会变成 <code>HTTP/1.0</code> 或者 <code>HTTP/0.9</code> 。）</p><p>HTTP&#x2F;1.1 定义了“关闭连接”的选项 “close”，发送者使用这个选项指示这次连接在响应结束之后会断开。例如：</p><blockquote><p>Connection:close</p></blockquote><p>不支持持久连接的 HTTP&#x2F;1.1 应用必须在每条消息中都包含 “close” 选项。</p><p>在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。</p><p>服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">200 OK</span><br><span class="line">[响应头部]</span><br></pre></td></tr></table></figure><p>然后是一个换行，接下来有效载荷(payload)，也就是 <code>www.google.com</code> 的HTML内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供之后的请求重用。</p><p>如果浏览器发送的HTTP头部包含了足够多的信息（例如包含了 Etag 头部），以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">304 Not Modified</span><br><span class="line">[响应头部]</span><br></pre></td></tr></table></figure><p>这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。</p><p>在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直到HTML页面引入的所有资源（图片，CSS，favicon.ico等等）全部都获取完毕，区别只是头部的 <code>GET / HTTP/1.1</code> 会变成 <code>GET /$(相对www.google.com的URL) HTTP/1.1</code> 。</p><p>如果HTML引入了 <code>www.google.com</code> 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 <code>Host</code> 头部会变成另外的域名。</p><h2 id="HTTP-服务器请求处理"><a href="#HTTP-服务器请求处理" class="headerlink" title="HTTP 服务器请求处理"></a>HTTP 服务器请求处理</h2><p>HTTPD(HTTP Daemon)在服务器端处理请求&#x2F;响应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。</p><ul><li><p>HTTPD 接收请求</p></li><li><p>服务器把请求拆分为以下几个参数：</p><ul><li>HTTP 请求方法(<code>GET</code>, <code>POST</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code>, <code>CONNECT</code>, <code>OPTIONS</code>, 或者 <code>TRACE</code>)。直接在地址栏中输入 URL 这种情况下，使用的是 GET 方法</li><li>域名：google.com</li><li>请求路径&#x2F;页面：&#x2F; (我们没有请求google.com下的指定的页面，因此 &#x2F; 是默认的路径)</li></ul></li><li><p>服务器验证其上已经配置了 google.com 的虚拟主机</p></li><li><p>服务器验证 google.com 接受 GET 方法</p></li><li><p>服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)</p></li><li><p>如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求</p></li><li><p>服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 “&#x2F;“ ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。</p></li><li><p>服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者</p></li></ul><h2 id="浏览器背后的故事"><a href="#浏览器背后的故事" class="headerlink" title="浏览器背后的故事"></a>浏览器背后的故事</h2><p>当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：</p><ul><li>解析 —— HTML，CSS，JS</li><li>渲染 —— 构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制</li></ul><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。资源的位置通过用户提供的 URI(Uniform Resource Identifier) 来确定。</p><p>浏览器解释和展示 HTML 文件的方法，在 HTML 和 CSS 的标准中有详细介绍。这些标准由 Web 标准组织 W3C(World Wide Web Consortium) 维护。</p><p>不同浏览器的用户界面大都十分接近，有很多共同的 UI 元素：</p><ul><li>一个地址栏</li><li>后退和前进按钮</li><li>书签选项</li><li>刷新和停止按钮</li><li>主页按钮</li></ul><p><strong>浏览器高层架构</strong></p><p>组成浏览器的组件有：</p><ul><li><strong>用户界面</strong> 用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分</li><li><strong>浏览器引擎</strong> 浏览器引擎负责让 UI 和渲染引擎协调工作</li><li><strong>渲染引擎</strong> 渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上</li><li><strong>网络组件</strong> 网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现</li><li><strong>UI后端</strong> UI 后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现</li><li><strong>Javascript 引擎</strong> Javascript 引擎用于解析和执行 Javascript 代码</li><li><strong>数据存储</strong> 数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制</li></ul><h2 id="HTML-解析"><a href="#HTML-解析" class="headerlink" title="HTML 解析"></a>HTML 解析</h2><p>浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成8kB大小的分块传输。</p><p>HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。</p><p>解析树是以 DOM 元素以及属性为节点的树。DOM是文档对象模型(Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部(如Javascript)的接口。树的根部是”Document”对象。整个 DOM 和 HTML 文档几乎是一对一的关系。</p><p><strong>解析算法</strong></p><p>HTML不能使用常见的自顶向下或自底向上方法来进行分析。主要原因有以下几点:</p><ul><li>语言本身的“宽容”特性</li><li>HTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们</li><li>解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 document.write() 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容</li></ul><p>由于不能使用常用的解析技术，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。</p><p><strong>解析结束之后</strong></p><p>浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。</p><p>此时浏览器把文档标记为可交互的（interactive），浏览器开始解析处于“推迟（deferred）”模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为“完成（complete）”，浏览器会触发“加载（load）”事件。</p><p>注意解析 HTML 网页时永远不会出现“无效语法（Invalid Syntax）”错误，浏览器会修复所有错误内容，然后继续解析。</p><h2 id="CSS-解析"><a href="#CSS-解析" class="headerlink" title="CSS 解析"></a>CSS 解析</h2><ul><li>根据 <a href="http://www.w3.org/TR/CSS2/grammar.html">CSS词法和句法</a> 分析CSS文件和 <code>&lt;style&gt;</code> 标签包含的内容以及 style 属性的值</li><li>每个CSS文件都被解析成一个样式表对象（<code>StyleSheet object</code>），这个对象里包含了带有选择器的CSS规则，和对应CSS语法的对象</li><li>CSS解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器</li></ul><h2 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h2><ul><li>通过遍历DOM节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个CSS样式值</li><li>通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算”Frame 树”中每个节点的首选(preferred)宽度</li><li>通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度</li><li>通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)，自底向上的计算每个节点的高度</li><li>使用上面的计算结果构建每个节点的坐标</li><li>当存在元素使用 <code>floated</code>，位置有 <code>absolutely</code> 或 <code>relatively</code> 属性的时候，会有更多复杂的计算，详见<a href="http://dev.w3.org/csswg/css2/">http://dev.w3.org/csswg/css2/</a> 和 <a href="http://www.w3.org/Style/CSS/current-work">http://www.w3.org/Style/CSS/current-work</a></li><li>创建layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层</li><li>页面上的每个层都被分配了纹理(?)</li><li>每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D&#x2F;SkiaGL在GPU上绘制</li><li>上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量</li><li>计算出各个层的最终位置，一组命令由 Direct3D&#x2F;OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server。</li></ul><h2 id="GPU-渲染"><a href="#GPU-渲染" class="headerlink" title="GPU 渲染"></a>GPU 渲染</h2><ul><li>在渲染过程中，图形处理层可能使用通用用途的 <code>CPU</code>，也可能使用图形处理器 <code>GPU</code></li><li>当使用 <code>GPU</code> 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 <code>GPU</code> 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。</li></ul><h2 id="Window-Server"><a href="#Window-Server" class="headerlink" title="Window Server"></a>Window Server</h2><h2 id="后期渲染与用户引发的处理"><a href="#后期渲染与用户引发的处理" class="headerlink" title="后期渲染与用户引发的处理"></a>后期渲染与用户引发的处理</h2><p>渲染结束后，浏览器根据某些时间机制运行JavaScript代码(比如Google Doodle动画)或与用户交互(在搜索栏输入关键字获得搜索建议)。类似Flash和Java的插件也会运行，尽管Google主页里没有。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制。</p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang Container.Heap 使用</title>
      <link href="/library/Golang/advanced-tutorial/go-container-heap/"/>
      <url>/library/Golang/advanced-tutorial/go-container-heap/</url>
      
        <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hp []*ListNode </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h hp)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125; </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h hp)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i].Val &lt; h[j].Val &#125; </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h hp)</span></span> Swap(i, j <span class="type">int</span>) &#123; h[i], h[j] = h[j], h[i] &#125; </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hp)</span></span> Push(v any) &#123; </span><br><span class="line">*h = <span class="built_in">append</span>(*h, v.(*ListNode)) </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hp)</span></span> Pop() any &#123; </span><br><span class="line">a := *h</span><br><span class="line">v := a[<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line">*h = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> v </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>源码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2009 The Go Authors. All rights reserved.  </span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style  </span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Package heap provides heap operations for any type that implements  </span></span><br><span class="line"><span class="comment">// heap.Interface. A heap is a tree with the property that each node is the  </span></span><br><span class="line"><span class="comment">// minimum-valued node in its subtree.  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// The minimum element in the tree is the root, at index 0.  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// A heap is a common way to implement a priority queue. To build a priority  </span></span><br><span class="line"><span class="comment">// queue, implement the Heap interface with the (negative) priority as the  </span></span><br><span class="line"><span class="comment">// ordering for the Less method, so Push adds items while Pop removes the// highest-priority item from the queue. The Examples include such an  </span></span><br><span class="line"><span class="comment">// implementation; the file example_pq_test.go has the complete source.  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="keyword">package</span> heap  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// The Interface type describes the requirements// for a type using the routines in this package.  </span></span><br><span class="line"><span class="comment">// Any type that implements it may be used as a  </span></span><br><span class="line"><span class="comment">// min-heap with the following invariants (established after  </span></span><br><span class="line"><span class="comment">// Init has been called or if the data is empty or sorted)://  </span></span><br><span class="line"><span class="comment">// !h.Less(j, i) for 0 &lt;= i &lt; h.Len() and 2*i+1 &lt;= j &lt;= 2*i+2 and j &lt; h.Len()  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// Note that Push and Pop in this interface are for package heap&#x27;s// implementation to call. To add and remove things from the heap,  </span></span><br><span class="line"><span class="comment">// use heap.Push and heap.Pop.  </span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;  </span><br><span class="line">   sort.Interface  </span><br><span class="line">   Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()  </span></span><br><span class="line">   Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Init establishes the heap invariants required by the other routines in this package.// Init is idempotent with respect to the heap invariants// and may be called whenever the heap invariants may have been invalidated.  </span></span><br><span class="line"><span class="comment">// The complexity is O(n) where n = h.Len().  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(h Interface)</span></span> &#123;  </span><br><span class="line">   <span class="comment">// heapify  </span></span><br><span class="line">   n := h.Len()  </span><br><span class="line">   <span class="keyword">for</span> i := n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;  </span><br><span class="line">      down(h, i, n)  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Push pushes the element x onto the heap.// The complexity is O(log n) where n = h.Len().  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(h Interface, x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">   h.Push(x)  </span><br><span class="line">   up(h, h.Len()<span class="number">-1</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Pop removes and returns the minimum element (according to Less) from the heap.// The complexity is O(log n) where n = h.Len().  </span></span><br><span class="line"><span class="comment">// Pop is equivalent to Remove(h, 0).  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(h Interface)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line">   n := h.Len() - <span class="number">1</span>  </span><br><span class="line">   h.Swap(<span class="number">0</span>, n)  </span><br><span class="line">   down(h, <span class="number">0</span>, n)  </span><br><span class="line">   <span class="keyword">return</span> h.Pop()  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Remove removes and returns the element at index i from the heap.// The complexity is O(log n) where n = h.Len().  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(h Interface, i <span class="type">int</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line">   n := h.Len() - <span class="number">1</span>  </span><br><span class="line">   <span class="keyword">if</span> n != i &#123;  </span><br><span class="line">      h.Swap(i, n)  </span><br><span class="line">      <span class="keyword">if</span> !down(h, i, n) &#123;  </span><br><span class="line">         up(h, i)  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> h.Pop()  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Fix re-establishes the heap ordering after the element at index i has changed its value.// Changing the value of the element at index i and then calling Fix is equivalent to,// but less expensive than, calling Remove(h, i) followed by a Push of the new value.// The complexity is O(log n) where n = h.Len().  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fix</span><span class="params">(h Interface, i <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> !down(h, i, h.Len()) &#123;  </span><br><span class="line">      up(h, i)  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">up</span><span class="params">(h Interface, j <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">for</span> &#123;  </span><br><span class="line">      i := (j - <span class="number">1</span>) / <span class="number">2</span> <span class="comment">// parent  </span></span><br><span class="line">      <span class="keyword">if</span> i == j || !h.Less(j, i) &#123;  </span><br><span class="line">         <span class="keyword">break</span>  </span><br><span class="line">      &#125;  </span><br><span class="line">      h.Swap(i, j)  </span><br><span class="line">      j = i  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">down</span><span class="params">(h Interface, i0, n <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">   i := i0  </span><br><span class="line">   <span class="keyword">for</span> &#123;  </span><br><span class="line">      j1 := <span class="number">2</span>*i + <span class="number">1</span>  </span><br><span class="line">      <span class="keyword">if</span> j1 &gt;= n || j1 &lt; <span class="number">0</span> &#123; <span class="comment">// j1 &lt; 0 after int overflow  </span></span><br><span class="line">         <span class="keyword">break</span>  </span><br><span class="line">      &#125;  </span><br><span class="line">      j := j1 <span class="comment">// left child  </span></span><br><span class="line">      <span class="keyword">if</span> j2 := j1 + <span class="number">1</span>; j2 &lt; n &amp;&amp; h.Less(j2, j1) &#123;  </span><br><span class="line">         j = j2 <span class="comment">// = 2*i + 2  // right child  </span></span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">if</span> !h.Less(j, i) &#123;  </span><br><span class="line">         <span class="keyword">break</span>  </span><br><span class="line">      &#125;  </span><br><span class="line">      h.Swap(i, j)  </span><br><span class="line">      i = j  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> i &gt; i0  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 进阶教程笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s 面试必备 100 题</title>
      <link href="/interview/100prob/k8s-interview-100/"/>
      <url>/interview/100prob/k8s-interview-100/</url>
      
        <content type="html"><![CDATA[<h1 id="K8S经典面试题解析"><a href="#K8S经典面试题解析" class="headerlink" title="K8S经典面试题解析"></a>K8S经典面试题解析</h1><h2 id="1、简述ETCD及其特点"><a href="#1、简述ETCD及其特点" class="headerlink" title="1、简述ETCD及其特点?"></a>1、简述ETCD及其特点?</h2><p>etcd是一个用于配置共享和服务发现的键值存储系统，能够为整个分布式集群存储关键数据，协助集群正常运转 服务端将配置信息存储在etcd中，客户端从etcd中得到配置信息，etcd监听配置信息的变化，发现配置变化通知到客户端 特点 - 安装、使用简单 - 数据分层存储在目录中，类似于文件系统 - watch机制 - 安装机制：支持ssl证书认证 - 高性能：etc支持2k&#x2F;s的读操作 - 一致可靠：基于Raft共识算法实现数据存储、服务调用的一致性和高可用性 - Revision机制：每个key带有一个revision号，每次事物便加一。 -</p><h2 id="2、简述ETCD适应的场景"><a href="#2、简述ETCD适应的场景" class="headerlink" title="2、简述ETCD适应的场景?"></a>2、简述ETCD适应的场景?</h2><ul><li>服务发现</li><li>消息发布与订阅</li><li>负载均衡</li><li>分布式通知与协调</li><li>分布式锁</li><li>集群监控与leader选举</li></ul><h2 id="3、简述什么是Kubernetes"><a href="#3、简述什么是Kubernetes" class="headerlink" title="3、简述什么是Kubernetes?"></a>3、简述什么是Kubernetes?</h2><p>k8s是一个开源的容器管理工具，负责容器部署，容器扩缩容以及负载平衡。可以说k8s是一个多容器管理解决方案。</p><h2 id="4、简述Kubernetes和Docker的关系"><a href="#4、简述Kubernetes和Docker的关系" class="headerlink" title="4、简述Kubernetes和Docker的关系?"></a>4、简述Kubernetes和Docker的关系?</h2><p>docker提供容器的生命周期管理、镜像构建运行时容器。k8s关联和编排容器在多个主机上互相通信。</p><h2 id="5、简述Kubernetes中什么是Minikube、Kubectl、Kubelet"><a href="#5、简述Kubernetes中什么是Minikube、Kubectl、Kubelet" class="headerlink" title="5、简述Kubernetes中什么是Minikube、Kubectl、Kubelet?"></a>5、简述Kubernetes中什么是Minikube、Kubectl、Kubelet?</h2><ul><li>是一种可以在本地轻松运行k8s的工具。</li><li>是一个命令行工具，可以使用该工具控制Kubernetes集群管理器，如检查群集资源，创建、删除和更新组件，查看应用程序</li><li>是一个代理服务，它在每个节点上运行，并使从服务器与主服务器通信</li></ul><h2 id="6、简述Kubernetes常见的部署方式"><a href="#6、简述Kubernetes常见的部署方式" class="headerlink" title="6、简述Kubernetes常见的部署方式?"></a>6、简述Kubernetes常见的部署方式?</h2><ul><li>二进制部署</li><li>kubeadm</li><li>源码安装部署</li></ul><h2 id="7、简述Kubernetes如何实现集群管理"><a href="#7、简述Kubernetes如何实现集群管理" class="headerlink" title="7、简述Kubernetes如何实现集群管理?"></a>7、简述Kubernetes如何实现集群管理?</h2><p>在集群管理方面，Kubernetes将集群中的机器划分为一个Master节点和一群工作节点Node。其中，在Master节点运行着集群管理相关的一组进程kube-apiserver、kube-controller-manager和kube-scheduler，这些进程实现了整个集群的资源管理、Pod调度、弹性伸缩、安全控制、系统监控和纠错等管理能力，并且都是全自动完成的</p><h2 id="8、简述Kubernetes的优势、适应场景及其特点"><a href="#8、简述Kubernetes的优势、适应场景及其特点" class="headerlink" title="8、简述Kubernetes的优势、适应场景及其特点?"></a>8、简述Kubernetes的优势、适应场景及其特点?</h2><p>优势 - 容器编排 - 轻量级 - 开源 - 弹性伸缩 - 负载均衡</p><p>场景 - 快速部署 - 快速扩展 - 快速对接新的应用功能 - 优化资源，提升资源利用率</p><p>特点 - 可移植 - 可扩展 - 自动化</p><h2 id="9、简述Kubernetes的缺点或当前的不足之处"><a href="#9、简述Kubernetes的缺点或当前的不足之处" class="headerlink" title="9、简述Kubernetes的缺点或当前的不足之处?"></a>9、简述Kubernetes的缺点或当前的不足之处?</h2><ul><li>安装过程和配置相对困难复杂</li><li>管理服务相对繁琐</li><li>运行和编译需要很多时间</li><li>它比其他替代品更昂贵</li></ul><h2 id="10、简述Kubernetes相关基础概念"><a href="#10、简述Kubernetes相关基础概念" class="headerlink" title="10、简述Kubernetes相关基础概念"></a>10、简述Kubernetes相关基础概念</h2><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td>Pod（Pod组）</td><td>Pod是Kubernetes的最小调度单元，它可以包含一个或多个容器。容器在同一个Pod中共享网络和存储，它们之间可以通过localhost通信。</td></tr><tr><td>Node（节点）</td><td>节点是Kubernetes集群中的一个工作机器，可以是物理机器或虚拟机。每个节点负责运行Pod中的容器，并由Master节点进行管理。</td></tr><tr><td>Cluster（集群）</td><td>集群是由一组工作节点和一个Master节点组成的Kubernetes系统。Master节点负责整个集群的控制和管理。</td></tr><tr><td>Service（服务）</td><td>服务是一种抽象，定义了一组Pod及其访问方式。它可以确保Pod的稳定网络标识和动态路由。</td></tr><tr><td>ReplicaSet</td><td>ReplicaSet是用于确保在集群中运行指定数量的Pod的控制器。当Pod数目发生变化时，ReplicaSet会启动或终止Pod，以维持所需的数量。</td></tr><tr><td>Deployment（部署）</td><td>部署是一种资源对象，它描述了应用程序的期望状态，并确保集群中的Pod数量符合这个状态。</td></tr><tr><td>Namespace（命名空间）</td><td>命名空间用于将集群划分为多个虚拟集群，每个命名空间中的资源相互隔离。</td></tr><tr><td>ConfigMap和Secret</td><td>ConfigMap用于将配置数据提供给应用程序，而Secret用于存储敏感信息，如密码和API密钥。</td></tr><tr><td>Service Discovery（服务发现）</td><td>Kubernetes通过服务发现机制允许容器应用程序找到和通信其他应用程序的服务。</td></tr><tr><td>Ingress</td><td>Ingress是一种API对象，定义了从集群外部到集群内部服务的规则。</td></tr><tr><td>Persistent Volumes和Persistent Volume Claims</td><td>Persistent Volumes（PV）提供了一种抽象，用于将存储资源与集群中的Pod分离开来。Persistent Volume Claims（PVC）是对Persistent Volumes的请求，用于绑定Pod中的存储资源。</td></tr><tr><td>RBAC（Role-Based Access Control）</td><td>RBAC用于定义对Kubernetes资源的访问权限，以及哪些用户或服务账户可以执行哪些操作。</td></tr></tbody></table><h2 id="11、简述Kubernetes集群相关组件"><a href="#11、简述Kubernetes集群相关组件" class="headerlink" title="11、简述Kubernetes集群相关组件?"></a>11、简述Kubernetes集群相关组件?</h2><ul><li><p>master</p></li><li><p>kube-controller-manager</p></li><li><p>kube-apiserver</p></li><li><p>kube-scheduler</p></li><li><p>etcd</p></li><li><p>worker</p></li><li><p>kubelet</p></li><li><p>kube-proxy</p></li></ul><h2 id="12、简述Kubernetes-RC的机制"><a href="#12、简述Kubernetes-RC的机制" class="headerlink" title="12、简述Kubernetes RC的机制?"></a>12、简述Kubernetes RC的机制?</h2><p>Replication Controller用来管理Pod的副本，保证集群中存在指定数量的Pod副本。当定义了RC并提交至Kubernetes集群中之后，Master节点上的Controller Manager组件获悉，并同时巡检系统中当前存活的目标Pod，并确保目标Pod实例的数量刚好等于此RC的期望值，若存在过多的Pod副本在运行，系统会停止一些Pod，反之则自动创建一些Pod</p><h2 id="13、简述kube-proxy作用"><a href="#13、简述kube-proxy作用" class="headerlink" title="13、简述kube-proxy作用?"></a>13、简述kube-proxy作用?</h2><p>kube-proxy的作用主要是负责service的实现,具体来说,就是实现了内部从pod到service和外部的从node port向service的访问</p><h2 id="14、简述kube-proxy-iptables原理"><a href="#14、简述kube-proxy-iptables原理" class="headerlink" title="14、简述kube-proxy iptables原理?"></a>14、简述kube-proxy iptables原理?</h2><p>Kubernetes从1.2版本开始，将iptables作为kube-proxy的默认模式。iptables模式下的kube-proxy不再起到Proxy的作用，其核心功能：通过API Server的Watch接口实时跟踪Service与Endpoint的变更信息，并更新对应的iptables规则，Client的请求流量则通过iptables的NAT机制“直接路由”到目标Pod</p><h2 id="15、简述kube-proxy-ipvs原理"><a href="#15、简述kube-proxy-ipvs原理" class="headerlink" title="15、简述kube-proxy ipvs原理?"></a>15、简述kube-proxy ipvs原理?</h2><p>答：IPVS 在 Kubernetes1.11 中升级为 GA 稳定版。IPVS 则专门用于高性能负载均衡，并使用更高效的数据结构（Hash 表），允许几乎无限的规模扩张，因此被 kube-proxy 采纳为最新模式。</p><p>在 IPVS 模式下，使用 iptables 的扩展 ipset，而不是直接调用 iptables 来生成规则链。iptables 规则链是一个线性的数据结构，ipset 则引入了带索引的数据结构，因此当规则很多时，也可以很高效地查找和匹配。</p><p>可以将 ipset 简单理解为一个 IP（段）的集合，这个集合的内容可以是 IP 地址、IP 网段、端口等，iptables 可以直接添加规则对这个“可变的集合”进行操作，这样做的好处在于可以大大减少 iptables 规则的数量，从而减少性能损耗。</p><h2 id="16、简述kube-proxy-ipvs和iptables的异同"><a href="#16、简述kube-proxy-ipvs和iptables的异同" class="headerlink" title="16、简述kube-proxy ipvs和iptables的异同?"></a>16、简述kube-proxy ipvs和iptables的异同?</h2><p>答：iptables 与 IPVS 都是基于 Netfilter 实现的，但因为定位不同，二者有着本质的</p><p>差别：iptables 是为防火墙而设计的；IPVS 则专门用于高性能负载均衡，并使用更高效的数据结构（Hash 表），允许几乎无限的规模扩张。</p><p>与 iptables 相比，IPVS 拥有以下明显优势：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、为大型集群提供了更好的可扩展性和性能；</span><br><span class="line"></span><br><span class="line">2、支持比 iptables 更复杂的负载均衡算法（最小负载、最少连接、加权等）；</span><br><span class="line"></span><br><span class="line">3、支持服务器健康检查和连接重试等功能；</span><br><span class="line"></span><br><span class="line">4、可以动态修改 ipset 的集合，即使 iptables 的规则正在使用这个集合。</span><br></pre></td></tr></table></figure><h2 id="17、简述Kubernetes中什么是静态Pod"><a href="#17、简述Kubernetes中什么是静态Pod" class="headerlink" title="17、简述Kubernetes中什么是静态Pod?"></a>17、简述Kubernetes中什么是静态Pod?</h2><p>答：静态 pod 是由 kubelet 进行管理的仅存在于特定 Node的Pod，他们不能通过 API Server 进行管理，无法与 ReplicationController、Deployment 或者DaemonSet 进行关联，并且 kubelet 无法对他们进行健康检查。静态 Pod 总是由kubelet 进行创建，并且总是在 kubelet 所在的 Node 上运行</p><h2 id="18、简述Kubernetes中Pod可能位于的状态"><a href="#18、简述Kubernetes中Pod可能位于的状态" class="headerlink" title="18、简述Kubernetes中Pod可能位于的状态?"></a>18、简述Kubernetes中Pod可能位于的状态?</h2><p>Pending API Server已经创建该Pod，且Pod内还有一个或多个容器的镜像没有创建，包括正在下载镜像的过程。 Running Pod内所有容器均已创建，且至少有一个容器处于运行状态、正在启动状态或正在重启状态。 Succeeded Pod内所有容器均成功执行退出，且不会重启。 Failed Pod内所有容器均已退出，但至少有一个容器退出为失败状态。 Unknown 由于某种原因无法获取该Pod状态，可能由于网络通信不畅导致。</p><h2 id="19、简述Kubernetes创建一个Pod的主要流程"><a href="#19、简述Kubernetes创建一个Pod的主要流程" class="headerlink" title="19、简述Kubernetes创建一个Pod的主要流程?"></a>19、简述Kubernetes创建一个Pod的主要流程?</h2><p>Kubernetes中创建一个Pod涉及多个组件之间联动，主要流程如下：</p><ul><li>客户端提交Pod的配置信息（可以是yaml文件定义的信息）到kube-apiserver。</li><li>Apiserver收到指令后，通知给controller-manager创建一个资源对象。</li><li>Controller-manager通过api-server将pod的配置信息存储到ETCD数据中心中。</li><li>Kube-scheduler检测到pod信息会开始调度预选，会先过滤掉不符合Pod资源配置要求的节点，然后开始调度调优，主要是挑选出更适合运行pod的节点，然后将pod的资源配置单发送到node节点上的kubelet组件上。</li><li>Kubelet根据scheduler发来的资源配置单运行pod，运行成功后，将pod的运行信息返回给scheduler，scheduler将返回的pod运行状况的信息存储到etcd数据中心。</li></ul><h2 id="20、简述Kubernetes中Pod的重启策略"><a href="#20、简述Kubernetes中Pod的重启策略" class="headerlink" title="20、简述Kubernetes中Pod的重启策略?"></a>20、简述Kubernetes中Pod的重启策略?</h2><p>Pod的重启策略包括Always、OnFailure和Never，默认值为Always。</p><p>Always：当容器失效时，由kubelet自动重启该容器； OnFailure：当容器终止运行且退出码不为0时，由kubelet自动重启该容器； Never：不论容器运行状态如何，kubelet都不会重启该容器。 同时Pod的重启策略与控制方式关联，当前可用于管理Pod的控制器包括ReplicationController、Job、DaemonSet及直接管理kubelet管理（静态Pod）。 不同控制器的重启策略限制如下： RC和DaemonSet：必须设置为Always，需要保证该容器持续运行； Job：OnFailure或Never，确保容器执行完成后不再重启； kubelet：在Pod失效时重启，不论将RestartPolicy设置为何值，也不会对Pod进行健康检查。</p><h2 id="21、简述Kubernetes中Pod的健康检查方式"><a href="#21、简述Kubernetes中Pod的健康检查方式" class="headerlink" title="21、简述Kubernetes中Pod的健康检查方式?"></a>21、简述Kubernetes中Pod的健康检查方式?</h2><p>对Pod的健康检查可以通过两类探针来检查：LivenessProbe和ReadinessProbe。</p><p>LivenessProbe探针：用于判断容器是否存活（running状态），如果LivenessProbe探针探测到容器不健康，则kubelet将杀掉该容器，并根据容器的重启策略做相应处理。若一个容器不包含LivenessProbe探针，kubelet认为该容器的LivenessProbe探针返回值用于是“Success”。</p><p>ReadineeProbe探针：用于判断容器是否启动完成（ready状态）。如果ReadinessProbe探针探测到失败，则Pod的状态将被修改。Endpoint Controller将从Service的Endpoint中删除包含该容器所在Pod的Eenpoint。</p><p>startupProbe探针：启动检查机制，应用一些启动缓慢的业务，避免业务长时间启动而被上面两类探针kill掉。</p><h2 id="22、简述Kubernetes-Pod的LivenessProbe探针的常见方式"><a href="#22、简述Kubernetes-Pod的LivenessProbe探针的常见方式" class="headerlink" title="22、简述Kubernetes Pod的LivenessProbe探针的常见方式?"></a>22、简述Kubernetes Pod的LivenessProbe探针的常见方式?</h2><p>ExecAction：在容器内执行一个命令，若返回码为0，则表明容器健康。</p><p>TCPSocketAction：通过容器的IP地址和端口号执行TCP检查，若能建立TCP连接，则表明容器健康。</p><p>HTTPGetAction：通过容器的IP地址、端口号及路径调用HTTP Get方法，若响应的状态码大于等于200且小于400，则表明容器健康。</p><h2 id="23、简述Kubernetes-Pod的常见调度方式"><a href="#23、简述Kubernetes-Pod的常见调度方式" class="headerlink" title="23、简述Kubernetes Pod的常见调度方式?"></a>23、简述Kubernetes Pod的常见调度方式?</h2><p>Kubernetes中，Pod通常是容器的载体，主要有如下常见调度方式：</p><p>Deployment或RC：该调度策略主要功能就是自动部署一个容器应用的多份副本，以及持续监控副本的数量，在集群内始终维持用户指定的副本数量。</p><p>NodeSelector：定向调度，当需要手动指定将Pod调度到特定Node上，可以通过Node的标签（Label）和Pod的nodeSelector属性相匹配。</p><p>NodeAffinity亲和性调度：亲和性调度机制极大的扩展了Pod的调度能力，目前有两种节点亲和力表达：</p><p>requiredDuringSchedulingIgnoredDuringExecution：硬规则，必须满足指定的规则，调度器才可以调度Pod至Node上（类似nodeSelector，语法不同）。</p><p>preferredDuringSchedulingIgnoredDuringExecution：软规则，优先调度至满足的Node的节点，但不强求，多个优先级规则还可以设置权重值。</p><p>Taints和Tolerations（污点和容忍）：</p><p>Taint：使Node拒绝特定Pod运行；</p><p>Toleration：为Pod的属性，表示Pod能容忍（运行）标注了Taint的Node。</p><h2 id="24、简述Kubernetes初始化容器（init-container）"><a href="#24、简述Kubernetes初始化容器（init-container）" class="headerlink" title="24、简述Kubernetes初始化容器（init container）?"></a>24、简述Kubernetes初始化容器（init container）?</h2><p>init container的运行方式与应用容器不同，它们必须先于应用容器执行完成，当设置了多个init container时，将按顺序逐个运行，并且只有前一个init container运行成功后才能运行后一个init container。当所有init container都成功运行后，Kubernetes才会初始化Pod的各种信息，并开始创建和运行应用容器。</p><h2 id="25、简述Kubernetes-deployment升级过程"><a href="#25、简述Kubernetes-deployment升级过程" class="headerlink" title="25、简述Kubernetes deployment升级过程?"></a>25、简述Kubernetes deployment升级过程?</h2><p>初始创建Deployment时，系统创建了一个ReplicaSet，并按用户的需求创建了对应数量的Pod副本。</p><p>当更新Deployment时，系统创建了一个新的ReplicaSet，并将其副本数量扩展到1，然后将旧ReplicaSet缩减为2。</p><p>之后，系统继续按照相同的更新策略对新旧两个ReplicaSet进行逐个调整。</p><p>最后，新的ReplicaSet运行了对应个新版本Pod副本，旧的ReplicaSet副本数量则缩减为0。</p><h2 id="26、简述Kubernetes-deployment升级策略"><a href="#26、简述Kubernetes-deployment升级策略" class="headerlink" title="26、简述Kubernetes deployment升级策略?"></a>26、简述Kubernetes deployment升级策略?</h2><p>在Deployment的定义中，可以通过spec.strategy指定Pod更新的策略，目前支持两种策略：Recreate（重建）和RollingUpdate（滚动更新），默认值为RollingUpdate。</p><p>Recreate：设置spec.strategy.type&#x3D;Recreate，表示Deployment在更新Pod时，会先杀掉所有正在运行的Pod，然后创建新的Pod。</p><p>RollingUpdate：设置spec.strategy.type&#x3D;RollingUpdate，表示Deployment会以滚动更新的方式来逐个更新Pod。同时，可以通过设置spec.strategy.rollingUpdate下的两个参数（maxUnavailable和maxSurge）来控制滚动更新的过程。</p><h2 id="27、简述Kubernetes-DaemonSet类型的资源特性"><a href="#27、简述Kubernetes-DaemonSet类型的资源特性" class="headerlink" title="27、简述Kubernetes DaemonSet类型的资源特性?"></a>27、简述Kubernetes DaemonSet类型的资源特性?</h2><p>DaemonSet资源对象会在每个Kubernetes集群中的节点上运行，并且每个节点只能运行一个pod，这是它和deployment资源对象的最大也是唯一的区别。因此，在定义yaml文件中，不支持定义replicas。</p><p>它的一般使用场景如下：</p><p>在去做每个节点的日志收集工作。</p><p>监控每个节点的的运行状态。</p><h2 id="28、简述Kubernetes自动扩容机制"><a href="#28、简述Kubernetes自动扩容机制" class="headerlink" title="28、简述Kubernetes自动扩容机制?"></a>28、简述Kubernetes自动扩容机制?</h2><p>Kubernetes使用Horizontal Pod Autoscaler（HPA）的控制器实现基于CPU使用率进行自动Pod扩缩容的功能。HPA控制器周期性地监测目标Pod的资源性能指标，并与HPA资源对象中的扩缩容条件进行对比，在满足条件时对Pod副本数量进行调整。</p><p>HPA原理</p><p>Kubernetes中的某个Metrics Server（Heapster或自定义Metrics Server）持续采集所有Pod副本的指标数据。HPA控制器通过Metrics Server的API（Heapster的API或聚合API）获取这些数据，基于用户定义的扩缩容规则进行计算，得到目标Pod副本数量。</p><p>当目标Pod副本数量与当前副本数量不同时，HPA控制器就向Pod的副本控制器（Deployment、RC或ReplicaSet）发起scale操作，调整Pod的副本数量，完成扩缩容操作。</p><h2 id="29、简述Kubernetes-Service类型"><a href="#29、简述Kubernetes-Service类型" class="headerlink" title="29、简述Kubernetes Service类型?"></a>29、简述Kubernetes Service类型?</h2><p>通过创建Service，可以为一组具有相同功能的容器应用提供一个统一的入口地址，并且将请求负载分发到后端的各个容器应用上。其主要类型有：</p><p>ClusterIP：虚拟的服务IP地址，该地址用于Kubernetes集群内部的Pod访问，在Node上kube-proxy通过设置的iptables规则进行转发；</p><p>NodePort：使用宿主机的端口，使能够访问各Node的外部客户端通过Node的IP地址和端口号就能访问服务；</p><p>LoadBalancer：使用外接负载均衡器完成到服务的负载分发，需要在spec.status.loadBalancer字段指定外部负载均衡器的IP地址，通常用于公有云。</p><h2 id="30、简述Kubernetes-Service分发后端的策略"><a href="#30、简述Kubernetes-Service分发后端的策略" class="headerlink" title="30、简述Kubernetes Service分发后端的策略?"></a>30、简述Kubernetes Service分发后端的策略?</h2><p>Service负载分发的策略有：RoundRobin和SessionAffinity</p><p>RoundRobin：默认为轮询模式，即轮询将请求转发到后端的各个Pod上。</p><p>SessionAffinity：基于客户端IP地址进行会话保持的模式，即第1次将某个客户端发起的请求转发到后端的某个Pod上，之后从相同的客户端发起的请求都将被转发到后端相同的Pod上。</p><h2 id="31、简述Kubernetes-Headless-Service"><a href="#31、简述Kubernetes-Headless-Service" class="headerlink" title="31、简述Kubernetes Headless Service?"></a>31、简述Kubernetes Headless Service?</h2><p>在某些应用场景中，若需要人为指定负载均衡器，不使用Service提供的默认负载均衡的功能，或者应用程序希望知道属于同组服务的其他实例。Kubernetes提供了Headless Service来实现这种功能，即不为Service设置ClusterIP（入口IP地址），仅通过Label Selector将后端的Pod列表返回给调用的客户端。</p><h2 id="32、简述Kubernetes外部如何访问集群内的服务"><a href="#32、简述Kubernetes外部如何访问集群内的服务" class="headerlink" title="32、简述Kubernetes外部如何访问集群内的服务?"></a>32、简述Kubernetes外部如何访问集群内的服务?</h2><p>对于Kubernetes，集群外的客户端默认情况，无法通过Pod的IP地址或者Service的虚拟IP地址:虚拟端口号进行访问。通常可以通过以下方式进行访问Kubernetes集群内的服务：</p><p>映射Pod到物理机：将Pod端口号映射到宿主机，即在Pod中采用hostPort方式，以使客户端应用能够通过物理机访问容器应用。</p><p>映射Service到物理机：将Service端口号映射到宿主机，即在Service中采用nodePort方式，以使客户端应用能够通过物理机访问容器应用。</p><p>映射Sercie到LoadBalancer：通过设置LoadBalancer映射到云服务商提供的LoadBalancer地址。这种用法仅用于在公有云服务提供商的云平台上设置Service的场景。</p><h2 id="33、简述Kubernetes-ingress"><a href="#33、简述Kubernetes-ingress" class="headerlink" title="33、简述Kubernetes ingress?"></a>33、简述Kubernetes ingress?</h2><p>Kubernetes的Ingress资源对象，用于将不同URL的访问请求转发到后端不同的Service，以实现HTTP层的业务路由机制。</p><p>Kubernetes使用了Ingress策略和Ingress Controller，两者结合并实现了一个完整的Ingress负载均衡器。使用Ingress进行负载分发时，Ingress Controller基于Ingress规则将客户端请求直接转发到Service对应的后端Endpoint（Pod）上，从而跳过kube-proxy的转发功能，kube-proxy不再起作用，全过程为：ingress controller + ingress 规则 —-&gt; services。</p><p>同时当Ingress Controller提供的是对外服务，则实际上实现的是边缘路由器的功能。</p><h2 id="34、简述Kubernetes镜像的下载策略"><a href="#34、简述Kubernetes镜像的下载策略" class="headerlink" title="34、简述Kubernetes镜像的下载策略?"></a>34、简述Kubernetes镜像的下载策略?</h2><p>K8s的镜像下载策略有三种：Always、Never、IFNotPresent。</p><p>Always：镜像标签为latest时，总是从指定的仓库中获取镜像。</p><p>Never：禁止从仓库中下载镜像，也就是说只能使用本地镜像。</p><p>IfNotPresent：仅当本地没有对应镜像时，才从目标仓库中下载。默认的镜像下载策略是：当镜像标签是latest时，默认策略是Always；当镜像标签是自定义时（也就是标签不是latest），那么默认策略是IfNotPresent。</p><h2 id="35、简述Kubernetes的负载均衡器"><a href="#35、简述Kubernetes的负载均衡器" class="headerlink" title="35、简述Kubernetes的负载均衡器?"></a>35、简述Kubernetes的负载均衡器?</h2><p>负载均衡器是暴露服务的最常见和标准方式之一。</p><p>根据工作环境使用两种类型的负载均衡器，即内部负载均衡器或外部负载均衡器。内部负载均衡器自动平衡负载并使用所需配置分配容器，而外部负载均衡器将流量从外部负载引导至后端容器。负载均衡器是暴露服务的最常见和标准方式之一。</p><p>根据工作环境使用两种类型的负载均衡器，即内部负载均衡器或外部负载均衡器。内部负载均衡器自动平衡负载并使用所需配置分配容器，而外部负载均衡器将流量从外部负载引导至后端容器。</p><h2 id="36、简述Kubernetes各模块如何与API-Server通信"><a href="#36、简述Kubernetes各模块如何与API-Server通信" class="headerlink" title="36、简述Kubernetes各模块如何与API Server通信?"></a>36、简述Kubernetes各模块如何与API Server通信?</h2><p>Kubernetes API Server作为集群的核心，负责集群各功能模块之间的通信。集群内的各个功能模块通过API Server将信息存入etcd，当需要获取和操作这些数据时，则通过API Server提供的REST接口（用GET、LIST或WATCH方法）来实现，从而实现各模块之间的信息交互。</p><p>如kubelet进程与API Server的交互：每个Node上的kubelet每隔一个时间周期，就会调用一次API Server的REST接口报告自身状态，API Server在接收到这些信息后，会将节点状态信息更新到etcd中。</p><p>如kube-controller-manager进程与API Server的交互：kube-controller-manager中的Node Controller模块通过API Server提供的Watch接口实时监控Node的信息，并做相应处理。</p><p>如kube-scheduler进程与API Server的交互：Scheduler通过API Server的Watch接口监听到新建Pod副本的信息后，会检索所有符合该Pod要求的Node列表，开始执行Pod调度逻辑，在调度成功后将Pod绑定到目标节点上。</p><h2 id="37、简述Kubernetes-Scheduler作用及实现原理"><a href="#37、简述Kubernetes-Scheduler作用及实现原理" class="headerlink" title="37、简述Kubernetes Scheduler作用及实现原理?"></a>37、简述Kubernetes Scheduler作用及实现原理?</h2><p>Kubernetes Scheduler是负责Pod调度的重要功能模块，Kubernetes Scheduler在整个系统中承担了“承上启下”的重要功能，“承上”是指它负责接收Controller Manager创建的新Pod，为其调度至目标Node；“启下”是指调度完成后，目标Node上的kubelet服务进程接管后继工作，负责Pod接下来生命周期。</p><p>Kubernetes Scheduler的作用是将待调度的Pod（API新创建的Pod、Controller Manager为补足副本而创建的Pod等）按照特定的调度算法和调度策略绑定（Binding）到集群中某个合适的Node上，并将绑定信息写入etcd中。</p><p>在整个调度过程中涉及三个对象，分别是待调度Pod列表、可用Node列表，以及调度算法和策略。</p><p>Kubernetes Scheduler通过调度算法调度为待调度Pod列表中的每个Pod从Node列表中选择一个最适合的Node来实现Pod的调度。随后，目标节点上的kubelet通过API Server监听到Kubernetes Scheduler产生的Pod绑定事件，然后获取对应的Pod清单，下载Image镜像并启动容器。</p><h2 id="38、简述Kubernetes-Scheduler使用哪两种算法将Pod绑定到worker节点"><a href="#38、简述Kubernetes-Scheduler使用哪两种算法将Pod绑定到worker节点" class="headerlink" title="38、简述Kubernetes Scheduler使用哪两种算法将Pod绑定到worker节点?"></a>38、简述Kubernetes Scheduler使用哪两种算法将Pod绑定到worker节点?</h2><p>预选（Predicates）：输入是所有节点，输出是满足预选条件的节点。kube-scheduler根据预选策略过滤掉不满足策略的Nodes。如果某节点的资源不足或者不满足预选策略的条件则无法通过预选。如“Node的label必须与Pod的Selector一致”。</p><p>优选（Priorities）：输入是预选阶段筛选出的节点，优选会根据优先策略为通过预选的Nodes进行打分排名，选择得分最高的Node。例如，资源越富裕、负载越小的Node可能具有越高的排名。</p><h2 id="39、简述Kubernetes-kubelet的作用"><a href="#39、简述Kubernetes-kubelet的作用" class="headerlink" title="39、简述Kubernetes kubelet的作用?"></a>39、简述Kubernetes kubelet的作用?</h2><p>在Kubernetes集群中，在每个Node（又称Worker）上都会启动一个kubelet服务进程。该进程用于处理Master下发到本节点的任务，管理Pod及Pod中的容器。每个kubelet进程都会在API Server上注册节点自身的信息，定期向Master汇报节点资源的使用情况，并通过cAdvisor监控容器和节点资源。</p><h2 id="40、简述Kubernetes-kubelet监控Worker节点资源是使用什么组件来实现的"><a href="#40、简述Kubernetes-kubelet监控Worker节点资源是使用什么组件来实现的" class="headerlink" title="40、简述Kubernetes kubelet监控Worker节点资源是使用什么组件来实现的?"></a>40、简述Kubernetes kubelet监控Worker节点资源是使用什么组件来实现的?</h2><p>kubelet使用cAdvisor对worker节点资源进行监控。在 Kubernetes 系统中，cAdvisor 已被默认集成到 kubelet 组件内，当 kubelet 服务启动时，它会自动启动 cAdvisor 服务，然后 cAdvisor 会实时采集所在节点的性能指标及在节点上运行的容器的性能指标。</p><h2 id="41、简述Kubernetes如何保证集群的安全性"><a href="#41、简述Kubernetes如何保证集群的安全性" class="headerlink" title="41、简述Kubernetes如何保证集群的安全性?"></a>41、简述Kubernetes如何保证集群的安全性?</h2><ul><li>最小权限原则</li><li>用户权限：划分普通用户和管理员的角色</li><li>API Server的认证授权</li><li>API Server的授权管理</li><li>敏感数据引入Secret机制</li><li>AdmissionControl（准入机制）</li></ul><h2 id="42、简述Kubernetes准入机制"><a href="#42、简述Kubernetes准入机制" class="headerlink" title="42、简述Kubernetes准入机制?"></a>42、简述Kubernetes准入机制?</h2><table><thead><tr><th>Kubernetes准入机制</th><th>描述</th></tr></thead><tbody><tr><td>准入控制插件</td><td></td></tr><tr><td>- AlwaysAdmit</td><td>总是通过请求，不执行检查。</td></tr><tr><td>- AlwaysDeny</td><td>总是拒绝请求，不执行检查。</td></tr><tr><td>- NamespaceLifecycle</td><td>确保命名空间存在，并根据策略允许或拒绝创建。</td></tr><tr><td>- ResourceQuota</td><td>实施资源配额，限制在命名空间内的资源使用。</td></tr><tr><td>- PodSecurityPolicy</td><td>强制执行容器安全策略。</td></tr><tr><td>- ServiceAccount</td><td>确保Pod使用有效的ServiceAccount。</td></tr><tr><td>Webhook准入控制</td><td></td></tr><tr><td>- Webhook机制</td><td>将自定义的准入控制插件集成到API服务器中。</td></tr><tr><td>动态准入控制配置</td><td></td></tr><tr><td>- 动态配置</td><td>在Kubernetes 1.9版本及以上，引入了动态准入控制配置，管理员可以动态配置准入控制插件。</td></tr><tr><td>Mutating和Validating准入控制</td><td></td></tr><tr><td>- MutatingAdmissionWebhook</td><td>在资源被持久化之前对其进行修改。例如，可以动态地注入sidecar容器。</td></tr><tr><td>- ValidatingAdmissionWebhook</td><td>对资源进行验证，确保其符合特定规则。例如，可以强制执行命名约定或其他策略。</td></tr><tr><td>默认准入控制配置</td><td></td></tr><tr><td>- 启用&#x2F;禁用默认插件</td><td>集群管理员可以通过启用或禁用默认的准入控制插件来调整系统的默认行为。</td></tr></tbody></table><h2 id="43、简述Kubernetes-RBAC及其特点（优势）"><a href="#43、简述Kubernetes-RBAC及其特点（优势）" class="headerlink" title="43、简述Kubernetes RBAC及其特点（优势）?"></a>43、简述Kubernetes RBAC及其特点（优势）?</h2><ul><li><p>对集群中的资源和非资源权限均有完整的覆盖。  </p></li><li><p>整个RBAC完全由几个API对象完成， 同其他API对象一样， 可以用kubectl或API进行操作。  </p></li><li><p>可以在运行时进行调整，无须重新启动API Server。</p></li></ul><h2 id="44、简述Kubernetes-Secret作用"><a href="#44、简述Kubernetes-Secret作用" class="headerlink" title="44、简述Kubernetes Secret作用?"></a>44、简述Kubernetes Secret作用?</h2><p>Secret对象，主要作用是保管私密数据，比如密码、OAuth Tokens、SSH Keys等信息。将这些私密信息放在Secret对象中比直接放在Pod或Docker Image中更安全，也更便于使用和分发。</p><h2 id="45、简述Kubernetes-Secret有哪些使用方式"><a href="#45、简述Kubernetes-Secret有哪些使用方式" class="headerlink" title="45、简述Kubernetes Secret有哪些使用方式?"></a>45、简述Kubernetes Secret有哪些使用方式?</h2><p>在创建Pod时，通过为Pod指定Service Account来自动使用该Secret。</p><p>通过挂载该Secret到Pod来使用它。</p><p>在Docker镜像下载时使用，通过指定Pod的spc.ImagePullSecrets来引用它。</p><h2 id="46、简述Kubernetes-PodSecurityPolicy机制"><a href="#46、简述Kubernetes-PodSecurityPolicy机制" class="headerlink" title="46、简述Kubernetes PodSecurityPolicy机制?"></a>46、简述Kubernetes PodSecurityPolicy机制?</h2><p>Kubernetes PodSecurityPolicy是为了更精细地控制Pod对资源的使用方式以及提升安全策略。在开启PodSecurityPolicy准入控制器后，Kubernetes默认不允许创建任何Pod，需要创建PodSecurityPolicy策略和相应的RBAC授权策略（Authorizing Policies），Pod才能创建成功。</p><h2 id="47、简述Kubernetes-PodSecurityPolicy机制能实现哪些安全策略"><a href="#47、简述Kubernetes-PodSecurityPolicy机制能实现哪些安全策略" class="headerlink" title="47、简述Kubernetes PodSecurityPolicy机制能实现哪些安全策略?"></a>47、简述Kubernetes PodSecurityPolicy机制能实现哪些安全策略?</h2><ul><li><p>特权模式：privileged是否允许Pod以特权模式运行。  </p></li><li><p>宿主机资源：控制Pod对宿主机资源的控制，如hostPID：是否允许Pod共享宿主机的进程空间。  </p></li><li><p>用户和组：设置运行容器的用户ID（范围）或组（范围）。  </p></li><li><p>提升权限：AllowPrivilegeEscalation：设置容器内的子进程是否可以提升权限，通常在设置非root用户（MustRunAsNonRoot）时进行设置。  </p></li><li><p>SELinux：进行SELinux的相关配置。</p></li></ul><h2 id="48、简述Kubernetes网络模型"><a href="#48、简述Kubernetes网络模型" class="headerlink" title="48、简述Kubernetes网络模型?"></a>48、简述Kubernetes网络模型?</h2><p>Kubernetes网络模型中每个Pod都拥有一个独立的IP地址，并假定所有Pod都在一个可以直接连通的、扁平的网络空间中。所以不管它们是否运行在同一个Node（宿主机）中，都要求它们可以直接通过对方的IP进行访问。设计这个原则的原因是，用户不需要额外考虑如何建立Pod之间的连接，也不需要考虑如何将容器端口映射到主机端口等问题。</p><p>同时为每个Pod都设置一个IP地址的模型使得同一个Pod内的不同容器会共享同一个网络命名空间，也就是同一个Linux网络协议栈。这就意味着同一个Pod内的容器可以通过localhost来连接对方的端口。</p><p>在Kubernetes的集群里，IP是以Pod为单位进行分配的。一个Pod内部的所有容器共享一个网络堆栈（相当于一个网络命名空间，它们的IP地址、网络设备、配置等都是共享的）。</p><h2 id="49、简述Kubernetes-CNI模型"><a href="#49、简述Kubernetes-CNI模型" class="headerlink" title="49、简述Kubernetes CNI模型?"></a>49、简述Kubernetes CNI模型?</h2><p>CNI提供了一种应用容器的插件化网络解决方案，定义对容器网络进行操作和配置的规范，通过插件的形式对CNI接口进行实现。CNI仅关注在创建容器时分配网络资源，和在销毁容器时删除网络资源。在CNI模型中只涉及两个概念：容器和网络。</p><p>容器（Container）：是拥有独立Linux网络命名空间的环境，例如使用Docker或rkt创建的容器。容器需要拥有自己的Linux网络命名空间，这是加入网络的必要条件。</p><p>网络（Network）：表示可以互连的一组实体，这些实体拥有各自独立、唯一的IP地址，可以是容器、物理机或者其他网络设备（比如路由器）等。</p><p>对容器网络的设置和操作都通过插件（Plugin）进行具体实现，CNI插件包括两种类型：CNI Plugin和IPAM（IP Address Management）Plugin。CNI Plugin负责为容器配置网络资源，IPAM Plugin负责对容器的IP地址进行分配和管理。IPAM Plugin作为CNI Plugin的一部分，与CNI Plugin协同工作。</p><h2 id="50、简述Kubernetes网络策略"><a href="#50、简述Kubernetes网络策略" class="headerlink" title="50、简述Kubernetes网络策略?"></a>50、简述Kubernetes网络策略?</h2><p>Network Policy的主要功能是对Pod间的网络通信进行限制和准入控制，设置允许访问或禁止访问的客户端Pod列表。Network Policy定义网络策略，配合策略控制器（Policy Controller）进行策略的实现。</p><h2 id="51、简述Kubernetes网络策略原理"><a href="#51、简述Kubernetes网络策略原理" class="headerlink" title="51、简述Kubernetes网络策略原理?"></a>51、简述Kubernetes网络策略原理?</h2><p>Network Policy的工作原理主要为：policy controller需要实现一个API Listener，监听用户设置的Network Policy定义，并将网络访问规则通过各Node的Agent进行实际设置（Agent则需要通过CNI网络插件实现）。</p><h2 id="52、简述Kubernetes中flannel的作用"><a href="#52、简述Kubernetes中flannel的作用" class="headerlink" title="52、简述Kubernetes中flannel的作用?"></a>52、简述Kubernetes中flannel的作用?</h2><p>它能协助Kubernetes，给每一个Node上的Docker容器都分配互相不冲突的IP地址。</p><p>它能在这些IP地址之间建立一个覆盖网络（Overlay Network），通过这个覆盖网络，将数据包原封不动地传递到目标容器内。</p><h2 id="53、简述Kubernetes-Calico网络组件实现原理"><a href="#53、简述Kubernetes-Calico网络组件实现原理" class="headerlink" title="53、简述Kubernetes Calico网络组件实现原理?"></a>53、简述Kubernetes Calico网络组件实现原理?</h2><p>Calico是一个基于BGP的纯三层的网络方案 Calico在每个计算节点都利用Linux Kernel实现了一个高效的vRouter来负责数据转发。每个vRouter都通过BGP协议把在本节点上运行的容器的路由信息向整个Calico网络广播，并自动设置到达其他节点的路由转发规则。</p><p>Calico保证所有容器之间的数据流量都是通过IP路由的方式完成互联互通的。Calico节点组网时可以直接利用数据中心的网络结构（L2或者L3），不需要额外的NAT、隧道或者Overlay Network，没有额外的封包解包，能够节约CPU运算，提高网络效率。</p><h2 id="54、简述Kubernetes共享存储的作用"><a href="#54、简述Kubernetes共享存储的作用" class="headerlink" title="54、简述Kubernetes共享存储的作用?"></a>54、简述Kubernetes共享存储的作用?</h2><p>Kubernetes对于有状态的容器应用或者对数据需要持久化的应用，因此需要更加可靠的存储来保存应用产生的重要数据，以便容器应用在重建之后仍然可以使用之前的数据。因此需要使用共享存储。</p><h2 id="55、简述Kubernetes数据持久化的方式有哪些"><a href="#55、简述Kubernetes数据持久化的方式有哪些" class="headerlink" title="55、简述Kubernetes数据持久化的方式有哪些?"></a>55、简述Kubernetes数据持久化的方式有哪些?</h2><p>EmptyDir（空目录）：没有指定要挂载宿主机上的某个目录，直接由Pod内保部映射到宿主机上。类似于docker中的manager volume。只需要临时将数据保存在磁盘上，比如在合并&#x2F;排序算法中；作为两个容器的共享存储。同个pod里面的不同容器，共享同一个持久化目录，当pod节点删除时，volume的数据也会被删除。 Hostpath：将宿主机上已存在的目录或文件挂载到容器内部。类似于docker中的bind mount挂载方式 PersistentVolume（简称PV）：如基于NFS服务的PV，也可以基于GFS的PV。它的作用是统一数据持久化目录，方便管理。</p><h2 id="56、简述Kubernetes-PV和PVC"><a href="#56、简述Kubernetes-PV和PVC" class="headerlink" title="56、简述Kubernetes PV和PVC?"></a>56、简述Kubernetes PV和PVC?</h2><p>PV是对底层网络共享存储的抽象，将共享存储定义为一种“资源”。</p><p>PVC则是用户对存储资源的一个“申请”。</p><h2 id="57、简述Kubernetes-PV生命周期内的阶段"><a href="#57、简述Kubernetes-PV生命周期内的阶段" class="headerlink" title="57、简述Kubernetes PV生命周期内的阶段?"></a>57、简述Kubernetes PV生命周期内的阶段?</h2><ul><li>Available：可用状态，还未与某个PVC绑定。</li><li>Bound：已与某个PVC绑定。</li><li>Released：绑定的PVC已经删除，资源已释放，但没有被集群回收。</li><li>Failed：自动资源回收失败。</li></ul><h2 id="58、简述Kubernetes所支持的存储供应模式"><a href="#58、简述Kubernetes所支持的存储供应模式" class="headerlink" title="58、简述Kubernetes所支持的存储供应模式?"></a>58、简述Kubernetes所支持的存储供应模式?</h2><p>Kubernetes支持两种资源的存储供应模式：静态模式（Static）和动态模式（Dynamic）。</p><p>静态模式：集群管理员手工创建许多PV，在定义PV时需要将后端存储的特性进行设置。</p><p>动态模式：集群管理员无须手工创建PV，而是通过StorageClass的设置对后端存储进行描述，标记为某种类型。此时要求PVC对存储的类型进行声明，系统将自动完成PV的创建及与PVC的绑定。</p><h2 id="59、简述Kubernetes-CSI模型"><a href="#59、简述Kubernetes-CSI模型" class="headerlink" title="59、简述Kubernetes CSI模型?"></a>59、简述Kubernetes CSI模型?</h2><p>Kubernetes CSI是Kubernetes推出与容器对接的存储接口标准，存储提供方只需要基于标准接口进行存储插件的实现，就能使用Kubernetes的原生存储机制为容器提供存储服务。CSI使得存储提供方的代码能和Kubernetes代码彻底解耦，部署也与Kubernetes核心组件分离，显然，存储插件的开发由提供方自行维护，就能为Kubernetes用户提供更多的存储功能，也更加安全可靠。</p><p>CSI包括CSI Controller和CSI Node：</p><p>CSI Controller的主要功能是提供存储服务视角对存储资源和存储卷进行管理和操作。</p><p>CSI Node的主要功能是对主机（Node）上的Volume进行管理和操作。</p><h2 id="60、简述Kubernetes-Worker节点加入集群的过程"><a href="#60、简述Kubernetes-Worker节点加入集群的过程" class="headerlink" title="60、简述Kubernetes Worker节点加入集群的过程?"></a>60、简述Kubernetes Worker节点加入集群的过程?</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、在该Node上安装Docker、kubelet和kube-proxy服务；</span><br><span class="line"></span><br><span class="line">2、然后配置kubelet和kubeproxy的启动参数，将Master URL指定为当前Kubernetes集群Master的地址，最后启动这些服务；</span><br><span class="line"></span><br><span class="line">3、通过kubelet默认的自动注册机制，新的Worker将会自动加入现有的Kubernetes集群中；</span><br><span class="line"></span><br><span class="line">4、Kubernetes Master在接受了新Worker的注册之后，会自动将其纳入当前集群的调度范围。</span><br></pre></td></tr></table></figure><h2 id="61、简述Kubernetes-Pod如何实现对节点的资源控制"><a href="#61、简述Kubernetes-Pod如何实现对节点的资源控制" class="headerlink" title="61、简述Kubernetes Pod如何实现对节点的资源控制?"></a>61、简述Kubernetes Pod如何实现对节点的资源控制?</h2><p>Kubernetes集群里的节点提供的资源主要是计算资源，计算资源是可计量的能被申请、分配和使用的基础资源。当前Kubernetes集群中的计算资源主要包括CPU、GPU及Memory。CPU与Memory是被Pod使用的，因此在配置Pod时可以通过参数CPU Request及Memory Request为其中的每个容器指定所需使用的CPU与Memory量，Kubernetes会根据Request的值去查找有足够资源的Node来调度此Pod。</p><p>通常，一个程序所使用的CPU与Memory是一个动态的量，确切地说，是一个范围，跟它的负载密切相关：负载增加时，CPU和Memory的使用量也会增加。</p><h2 id="62、简述Kubernetes-Requests和Limits如何影响Pod的调度"><a href="#62、简述Kubernetes-Requests和Limits如何影响Pod的调度" class="headerlink" title="62、简述Kubernetes Requests和Limits如何影响Pod的调度?"></a>62、简述Kubernetes Requests和Limits如何影响Pod的调度?</h2><p>当一个Pod创建成功时，Kubernetes调度器（Scheduler）会为该Pod选择一个节点来执行。对于每种计算资源（CPU和Memory）而言，每个节点都有一个能用于运行Pod的最大容量值。调度器在调度时，首先要确保调度后该节点上所有Pod的CPU和内存的Requests总和，不超过该节点能提供给Pod使用的CPU和Memory的最大容量值。</p><h2 id="63、简述Kubernetes-Metric-Service"><a href="#63、简述Kubernetes-Metric-Service" class="headerlink" title="63、简述Kubernetes Metric Service?"></a>63、简述Kubernetes Metric Service?</h2><p>在Kubernetes从1.10版本后采用Metrics Server作为默认的性能数据采集和监控，主要用于提供核心指标（Core Metrics），包括Node、Pod的CPU和内存使用指标。</p><p>对其他自定义指标（Custom Metrics）的监控则由Prometheus等组件来完成。</p><h2 id="64、简述Kubernetes中，如何使用EFK实现日志的统一管理"><a href="#64、简述Kubernetes中，如何使用EFK实现日志的统一管理" class="headerlink" title="64、简述Kubernetes中，如何使用EFK实现日志的统一管理"></a>64、简述Kubernetes中，如何使用EFK实现日志的统一管理</h2><p>在Kubernetes集群环境中，通常一个完整的应用或服务涉及组件过多，建议对日志系统进行集中化管理，通常采用EFK实现。</p><p>EFK是 Elasticsearch、Fluentd 和 Kibana 的组合，其各组件功能如下：</p><p>Elasticsearch：是一个搜索引擎，负责存储日志并提供查询接口；</p><p>Fluentd：负责从 Kubernetes 搜集日志，每个node节点上面的fluentd监控并收集该节点上面的系统日志，并将处理过后的日志信息发送给Elasticsearch；</p><p>Kibana：提供了一个 Web GUI，用户可以浏览和搜索存储在 Elasticsearch 中的日志。</p><p>通过在每台node上部署一个以DaemonSet方式运行的fluentd来收集每台node上的日志。Fluentd将docker日志目录&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers和&#x2F;var&#x2F;log目录挂载到Pod中，然后Pod会在node节点的&#x2F;var&#x2F;log&#x2F;pods目录中创建新的目录，可以区别不同的容器日志输出，该目录下有一个日志文件链接到&#x2F;var&#x2F;lib&#x2F;docker&#x2F;contianers目录下的容器日志输出。</p><h2 id="65、简述Kubernetes如何进行优雅的节点关机维护"><a href="#65、简述Kubernetes如何进行优雅的节点关机维护" class="headerlink" title="65、简述Kubernetes如何进行优雅的节点关机维护?"></a>65、简述Kubernetes如何进行优雅的节点关机维护?</h2><p>由于Kubernetes节点运行大量Pod，因此在进行关机维护之前，建议先使用kubectl drain将该节点的Pod进行驱逐，然后进行关机维护。</p><h2 id="66、简述Kubernetes集群联邦"><a href="#66、简述Kubernetes集群联邦" class="headerlink" title="66、简述Kubernetes集群联邦?"></a>66、简述Kubernetes集群联邦?</h2><p>Kubernetes集群联邦可以将多个Kubernetes集群作为一个集群进行管理。因此，可以在一个数据中心&#x2F;云中创建多个Kubernetes集群，并使用集群联邦在一个地方控制&#x2F;管理所有集群。</p><h2 id="67、简述Helm及其优势"><a href="#67、简述Helm及其优势" class="headerlink" title="67、简述Helm及其优势?"></a>67、简述Helm及其优势?</h2><table><thead><tr><th>Helm及其优势</th><th>描述</th></tr></thead><tbody><tr><td>什么是Helm</td><td>Helm是一个用于简化Kubernetes应用程序部署、更新和管理的包管理工具。</td></tr><tr><td>Chart</td><td>Helm使用Chart来定义、安装和升级Kubernetes应用程序。Chart是一个包含了所有部署Kubernetes应用所需信息的打包文件。</td></tr><tr><td>优势</td><td></td></tr><tr><td>- 模板引擎</td><td>Helm使用Go语言的模板引擎，允许用户动态生成Kubernetes资源配置，实现配置的可重用性和参数化。</td></tr><tr><td>- 版本控制</td><td>Helm允许用户版本控制Chart，轻松管理不同应用程序版本的发布和回滚。</td></tr><tr><td>- 包管理</td><td>通过Helm，用户可以轻松共享和重用应用程序定义，避免重复劳动。</td></tr><tr><td>- 依赖管理</td><td>Helm支持定义Chart之间的依赖关系，简化了多组件应用程序的部署。</td></tr><tr><td>- 社区支持</td><td>Helm拥有活跃的社区，用户可以从社区中获取Chart，共享经验和解决问题。</td></tr><tr><td>- 插件系统</td><td>Helm提供插件系统，允许用户扩展其功能，满足特定需求。</td></tr><tr><td>- 安全发布</td><td>Helm允许用户将应用程序作为一个整体发布，确保一致性和可重复性。</td></tr><tr><td>- Charts存储库</td><td>用户可以配置Charts存储库，从中获取和发布Charts，便于管理和分发。</td></tr><tr><td>- 自定义配置值</td><td>Helm允许通过values文件自定义Chart的配置，提高了可配置性和灵活性。</td></tr></tbody></table><h2 id="69、容器和主机部署应用的区别是什么"><a href="#69、容器和主机部署应用的区别是什么" class="headerlink" title="69、容器和主机部署应用的区别是什么?"></a>69、容器和主机部署应用的区别是什么?</h2><p>容器的中心思想就是秒级启动；一次封装、到处运行 容器部署可以将各个服务进行隔离，互不影响</p><h2 id="70、请你说一下kubenetes针对pod资源对象的健康监测机制"><a href="#70、请你说一下kubenetes针对pod资源对象的健康监测机制" class="headerlink" title="70、请你说一下kubenetes针对pod资源对象的健康监测机制?"></a>70、请你说一下kubenetes针对pod资源对象的健康监测机制?</h2><ul><li>livenessProbe</li><li>readinessProbe</li><li>startupProbe</li></ul><h2 id="71、如何控制滚动更新过程"><a href="#71、如何控制滚动更新过程" class="headerlink" title="71、如何控制滚动更新过程?"></a>71、如何控制滚动更新过程?</h2><p>maxSurge：　此参数控制滚动更新过程，副本总数超过预期pod数量的上限。可以是百分比，也可以是具体的值。默认为1。</p><p>（上述参数的作用就是在更新过程中，值若为3，那么不管三七二一，先运行三个pod，用于替换旧的pod，以此类推）</p><p>maxUnavailable： 此参数控制滚动更新过程中，不可用的Pod的数量。</p><p>（这个值和上面的值没有任何关系，举个例子：我有十个pod，但是在更新的过程中，我允许这十个pod中最多有三个不可用，那么就将这个参数的值设置为3，在更新的过程中，只要不可用的pod数量小于或等于3，那么更新过程就不会停止）。</p><h2 id="75、Service这种资源对象的作用是什么"><a href="#75、Service这种资源对象的作用是什么" class="headerlink" title="75、Service这种资源对象的作用是什么?"></a>75、Service这种资源对象的作用是什么?</h2><p>用来给相同的多个pod对象提供一个固定的统一访问接口，常用于服务发现和服务访问。</p><h2 id="76、版本回滚相关的命令"><a href="#76、版本回滚相关的命令" class="headerlink" title="76、版本回滚相关的命令?"></a>76、版本回滚相关的命令?</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>kubectl rollout history deployment&#x2F;<deployment-name></td><td>查看滚动升级历史记录</td></tr><tr><td>kubectl rollout history deployment&#x2F;<deployment-name> –revision&#x3D;<revision-number></td><td>查看特定版本的详细信息</td></tr><tr><td>kubectl rollout undo deployment&#x2F;<deployment-name></td><td>回滚到上一个版本</td></tr><tr><td>kubectl rollout undo deployment&#x2F;<deployment-name> –to-revision&#x3D;<revision-number></td><td>回滚到特定版本</td></tr></tbody></table><h2 id="77、标签与标签选择器的作用是什么"><a href="#77、标签与标签选择器的作用是什么" class="headerlink" title="77、标签与标签选择器的作用是什么?"></a>77、标签与标签选择器的作用是什么?</h2><table><thead><tr><th>名词</th><th>描述</th></tr></thead><tbody><tr><td>标签（Label）</td><td>标签是键值对，用于附加元数据到Kubernetes资源对象（如Pod、Service、Node等）。</td></tr><tr><td>标签选择器（Label Selector）</td><td>标签选择器用于选择带有特定标签的资源对象，以便进行筛选和操作。</td></tr><tr><td>作用</td><td>通过标签，可以对资源对象进行分类、组织和识别，提供更灵活的资源管理和调度方式。</td></tr><tr><td></td><td>标签选择器允许用户根据标签的键值对对资源进行查询和选择，用于实现有选择性的操作。</td></tr><tr><td>示例</td><td>一个Pod可以有标签app&#x3D;web，允许使用标签选择器选择所有具有该标签的Pod进行管理。</td></tr><tr><td></td><td>Service可以使用标签选择器将请求路由到具有特定标签的Pod，实现服务发现和负载均衡。</td></tr></tbody></table><h2 id="78、常用的标签分类有哪些"><a href="#78、常用的标签分类有哪些" class="headerlink" title="78、常用的标签分类有哪些?"></a>78、常用的标签分类有哪些?</h2><table><thead><tr><th>类别</th><th>描述</th></tr></thead><tbody><tr><td>环境</td><td>用于区分不同环境，如environment&#x3D;production。</td></tr><tr><td>应用程序</td><td>用于标识属于哪个应用程序，如app&#x3D;web。</td></tr><tr><td>版本</td><td>用于标识应用程序或组件的版本，如version&#x3D;1.2.3。</td></tr><tr><td>部门</td><td>用于区分不同部门的资源，如department&#x3D;finance。</td></tr><tr><td>客户</td><td>用于标识属于哪个客户，如customer&#x3D;companyA。</td></tr><tr><td>组织</td><td>用于标识属于哪个组织，如organization&#x3D;dev-team。</td></tr><tr><td>状态</td><td>用于标识资源的状态，如status&#x3D;ready。</td></tr><tr><td>系统</td><td>用于标识系统级别的资源，如system&#x3D;true。</td></tr></tbody></table><h2 id="79、有几种查看标签的方式"><a href="#79、有几种查看标签的方式" class="headerlink" title="79、有几种查看标签的方式?"></a>79、有几种查看标签的方式?</h2><table><thead><tr><th>方式</th><th>命令&#x2F;操作</th></tr></thead><tbody><tr><td>查看单个资源的标签</td><td>kubectl get &lt;资源类型&gt; &lt;资源名称&gt; -o yaml</td></tr><tr><td>查看所有资源的标签</td><td>kubectl get &lt;资源类型&gt; –show-labels</td></tr><tr><td>查看特定标签的资源</td><td>kubectl get &lt;资源类型&gt; -l &lt;标签选择器&gt;</td></tr><tr><td>查看所有命名空间中的标签</td><td>kubectl get all –all-namespaces –show-labels</td></tr><tr><td>使用kubectl describe查看资源详情</td><td>kubectl describe &lt;资源类型&gt; &lt;资源名称&gt;</td></tr></tbody></table><h2 id="80、添加、修改、删除标签的命令"><a href="#80、添加、修改、删除标签的命令" class="headerlink" title="80、添加、修改、删除标签的命令?"></a>80、添加、修改、删除标签的命令?</h2><table><thead><tr><th>操作</th><th>命令</th><th>示例</th></tr></thead><tbody><tr><td>添加标签</td><td>kubectl label &lt;资源类型&gt; &lt;资源名称&gt; &lt;键&gt;&#x3D;&lt;值&gt;</td><td>kubectl label pod nginx-app app&#x3D;web</td></tr><tr><td>修改标签</td><td>kubectl label –overwrite &lt;资源类型&gt; &lt;资源名称&gt; &lt;键&gt;&#x3D;&lt;新值&gt;</td><td>kubectl label –overwrite pod nginx-app app&#x3D;backend</td></tr><tr><td>删除标签</td><td>kubectl label &lt;资源类型&gt; &lt;资源名称&gt; &lt;键&gt;-</td><td>kubectl label pod nginx-app app-</td></tr></tbody></table><h2 id="82、说说你对Job这种资源对象的了解"><a href="#82、说说你对Job这种资源对象的了解" class="headerlink" title="82、说说你对Job这种资源对象的了解?"></a>82、说说你对Job这种资源对象的了解?</h2><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td>任务类型</td><td>Job主要用于管理一次性任务或批处理任务</td></tr><tr><td>Pod管理</td><td>创建一个或多个Pod，Pod包含执行任务所需的容器</td></tr><tr><td>任务完成策略</td><td>有两种策略，Parallel允许多个Pod并行运行，Complete确保所有Pod成功完成</td></tr><tr><td>重试机制</td><td>支持任务的重试，启动新的Pod替代失败的Pod</td></tr><tr><td>成功条件</td><td>配置成功的条件，如成功运行的Pod数量或成功完成的总任务数</td></tr><tr><td>示例</td><td>一个简单的Job定义包括容器镜像、命令和重试策略</td></tr></tbody></table><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-job</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">example-job-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example-container</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">example-image</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;Hello, Kubernetes!&quot;</span>]</span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="85、删除一个Pod会发生什么事情"><a href="#85、删除一个Pod会发生什么事情" class="headerlink" title="85、删除一个Pod会发生什么事情?"></a>85、删除一个Pod会发生什么事情?</h2><p>答：Kube-apiserver会接受到用户的删除指令，默认有30秒时间等待优雅退出，超过30秒会被标记为死亡状态，此时Pod的状态Terminating，kubelet看到pod标记为Terminating就开始了关闭Pod的工作；</p><p>关闭流程如下：</p><p>pod从service的endpoint列表中被移除； 如果该pod定义了一个停止前的钩子，其会在pod内部被调用，停止钩子一般定义了如何优雅的结束进程； 进程被发送TERM信号（kill -14） 当超过优雅退出的时间后，Pod中的所有进程都会被发送SIGKILL信号（kill -9）。</p><h2 id="87、k8s是怎么进行服务注册的"><a href="#87、k8s是怎么进行服务注册的" class="headerlink" title="87、k8s是怎么进行服务注册的?"></a>87、k8s是怎么进行服务注册的?</h2><p>Pod启动后会加载当前环境所有Service信息，以便不同Pod根据Service名进行通信。</p><h2 id="88、k8s集群外流量怎么访问Pod"><a href="#88、k8s集群外流量怎么访问Pod" class="headerlink" title="88、k8s集群外流量怎么访问Pod?"></a>88、k8s集群外流量怎么访问Pod?</h2><p>可以通过Service的NodePort方式访问，会在所有节点监听同一个端口，比如：30000，访问节点的流量会被重定向到对应的Service上面。</p><h2 id="90、Kubernetes与Docker-Swarm的区别如何"><a href="#90、Kubernetes与Docker-Swarm的区别如何" class="headerlink" title="90、Kubernetes与Docker Swarm的区别如何?"></a>90、Kubernetes与Docker Swarm的区别如何?</h2><p>Kubernetes有助于管理更复杂的软件应用容器；Docker Swarm只能编排简单的Docker容器 支持自动扩缩容；不支持自动扩缩容 滚动更新回滚；滚动更新不能自动回滚 仅能与同一pod的容器共享存储卷；可以和其他任何容器共享存储卷</p><h2 id="94、什么是Container-Orchestration（容器编排）"><a href="#94、什么是Container-Orchestration（容器编排）" class="headerlink" title="94、什么是Container Orchestration（容器编排）?"></a>94、什么是Container Orchestration（容器编排）?</h2><p>意味着各个容器中的所有服务协同工作以满足单个服务器的需求</p><h2 id="95、Container-Orchestration需要什么"><a href="#95、Container-Orchestration需要什么" class="headerlink" title="95、Container Orchestration需要什么?"></a>95、Container Orchestration需要什么?</h2><table><thead><tr><th>组件&#x2F;功能</th><th>描述</th></tr></thead><tbody><tr><td>编排引擎</td><td>管理和调度容器的核心组件，负责实现自动化部署和伸缩</td></tr><tr><td>编排策略</td><td>决定容器如何分布、伸缩和调度的规则和算法</td></tr><tr><td>服务发现</td><td>动态发现和管理容器化应用程序中的服务和网络细节</td></tr><tr><td>负载均衡</td><td>将流量分发到不同的容器实例，确保应用程序高可用性</td></tr><tr><td>自动伸缩</td><td>根据应用程序负载和需求自动调整容器实例数量</td></tr><tr><td>健康检查</td><td>定期检查容器实例的健康状态，以确保高可用性</td></tr><tr><td>日志管理</td><td>收集、存储和管理容器产生的日志信息</td></tr><tr><td>配置管理</td><td>管理应用程序配置的中心化系统，支持动态配置更新</td></tr><tr><td>安全性和权限</td><td>提供容器级别和集群级别的安全性和访问控制</td></tr><tr><td>存储编排</td><td>管理和调度容器中的数据存储，支持持久化和共享存储</td></tr><tr><td>版本控制</td><td>管理应用程序和容器镜像的版本，支持回滚和升级</td></tr><tr><td>跨节点通信</td><td>实现容器之间的通信，跨节点通信保障分布式应用正常运行</td></tr><tr><td>故障恢复</td><td>处理节点故障、容器故障，确保应用程序的高可用性</td></tr></tbody></table><h2 id="97、Kubernetes如何简化容器化部署"><a href="#97、Kubernetes如何简化容器化部署" class="headerlink" title="97、Kubernetes如何简化容器化部署?"></a>97、Kubernetes如何简化容器化部署?</h2><p>由于典型应用程序将具有跨多个主机运行的容器集群，因此所有这些容器都需要相互通信。因此，要做到这一点，你需要一些能够负载平衡，扩展和监控容器的东西。由于Kubernetes与云无关并且可以在任何公共&#x2F;私有提供商上运行，因此必须是您简化容器化部署的选择。</p><h2 id="98、对Kubernetes的集群了解多少？"><a href="#98、对Kubernetes的集群了解多少？" class="headerlink" title="98、对Kubernetes的集群了解多少？"></a>98、对Kubernetes的集群了解多少？</h2><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td>Master节点</td><td>Kubernetes集群的控制中心，负责整个集群的管理和控制。主要组件包括kube-apiserver、kube-controller-manager、kube-scheduler和etcd等。</td></tr><tr><td>Node节点</td><td>集群中的工作节点，负责运行应用程序容器。每个Node节点上都运行有kubelet和kube-proxy，与Master节点协同工作。</td></tr><tr><td>Pod</td><td>Kubernetes中最小的部署单元，包含一个或多个容器。Pod共享网络和存储资源，它们在同一节点上运行，并可以直接通过localhost通信。</td></tr><tr><td>Service</td><td>服务是一种抽象，定义了一组Pod及其访问方式。它确保了Pod的稳定网络标识和动态路由。</td></tr><tr><td>Namespace</td><td>命名空间用于将集群划分为多个虚拟集群，每个命名空间中的资源相互隔离。</td></tr><tr><td>ConfigMap和Secret</td><td>ConfigMap用于将配置数据提供给应用程序，而Secret用于存储敏感信息，如密码和API密钥。</td></tr></tbody></table><h2 id="99、什么是Google容器引擎"><a href="#99、什么是Google容器引擎" class="headerlink" title="99、什么是Google容器引擎?"></a>99、什么是Google容器引擎?</h2><p>Google Container Engine（GKE）是Docker容器和集群的开源管理平台。这个基于Kubernetes的引擎仅支持在Google的公共云服务中运行的群集。</p><h2 id="100、什么是Heapster"><a href="#100、什么是Heapster" class="headerlink" title="100、什么是Heapster?"></a>100、什么是Heapster?</h2><p>Heapster是由每个节点上运行的Kubelet提供的集群范围的数据聚合器。此容器管理工具在Kubernetes集群上本机支持，并作为pod运行，就像集群中的任何其他pod一样。因此，它基本上发现集群中的所有节点，并通过机上Kubernetes代理查询集群中Kubernetes节点的使用信息。</p><h2 id="107、kube-apiserver和kube-scheduler的作用是什么"><a href="#107、kube-apiserver和kube-scheduler的作用是什么" class="headerlink" title="107、kube-apiserver和kube-scheduler的作用是什么?"></a>107、kube-apiserver和kube-scheduler的作用是什么?</h2><p>kube-apiserver遵循横向扩展架构，是主节点控制面板的前端。这将公开Kubernetes主节点组件的所有API，并负责在Kubernetes节点和Kubernetes主组件之间建立通信。 kube-scheduler负责工作节点上工作负载的分配和管理。因此，它根据资源需求选择最合适的节点来运行未调度的pod，并跟踪资源利用率。它确保不在已满的节点上调度工作负载。</p><h2 id="108、你能简要介绍一下Kubernetes控制管理器吗"><a href="#108、你能简要介绍一下Kubernetes控制管理器吗" class="headerlink" title="108、你能简要介绍一下Kubernetes控制管理器吗?"></a>108、你能简要介绍一下Kubernetes控制管理器吗?</h2><p>多个控制器进程在主节点上运行，但是一起编译为单个进程运行，即Kubernetes控制器管理器。因此，Controller Manager是一个嵌入控制器并执行命名空间创建和垃圾收集的守护程序。它拥有责任并与API服务器通信以管理端点。 常见控制器： - node controller - hpa controller - replication controller - service account &amp; token controller - endpoints controller</p><h2 id="112、什么是Ingress网络，它是如何工作的"><a href="#112、什么是Ingress网络，它是如何工作的" class="headerlink" title="112、什么是Ingress网络，它是如何工作的?"></a>112、什么是Ingress网络，它是如何工作的?</h2><p>Ingress网络是一组规则，充当Kubernetes集群的入口点。这允许入站连接，可以将其配置为 通过可访问的URL，负载平衡流量或通过提供基于名称的虚拟主机从外部提供服务。因此， Ingress是一个API对象，通常通过HTTP管理集群中服务的外部访问，是暴露服务的最有效方 式。</p><p>现在，让我以一个例子向您解释Ingress网络的工作。</p><p>有2个节点具有带有Linux桥接器的pod和根网络命名空间。除此之外，还有一个名为 flannel0（网络插件）的新虚拟以太网设备被添加到根网络中。</p><p>现在，假设我们希望数据包从pod1流向pod 4。</p><p>因此，数据包将pod1的网络保留在eth0，并进入veth0的根网络。 然后它被传递给cbr0，这使得ARP请求找到目的地，并且发现该节点上没有人具有目的地IP地址。</p><p>因此，桥接器将数据包发送到flannel0，因为节点的路由表配置了flannel0。 现在，flannel守护程序与Kubernetes的API服务器通信，以了解所有pod IP及其各自的节 点，以创建pods IP到节点IP的映射。</p><p>网络插件将此数据包封装在UDP数据包中，其中额外的标头将源和目标IP更改为各自的节点， 并通过eth0发送此数据包。</p><p>现在，由于路由表已经知道如何在节点之间路由流量，因此它将数据包发送到目标节点2。 数据包到达node2的eth0并返回到flannel0以解封装并在根网络命名空间中将其发回。 同样，数据包被转发到Linux网桥以发出ARP请求以找出属于veth1的IP。 数据包最终穿过根网络并到达目标Pod4。</p><h2 id="113、您对云控制器管理器有何了解"><a href="#113、您对云控制器管理器有何了解" class="headerlink" title="113、您对云控制器管理器有何了解?"></a>113、您对云控制器管理器有何了解?</h2><p>Cloud Controller Manager负责持久存储，网络路由，从核心Kubernetes特定代码中抽象出特定于云的代码，以及管理与底层云服务的通信。它可能会分成几个不同的容器，具体取决于您运行的是哪个云平台，然后它可以使云供应商和Kubernetes代码在没有任何相互依赖的情况下开发。因此，云供应商开发他们的代码并在运行Kubernetes时与Kubernetes云控制器管理器连接。 - node controller - route controller - volume controller - service controller</p><h2 id="114、什么是Container资源监控"><a href="#114、什么是Container资源监控" class="headerlink" title="114、什么是Container资源监控?"></a>114、什么是Container资源监控?</h2><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td>容器资源监控</td><td>监控容器运行时的资源使用情况，包括CPU利用率、内存使用、网络IO等。用于性能分析、故障排查和资源优化。</td></tr><tr><td>监控指标</td><td>常见的容器监控指标包括CPU利用率、内存使用量、磁盘IO、网络IO、容器启动时间等。</td></tr><tr><td>监控工具</td><td>一些常用的容器监控工具包括Prometheus、Grafana、cAdvisor等。它们提供可视化和警报功能，帮助管理员实时监控和管理容器。</td></tr><tr><td>数据收集</td><td>监控工具通过在容器内运行代理或直接访问容器运行时API，收集实时的性能数据。</td></tr><tr><td>可视化和报警</td><td>容器监控工具通常提供仪表盘和报警功能，让管理员能够直观地查看容器集群的状态，并在发生异常时及时收到通知。</td></tr></tbody></table><h2 id="115、Replica-Set和Replication-Controller之间有什么区别"><a href="#115、Replica-Set和Replication-Controller之间有什么区别" class="headerlink" title="115、Replica Set和Replication Controller之间有什么区别?"></a>115、Replica Set和Replication Controller之间有什么区别?</h2><p>Replica Set 和 Replication Controller几乎完全相同。它们都确保在任何给定时间运行指定数量的pod副本。不同之处在于复制pod使用的选择器。Replica Set使用基于集合的选择器，而Replication Controller使用基于权限的选择器。</p><h2 id="117、使用Kubernetes时可以采取哪些最佳安全措施"><a href="#117、使用Kubernetes时可以采取哪些最佳安全措施" class="headerlink" title="117、使用Kubernetes时可以采取哪些最佳安全措施?"></a>117、使用Kubernetes时可以采取哪些最佳安全措施?</h2><ul><li>日志记录生产环境中的所有内容</li><li>定期对环境应用安全更新</li><li>实施网络分割</li><li>为资源制定严格的策略&#x2F;规则</li><li>实施持续安全漏洞扫描</li><li>提供对 k8s 节点的有限直接访问</li><li>定义资源限制</li><li>使用私有镜像仓库</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试100题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-ziplist</title>
      <link href="/library/db/Redis/redis-ziplist/"/>
      <url>/library/db/Redis/redis-ziplist/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis 跳表详解</title>
      <link href="/library/db/Redis/redis-skiplist/"/>
      <url>/library/db/Redis/redis-skiplist/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/library/elementary/network/"/>
      <url>/library/elementary/network/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统八股文</title>
      <link href="/library/elementary/os-eight-part-frame/"/>
      <url>/library/elementary/os-eight-part-frame/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p><strong>并发和并行</strong><br>并发是指<strong>一个处理器</strong>同时处理多个任务。<br>并行是指<strong>多个处理器</strong>或者是多核的处理器同时处理多个不同的任务。<br>并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。</p><p>**并行(parallel)**：指在同一时刻，有多条指令在多个处理器上同时执行。就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。所以无论从微观还是从宏观来看，二者都是一起执行的。</p><p>**并发(concurrency)**：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。这就好像两个人用同一把铁锨，轮流挖坑，一小时后，两个人各挖一个小一点的坑，要想挖两个大一点得坑，一定会用两个小时。</p><p>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。</p><p>操作系统的功能</p><ul><li>进程管理</li><li>内存管理：提高内存利用率和访问速度，从而提高计算机的运行效率</li><li>文件管理</li><li>IO设备管理：设备无关性，将设备抽象成逻辑设备</li></ul><p>分成外核与内核模式的原因：</p><ul><li>保证操作系统受其他系统异常故障的影响；内核模式只能运行操作系统的程序，用户程序运行在外核中；</li><li>确保可能引起系统崩溃的指令（特权指令）只能在内核模式下运行；</li><li>为了防止非法IO，将所有IO指令定义为特权指令</li><li>设置中断，一定时间后将控制权返回给操作系统</li></ul><h6 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a><strong>进程和线程的区别</strong></h6><p>进程，是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位</p><p>在执行一些细小任务时，本身无需分配单独资源时(多个任务共享同一组资源即可，比如所有子进程共享父进程的资源)，进程的实现机制依然会繁琐的将资源分割，这样造成浪费，而且还消耗时间。后来就有了专门的多任务技术被创造出来——线程。</p><p><strong>共同点</strong>：在多任务程序中，子进程(子线程)的调度一般与父进程(父线程)平等竞争。在早期的Linux内核中，线程的实现和管理方式就是<strong>完全按照进程方式实现的</strong>。在2.6版内核以后才有了单独的线程实现。</p><p><strong>实现方法的差异</strong>：进程的个体间是完全独立的，而线程间是彼此依存的。多进程环境中，任何一个进程的终止，不会影响到其他进程。而多线程环境中，父线程终止，全部子线程被迫终止(没有了资源)。而任何一个子线程终止一般不会影响其他线程，除非<strong>子线程执行了exit()系统调用</strong>。任何一个子线程执行exit()，全部线程同时灭亡。</p><ul><li>从系统实现角度讲，进程的实现是调用fork系统调用：pid_t fork(void)；线程的实现是调用clone系统调用</li><li>fork()是将父进程的<strong>全部资源复制给了子进程</strong>。而线程的<strong>clone只是复制了一小部分必要的资源</strong>。后来操作系统还进一步优化fork实现——<strong>写时复制技术</strong>。在子进程需要复制资源(比如子进程执行写入动作更改父进程内存空间)时才复制，否则创建子进程时先不复制。</li><li>个体间辈分关系的迥异；进程的备份关系森严，在父进程没有结束前，所有的子进程都尊从父子关系；多线程间的关系没有那么严格，不管是父线程还是子线程创建了新的线程，都是共享父线程的资源，所以，都可以说是父线程的子线程，也就是只存在一个父线程，其余线程都是父线程的子线程。</li></ul><p><strong>内核态线程、轻量级进程、用户态线程</strong></p><p>它的创建和撤消是由内核的内部需求来决定的，一个内核线程不需要</p><p><strong>内核态线程</strong>：和一个用户进程联系起来。它共享内核的正文段和全局数据，具有自己的内核堆栈。内核线程的调度由于不需要经过态的转换并进行地址空间的重新映射，因此在内核线程间做上下文切换比在进程间做上下文切换快得多。</p><p><strong>轻量级进程</strong>：轻量级进程是核心支持的用户线程，它在一个单独的进程中提供多线程控制。这些轻量级进程被单独的调度，可以在多个处理器上运行，<strong>每一个轻量级进程都被绑定在一个内核线程上</strong>，而且在它的<strong>生命周期</strong>这种绑定都是有效的。轻量级进程被独立调度并且共享地址空间和进程中的其它资源，但是每个LWP都应该有自己的程序计数器、寄存器集合、核心栈和用户栈。</p><p><strong>用户线程</strong>：用户线程是通过线程库实现的。它们可以在没有内核参与下创建、释放和管理。内核对它们一无所知，而只是调度用户线程下的进程或者轻量级进程，这些进程再通过线程库函数来调度它们的线程。当一个进程被抢占时，它的所有用户线程都被抢占，当一个用户线程被阻塞时，它会阻塞下面的轻量级进程，如果进程只有一个轻量级进程，则它的所有用户线程都会被阻塞。</p><p> <strong>注意</strong>：Linux中，每个线程都有一个task_struct，所以线程和进程可以使用同一调度器调度。如果一个task独占所有的资源，则是一个HWP，如果一个task和其它task共享部分资源，则是LWP。<strong>clone</strong>系统调用就是一个<strong>创建轻量级进程</strong>的系统调用，clone的用法和pthread_create有些相似，两者的最根本的差别在于clone是创建一个LWP，对核心是可见的，由核心调度，<strong>而pthread_create通常只是创建一个用户线程</strong>，对核心是不可见的，由线程库调度。</p><p><strong>PCB进程控制模块</strong></p><ul><li>记录进程信息：进程标识信息、处理机状态、进程调度信息、资源分配信息</li><li>操作系统是根据进程控制块PCB来对并发执行的进程进行控制和管理的。</li><li>PCB是进程存在的唯一标志</li><li>寄存器、堆栈指针、程序计数器、进程状态、优先级、调度的参数、父进程、cpu占用时间</li></ul><p><strong>进程和程序的区别</strong></p><p>Program 指令的集合、是静态的概念；是持久的</p><p>Process 描述的是执行，动态的概念、包含程序、数据以及PCB；是暂时的</p><h6 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a><strong>进程之间的通信</strong></h6><ul><li><p>共享内存</p><ul><li>最快的速度进行方便的通信；</li></ul></li><li><p>信息传递</p><ul><li>交换较少的数据；小号时间多</li></ul></li><li><p>间接通信</p><ul><li>每当一个信箱有一个唯一的id</li><li>仅当共享一个信箱时，才能通信</li></ul></li><li><p>共享存储</p><ul><li>两个进程对共享空间的存储是互斥的<ul><li>基于数据结构的：共享速度慢、限制多、是一种低级通信方法</li><li>基于存储区的共享，数据的形式、存放位置都是由进程控制的，是一种高级通信方式</li></ul></li></ul></li><li><p>管道通信</p><ul><li>某个时间只能单行通信，在内存中开辟一个固定大小的缓冲区，但是也是互斥的</li><li>需要将缓冲区写满，缓冲区读满的时候才可以</li><li>数据不可以重复读，所以读进程只能有一个</li></ul></li><li><p>消息传递</p><ul><li>直接通信：将消息挂到对应线程的缓冲队列上，每个进程都会有自己信息缓冲队列，需要设置一些头</li><li>间接通信方式：将信息挂载到中间实体，也被称为“信箱”</li></ul></li></ul><p><strong>线程</strong></p><p>引入的原因</p><ul><li>​    进程操作系统开销大；将进程的两个任务分开：<strong>分配资源</strong>以及<strong>调度</strong>；对于作为调度和分派的基本单位，不同时作为拥有资源的单位，以做到“轻装上阵”； 对于拥有资源的基本单位，又不对之进行频繁的切换。</li><li>因此线程为CPU调度的最小单位，进程为资源分配的最小单位</li></ul><p>线程<strong>不拥有系统资源</strong>，只有其运行所必需的一些数据结构：TCB, a program counter, a register set, and a stack. 它与该进程内其它线程<strong>共享</strong>该进程所拥有的<strong>全部资源</strong>。</p><p><strong>线程和进程的区别</strong></p><ol><li>进程是<strong>资源分配</strong>的基本单位，所有与该进程有关的资源分配情况，进程也是分配主存的基本单位，它拥有一个完整的虚拟地址空间。而线程与资源分配无关，它属于某一个进程，并与该进程内的其它线程一起共享进程的资源。 </li><li>不同的进程拥有不同的虚拟地址空间，而同一进程中的多个线程共享同一地址空间。</li><li>进程调度的切换将涉及到有关资源指针的保存及进程地址空间的转换等问题。而线程的切换将<strong>不涉及资源指针</strong>的保存和地址空间的变化。所以，线程切换的开销要比进程切换的开销小得多。</li><li>进程的调度与切换都是由操作系统内核完成，而线程则既可由操作系统内核完成，也可由用户程序进行。</li><li>进程可以动态创建进程。被进程创建的线程也可以创建其它线程。</li><li>进程有创建、执行、消亡的生命周期。线程也有类似的生命周期</li></ol><p><strong>线程模型</strong></p><ul><li>用户线程，一对多<ul><li>线程在用户态中运行，运行与调度在用户空间中运行，内核无法感知，出问题无法切换，多个线程不能并发执行在多个处理器上（内核中只看到一个进程）</li></ul></li><li>一对一模型<ul><li>可以并行在多个处理器上</li><li>内核开销大</li></ul></li><li>多个多模型</li></ul><p><strong>进程同步</strong>：对多个相关进程在执行次序上的协调，用于保证这种关系的相应机制称为进程同步。</p><p>进程间通信问题</p><ul><li>竞争：竞争共享资源，导致运行的结果和进程执行的顺序相关； 解决方法：互斥，某种方法来确保如果一个进程正在使用一个共享的变量或文件，将被其他进程占用不能做同样的事情</li></ul><p>四种必要情况去保证互斥</p><ol><li>不能有两个进程同时在临界区中</li><li>不能假设CPU的速度以及数量</li><li>任何运行在关键区域之外的进程都不能阻止另一个进程</li><li>没有进程必须永远等待才能进入关键区域</li></ol><p><strong>忙等待的互斥</strong></p><ol><li>屏蔽中断<ol><li>每个进程刚进去临界区便屏蔽所有终端</li><li>如果屏蔽中断后忘记打开中断会导致系统的崩溃</li><li>如果系统是多处理器，屏蔽中断只会对单个cpu有效</li></ol></li><li>锁变量<ol><li>可能会有多个进程同时进入到临界区中</li></ol></li><li>严格轮换法<ol><li>不断测试变量直到某一个值的出现为止，称为忙等待；</li><li>在认为等待时间<strong>非常短</strong>的情况下，用于忙等待的锁，称为<strong>自旋锁</strong></li></ol></li></ol><p><strong>睡眠与唤醒</strong>:生产者和消费者问题</p><p><strong>信号量</strong>：检测信号量的数值、修改变量数值都是不可分割的<strong>原子操作</strong>。在操作完成或者阻塞前，其他进程都是无法访问该信号量的。</p><p><strong>管程的引入</strong></p><p>信号量的缺点：用信号量可实现进程间的同步，但由于信号量的控制分布在整个序中，其正确性分析很困难</p><p>引入管程：把信号量及其操作原语封装在一个对象内部；管程是管理进程间同步的机制，它保证进程互斥地访问共享变量，并方便地阻塞和唤醒进程。</p><p>经典的进程通信问题</p><ul><li>生产者消费者；等待唤醒机制</li><li>哲学家就餐问题；通过增加信号量，保证有一位哲学家可以吃到</li><li>读写问题；对资源加锁；对读者之间用锁保证互斥</li></ul><p>CPU调度问题</p><p>首先是处理机调度算法的共同目标（就与OS的共同目标一样）：</p><ul><li>资源利用率高：系统中处理机和其他资源都应尽可能的保持忙碌状态，其中最重要的资源是<strong>处理机</strong>；</li><li>公平性：诸进程都获得合理的CPU时间，不会发生进程<strong>饥饿现象</strong>；</li><li>平衡性：调度算法应当尽可能的保证系统资源使用的平衡性；</li><li>策略强制执行：对于所制定的策略，只要需要，就必须执行，即使会造成某些工作的延迟也要执行。</li></ul><p> <strong>作业(Job)<strong>：作业是一个比程序更为广泛的概念，它不仅包含了通常的</strong>程序和数据</strong>，而且还应配有一份<strong>作业说明书</strong>，系统根据该说明书来对程序的运行进行控制。</p><p>作业从进入系统到运行，通常需要经历<strong>收容</strong>、<strong>运行</strong>、<strong>完成</strong>三个阶段，其对应的作业状态分别为：<strong>后备状态</strong>（后备队列中）、<strong>运行状态</strong>（创建进程，进程的生命周期）、<strong>完成状态</strong>（作业运行结束或提前中断）。</p><p><strong>进程调度方式</strong>：分为非抢占式和抢占式两种，主要的划分方式就是进程在正常执行的过程中（发生阻塞情况例外），处理机是否可以被抢占。</p><p><strong>非抢占式</strong>：分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生某事件而阻塞时，才把处理机分配给另一个进程；<br><strong>抢占式</strong>：当一个进程正在运行时，系统可以基于某种原则（优先权原则、短进程优先原则、时间片原则），剥夺已分配给它的处理机，将之分配给其它进程。</p><p>调度发生的情况</p><ul><li>在创建一个进程后，需要决定是运行父进程还是子进程</li><li>在一个进程退出时必须做调度决策</li><li>当一个进程阻塞在IO和信号量时，或者由于其他原因，必须选择另一个进程运行</li><li>在一个IO中断发生时，必须做出决策调度</li></ul><p>批处理中的调度</p><ul><li>先来先服务</li><li>最短作业优先</li><li>最短剩余作业优先（每当新的进程时间比当前的剩余时间段，则挂起当前的）；饥饿问题</li></ul><p>交互系统中的调度</p><ul><li>轮转调度：时间片划分；时间短效率低，时间长交互效果不好</li><li>优先级调度：在每个时钟都会降低当前进程的优先级；优先级可以<strong>动态（随时间递减）或者静态</strong>赋予，<ul><li>静态非抢占式</li><li>抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。就是在运行进程的过程中，放弃当前进行，去进行优先级高的进程。</li></ul></li><li>多级队列<ul><li><img src="C:\Users\huami\AppData\Roaming\Typora\typora-user-images\image-20210628202032099.png" alt="image-20210628202032099"></li></ul></li><li>保证调度：系统跟踪各个进程自创以来使用过多少CPU的时间</li><li>公平分享调度算法：对于上述的保证调度算法，是对诸进程而言体现的一定程度的公平性。但是对于<strong>用户</strong>来讲就不一定公平了。</li><li>彩票调度：权重高的进程拥有更多的票，然后随机</li></ul><h5 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h5><p>无内存抽象：编程时直接写死地址；这样不能同时在系统上运行两份一样程序</p><p><strong>地址空间</strong>：保护和重定位；是一个进程可用于寻址内存的一套地址集合。每个进程都有自己的地址空间，并且这个地址空间是独立于其他程度的地址空间；动态重定位：用基址寄存器和界限寄存器；</p><p><strong>交换技术</strong>：处理<strong>内存超载</strong>问题</p><ul><li>直接交换：把程序完整调入内存中，使用该进程一段时间后，把它存到磁盘中</li><li>虚拟内存：是程序只有一部分被调入内存的情况下运行</li><li>会导致空洞；用内存紧缩技术会耗时</li><li>所需空间动态增长问题</li></ul><p><strong>空闲内存管理</strong></p><ul><li>使用位图来管理；单元越小图越大，检索连续的指定长度的空闲空间是耗时的</li><li>使用链表的储存管理：进程结束或者换出链表时块；<ul><li>下次适配算法</li><li>最佳适配算法</li></ul></li></ul><p><strong>虚拟内存</strong></p><p><strong>虚拟存储器就是作为主存储器空间扩充的一种方式</strong>，存储器管理把进程的全部信息放到辅存中，执行时先将其中的一部分装入主存，以后根据执行行为<strong>随用随调入</strong>，并且当主存中没有足够的内存空间时，存储器管理依据某些算法（页面置换算法或者是分区淘汰算法）淘汰内存中的页或者是分区。</p><p>页面:虚拟地址分为多个单元。</p><p>页帧:物理内存中相应的单元。</p><p><strong>内存管理单元</strong>负责虚拟地址到物理地址的转换</p><p>逻辑地址：页号+偏移量；前面几位是页号后面几位是偏移量；用页号去页表（map）去查询得到物理地址+上偏移量就得到物理地址；</p><p>页表会保存在内存中，寄存器存页表指针</p><p>TLB寄存器：相当于给页表加个缓存，为了解决虚拟地址到物理地址的转换速度</p><p>页式管理：页号+偏移量</p><p>段式管理：段号+段长度+偏移量</p><p>段页式管理：段号+页表长度+页的偏移量（段表【页的长度+页表存放的位置】 需要三次访存：第一次是段表、第二次页表、第三次访目标单元）</p><p>​    可以引用块表，将【段号和页号】作为关键字，这样只要一次访存，依旧是直接访问目标数据</p><p><strong>分页的原理</strong></p><p>将内存划分成多个小的分区，让一个进程的代码分布在<strong>非连续的内存地址中</strong>，一个进程按页的大小划分后，不同片段可以分开存储，但是这样就不能使用了之前连续分配的动态重定位的方式，需要额外实现定位的方法；按页的大小划分的一个较大的好处就是减少了进程的内部碎片的问题</p><p><strong>局部性原理</strong></p><ol><li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li><li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li></ol><p>针对大内存的页表</p><ul><li>多级页表<ul><li>避免全部页表保存一直保存在内存中</li></ul></li><li>倒排页表<ul><li>将虚拟地址作hash，然后根据hash值去对应槽找节点，如果有对应的（虚拟页面，页框）则找到</li></ul></li></ul><p>页面置换算法</p><ul><li>最近未使用页面置换算法NRU<ul><li>定时将页面设置为没有被访问<ul><li>没有被访问，没有被修改</li><li>没有被访问，已经被修改</li><li>已经被访问，没有修改</li><li>已经被访问，已经修改</li></ul></li></ul></li><li>先进先出</li><li>第二次机会页面置换算法<ul><li>修改FIFO，如果已经被访问，则设置为没被访问，重新进队</li></ul></li><li>时钟置换算法<ul><li>循环队列，如果R（访问）为0，直接淘汰，如果为1设为0，继续向前走</li></ul></li><li>最近最少使用LRU<ul><li>可以用老化算法来模拟；</li><li>可以理解为每次都访问的放到队头</li></ul></li><li>最近最不常用LFU<ul><li>计算访问次数</li></ul></li></ul><p>页面小</p><ul><li>优点：更少的页框，更少没被使用的</li><li>缺点：页表大</li></ul><p><strong>分段</strong></p><p>采用分页内存管理有一个不可避免的问题：用户视角的内存和实际物理内存的分离。用户通常更愿意将内存看做是一组<strong>不同长度的段的集合，这些段之间并没有一定的顺序</strong>，因此<strong>用户通过两个量来指定地址：段号+偏移</strong></p><p><strong>分段和分页的差别</strong></p><ol><li>页式和段式管理策略都不会产生外部碎片，但都有可能产生内部碎片</li><li>页的大小是统一的，而段的大小是可变的</li><li>采用分页会导致用户视角的内存和实际内存的分离，即使用户视角的内存和实际物理内存不一样，而分段正好可以支持用户视角，使用户视角的内存和实际物理内存分布保持一致</li><li>分页对程序员来说是透明的，用户指定一个地址，该地址通过硬件分为页码和偏移，这些程序员是看不见的；而分段对程序员来说通常是可见的，用户通过两个量：段号和偏移来指定地址，这两个量作为组织程序和数据的一种方便手段提供给程序员，程序员可以通过这两个量把程序和数据指定到不同的段（程序员必须清楚段的最大长度）</li></ol><p><strong>文件管理</strong></p><p>提供文件和目录的抽象，隐藏硬件设施的复杂信息；提供文件保护</p><p>同样也有文件控制块的概念</p><p>文件名-255字符</p><p>目录：包含所有文件信息的节点集合，是根据文件名检索文件的桥梁</p><p>通过FCB再次索引，索引中只有文件名，只有真正需要采取读取FCB,再根据FCB来找出文件的存放位置</p><p><strong>文件跟踪</strong>：实现文件存储就是跟踪哪些磁盘块与哪些文件一起使用。</p><ul><li>连续分配<ul><li>容易实现；读取效率高；文件删除后会留下空洞；文件最大空间在创建时就要确定</li></ul></li><li>链表分配<ul><li>没有外部碎片；文件检索简单；可以做到增长；随机访问速率低，空间不一定会填满一个空</li></ul></li><li>索引分配<ul><li>只有在打开相应文件时，才需要将i-node加载到内存中。</li><li>支持直接访问；没有外部碎片；索引也会占用空间开销</li></ul></li></ul><p><strong>文件名字的管理</strong></p><ul><li>固定长度：浪费空间</li><li>线性：删除文件时会留下空洞</li><li>堆：需要额外的开销</li></ul><p><strong>文件共享</strong></p><ul><li>硬链接：都保存的i-node节点<ul><li>删除源文件时，文件并没有被删除，会导致文件一直存在（按理删了源全部都要删掉）</li></ul></li><li>软链接：只有一个节点是保存了i-node，其他是保存”路径“<ul><li>需要额外的开销</li></ul></li></ul><h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p>管理和控制IO操作和IO设备；主要管理IO设备和对应的控制器</p><p><strong>设备无关性</strong>：应用程序独立于具体使用的物理设备；在系统中引入<strong>逻辑设备</strong>和<strong>物理设备</strong>；在应用程序中使用逻辑设备名来请求使用某类设备，而系统在实际执行中使用物理设备名；</p><p>设备驱动程序层：为内核IO子系统隐藏设别控制器的不同细节</p><ul><li>将串行位流转换为字节块</li><li>执行必要的错误纠正</li><li>方便主存使用</li></ul><p><strong>内存映射</strong>：CPU如何与设备的控制器和数据缓冲区进行通信</p><ul><li>每个控制寄存器都被分配一个IO端口，所有的IO端口形成IO端口空间<ul><li>直接访问</li></ul></li><li>将所有控制器映射到内存空间中，每个寄存器都被分配唯一的内存空间<ul><li>不需要特殊的保护机制来保护控制寄存器不被用户直接访问</li><li>每一条引用内存的指令也可以引用控制寄存器</li><li>但是需要缓存</li><li>因为只有一个地址空间，所有主内存模块和所有I&#x2F;O设备控制器必须检查所有内存引用才能看到该回应哪一个呢</li></ul></li></ul><p><img src="C:\Users\huami\AppData\Roaming\Typora\typora-user-images\image-20210729213204890.png" alt="image-20210729213204890"></p><p><strong>DMA直接存储器存取</strong></p><p>在ＤＭＡ出现之前，CPU与外设之间的数据传送方式有程序传送方式、中断传送方式。CPU是通过系统总线与其他部件连接并进行数据传输。</p><p>DMA的出现就是为了解决批量数据的输入&#x2F;输出问题。DMA是指外部设备不通过CPU而直接与系统内存交换数据的接口技术。这样数据的传送速度就取决于存储器和外设的工作速度。</p><p><strong>死锁</strong>：一个进程集合中每个程序都在等待只能由该进程集合中其他进程才能引发的事件，那么说明该进程集合是死锁</p><p><strong>死锁的四个必要条件</strong></p><ul><li>互斥条件</li><li>占有和等待</li><li>不可抢占</li><li>环路等待</li></ul><p>处理死锁的四种策略</p><ul><li><p>鸵鸟算法；发生的概率是很低的</p></li><li><p>检测死锁并且恢复</p><ul><li>通过深搜+回溯来找环，如果所有节点都是可以则是安全的</li><li>每种类型多个资源的死锁检测（E+R+A矩阵）</li><li>恢复地方法<ul><li>抢占</li><li>利用回滚</li><li>杀死进程来恢复</li></ul></li></ul></li><li><p>死锁避免</p><ul><li>资源轨迹图：不安全不代表一定会死锁，只代表有可能死锁</li><li>银行家算法；分配然后回收看是否可以全部满足</li></ul></li><li><p>死锁预防：从四个条件去破坏</p><ul><li>破坏互斥条件：避免在非绝对必要时分配资源；申请资源的进程越少越好</li><li>破坏占有和等待条件：规定开始执行前必须获得所有资源；当它请求时先释放自己手上的资源</li><li>破坏不可抢占条件：如果遭到拒绝就释放自己的资源</li><li>破坏环形等待：给资源编号，申请后面的必须先获得前面的资源</li></ul></li></ul><p><strong>两阶段锁</strong></p><p>第一阶段：进程试图对所有所需资源的记录进行加锁。如果成功执行第二阶段，完成后释放锁，第一阶段并没有做实际工作</p><p>如果第一阶段所需的锁已经被加锁，则释放全部锁，从头再来</p><p><strong>通信死锁</strong></p><p>通过超时中断死锁</p><p><strong>活锁</strong></p><p>互相谦让，但是没有进展</p><p><strong>饥饿</strong></p><p>无限制推后，虽然没有被阻塞</p><h1 id="操作系统-1"><a href="#操作系统-1" class="headerlink" title="操作系统"></a>操作系统</h1><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>进程的创建</p><ul><li>系统启动</li><li>执行正在进行的进程调用进程的创建</li><li>用户申请创建</li><li>批处理的初始化</li></ul><p>进程的结束</p><ul><li>完成任务</li><li>发生了错误（自愿）</li><li>发生严重错误（非自愿）</li><li>被其他进程杀死</li></ul><p>三个状态</p><ul><li>运行</li><li>就绪</li><li>阻塞</li></ul><p>运行到就绪：调用程序选择另一个进程</p><p><strong>进程的内部结构</strong></p><p>代码块、数据、堆、栈、PCB进程控制块（用户内用、系统内用、寄存器信息）</p><p><strong>切换的步骤</strong></p><ul><li>保存PCB</li><li>加载PCB</li><li>刷新内存缓存</li><li>改变地址映射</li></ul><h6 id="父进程和子进程"><a href="#父进程和子进程" class="headerlink" title="父进程和子进程"></a>父进程和子进程</h6><p>新创建的子进程<strong>几乎</strong>和父进程完全一样，子进程会获得父进程用户级虚拟地址空间（但是独立）一份副本，包括<strong>代码和数据段、堆、共享库以及与用户栈</strong>，子进程获得父进程任何打开<strong>文件描述符相同的副本</strong>，也就是子进程可以读取父进程中打开的任何文件。最大区别是拥有不同的PID；只是在创建的时候是一样的，后续的改变是相互独立的。</p><p><strong>僵死进程</strong></p><p>发生在子进程回收过程中，当进程由于某种原因终止时，内核不会立刻从系统中删除，而是保持已终止状态，直到父进程回收。所以一个终止了但是还没被回收的进程时<strong>僵死进程</strong></p><p>如果父进程终止了，但是还没有回收子进程，会有一个init进程成为其养父进程，来回收子进程</p><h6 id="fork和execve"><a href="#fork和execve" class="headerlink" title="fork和execve"></a>fork和execve</h6><p>fork会创建一个子进程，并且返回两次（用来区别父进程和子进程）；execve是在原来的进程的<strong>上下文中加载运行另一个新程序</strong>，如果成功不会返回</p><ul><li>系统中的每个程序都是运行在某个进程的<strong>context</strong>中的。context是由程序正确运行所需的状态组成的，这个状态包括存放在存储器中的<strong>程序的代码和数据</strong>，它的<strong>栈</strong>、<strong>通用目的寄存器的内容</strong>、<strong>程序计数器</strong>（PC）、<strong>环境变量</strong>以及打开的<strong>文件描述符的集合</strong>。</li><li>每个<strong>线程</strong>都有它自己的线程context，包括一个唯一的整数线程ID、栈、栈指针、程序计数器（PC）、通用目的寄存器和条件码。</li><li>每个线程和运行在同一进程内的其他线程一起共享进程context的<strong>剩余部分</strong>。这包括整个用户虚拟地址空间，它是由<strong>只读文本（代码）</strong>、<strong>读&#x2F;写数据</strong>、<strong>堆以及所有的共享库代码和数据区域组成</strong>。线程也同样共享打开文件的集合。</li></ul><h6 id="线程的过程"><a href="#线程的过程" class="headerlink" title="线程的过程"></a>线程的过程</h6><p><strong>创建线程</strong></p><ul><li>pthread_create:创建一个新的线程，可以在参数中绑定返回的线程tid，传入函数用于让新创线程执行这个函数，设置可以传入参数改变线程的默认值</li></ul><p><strong>线程终止</strong></p><ul><li>当顶层的线程例程返回时，线程也就隐式终止</li><li>通过调用pthread_exit函数，线程会显示结束。主线程调用pthread_exit会让其他所有对等线程终止</li><li>其他对象线程调用exit，该函数会终止进程导致该进程相关的线程都终止</li><li>零杠一个对等线程通过以线程id传入<strong>pthread_cancel</strong>来终止其他线程</li></ul><p><strong>回收已终止线程的资源</strong></p><p>pthread_join函数可以等待一个函数终止</p><p><strong>分离线程</strong></p><p>线程是可结合的也可以是分离的，一个结合的线程能够被其他线程收回和杀死；分离的线程是不能被其他线程杀死或者回收，<strong>他的资源在它终止的时候由系统自动释放</strong>。</p><p>使用pthread_detach</p><h6 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h6><p>一个小消息，通知进程系统发生了某一种类型的事件。通知用户进程发生了异常；如通过kill9一个进程向另一个进程来强制终止它；ctrl+c内核向前台进程组发送信号，一般是挂起前台进程；</p><p>发送但是还没接受的信号称为待处理信号（pending singal）；任何时候，一个类型最多只有一个待处理信号。如果同一个类型的信号收到多个，就会被丢弃。</p><p><strong>线程</strong></p><ul><li>如何能使多个程序更好地并发执行，同时又尽量减少系统的开销，成为设计操作系统的重要目标。</li><li>将进程的两个基本属性分开，由操作系统分开处理：对于作为调度和分派的基本单位，不同时作为拥有资源的单位，可以做到“轻装上阵”； </li><li>对于拥有资源的基本单位，又不对之进行频繁的切换。‘’</li></ul><p>修改为进程作为资源分配的单位，线程作为调度的单位</p><p>线程不拥有系统的资源，但是拥有其运行时必须的数据结构（TCB，程序计数器，寄存器，栈）</p><p>当然也有自己独有的部分：程序计数器、寄存器、栈、状态</p><p><strong>线程的不同实现方案</strong></p><p>纯用户态：线程表放在用户态中，可以自己定制调度算法，阻塞会一起阻塞（某个线程去IO）；线程占有CPU，除非资源放弃，其他线程不能保证</p><p>内核态中实现：线程表放在内核中，用池化技术循环利用</p><p><strong>轻量级进程</strong></p><p>与普通进程相比，<em>LWP</em>与其它进程<strong>共享所有（或大部分）逻辑地址空间和系统资源</strong>，一个进程可以创建多个<em>LWP</em>，这样它们共享大部分资源；<em>LWP</em>有它自己的*<a href="http://zh.wikipedia.org/w/index.php?title=%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86%E7%AC%A6&action=edit&redlink=1"><strong>进程标识符</strong></a><em>，并和其他进程有着</em><a href="http://zh.wikipedia.org/w/index.php?title=%E7%88%B6%E8%BF%9B%E7%A8%8B&action=edit&redlink=1"><strong>父子关系</strong></a><em>；</em>LWP*与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息；</p><p><strong>用户线程与内核线程</strong></p><p>1）可移植性：因为ULT完全在用户态实现线程，因此也就和具体的内核没有什么关系，可移植性方面ULT略胜一筹；</p><p>2）可扩展性：ULT是由用户控制的，因此扩展也就容易；相反，KLT扩展就很不容易，基本上只能受制于具体的操作系统内核；</p><p>3）性能：由于ULT的线程是在用户态，对应的内核部分还是一个进程，因此ULT就没有办法利用多处理器的优势，而KLT就可以通过调度将线程分布在多个处理上运行，这样KLT的性能高得多；另外，一个ULT的线程阻塞，所有的线程都阻塞，而KLT一个线程阻塞不会影响其它线程。</p><p>4）编程复杂度：ULT的所有管理工作都要由用户来完成，而KLT仅仅需要调用API接口，因此ULT要比KLT复杂的多。</p><p><strong>Linux的进程</strong></p><p><em>Linux</em>采用的“一对一”的线程模型，即一个<em>LWP</em>对应一个线程。这个模型最大的好处是线程调度由内核完成了，而其他线程操作（同步、取消）等都是核外的线程库函数完成的。</p><p>在<em>LinuxThreads</em>中，专门为<strong>每一个进程构造了一个管理线程</strong>，负责处理线程相关的管理工作。</p><p><strong>进程VS线程</strong></p><ul><li>进程是资源分配的基本单位，所有与该进程有关的资源分配情况，进程也是分配主存的基本单位，它拥有一个完整的虚拟地址空间。而线程与资源分配无关，它属于某一个进程，并与该进程内的其它线程一起共享进程的资源。</li><li>不同的进程拥有<strong>不同的虚拟地址空间</strong>，而同一进程中的多个线程<strong>共享同一地址空间</strong>。</li><li>进程调度的切换将涉及到有关<strong>资源指针</strong>的保存及<strong>进程地址空间的转换等</strong>问题。而线程的切换将<strong>不涉及资源指针的保存和地址空间的变化</strong>。所以，线程切换的开销要比进程切换的开销小得多。</li><li>进程的调度与切换都是由操作系统内核完成，而线程则既可由操作系统内核完成，也可由用户程序进行。</li></ul><p><strong>进程间的通信</strong></p><p>关注点：</p><ul><li>进程如何把信息传递给另一个进程（共享同一片空间）</li><li>进程在关键点直接不会出现交叉</li><li>正确的顺序</li></ul><p>进程同步：在多个进程执行次序上的协调；相互合作的一组并发进程在一些<strong>关键点</strong>上可能需要相互等待与互通信息，保证这种关系的就叫进程同步</p><p><strong>竞争条件</strong>：多个进程对共享资源，导致最后的结果与操作的顺序有关</p><p><strong>互斥</strong>：保证进程在使用共享资源的时候，其他进程不能进行相同的操作</p><h5 id="保证互斥的四个条件"><a href="#保证互斥的四个条件" class="headerlink" title="保证互斥的四个条件"></a><strong>保证互斥的四个条件</strong></h5><ul><li>任何两个进程不能同时处于临济区</li><li>不应对cpu的速度和数量作任何假设</li><li>临界区域外进程不能阻塞其他进程</li><li>不能使进程无限期等待进入临界区</li></ul><h6 id="忙等待的互斥"><a href="#忙等待的互斥" class="headerlink" title="忙等待的互斥"></a><strong>忙等待的互斥</strong></h6><p><strong>信号屏蔽</strong></p><ul><li>信号屏蔽<ul><li>多核中不好用，是针对操作系统的，忘记开启有问题</li></ul></li><li>锁变量<ul><li>获取并将其变成1，但是会有问题，因为进程可能随时切换，还是会卡进去</li></ul></li><li>严格轮换法<ul><li>忙等待，属于自己的就进去，但是违反了条件3，阻塞了别的进程</li></ul></li></ul><p><strong>睡眠与唤醒</strong></p><ul><li>信号量：控制进去临界区域的进层数；如果失败就在该位置睡眠，然后等待信号量增加后，系统随机选取一个唤醒</li></ul><p>信号量可以实现进程间的通信，但是由于信号量的控制分布在整个程序中，正确性难分析</p><ul><li>管程：引入了条件变量，wait和signal，当发现无法继续运行时会在变量上wait，导致进程阻塞；它存在于内存中，进程可以对它进行读写，它提供流控制，保证进程的正确读写，即管道为空时读进程会阻塞，管道为满时写进程会阻塞，以此实现进程之间的通信。</li></ul><h5 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h5><p>要么是陷入内核，要么是涉及外设</p><ol><li>管道( pipe )：<br>管道是一种<strong>半双工</strong>的通信方式，数据<strong>只能单向流动</strong>，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。<strong>以内存文件的形式存在</strong></li><li>匿名管道：克服了亲缘的限制，<strong>以磁盘文件的形式存在</strong>，先进先出，可以任意进程间通信</li><li>信号量(semophore ) ：<br>信号量是一个计数器，可以用来控制<strong>多个进程对共享资源的访问</strong>。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li>消息队列( message queue ) ：<br>消息队列是由消息的链表，存放在<strong>内核中</strong>并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。存在内核中说明其内核重启或者显式删除的时候才被删除</li><li>信号 (sinal ) ：<br>信号是一种比较复杂的通信方式<strong>，用于通知接收进程某个事件已经发生。</strong></li><li>共享内存(shared memory ) ：<br>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。<strong>就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。需要某种同步操作来保证，例如<strong>信号量</strong></li><li>套接字(socket ) ：<br>套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</li></ol><p>理解：<strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，但是多进程竞争同个共享资源会造成<strong>数据的错乱</strong>；</p><h6 id="线程间通信方式"><a href="#线程间通信方式" class="headerlink" title="线程间通信方式"></a>线程间通信方式</h6><ol><li>锁机制：包括互斥锁、条件变量、读写锁：只有<strong>拥有互斥对象的线程才有访问公共资源的权限</strong><ul><li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。</li><li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</li><li>条件变量可以以原子的方式阻塞进程，<strong>直到某个特定条件为真为止</strong>。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li></ul></li><li>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</li><li>信号机制(Signal)：类似进程间的信号处理<br>线程间的通信目的主要是用于线程同步，<strong>所以线程没有像进程通信中的用于数据交换的通信机制</strong>。</li></ol><h4 id="用户态切换到内核态的方式"><a href="#用户态切换到内核态的方式" class="headerlink" title="用户态切换到内核态的方式"></a>用户态切换到内核态的方式</h4><ol><li><p>系统调用</p><p>这是用户态进程<strong>主动</strong>要求切换到内核态的一种方式，<strong>用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作</strong>，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p></li><li><p>异常</p><p>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到<strong>处理此异常</strong>的内核相关程序中，也就转到了内核态，比如<strong>缺页异常</strong>。</p></li><li><p>外围设备的中断</p><p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p></li></ol><h6 id="调度"><a href="#调度" class="headerlink" title="调度"></a><strong>调度</strong></h6><p><strong>发生调度的时间</strong></p><ul><li>新的进程被创建</li><li>进行的进程退出</li><li>进行的进程被阻塞</li><li>IO中断</li><li>时钟中断</li></ul><p>调度算法</p><ul><li>FIFO：队列、链表</li><li>最短作业优先：优先队列</li><li>最短剩余时间优先</li><li>优先级调度（优先级的静态和动态）</li><li>多级队列（不同队列的时间片不同，2幂增）</li><li>保证调度（跟踪已经使用的时间）</li><li>彩票调度（优先级高拥有的票多）</li></ul><h4 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h4><p><strong>地址的抽象</strong></p><p>多个应用程序处于内存中互补影响，要满足<strong>保护和重定位</strong>的问题</p><p><strong>交换技术和虚拟内存</strong></p><p><strong>空间的分配问题</strong>（交换中引起了空洞问题）</p><ul><li>位图<ul><li>但是内存很大时，位图也很大</li></ul></li><li>链表的方式<ul><li>算法<ul><li>首次适配</li><li>最佳适配（要遍历一遍）</li></ul></li></ul></li></ul><p><strong>虚拟空间</strong></p><p>将程序切割成片段，但是前期时由程序员完成，将这个工作交给系统过去完成；</p><p>讲程序中的逻辑地址通过<strong>内存管理单元</strong>MMU进行转换，</p><p>虚拟空间中的页面&#x3D;物理地址中的页框</p><p>虚拟地址&#x3D;虚拟地址页号+偏移量</p><p>页表项</p><p><img src="C:\Users\huami\AppData\Roaming\Typora\typora-user-images\image-20210717232227535.png" alt="image-20210717232227535"></p><p>通过虚拟地址页号去<strong>页表</strong>找对应的页框同时判断其在不在内存中</p><p><strong>TLB</strong></p><p>在页表也很大时时候；以及<strong>映射得不够快</strong></p><p>相当于给页表再做一个<strong>缓存</strong></p><p><strong>多级页表</strong></p><p>从页号去找二级页表号，从二级页表号根据第二段找到框号，再加上偏移量</p><p><strong>倒查页表</strong></p><p>根据物理地址页框数量作为哈希数组长度，然后进行哈希</p><p><strong>页表置换算法</strong></p><ul><li><p>最近未使用算法NRU:</p><ul><li>两位（是否被访问，是否被修改），定期抹除访问标志（变成0）</li></ul></li><li><p>FIFO</p></li><li><p>第二次机会置换算法</p><ul><li>FIFO的优化，如果被访问过就将其痕迹抹掉重新入队</li></ul></li><li><p>时钟置换算法</p><ul><li>相当于给第二次置换算法，用循环链表来实现</li></ul></li><li><p>最近最少使用算法LRU</p><ul><li>老化算法</li><li>双向链表和HashMap实现</li></ul></li><li><p>LFU最不经常使用</p><ul><li>计算频率</li></ul></li></ul><h6 id="分段技术"><a href="#分段技术" class="headerlink" title="分段技术"></a><strong>分段技术</strong></h6><p>按照类型把进程的地址空间分为多个，每一种功能对应一个地址空间，独立增长，这就是分段思想，分段使得我们不需要关心如何管理和分割地址空间。分段与分页的区别在于，分段存在于逻辑地址的概念上，是一种划分逻辑地址的思想，而分页是解决逻辑地址到物理地址的映射过程的。</p><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p><strong>文件命名</strong></p><ul><li>长度为255</li><li>windows大小写不敏感，linux是大小写敏感</li></ul><p><strong>文件结构</strong></p><ul><li>线性+定长</li><li>树状结构</li></ul><p><strong>目录结构</strong></p><ul><li>单层结构<ul><li>难以查找文件</li></ul></li><li>两层结构<ul><li>解决了命名冲突问题</li><li>提高了搜索效率</li><li>可以文件共享和保护</li></ul></li><li>多层次<ul><li>文件和目录</li></ul></li></ul><p><strong>空间分配问题</strong></p><ul><li>顺序存储<ul><li>容易实现、可以直接访问和顺序访问</li><li>外部碎片，文件的<strong>长度必须提前知道</strong></li></ul></li><li>链式存储<ul><li>没有外部碎片、文件变长</li><li><strong>随机访问</strong>性能差，存在结构性开销</li></ul></li><li>i-node<ul><li>所有的i-node统一存储</li><li>每个文件都有自己i-node结点，支持直接访问，不存在外部碎片</li><li>i-node节点的结构性开销</li></ul></li></ul><p><strong>共享文件</strong></p><ul><li>i-node<ul><li>硬链接，每个节点都会指向这个文件</li></ul></li><li>符号链接<ul><li>其他接待保存路径</li></ul></li></ul><h4 id="IO-1"><a href="#IO-1" class="headerlink" title="IO"></a>IO</h4><p>分类</p><ul><li>块设备：把信息存储在固定的大小中，每个块都有自己的地址，每个块都能独立于其他块而读写</li><li>字符设备：不能寻址，也没有任何寻道操作</li></ul><p><strong>轮询</strong></p><p>cpu的干预非常频繁</p><p><img src="C:\Users\huami\AppData\Roaming\Typora\typora-user-images\image-20210729214538130.png" alt="image-20210729214538130"></p><p><strong>中断驱动</strong></p><p>容控制器自己完成任务后向cpu发一个中断信号，处理中断过程就是从控制器中读<strong>一个字的数据</strong>到cpu寄存器中，再写入内存，接着恢复去执行别的，等待下一次中断信号；但是中断次数过多也不好</p><p><img src="C:\Users\huami\AppData\Roaming\Typora\typora-user-images\image-20210729215353822.png" alt="image-20210729215353822"></p><h6 id="IO多路复用技术"><a href="#IO多路复用技术" class="headerlink" title="IO多路复用技术"></a>IO多路复用技术</h6><p>IO多路复用的事件驱动服务器是运行在单一进程上下文中的，因此每个逻辑流都能访问该进程的全部空间，使得流之间共享数据非常容易；</p><p>但是并发粒度的缩小会让代码量上升，而且使得如果一个逻辑流在忙于读文本行，其他是无法进展的</p><p><strong>DMA</strong></p><p><img src="C:\Users\huami\AppData\Roaming\Typora\typora-user-images\image-20210729220610942.png" alt="image-20210729220610942"></p><p>5.<strong>主要缺点和主要优点</strong></p><p>优点:数据传输以“块”为单位，CPU介入频率进- -步降低。数据的传输不再需要先经过CPU再写入内存，数据传输效率进- -步增加。CPU和&#x2F;O设备的并行性得到提升。</p><p>缺点: CPU每发出一- 条I&#x2F;0指令，只能读&#x2F;写一个或多个连续的数据块。</p><p><strong>控制器的任务</strong></p><p>把串行的位流转换成字节块，并且进行有必要的<strong>错误校验</strong></p><p>CPU<strong>如何与设备控制器何数据缓冲区进行通信</strong>？</p><ul><li>每个控制存储器被分配一个IO端口；只能由操作系统能对其访问；使用特殊的指令去读写</li><li>讲IO映射到内存空间中；像访问内存空间一样去访问；不需要特殊的保护机制去组织用户进程执行IO操作</li></ul><h4 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h4><ol><li><p>同步阻塞IO</p><p><img src="https://pic3.zhimg.com/v2-abef476a75afe52193be9577dcbcb88a_r.jpg" alt="preview"></p></li><li><p>同步非阻塞IO</p><p>非阻塞IO是在应用调用recvfrom读取数据时，如果该缓冲区没有数据的话，就会直接返回一个EWOULDBLOCK错误，不会让应用一直等待中。在没有数据的时候会即刻返回错误标识，那也意味着如果应用要读取数据就需要<strong>不断的调用recvfrom请求</strong>，直到读取到它数据要的数据为止。</p></li><li><p>多路复用IO</p><p><img src="https://pic3.zhimg.com/v2-260e80cbec13cbcc677779690f6ab2fa_r.jpg" alt="preview"></p><ul><li><p>为什么会产生多路复用IO？</p><p>因为当有多个网络连接，连接到某个进程的时候，我们想要监听这些socket接口，并当这些接口有数据返回的时候，进行处理。一种解决方案就是，对于每一个socket接口，我们都开辟一个线程来侦听，处理。这样做的局限就是，当连接数变大的时候（成千上万），那么我们就要创建多个线程变量。创建线程变量开销很大，而且，线程切换的开销也会变大。所以我们就寻求一种，<strong>单线程的情况下监听多个socket接口的方式</strong>，所以就会有多路复用IO的诞生。</p><p>本质上还是同步非阻塞IO，但是将阻塞放在了select上</p></li></ul></li><li><p>信号驱动IO,继续改良复用IO,思想是发出请求后等你数据准备好了就通知我</p></li><li><p>异步IO</p><p><img src="https://pic4.zhimg.com/v2-5095ab1ffe868a2577bc15310d740293_r.jpg" alt="preview"></p><p>异步IO需要更强的操作系统支持；当用户线程收到通知时，数据已经被内核读取完毕，<strong>并放在了用户线程指定的缓冲区内</strong>，内核在IO完成后通知用户线程直接使用即可。</p></li></ol><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁的定义：如果一组进程中每个进程都在等待一个事件，而这个事件只有该集合中的另一个进程才能引起，那么该集合就是死锁的。（都占有资源，然后互相等待）</p><p><strong>引起死锁四个条件</strong></p><ul><li>互斥条件：资源要么分配给一个进程，要么可用</li><li>占有资源和等待</li><li>不可抢占</li><li>环路等待</li></ul><p><strong>死锁检测</strong></p><ol><li>建模之后寻找环路</li><li>多资源的死锁检测，矩阵，先给能满足的，然后释放</li></ol><p><strong>死锁恢复</strong></p><ul><li>抢占</li><li>回滚</li><li>杀死进程</li></ul><p><strong>死锁避免</strong></p><ul><li>资源轨迹图</li><li>安全状态和不安全状态</li><li>单个银行家算法</li><li>多个资源的银行家算法</li></ul><p><strong>死锁预防</strong></p><ul><li><p><strong>破坏互斥条件</strong>：有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。</p></li><li><p><strong>破环占有和等待条件</strong>：预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。<strong>会有“饥饿”</strong></p></li><li><p><strong>破环不可抢占资源</strong>：当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。</p></li><li><p>破坏循环等待条件：规定每个进程，必须按编号递增的顺序请求资源</p></li></ul><p>活锁：互相谦让，导致谁都没办法开始</p><p><strong>中断</strong></p><p>中断主要是一个cpu硬件产生的定时脉冲，为了能通知操作系统是时间片到了，将cpu的使用权限从用户态切换到内核态中，内核态去根据中断信号进行不同的处理；</p><p>中断可能来自cpu内部，也可能来自外部；来自内部就是用户申请使用特权指令、时间片到了；外部一般是外设导致，如键盘输入</p><p><strong>系统调用：</strong></p><p>用户态程序通过系统调用的方法来申请操作系统的服务，因为其可能涉及到一些特权指令才能完成</p><p>陷入指令：是唯一一个只能在用户态不能在内核态执行的指令</p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库 面试必备</title>
      <link href="/interview/sql-interview/"/>
      <url>/interview/sql-interview/</url>
      
        <content type="html"><![CDATA[<h1 id="△-66次-MySQL-为什么使用-B-树来作索引，对比-B-树它的优点和缺点是什么？-中等"><a href="#△-66次-MySQL-为什么使用-B-树来作索引，对比-B-树它的优点和缺点是什么？-中等" class="headerlink" title="△ 66次 MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？  中等"></a><em>△ 66次</em> MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？  中等</h1><ol><li>从需求分析上来讲，数据库使用多为 <em>查询</em> 和 <em>新增</em> 操作，<em>改删</em>  本质上也是查询的进一步动作</li><li>二分搜索树实现的 DB 存在一个问题: 范围查询会很慢。我们需要不断地从根节点出发，然后往下遍历。所以我们稍微改造下，数据只 保存在叶子节点上，并且用双向链表进行连接</li><li>对于二分搜索树实现的 DB 而言，其查询效率是与树高有关的。假设我们有 2000 万条数据，我们大概需要一棵树高为 25 的 BST 才能装下所 有数据和索引。也就是说，我们至少需要 25 次硬盘 I&#x2F;O 才能取出一条数据</li><li>将刚刚说的二分搜索树进行树高的压缩，让它变矮胖，就得到了多叉搜索树，aka B-树。</li><li>B+ 树是二叉搜索树的一个扩充，是多路搜索树。它只在叶子节点存储具体的数据或者数据的指向指针，而非叶子节点存放索引数据。这样可以降低磁盘 IO，还能充分利用磁盘的预读功能，批量的加载索引数据。</li></ol><h1 id="△-42次-数据库的事务隔离级别有哪些？各有哪些优缺点？-中等"><a href="#△-42次-数据库的事务隔离级别有哪些？各有哪些优缺点？-中等" class="headerlink" title="△ 42次 数据库的事务隔离级别有哪些？各有哪些优缺点？  中等"></a><em>△ 42次</em> 数据库的事务隔离级别有哪些？各有哪些优缺点？  中等</h1><p>首先要明白几个概念</p><ul><li><p><strong>脏读</strong>：脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。</p></li><li><p><strong>可重复读</strong>：可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。通常针对数据<strong>更新（UPDATE）</strong>操作。</p></li><li><p><strong>不可重复读</strong>：对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据<strong>更新（UPDATE）</strong>操作。</p></li><li><p><strong>幻读</strong>：幻读是针对数据<strong>插入（INSERT）</strong>操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。</p></li><li></li><li><p><strong>未提交读：</strong>（Read Uncommited）</p><ul><li>读取未提交内容，所有事务可看到其他未提交事务的结果，很少实际使用</li><li>读取未提交的数据称为脏读（Dirty Read）。</li><li>修改时加排它锁；读取时加共享锁，读完释放。 eg：select for update</li></ul></li><li><p><strong>已提交读：</strong>（Read Committed） 如果想防止脏读，就需要等待其他事务提交后再进行读取操作。</p></li><li><p><strong>可重复读：</strong> （Repeatable Read）已提交读的隔离级别考虑到了数据回滚的无效性，却无法阻止事务的多次提交。比如事务 A 不断的对表进行修改提交，那么事务 B 就会在不同的时间点读取到不同的数据。为了让事务 B 在执行期间读取的数据都是一致的，就有了可重复读的隔离级别，即事务 B 在执行期间，其他事务不得进行修改操作。</p></li><li><p><strong>可串行化：</strong> （Serializable）上面的可重复读隔离级别保证了事务执行期间读取的一致性。然而这里并不包括插入、删除操作。即会出现读多读少数据的情况，这种现象叫做幻读。为了解决幻读，只得进行串行化执行事务，才能互不影响。而此时的事务并发性是最低的</p></li></ul><h1 id="△-36次-简述-Redis-持久化中-RDB-以及-AOF-方案的优缺点-困难"><a href="#△-36次-简述-Redis-持久化中-RDB-以及-AOF-方案的优缺点-困难" class="headerlink" title="△ 36次 简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点  困难"></a><em>△ 36次</em> 简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点  困难</h1><h3 id="1-RDB：Redis-Database"><a href="#1-RDB：Redis-Database" class="headerlink" title="1. RDB：Redis Database"></a>1. RDB：Redis Database</h3><p>指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作是 fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，使用二进制压缩存储。<br>优点：</p><ul><li>整个 redis 只包含一个文件 dump.rdb，方便持久化</li><li>容灾性好，易于备份</li><li>性能最大化，使用子进程处理，保证主进程 IO 吞吐，保证了 redis 的高性能</li><li>相对于数据集大时，比 AOF 的启动效率更高<br>缺点：</li><li>数据安全性低，因为会有间隔时间，所以如果间隔期间出现故障，无法保证期间的数据正常备份</li><li>当数据集较大时，子进程长期占用 CPU，会导致服务中断时间延长至秒级</li></ul><h3 id="2-AOF：Append-Only-File"><a href="#2-AOF：Append-Only-File" class="headerlink" title="2. AOF：Append Only File"></a>2. AOF：Append Only File</h3><p>以日志的形式记录服务器处理的每个读写操作，以文本的方式详细记录，可以查看历史操作记录<br>优点：</p><ul><li>数据安全：每秒同步、每修改同步、不同步3中策略。每秒同步可以理解为类似1s间隔的 RDB ，可能也会出现丢失的情况；每修改同步可以认为是同步持久化，不会丢失</li><li>通过 append 方式追加新的操作，不惧宕机，可以使用 redis-check-aof 工具来解决一致性的问题。</li><li>rewrite 模式可以定期对 AOF 文件重写，合并相关操作，以达到压缩存储的目的<br>缺点</li><li>AOF 文件较大，恢复速度慢</li><li>数据集大的情况下，启动比 RDB 慢</li><li>运行效率 AOF &lt; RDB</li></ul><p>4.x版本后，把重写方式变成 RDB 直接放到 AOF 文件的头部，比以前版本更快</p><h3 id="3-主从同步"><a href="#3-主从同步" class="headerlink" title="3. 主从同步"></a>3. 主从同步</h3><ul><li>全量复制：<ul><li>主节点通过 bgsave 命令 fork 子进程进行 rdb 持久化，过程非常消耗CPU，内存，硬盘io</li><li>主节点将rdb文件通过网络发给从节点，消耗带宽</li><li>从节点清空数据，使用rdb文件载入，整个过程阻塞，无法响应命令</li></ul></li><li>部分复制：<ul><li>复制偏移量，双方都要维护</li><li>复制积压缓冲区：定长FIFO的队列作为缓冲区</li></ul></li></ul><h1 id="△-36次-Redis-如何实现分布式锁？-困难"><a href="#△-36次-Redis-如何实现分布式锁？-困难" class="headerlink" title="△ 36次 Redis 如何实现分布式锁？  困难"></a><em>△ 36次</em> Redis 如何实现分布式锁？  困难</h1><p>一般可以采用 setnx 原子操作来进行加锁，常规过期时间为 1s，设置的值为随机数。对于加锁的 key，一般要和当前的操作和请求有幂等关系，防止解锁的时候把其他请求的锁解掉；另一方面如果 1s 过期时间还未执行完毕，可以考虑使用看门狗给这个锁续期。<br>对于 setnx 的解锁，可以使用 lua 脚本 ‘if redis.call(‘get’, KEYS[1]) &#x3D;&#x3D; ARGV[1] then return redis.call(‘del’, KEYS[1]) else return 0 end’ 保证解的锁就是请求刚刚申请的那个锁</p><h3 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h3><p>这个是针对于 Redis 中多 master 实例的情况来获取锁的。具体的步骤如下：</p><ul><li>获取当前毫秒单位时间</li><li>以相同的 key 和随机值在 n 个节点上请求锁，这里获取锁的尝试时间一定要远小于锁的过期时间，防止某个 master 宕机，而我们还在不断地尝试，产生较长的阻塞时间</li><li>只有在绝对大多数节点上获取了锁，且获取时间小于锁的过期时间，就认为锁获取成功了</li><li>如果获取成功，key 的真正有效时间等于过期时间时间减去获取锁所使用的时间（即还会在预设的过期时间过期掉）</li><li>如果获取失败，或者尝试时间超过了超时时间，都认为是获取失败，要将已经设置了 key 的 master 节点删除该 key</li></ul><h1 id="△-34次-Redis-序列化有哪些方式？-中等"><a href="#△-34次-Redis-序列化有哪些方式？-中等" class="headerlink" title="△ 34次 Redis 序列化有哪些方式？  中等"></a><em>△ 34次 Redis</em> 序列化有哪些方式？  中等</h1><ol><li>字符串序列化：将数据以字符串的形式进行序列化和反序列化，常用的字符串序列化方式有JSON、XML、YAML等。</li><li>二进制序列化：将数据以二进制的形式进行序列化和反序列化，常用的二进制序列化方式有MessagePack、Protocol Buffers、Thrift等。</li><li>压缩序列化：将序列化后的数据进行压缩，减小存储空间，常用的压缩序列化方式有Gzip、Snappy等。</li><li>自定义序列化：根据业务需求自定义序列化方式，可以根据数据的特点选择最合适的序列化方式，例如使用Hessian、Kryo等。</li></ol><h1 id="△-34次-简述-Redis-的哨兵机制-中等"><a href="#△-34次-简述-Redis-的哨兵机制-中等" class="headerlink" title="△ 34次 简述 Redis 的哨兵机制  中等"></a><em>△ 34次</em> 简述 Redis 的哨兵机制  中等</h1><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>当从数据库启动时，会向主数据库发送sync命令，主数据库接收到sync后开始在后台保存快照rdb，在保存快照期间收到的命令缓存起来，当快照完成时，主数据库会将快照和缓存的命令一块发送给从库。复制初始化结束。 之后，主每收到1个命令就同步发送给从。 当出现断开重连后，2.8之后的版本会将断线期间的命令传给重数据库。增量复制</p><p>主从复制是乐观复制，当客户端发送写执行给主，主执行完立即将结果返回客户端，并异步的把命令发送给从，从而不影响性能。也可以设置至少同步给多少个从主才可写。 无硬盘复制:如果硬盘效率低将会影响复制性能，2.8之后可以设置无硬盘复制，repl-diskless-sync yes</p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>哨兵的作用：<br>1、监控redis主、从数据库是否正常运行<br>2、主出现故障自动将从数据库转换为主数据库。<br>哨兵的核心知识<br>1、哨兵至少需要 3 个实例，来保证自己的健壮性。<br>2、哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。<br>3、对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。<br>4、配置哨兵监控一个系统时，只需要配置其监控主数据库即可，哨兵会自动发现所有复制该主数据库的从数据库。</p><h1 id="△-30次-简述-Redis-中如何防止缓存雪崩和缓存击穿-中等"><a href="#△-30次-简述-Redis-中如何防止缓存雪崩和缓存击穿-中等" class="headerlink" title="△ 30次 简述 Redis 中如何防止缓存雪崩和缓存击穿  中等"></a><em>△ 30次</em> 简述 Redis 中如何防止缓存雪崩和缓存击穿  中等</h1><p>数据库是架构的瓶颈，要尽量保证有效请求到达数据库，可以酌情放大链路上前置位置的复杂度和成本<br>c client；redis ； db&#x2F;mysql</p><p>穿透：缓存和db中都找不到该数据 &#x3D; db中无数据，redis无数据，大量并发，请求打到db层<br>原因：接口请求数据不是有效参数，因此根本查不到结果；有效参数但是确实没有数据<br>解法：接口层增加鉴权，业务层增加有效请求判断；返回空 &amp;&amp; 增加短效的空缓存；布隆过滤器（难道要加到每个接口上么？需要思考嗷）；业务加互斥锁；对于空值可以增加一个空缓存</p><p>击穿：热点key过期 or key从来没有被访问过 &#x3D; db中有数据，大量并发，redis无缓存，请求打到db层<br>解法：热点数据永不过期；互斥锁（挡住大量重复的并发请求）</p><p>雪崩：N个key的都过期了（没有被缓存到） &#x3D; db中有，大量并发，redis无缓存，请求打到db层<br>解法：缓存数据设置随机过期时间；增加缓存失效标记位；缓存预热；互斥锁</p><p>流程： 请求redis，查不到 –&gt; 大家抢锁 O（1） –&gt; 抢上的查db，并更新缓存 O（1） –&gt; 没抢上的重复请求Redis ，拿到数据<br>延伸问题：多个等待的请求，是blocking的轻量级进程，不参与cpu及内核调度，注意处理线程池即可</p><p>△ 30次</p><p>产生死锁的必要条件有哪些？如何解决死锁？  中等 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks.html">参考1</a> <a href="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Phyduck/database/%E5%85%A8%E5%B1%80%E9%94%81%E3%80%81%E8%A1%A8%E7%BA%A7%E9%94%81%E4%BB%A5%E5%8F%8A%E8%A1%8C%E9%94%81%EF%BC%88%E4%B8%8A%EF%BC%89.pdf">参考2</a> <a href="https://www.gatevidyalay.com/deadlock-in-os-conditions-for-deadlock/">参考3</a></p><h1 id="△-28次-简述-Redis-中常见类型的底层数据结构"><a href="#△-28次-简述-Redis-中常见类型的底层数据结构" class="headerlink" title="△ 28次 简述 Redis 中常见类型的底层数据结构"></a><em>△ 28次</em> 简述 Redis 中常见类型的底层数据结构</h1><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul><li>id&#x2F;id_info 缓存  </li><li>计数器  </li><li>setnx 分布式锁 <ul><li>setnx 的时候会传入一个随机值</li><li>解锁：‘if redis.call(‘get’, KEYS[1]) &#x3D;&#x3D; ARGV[1] then return redis.call(‘del’, KEYS[1]) else return 0 end’</li><li>lua脚本</li></ul></li><li>分布式ID </li><li>sds（动态简单字符串）<ul><li>底层结构为：<ul><li>len buf中已经占有的长度(表示此字符串的实际长度)</li><li>free buf中未使用的缓冲区长度</li><li>buf[] 实际保存字符串数据的地方</li></ul></li><li>读取时间复杂度为 O(1)</li><li>惰性删除，留待下次使用</li><li>一次分配最大为 128kb<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3></li></ul></li><li>当队列用，最近100个购买用户信息  </li><li>当栈用  </li><li>元素可重复</li><li>非实时分页列表，比如小时榜，日榜，周榜</li><li>存储微博、微信公众号等消息流数据</li><li>等于链表，插入删除 O(1)，查找 O(n)</li><li>底层是一个叫做 quicklist 的节点，相当于由 ziplist 节点组成的双向链表<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3></li><li>相比string获取单个字段节省 序列化与反序列化操作</li><li>相当于 HashMap ，由数组加链表组合而成，当一维的 hash 数组碰撞时，用链表串起来</li><li>底层实现方式有两种，数据量少的时候是 ziplist；量大时转为 Hashtable</li><li>hashtable 由 size、used、哈希节点数组组成；<ul><li>hash节点就是 kv 键值对，并且用链地址法处理冲突<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3></li></ul></li><li>取交、并、差集  </li><li>点赞、收藏、关注等…  </li><li>kv 模式</li><li>内部元素不重复<h3 id="sorted-set（zset）"><a href="#sorted-set（zset）" class="headerlink" title="sorted set（zset）"></a>sorted set（zset）</h3></li><li>排行榜功能，实时分页列表，实时榜单等</li><li>延迟队列，score 存储过期时间，从小到大排序，最靠前的就是最先到期的数据。</li><li>set 基础上增加了分数</li><li>结构上是由一个 dict 和一个跳表组成，dict 保证 key 唯一性</li><li>插入删除都是 O(log n)，查找 O(logn)</li><li>一大优点是可以对分数进行范围查找 zrange</li><li>少量数据按照 ziplist 存储，member和score顺序存放并按score的顺序排列；元素数量 &lt; 128，元素大小 &lt; 64kb</li><li>大量数据按照跳表存储</li></ul><h1 id="△-28次-简述什么是最左匹配原则-简单"><a href="#△-28次-简述什么是最左匹配原则-简单" class="headerlink" title="△ 28次 简述什么是最左匹配原则  简单"></a><em>△ 28次</em> 简述什么是最左匹配原则  简单</h1><p>mysql 建立联合索引后，是按最左匹配原则来筛选记录的，即检索数据是从联合索引的第一个字段来筛选的。如果 where 里的条件只有第二个字段，那么将无法应用到索引。</p><h1 id="△-26次-简述-Redis-的过期机制和内存淘汰策略-困难"><a href="#△-26次-简述-Redis-的过期机制和内存淘汰策略-困难" class="headerlink" title="△ 26次 简述 Redis 的过期机制和内存淘汰策略  困难"></a><em>△ 26次</em> 简述 Redis 的过期机制和内存淘汰策略  困难</h1><h3 id="过期机制"><a href="#过期机制" class="headerlink" title="过期机制"></a>过期机制</h3><ol><li>惰性过期：访问一个 key 的时候才判断这个 key 是否已经过期，该策略可以最大化的节省 CPU 资源，但是对内存不友好，会存在大量的过期 key 没有被再次访问，从而不会被清除，占用内存，造成泄漏</li><li>定期过期：每隔一定的时间，扫描数据库中一定量的 expire 字典中的 key，并清除其中已经过期的 key。该策略是前两者的一个折中方案，通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使内存和 CPU 达到最优平衡。<strong>特点：随机抽取检查</strong>，缺点是实际操作中很难界定时间间隔和限定耗时。</li><li>二种策略同时生效<h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><h4 id="常见的六种淘汰策略"><a href="#常见的六种淘汰策略" class="headerlink" title="常见的六种淘汰策略"></a>常见的六种淘汰策略</h4></li></ol><ul><li>noeviction: 不删除策略， 达到最大内存限制时， 如果需要更多内存， 直接返回错误信息。 大多数写命令都会导致占用更多的内存(有极少数会例外， 如 DEL )</li><li>allkeys-lru: 所有key通用; 优先删除最近最少使用(less recently used ，LRU) 的 key</li><li>volatile-lru: 只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ，LRU) 的 key</li><li>allkeys-random: 所有key通用; 随机删除一部分 key</li><li>volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key</li><li>volatile-ttl: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live，TTL) 短的key<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4></li><li>如果分为热数据与冷数据， 推荐使用 allkeys-lru 策略；也就是， 其中一部分key经常被读写. 如果不确定具体的业务特征， 那么 allkeys-lru 是一个很好的选择</li><li>如果需要循环读写所有的key， 或者各个key的访问频率差不多， 可以使用 allkeys-random 策略， 即读写所有元素的概率差不多</li><li>假如要让 Redis 根据 TTL 来筛选需要删除的key， 请使用 volatile-ttl 策略<br>volatile-lru 和 volatile-random 策略主要应用场景是: 既有缓存，又有持久key的实例中。一般来说， 像这类场景， 应该使用两个单独的 Redis 实例<br>值得一提的是， 设置 expire 会消耗额外的内存， 所以使用 allkeys-lru 策略， 可以更高效地利用内存， 因为这样就可以不再设置过期时间了<h4 id="淘汰的内部实现"><a href="#淘汰的内部实现" class="headerlink" title="淘汰的内部实现"></a>淘汰的内部实现</h4>淘汰过程可以这样理解：</li><li>应用执行一个命令， 导致 Redis 中的数据增加，占用更多内存</li><li>Redis 检查内存使用量， 如果超出 <code>maxmemory</code> （redis.conf中配置）限制，根据策略清除部分 key</li><li>继续执行下一条命令， 以此类推<br>在这个过程中， 内存使用量会不断地达到 limit 值， 然后超过， 然后删除部分 key， 使用量又下降到 limit 值之下<br>如果某个命令导致大量内存占用(比如通过新key保存一个很大的set)， 在一段时间内， 可能内存的使用量会明显超过 maxmemory 限制</li></ul><p>△ 24次</p><p>数据库有哪些常见索引？数据库设计的范式是什么？  中等 <a href="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Phyduck/database/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20InnoDB%20Index.pdf">参考1</a></p><h1 id="△-24次-简述乐观锁以及悲观锁的区别以及使用场景-简单"><a href="#△-24次-简述乐观锁以及悲观锁的区别以及使用场景-简单" class="headerlink" title="△ 24次 简述乐观锁以及悲观锁的区别以及使用场景  简单"></a><em>△ 24次</em> 简述乐观锁以及悲观锁的区别以及使用场景  简单</h1><p>悲观锁（Pessimistic Lock）：<br>总是担心数据被修改，每次使用数据都要加锁，使用结束以后解锁，期间所有其他线程等待。<br>乐观锁（Optimistic Lock）：<br>不担心数据被修改，使用数据不加锁，但是更新数据时会判断是否有其他人修改过，如果已经被修改，就不继续修改。</p><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>悲观锁：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。<br>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</p><h1 id="△-24次-MySQL-中-join-与-left-join-的区别是什么？-简单"><a href="#△-24次-MySQL-中-join-与-left-join-的区别是什么？-简单" class="headerlink" title="△ 24次 MySQL 中 join 与 left join 的区别是什么？  简单"></a><em>△ 24次</em> MySQL 中 join 与 left join 的区别是什么？  简单</h1><p>join &#x3D; inner join 返回两个表中都有的数据<br>left join 以左表为基准，返回左表中的所有数据结果，右表中不存在的值一般为 null</p><p>△ 24次</p><p>简述 MySQL MVCC 的实现原理  困难 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html">参考1</a></p><p>△ 22次</p><p>简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？  中等 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html">参考1</a> <a href="https://cloud.tencent.com/developer/article/1450773">参考2</a></p><p>△ 20次</p><p>Redis 有几种数据结构？Zset 是如何实现的？  中等 <a href="https://redis.io/topics/data-types">参考1</a> <a href="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Phyduck/database/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.pdf">参考2</a></p><h1 id="△-20次-简述-Redis-中跳表的应用以及优缺点-中等"><a href="#△-20次-简述-Redis-中跳表的应用以及优缺点-中等" class="headerlink" title="△ 20次 简述 Redis 中跳表的应用以及优缺点  中等"></a><em>△ 20次</em> 简述 Redis 中跳表的应用以及优缺点  中等</h1><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>我们知道单链表查询的时间复杂度为O(n)，而插入、删除操作需要先找到对应的位置，所以插入、删除的时间复杂度也是O(n)。<br>那么，跳表的时间复杂度是多少呢？<br>如果按照标准的跳表来看的话，每一级索引减少k&#x2F;2个元素（k为其下面一级索引的个数），那么整个跳表的高度就是(log n)。<br>学习过平衡二叉树的同学都知道，它的时间复杂度与树的高度成正比，即O(log n)。<br>所以，这里跳表的时间复杂度也是O(log n)。（这里不一步步推倒了，只要记住，查询时每次减少一半的元素的时间复杂度都是O(log n)，比如二叉树的查找、二分法查找、归并排序、快速排序）</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>我们还是以标准的跳表来分析，每两个元素向上提取一个元素，那么，最后额外需要的空间就是：<br>n&#x2F;2 + (n&#x2F;2)^2 + (n&#x2F;2)^3 + … + 8 + 4 + 2 &#x3D; n - 2<br>所以，跳表的空间复杂度是O(n)。</p><h3 id="随机层数"><a href="#随机层数" class="headerlink" title="随机层数"></a>随机层数</h3><p>在新增节点时会计算当前节点应该放置的层数，表面上是按照随机数计算出来的。<br>跳表通常需要有一个最大层数maxLevel，以及一个概率p，即新增加一层的概率。通常数据量够大，就会呈现出一定的比率。<br>当p是0.25，那么只有产生一层的概率就是1-p（0.75），产生第二层的概率就是（1-p） * p。三层（1-p）pp…<br>因此，一个节点的平均层数（也即包含的平均指针数目）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>（1）跳表是可以实现二分查找的有序链表；<br>（2）每个元素插入时随机生成它的level；<br>（3）最低层包含所有的元素；<br>（4）如果一个元素出现在level(x)，那么它肯定出现在x以下的level中；<br>（5）每个索引节点包含两个指针，一个向下，一个向右；<br>（6）跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近；</p><h1 id="△-18次-聚簇索引和非聚簇索引有什么区别？-简单"><a href="#△-18次-聚簇索引和非聚簇索引有什么区别？-简单" class="headerlink" title="△ 18次 聚簇索引和非聚簇索引有什么区别？  简单"></a><strong>△ 18次</strong> 聚簇索引和非聚簇索引有什么区别？  简单</h1><p>聚簇索引（Clustered Index）和非聚簇索引（Non-Clustered Index），也称为二级索引或非聚集索引，是数据库索引的两种主要类型，它们在结构和性能方面有显著的区别：</p><ol><li><p><strong>存储结构</strong>：</p><ul><li><strong>聚簇索引</strong>：在聚簇索引中，索引的构建与表数据是一起存储的。这意味着索引的叶节点直接包含行数据或指向行数据的指针。由于数据按索引顺序存储，聚簇索引可以快速检索数据。</li><li><strong>非聚簇索引</strong>：在非聚簇索引中，索引结构是独立的，并且索引的叶节点包含指向表数据的指针（如行ID）。这意味着索引和数据分开存储，非聚簇索引用于快速定位到数据行，但可能需要额外的I&#x2F;O操作来检索实际的数据。</li></ul></li><li><p><strong>物理顺序</strong>：</p><ul><li>聚簇索引的物理顺序与索引顺序相同，即数据行是按照索引的顺序来存储的。</li><li>非聚簇索引的物理顺序与索引顺序可以不同，数据行的存储顺序与索引顺序是独立的。</li></ul></li><li><p><strong>一个表中的索引数量</strong>：</p><ul><li><strong>聚簇索引</strong>：一个表只能有一个聚簇索引，因为表数据本身只能按一种顺序存储。</li><li><strong>非聚簇索引</strong>：一个表可以有多个非聚簇索引，每个索引都可以提供访问数据的不同路径。</li></ul></li><li><p><strong>性能</strong>：</p><ul><li>聚簇索引由于数据和索引在一起，对于范围查询和顺序访问非常高效。</li><li>非聚簇索引在执行查找时可能需要两次查找：首先在索引中查找行的指针，然后在表数据中检索实际数据。</li></ul></li><li><p><strong>更新性能</strong>：</p><ul><li>更新聚簇索引可能更昂贵，因为可能需要移动数据行来维护索引的物理顺序。</li><li>非聚簇索引的更新通常更快，因为只需更新索引页，不需要移动数据行。</li></ul></li><li><p><strong>主键约束</strong>：</p><ul><li>通常，表的主键会自动创建一个聚簇索引，除非明确指定使用非聚簇索引。</li><li>非聚簇索引可以通过唯一约束或索引命令显式创建。</li></ul></li><li><p><strong>使用场景</strong>：</p><ul><li>聚簇索引适合于经常通过索引值访问数据的场景，如主键查询。</li><li>非聚簇索引适合于需要多种不同方式访问数据的场景，可以提高查询的灵活性。</li></ul></li></ol><p>理解聚簇索引和非聚簇索引的区别对于数据库设计和性能优化非常重要，合理的索引设计可以显著提高数据库的查询效率和整体性能。</p><h1 id="△-17次-MySQL-中-varchar-和-char-的区别是什么？-简单"><a href="#△-17次-MySQL-中-varchar-和-char-的区别是什么？-简单" class="headerlink" title="△ 17次 MySQL 中 varchar 和 char 的区别是什么？  简单"></a><em>△ 17次</em> MySQL 中 varchar 和 char 的区别是什么？  简单</h1><h3 id="CHAR"><a href="#CHAR" class="headerlink" title="CHAR"></a>CHAR</h3><ul><li>固定长度：CHAR 类型用于存储固定长度的字符串。不管实际存储的数据长度是多少，CHAR 类型的列都会在存储时填充空格（空格补齐）到指定长度。</li><li>存储效率：由于长度固定，CHAR 类型在存储时效率较高，因为 MySQL 可以直接定位到特定行的位置。</li><li>适用场景：适合存储长度固定的数据，例如国家代码、邮政编码等。<h3 id="VARCHAR"><a href="#VARCHAR" class="headerlink" title="VARCHAR"></a>VARCHAR</h3></li><li>可变长度：VARCHAR 类型用于存储可变长度的字符串。它只会存储实际使用的字符数，并在存储时附加一个额外字节（或两个字节，如果字符串长度超过 255）来记录字符串的长度。</li><li>存储效率：由于长度可变，VARCHAR 类型在插入和检索数据时可能需要更多的处理时间，但在存储空间的使用上更为灵活。</li><li>适用场景：适合存储长度不固定的数据，例如名字、地址、描述等。</li></ul><h1 id="△-16次-简述数据库中的-ACID-分别是什么？-简单"><a href="#△-16次-简述数据库中的-ACID-分别是什么？-简单" class="headerlink" title="△ 16次* 简述数据库中的 ACID 分别是什么？  简单"></a>△ 16次* 简述数据库中的 ACID 分别是什么？  简单</h1><ul><li><strong>原子性(Atomicity)：</strong>事务是一个不可分割的单位，因此在一个事务里的所有操作要么全部生效，要么全部不生效。</li><li><strong>一致性(Consistency)：</strong>也可以理解为是预期状态的正确性，即从一个正确的状态到另一个正确的状态，这里的状态往往是由业务来定义的。比如转账中的一个扣钱一个加钱，是我们规定的一个数据流转，那么执行前的账户余额和转账后的账户余额就得满足加减特性，这就是所谓的业务正确。题外话：银行家舍入 —— 四舍六入五考虑，五后非零则进一，五后皆零看奇偶，奇进偶舍不连续。</li><li><strong>隔离性(Isolation)：</strong>事务并发执行时，各个事务之间相互影响的程度。</li><li><strong>持久化(Durability)：</strong>通过日志等手段，只要我们的事务提交成功了，那么就意味着这次的数据操作是成功的。即使下次重启了程序，也不会丢失此处的操作结果。</li></ul><p>△ 16次</p><p>简述 MySQL 三种日志的使用场景  中等 <a href="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Phyduck/database/InnoDB-WAL.pdf">参考1</a> <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-log.html">参考2</a></p><p>△ 16次</p><p>模糊查询是如何实现的？  简单</p><p>△ 14次</p><p>并发事务会引发哪些问题？如何解决？  中等</p><p>△ 12次</p><p>什么是数据库事务，MySQL 为什么会使用 InnoDB 作为默认选项</p><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>可以简单的理解为有一批哈希函数，对将要存储的内容进行哈希计算，每个哈希函数的结果对应一个 bit 位，如果命中了结果，就将对应 bit 位置为1。那么当这个数据查询请求再次来到时，比较哈希函数结果位是否都为1，就可以知道这个数据是不是在我们的集合内了。<br>值得一提的是，当存储的内容很大时，可能大部分 bit 位都被标记为1了，存在误判的可能。<br>即布隆过滤器中查到的元素可能存在在集合中，但是查不到的元素一定不在</p><h3 id="常见应用："><a href="#常见应用：" class="headerlink" title="常见应用："></a>常见应用：</h3><ul><li>网页爬虫对 URL 去重，避免爬取相同的 URL 地址；</li><li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱；</li></ul><p>遇见慢查询如何查看执行计划<br>2024-02-05 京东<br>可以开启慢查询日志，使用 EXPLAIN 语句来查看执行计划。<br>通过分析执行计划，可以了解数据库如何执行查询语句的。在执行计划中，表的访问方式、使用的索引、行数估计等信息，都可能通过调整来提高查询性能。</p><p>MySQL 的索引机制<br>2024-02-28 阿里<br>B-tree索引：<br>B-tree（Balanced Tree）是一种平衡树结构，用于实现对数据的快速查找。MySQL的B-tree索引是基于这种数据结构实现的，包括以下几种类型：<br>普通索引（Normal Index）： 普通的B-tree索引，没有任何限制。<br>唯一索引（Unique Index）： 确保索引列的所有值都是唯一的，不允许重复。<br>主键索引（Primary Key Index）： 主键是一种特殊的唯一索引，用于唯一标识每一条记录。<br>组合索引（Composite Index）： 使用多个列组合成一个索引，可以提高查询的效率。<br>哈希索引：<br>哈希索引是基于哈希表实现的索引，适用于等值查询。相比B-tree索引，哈希索引在等值查询时速度更快，但在范围查询和排序等操作上性能较差。<br>哈希索引的主要特点：<br>适用于等值查询，例如WHERE column &#x3D; value。<br>不支持范围查询和排序操作。<br>不支持部分索引查询。<br>对于哈希冲突（多个不同的键值映射到同一个哈希桶）的处理通常通过链表等方式实现。</p><p>MySQL 如何避免死锁<br>2024-02-12 bilibili<br>死锁是无法完全避免的，但可以通过一些手段降低死锁发生概率。</p><p>缩短锁持有的时间<br>减少间隙锁<br>减少加锁范围<br>设置 MySQL 参数<br>设置锁等待超时参数：innodb_lock_wait_timeout<br>开启主动死锁检测：innodb_deadlock_detect</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang GC 详解</title>
      <link href="/library/Golang/advanced-tutorial/go-gc/"/>
      <url>/library/Golang/advanced-tutorial/go-gc/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 进阶教程笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>go-sync-map</title>
      <link href="/library/Golang/concurrency/go-sync-map/"/>
      <url>/library/Golang/concurrency/go-sync-map/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet212</title>
      <link href="/interview/juan/neet150/tries/leet212/"/>
      <url>/interview/juan/neet150/tries/leet212/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Tries </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet211</title>
      <link href="/interview/juan/neet150/tries/leet211/"/>
      <url>/interview/juan/neet150/tries/leet211/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Tries </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.208 实现 Trie (前缀树)</title>
      <link href="/interview/juan/neet150/tries/leet-208-implement-trie-prefix-tree/"/>
      <url>/interview/juan/neet150/tries/leet-208-implement-trie-prefix-tree/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></p><p>**<a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a>**（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>示例：</strong></p><pre><code>输入[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;][[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]输出[null, null, true, false, true, null, true]解释Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;);   // 返回 Truetrie.search(&quot;app&quot;);     // 返回 Falsetrie.startsWith(&quot;app&quot;); // 返回 Truetrie.insert(&quot;app&quot;);trie.search(&quot;app&quot;);     // 返回 True</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li><li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li><li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 104</code> 次</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">children []*Trie</span><br><span class="line">isEnd <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> Trie &#123;</span><br><span class="line"><span class="keyword">return</span> Trie&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span></span> Insert(word <span class="type">string</span>) &#123;</span><br><span class="line">node := this</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">ch -= <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">if</span> node.children[ch] == <span class="literal">nil</span> &#123;</span><br><span class="line">node.children[ch] = &amp;Trie&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">node = node.children[ch]</span><br><span class="line">&#125;</span><br><span class="line">node.isEnd = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span></span> SearchPrefix(prefix <span class="type">string</span>) *Trie &#123;</span><br><span class="line">node := this</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> prefix &#123;</span><br><span class="line">ch -= <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">if</span> node.children[ch] == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">node = node.children[ch]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span></span> Search(word <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">node := this.SearchPrefix(word)</span><br><span class="line"><span class="keyword">return</span> node != <span class="literal">nil</span> &amp;&amp; node.isEnd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span></span> StartsWith(prefix <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> this.SearchPrefix(prefix) != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">* obj := Constructor();</span></span><br><span class="line"><span class="comment">* obj.Insert(word);</span></span><br><span class="line"><span class="comment">* param_2 := obj.Search(word);</span></span><br><span class="line"><span class="comment">* param_3 := obj.StartsWith(prefix);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Tries </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet235</title>
      <link href="/interview/juan/neet150/trees/leet235/"/>
      <url>/interview/juan/neet150/trees/leet235/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Trees </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet230</title>
      <link href="/interview/juan/neet150/trees/leet230/"/>
      <url>/interview/juan/neet150/trees/leet230/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Trees </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.98 验证二叉搜索树</title>
      <link href="/interview/juan/neet150/trees/leet-98-validate-binary-search-tree/"/>
      <url>/interview/juan/neet150/trees/leet-98-validate-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">Leetcode.98 验证二叉搜索树</a></p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg"></p><pre><code>输入：root = [2,1,3]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg"></p><pre><code>输入：root = [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123; </span><br><span class="line">stack := []*TreeNode&#123;&#125; </span><br><span class="line">inorder := math.MinInt64 </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> || root != <span class="literal">nil</span> &#123; </span><br><span class="line"><span class="keyword">for</span> root != <span class="literal">nil</span> &#123; </span><br><span class="line">stack = <span class="built_in">append</span>(stack, root) </span><br><span class="line">root = root.Left </span><br><span class="line">&#125; </span><br><span class="line">root = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] </span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>] </span><br><span class="line"><span class="keyword">if</span> root.Val &lt;= inorder &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">&#125; </span><br><span class="line">inorder = root.Val </span><br><span class="line">root = root.Right </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST2</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123; </span><br><span class="line"><span class="keyword">return</span> helper(root, math.MinInt64, math.MaxInt64) </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode, lower, upper <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; </span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> root.Val &lt;= lower || root.Val &gt;= upper &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> helper(root.Left, lower, root.Val) &amp;&amp; helper(root.Right, root.Val, upper) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Trees </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.105 从前序与中序遍历序列构造二叉树</title>
      <link href="/interview/juan/neet150/trees/leet-105-construct-binary-tree-from-preorder-and-inorder-traversal/"/>
      <url>/interview/juan/neet150/trees/leet-105-construct-binary-tree-from-preorder-and-inorder-traversal/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg"></p><pre><code>输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]输出: [3,9,20,null,null,15,7]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: preorder = [-1], inorder = [-1]输出: [-1]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li><li><code>inorder</code> 均出现在 <code>preorder</code></li><li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li><li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Left *TreeNode</span></span><br><span class="line"><span class="comment">* Right *TreeNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="type">int</span>, inorder []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">root := &amp;TreeNode&#123;preorder[<span class="number">0</span>], <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ;i&lt;<span class="built_in">len</span>(inorder); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> inorder[i] == preorder[<span class="number">0</span>] &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">root.Left = buildTree(preorder[<span class="number">1</span>:<span class="built_in">len</span>(inorder[:i])+<span class="number">1</span>], inorder[:i])</span><br><span class="line">root.Right = buildTree(preorder[<span class="built_in">len</span>(inorder[:i])+<span class="number">1</span>:], inorder[i+<span class="number">1</span>:])</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Trees </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.297 二叉树的序列化与反序列化</title>
      <link href="/interview/juan/neet150/trees/leet-297-serialize-and-deserialize-binary-tree/"/>
      <url>/interview/juan/neet150/trees/leet-297-serialize-and-deserialize-binary-tree/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></p><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>提示:</strong> 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a href="https://support.leetcode.cn/hc/kb/article/1567641/">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg"></p><pre><code>输入：root = [1,2,3,null,null,4,5]输出：[1,2,3,null,null,4,5]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [1]输出：[1]</code></pre><p><strong>示例 4：</strong></p><pre><code>输入：root = [1,2]输出：[1,2]</code></pre><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 104]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Codec <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> (_ Codec) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Codec)</span></span> serialize(root *TreeNode) <span class="type">string</span> &#123;</span><br><span class="line">    sb := &amp;strings.Builder&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            sb.WriteString(<span class="string">&quot;null,&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        sb.WriteString(strconv.Itoa(node.Val))</span><br><span class="line">        sb.WriteByte(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        dfs(node.Left)</span><br><span class="line">        dfs(node.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> sb.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Codec)</span></span> deserialize(data <span class="type">string</span>) *TreeNode &#123;</span><br><span class="line">    sp := strings.Split(data, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> build <span class="function"><span class="keyword">func</span><span class="params">()</span></span> *TreeNode</span><br><span class="line">    build = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> *TreeNode &#123;</span><br><span class="line">        <span class="keyword">if</span> sp[<span class="number">0</span>] == <span class="string">&quot;null&quot;</span> &#123;</span><br><span class="line">            sp = sp[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        val, _ := strconv.Atoi(sp[<span class="number">0</span>])</span><br><span class="line">        sp = sp[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> &amp;TreeNode&#123;val, build(), build()&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Trees </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.102 二叉树的层序遍历</title>
      <link href="/interview/juan/neet150/trees/leet-102-binary-tree-level-order-traversal/"/>
      <url>/interview/juan/neet150/trees/leet-102-binary-tree-level-order-traversal/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg"></p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1]输出：[[1]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><p>一定记得函数要先判断节点是否为 nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Left *TreeNode</span></span><br><span class="line"><span class="comment">* Right *TreeNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stack []*TreeNode</span><br><span class="line">  </span><br><span class="line">stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line">ans := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; <span class="built_in">len</span>(stack)&gt;<span class="number">0</span>; i++ &#123;</span><br><span class="line">ans = <span class="built_in">append</span>(ans, []<span class="type">int</span>&#123;&#125;)</span><br><span class="line">nextstack := []*TreeNode&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(stack); j++ &#123;</span><br><span class="line">nod := stack[j]</span><br><span class="line">ans[i] = <span class="built_in">append</span>(ans[i], nod.Val)</span><br><span class="line"><span class="keyword">if</span> nod.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">nextstack = <span class="built_in">append</span>(nextstack, nod.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> nod.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">nextstack = <span class="built_in">append</span>(nextstack, nod.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">stack = nextstack</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Trees </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.124 二叉树中的最大路径和</title>
      <link href="/interview/juan/neet150/trees/leet-124-binary-tree-maximum-path-sum/"/>
      <url>/interview/juan/neet150/trees/leet-124-binary-tree-maximum-path-sum/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></p><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg"></p><pre><code>输入：root = [1,2,3]输出：6解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg"></p><pre><code>输入：root = [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围是 <code>[1, 3 * 104]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Left *TreeNode</span></span><br><span class="line"><span class="comment">* Right *TreeNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxPathSum</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">maxSum := math.MinInt32</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> gain <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span> <span class="type">int</span></span><br><span class="line">gain = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">leftGain := max(<span class="number">0</span>, gain(node.Left))</span><br><span class="line">rightGain := max(<span class="number">0</span>, gain(node.Right))</span><br><span class="line">  </span><br><span class="line">pathMax := node.Val + leftGain + rightGain</span><br><span class="line">maxSum = max(maxSum, pathMax)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 节点贡献值需要只取一边</span></span><br><span class="line"><span class="keyword">return</span> node.Val + max(leftGain, rightGain)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">gain(root)</span><br><span class="line"><span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Trees </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet226</title>
      <link href="/interview/juan/neet150/trees/leet1448/"/>
      <url>/interview/juan/neet150/trees/leet1448/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Trees </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet226</title>
      <link href="/interview/juan/neet150/trees/leet110/"/>
      <url>/interview/juan/neet150/trees/leet110/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Trees </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet226</title>
      <link href="/interview/juan/neet150/trees/leet226/"/>
      <url>/interview/juan/neet150/trees/leet226/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Trees </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet226</title>
      <link href="/interview/juan/neet150/trees/leet543/"/>
      <url>/interview/juan/neet150/trees/leet543/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Trees </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.100 相同的树</title>
      <link href="/interview/juan/neet150/trees/leet-100-same-tree/"/>
      <url>/interview/juan/neet150/trees/leet-100-same-tree/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></p><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg"></p><pre><code>输入：p = [1,2,3], q = [1,2,3]输出：true</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg"></p><pre><code>输入：p = [1,2], q = [1,null,2]输出：false</code></pre><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg"></p><pre><code>输入：p = [1,2,1], q = [1,1,2]输出：false</code></pre><p><strong>提示：</strong></p><ul><li>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Left *TreeNode</span></span><br><span class="line"><span class="comment">* Right *TreeNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSameTree</span><span class="params">(p *TreeNode, q *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> &amp;&amp; q == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || q == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p.Val != q.Val &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p.Val == q.Val &amp;&amp; isSameTree(p.Left, q.Left) &amp;&amp; isSameTree(p.Right, q.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Trees </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.104 二叉树的最大深度</title>
      <link href="/interview/juan/neet150/trees/leet-104-maximum-depth-of-binary-tree/"/>
      <url>/interview/juan/neet150/trees/leet-104-maximum-depth-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p><p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p><p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg"></p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：3</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1,null,2]输出：2</code></pre><p><strong>提示：</strong></p><ul><li>树中节点的数量在 <code>[0, 104]</code> 区间内。</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Left *TreeNode</span></span><br><span class="line"><span class="comment">* Right *TreeNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max(maxDepth(root.Left), maxDepth(root.Right)) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Trees </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet295</title>
      <link href="/interview/juan/neet150/heap-queue/leet295/"/>
      <url>/interview/juan/neet150/heap-queue/leet295/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Heap &amp; Priority Queue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet347</title>
      <link href="/uncategorized/leet347/"/>
      <url>/uncategorized/leet347/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.23 合并K个升序链表</title>
      <link href="/interview/juan/neet150/heap-queue/leet-23-merge-k-sorted-lists/"/>
      <url>/interview/juan/neet150/heap-queue/leet-23-merge-k-sorted-lists/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">Leetcode.23 合并K个升序链表</a></p><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><pre><code>输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：lists = []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：lists = [[]]输出：[]</code></pre><p><strong>提示：</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li><li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li></ul><p><strong>解法：</strong><br>利用小根堆思路，把每个链表的头结点按照小根堆排列，pop 出来的节点取下来放到结果链表上，然后再将新的头结点 push 进去，重复此过程即可得到所求</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">impost (</span><br><span class="line"><span class="string">&quot;container/heap&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">/** * Definition for singly-linked list. * </span></span><br><span class="line"><span class="comment">type ListNode struct &#123; </span></span><br><span class="line"><span class="comment">* Val int </span></span><br><span class="line"><span class="comment">* Next *ListNode </span></span><br><span class="line"><span class="comment">&#125; */</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123; </span><br><span class="line">pq := hp&#123;&#125; </span><br><span class="line"><span class="keyword">for</span> _, head := <span class="keyword">range</span> lists &#123; </span><br><span class="line"><span class="keyword">if</span> head != <span class="literal">nil</span> &#123; </span><br><span class="line">pq = <span class="built_in">append</span>(pq, head) </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">heap.Init(&amp;pq) </span><br><span class="line">dummy := &amp;ListNode&#123;&#125; </span><br><span class="line">cur := dummy </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(pq) &gt; <span class="number">0</span> &#123; </span><br><span class="line">cur.Next = heap.Pop(&amp;pq).(*ListNode) </span><br><span class="line">cur = cur.Next </span><br><span class="line"><span class="keyword">if</span> cur.Next != <span class="literal">nil</span> &#123; </span><br><span class="line">heap.Push(&amp;pq, cur.Next) </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> dummy.Next </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> hp []*ListNode </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h hp)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125; </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h hp)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i].Val &lt; h[j].Val &#125; </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h hp)</span></span> Swap(i, j <span class="type">int</span>) &#123; h[i], h[j] = h[j], h[i] &#125; </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hp)</span></span> Push(v any) &#123; </span><br><span class="line">*h = <span class="built_in">append</span>(*h, v.(*ListNode)) </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hp)</span></span> Pop() any &#123; </span><br><span class="line">a := *h</span><br><span class="line">v := a[<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line">*h = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> v </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>左右分治 + 合并两个有序链表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Next *ListNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(lists) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(lists) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">n := <span class="built_in">len</span>(lists)</span><br><span class="line">left := mergeKLists(lists[:n/<span class="number">2</span>])</span><br><span class="line">right := mergeKLists(lists[n/<span class="number">2</span>:])</span><br><span class="line"><span class="keyword">return</span> merge2Lists(left, right)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge2Lists</span><span class="params">(h1, h2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">t, t1, t2 := dummy, h1, h2</span><br><span class="line"><span class="keyword">for</span> t1 != <span class="literal">nil</span> &amp;&amp; t2 != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> t1.Val &lt;= t2.Val &#123;</span><br><span class="line">t.Next = t1</span><br><span class="line">t1 = t1.Next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">t.Next = t2</span><br><span class="line">t2 = t2.Next</span><br><span class="line">&#125;</span><br><span class="line">t = t.Next</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> t1 != <span class="literal">nil</span> &#123;</span><br><span class="line">t.Next = t1</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> t2 != <span class="literal">nil</span> &#123;</span><br><span class="line">t.Next = t2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Heap &amp; Priority Queue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.647 回文子串</title>
      <link href="/interview/juan/neet150/1-d-dp/leet-647-palindromic-substrings/"/>
      <url>/interview/juan/neet150/1-d-dp/leet-647-palindromic-substrings/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></p><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;abc&quot;输出：3解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;aaa&quot;输出：6解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 由小写英文字母组成</li></ul><p>学习中心扩散法的 dp</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSubstrings</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(s)</span><br><span class="line"><span class="keyword">if</span> n&lt;<span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">bool</span>, n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">dp[i][i] = <span class="literal">true</span></span><br><span class="line">ans += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> L:=<span class="number">2</span>; L&lt;=n; L++ &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n-L+<span class="number">1</span>; i++ &#123;</span><br><span class="line">j := i+L<span class="number">-1</span></span><br><span class="line"><span class="keyword">if</span> s[i] != s[j] &#123;</span><br><span class="line">dp[i][j] = <span class="literal">false</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> j-i&lt;<span class="number">3</span> &#123;</span><br><span class="line">dp[i][j] = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> dp[i][j] &#123;</span><br><span class="line">ans += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> 1-D DP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.5 最长回文子串</title>
      <link href="/interview/juan/neet150/1-d-dp/leet-5-longest-palindromic-substring/"/>
      <url>/interview/juan/neet150/1-d-dp/leet-5-longest-palindromic-substring/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></p><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文子串。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;babad&quot;输出：&quot;bab&quot;解释：&quot;aba&quot; 同样是符合题意的答案。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;cbbd&quot;输出：&quot;bb&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><p><strong>解答：</strong></p><ul><li>动规<br>首先确定几个规则：单个字符本身符合回文结构；连续两个字符如果相同，他们也符合回文结构；假设子串起止索引为 i，j 且 s[i] &#x3D;&#x3D; s[j]，那么他们的回文结构状态应该与 i+1，j-1 的子串相同。<br>因此可以得到状态转移方程，我们可以从子串长度为 2 开始求解，向外层拓展。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(s)</span><br><span class="line"><span class="keyword">if</span> n&lt;<span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意结果的初值，第一个字符本身就是回文，可以放到结果中记录</span></span><br><span class="line">res := <span class="type">string</span>(s[<span class="number">0</span>])</span><br><span class="line">  </span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">bool</span>, n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line"><span class="comment">// 每个单独的 ch 都是回文结构</span></span><br><span class="line">dp[i][i] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// L 为枚举的子串长度</span></span><br><span class="line"><span class="keyword">for</span> L:=<span class="number">2</span>; L&lt;=n; L++ &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n-L+<span class="number">1</span>; i++ &#123;</span><br><span class="line">j := i+L<span class="number">-1</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> s[i] != s[j] &#123;</span><br><span class="line">dp[i][j] = <span class="literal">false</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> j-i&lt;<span class="number">3</span> &#123; <span class="comment">// s[i] == s[j] &amp;&amp; L&lt;3 // 两个连续相同的 ch 符合回文结构</span></span><br><span class="line">dp[i][j] = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] <span class="comment">// 由内向外扩散</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 是回文，且比以前记录的长，更新</span></span><br><span class="line"><span class="keyword">if</span> dp[i][j] &amp;&amp; j-i+<span class="number">1</span> &gt; <span class="built_in">len</span>(res) &#123;</span><br><span class="line">res = s[i:j+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> 1-D DP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.125 验证回文串</title>
      <link href="/interview/juan/neet150/two-ptr/leet-125-valid-palindrome/"/>
      <url>/interview/juan/neet150/two-ptr/leet-125-valid-palindrome/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/valid-palindrome/">125. 验证回文串</a></p><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 <strong>回文串</strong> 。</p><p>字母和数字都属于字母数字字符。</p><p>给你一个字符串 <code>s</code>，如果它是 <strong>回文串</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入: s = &quot;A man, a plan, a canal: Panama&quot;输出：true解释：&quot;amanaplanacanalpanama&quot; 是回文串。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;race a car&quot;输出：false解释：&quot;raceacar&quot; 不是回文串。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot; &quot;输出：true解释：在移除非字母数字字符之后，s 是一个空字符串 &quot;&quot; 。由于空字符串正着反着读都一样，所以是回文串。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 2 * 105</code></li><li><code>s</code> 仅由可打印的 ASCII 字符组成</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">var</span> pures <span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> isGoodCh(s[i]) &#123;</span><br><span class="line">pures += <span class="type">string</span>(s[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">pures = strings.ToLower(pures)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(pures)/<span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> pures[i] != pures[<span class="built_in">len</span>(pures)<span class="number">-1</span>-i] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isGoodCh</span><span class="params">(ch <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (ch &gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;=<span class="string">&#x27;Z&#x27;</span>) || (ch &gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;=<span class="string">&#x27;z&#x27;</span>) || (ch &gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.20. 有效的括号</title>
      <link href="/interview/juan/neet150/stack/leet-20-valid-parentheses/"/>
      <url>/interview/juan/neet150/stack/leet-20-valid-parentheses/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/valid-parentheses/">Leetcode.20. 有效的括号</a></p><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;()&quot;输出：true</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;()[]&#123;&#125;&quot;输出：true</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;(]&quot;输出：false</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul><p><strong>思路：</strong><br>一个比较讨巧的方法是：当发现左括号的时候将对应右括号入栈，发现右括号时直接比较栈顶元素是否相同即可，不同就提前退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stack []<span class="type">rune</span></span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">if</span> ch == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ch == <span class="string">&#x27;[&#x27;</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ch == <span class="string">&#x27;&#123;&#x27;</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(stack, ch)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] != ch &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(stack)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Stack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.49 字母异位词分组</title>
      <link href="/interview/juan/neet150/arrays-hashing/leet-49-group-anagrams/"/>
      <url>/interview/juan/neet150/arrays-hashing/leet-49-group-anagrams/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></p><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例 1:</strong></p><pre><code>输入: strs = `[&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]`输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: strs = `[&quot;&quot;]`输出: [[&quot;&quot;]]</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: strs = `[&quot;a&quot;]`输出: [[&quot;a&quot;]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><p>排序后加入集合，再遍历出来就行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">groupAnagrams</span><span class="params">(strs []<span class="type">string</span>)</span></span> [][]<span class="type">string</span> &#123;</span><br><span class="line">mp := <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, str := <span class="keyword">range</span> strs &#123;</span><br><span class="line">s := []<span class="type">byte</span>(str)</span><br><span class="line">sort.Slice(s, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s[i] &lt; s[j]</span><br><span class="line">&#125;)</span><br><span class="line">sortedStr := <span class="type">string</span>(s)</span><br><span class="line">mp[sortedStr] = <span class="built_in">append</span>(mp[sortedStr], str)</span><br><span class="line">&#125;</span><br><span class="line">ans := <span class="built_in">make</span>([][]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(mp))</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> mp &#123;</span><br><span class="line">ans = <span class="built_in">append</span>(ans, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Arrays &amp; Hashing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.242 有效的字母异位词</title>
      <link href="/interview/juan/neet150/arrays-hashing/leet-242-valid-anagram/"/>
      <url>/interview/juan/neet150/arrays-hashing/leet-242-valid-anagram/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></p><p>给定两个字符串 <code>_s_</code> 和 <code>_t_</code> ，编写一个函数来判断 <code>_t_</code> 是否是 <code>_s_</code> 的字母异位词。</p><p><strong>注意：</strong>若 <code>_s_</code> 和 <code>_t_</code> 中每个字符出现的次数都相同，则称 <code>_s_</code> 和 <code>_t_</code> 互为字母异位词。</p><p><strong>示例 1:</strong></p><pre><code>输入: _s_ = &quot;anagram&quot;, _t_ = &quot;nagaram&quot;输出: true</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: _s_ = &quot;rat&quot;, _t_ = &quot;car&quot;输出: false</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li><li><code>s</code> 和 <code>t</code> 仅包含小写字母</li></ul><p><strong>进阶:</strong> 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><p>还可以直接排序嗷，牛的！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">chm := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>, <span class="number">26</span>)</span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := chm[s[i]]; ok &#123;</span><br><span class="line">chm[s[i]] += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">chm[s[i]] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> t &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := chm[t[i]]; ok &#123;</span><br><span class="line">chm[t[i]] -= <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> chm &#123;</span><br><span class="line"><span class="keyword">if</span> v != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(s, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123; </span><br><span class="line">s1, s2 := []<span class="type">byte</span>(s), []<span class="type">byte</span>(t) </span><br><span class="line">sort.Slice(s1, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> s1[i] &lt; s1[j] &#125;) </span><br><span class="line">sort.Slice(s2, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> s2[i] &lt; s2[j] &#125;) </span><br><span class="line"><span class="keyword">return</span> <span class="type">string</span>(s1) == <span class="type">string</span>(s2) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Arrays &amp; Hashing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet76</title>
      <link href="/interview/juan/neet150/s-window/leet76/"/>
      <url>/interview/juan/neet150/s-window/leet76/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet424</title>
      <link href="/interview/juan/neet150/s-window/leet424/"/>
      <url>/interview/juan/neet150/s-window/leet424/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.3 无重复字符的最长子串</title>
      <link href="/interview/juan/neet150/s-window/leet-3-longest-substring-without-repeating-characters/"/>
      <url>/interview/juan/neet150/s-window/leet-3-longest-substring-without-repeating-characters/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长</strong> <strong>子串</strong>的长度。</p><p><strong>示例 1:</strong></p><pre><code>输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 `&quot;abc&quot;`，所以其长度为 3。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 `&quot;b&quot;`，所以其长度为 1。</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 `&quot;wke&quot;`，所以其长度为 3。     请注意，你的答案必须是 **子串** 的长度，`&quot;pwke&quot;` 是一个_子序列，_不是子串。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">hm := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">l := <span class="built_in">len</span>(s)</span><br><span class="line"><span class="comment">// 右指针，初始值为-1，代表还未移动</span></span><br><span class="line">rk, ans := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line"><span class="comment">// i 作为左指针</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;l; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 左指针移动，移除一个字符</span></span><br><span class="line"><span class="comment">// 注意移除的是前一个字符</span></span><br><span class="line"><span class="built_in">delete</span>(hm, s[i<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> rk+<span class="number">1</span>&lt;l &amp;&amp; hm[s[rk+<span class="number">1</span>]] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 移动右指针，且记录字符数++</span></span><br><span class="line">hm[s[rk+<span class="number">1</span>]]++</span><br><span class="line">rk++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第 i 到 rk 个字符是极长的无重复字符的子串</span></span><br><span class="line">ans = max(ans, rk-i+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet79</title>
      <link href="/interview/juan/neet150/backtracking/leet79/"/>
      <url>/interview/juan/neet150/backtracking/leet79/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.48 旋转图像</title>
      <link href="/interview/juan/neet150/math/leet-48-rotate-image/"/>
      <url>/interview/juan/neet150/math/leet-48-rotate-image/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/rotate-image/description/">Leetcode.48 旋转图像</a></p><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 <strong>原地</strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg"></p><pre><code>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[[7,4,1],[8,5,2],[9,6,3]]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg"></p><pre><code>输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</code></pre><p><strong>提示：</strong></p><ul><li><code>n == matrix.length == matrix[i].length</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li></ul><p><strong>牛了逼了</strong>，两次翻转达成目标</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> &#123; </span><br><span class="line">n := <span class="built_in">len</span>(matrix) </span><br><span class="line"><span class="comment">// 水平翻转 </span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i++ &#123; </span><br><span class="line">matrix[i], matrix[n<span class="number">-1</span>-i] = matrix[n<span class="number">-1</span>-i], matrix[i] </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 主对角线翻转 </span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; </span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123; </span><br><span class="line">matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准解法<br>由于矩阵中的行列从 000 开始计数，因此对于矩阵中的元素 matrix[row][col]，在旋转后，它的新位置为 matrix_new[col][n−row−1]。<br>然后用辅助数组存储翻转后的结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> &#123; </span><br><span class="line">n := <span class="built_in">len</span>(matrix) </span><br><span class="line">tmp := <span class="built_in">make</span>([][]<span class="type">int</span>, n) </span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> tmp &#123; </span><br><span class="line">tmp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n) </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, row := <span class="keyword">range</span> matrix &#123; </span><br><span class="line"><span class="keyword">for</span> j, v := <span class="keyword">range</span> row &#123; </span><br><span class="line">tmp[j][n<span class="number">-1</span>-i] = v </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">copy</span>(matrix, tmp) <span class="comment">// 拷贝 tmp 矩阵每行的引用 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.54 螺旋区间</title>
      <link href="/interview/juan/neet150/math/leet-54-spiral-matrix/"/>
      <url>/interview/juan/neet150/math/leet-54-spiral-matrix/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/spiral-matrix/description/">Leetcode.54 螺旋区间</a></p><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg"></p><pre><code>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg"></p><pre><code>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7]</code></pre><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><p><strong>思路：</strong><br>用最直观的理解，定边界</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> || <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">ans := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">rowStart, rowEnd := <span class="number">0</span>, <span class="built_in">len</span>(matrix)<span class="number">-1</span></span><br><span class="line">colStart, colEnd := <span class="number">0</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>])<span class="number">-1</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 左 - 右</span></span><br><span class="line"><span class="keyword">for</span> i:=colStart; i&lt;=colEnd; i++ &#123;</span><br><span class="line">ans = <span class="built_in">append</span>(ans, matrix[rowStart][i])</span><br><span class="line">&#125;</span><br><span class="line">rowStart += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> rowStart &gt; rowEnd &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 上 - 下</span></span><br><span class="line"><span class="keyword">for</span> i:=rowStart; i&lt;=rowEnd; i++ &#123;</span><br><span class="line">ans = <span class="built_in">append</span>(ans, matrix[i][colEnd])</span><br><span class="line">&#125;</span><br><span class="line">colEnd -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> colStart &gt; colEnd &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右 - 左</span></span><br><span class="line"><span class="keyword">for</span> i:=colEnd; i&gt;=colStart; i-- &#123;</span><br><span class="line">ans = <span class="built_in">append</span>(ans, matrix[rowEnd][i])</span><br><span class="line">&#125;</span><br><span class="line">rowEnd -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> rowStart &gt; rowEnd &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 下 - 上</span></span><br><span class="line"><span class="keyword">for</span> i:=rowEnd; i&gt;=rowStart; i-- &#123;</span><br><span class="line">ans = <span class="built_in">append</span>(ans, matrix[i][colStart])</span><br><span class="line">&#125;</span><br><span class="line">colStart += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> colStart &gt; colEnd &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet73</title>
      <link href="/interview/juan/neet150/math/leet73/"/>
      <url>/interview/juan/neet150/math/leet73/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Math &amp; Geometry </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.143 重排链表</title>
      <link href="/interview/juan/neet150/linked-list/leet-143-reorder-list/"/>
      <url>/interview/juan/neet150/linked-list/leet-143-reorder-list/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></p><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><p>L0 → L1 → … → Ln - 1 → Ln</p><p>请将其重新排列后变为：</p><p>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</p><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例 1：</strong></p><p><img src="https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png"></p><pre><code>输入：head = [1,2,3,4]输出：[1,4,2,3]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://pic.leetcode-cn.com/1626420320-YUiulT-image.png"></p><pre><code>输入：head = [1,2,3,4,5]输出：[1,5,2,4,3]</code></pre><p><strong>提示：</strong></p><ul><li>链表的长度范围为 <code>[1, 5 * 104]</code></li><li><code>1 &lt;= node.val &lt;= 1000</code></li></ul><p>方法1：转化为线性表，再按照要求链接节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Next *ListNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reorderList</span><span class="params">(head *ListNode)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> nums []*ListNode</span><br><span class="line">dummy := head</span><br><span class="line"><span class="keyword">for</span> dummy != <span class="literal">nil</span> &#123;</span><br><span class="line">nums = <span class="built_in">append</span>(nums, dummy)</span><br><span class="line">dummy = dummy.Next</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> l&lt;r &#123;</span><br><span class="line">nums[l].Next = nums[r]</span><br><span class="line">l++</span><br><span class="line"><span class="keyword">if</span> l == r &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">nums[r].Next = nums[l]</span><br><span class="line">r--</span><br><span class="line">&#125;</span><br><span class="line">nums[l].Next = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：从链表中间切断，后半段逆序，然后再把二者合并<br>链表操作秀肌肉</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Next *ListNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reorderList</span><span class="params">(head *ListNode)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">mid := findMiddle(head)</span><br><span class="line">l1 := head</span><br><span class="line">l2 := mid.Next</span><br><span class="line">mid.Next = <span class="literal">nil</span></span><br><span class="line">nl2 := reverse(l2)</span><br><span class="line">merge(l1, nl2)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMiddle</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">slow, fast := head, head</span><br><span class="line"><span class="keyword">for</span> fast.Next != <span class="literal">nil</span> &amp;&amp; fast.Next.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line"><span class="keyword">var</span> pre, cur *ListNode = <span class="literal">nil</span>, head</span><br><span class="line"><span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">nxt := cur.Next</span><br><span class="line">cur.Next = pre</span><br><span class="line">pre = cur</span><br><span class="line">cur = nxt</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(h1, h2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">t := dummy</span><br><span class="line"><span class="keyword">for</span> h1 != <span class="literal">nil</span> &amp;&amp; h2 != <span class="literal">nil</span> &#123;</span><br><span class="line">t.Next = h1</span><br><span class="line">t = t.Next</span><br><span class="line">h1 = h1.Next</span><br><span class="line">  </span><br><span class="line">t.Next = h2</span><br><span class="line">t = t.Next</span><br><span class="line">h2 = h2.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h1 != <span class="literal">nil</span> &#123;</span><br><span class="line">t.Next = h1</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> h2 != <span class="literal">nil</span> &#123;</span><br><span class="line">t.Next = h2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.19 删除链表的倒数第 N 个结点</title>
      <link href="/interview/juan/neet150/linked-list/leet-19-remove-nth-node-from-end-of-list/"/>
      <url>/interview/juan/neet150/linked-list/leet-19-remove-nth-node-from-end-of-list/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></p><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg"></p><pre><code>输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：head = [1], n = 1输出：[]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：head = [1,2], n = 1输出：[1]</code></pre><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><p>双指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Next *ListNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">dummy := &amp;ListNode&#123;<span class="number">0</span>, head&#125;</span><br><span class="line">pre, cur := dummy, head</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n ; i++ &#123;</span><br><span class="line">cur = cur.Next</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">pre = pre.Next</span><br><span class="line">cur = cur.Next</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">nod := pre.Next <span class="comment">// 待删除的点</span></span><br><span class="line">pre.Next = nod.Next</span><br><span class="line"><span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.21 合并两个有序链表</title>
      <link href="/interview/juan/neet150/linked-list/leet-21-merge-two-sorted-lists/"/>
      <url>/interview/juan/neet150/linked-list/leet-21-merge-two-sorted-lists/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg"></p><pre><code>输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：l1 = [], l2 = []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：l1 = [], l2 = [0]输出：[0]</code></pre><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Next *ListNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(list1 *ListNode, list2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">newHead, dummy := &amp;ListNode&#123;Val: <span class="number">-1</span>&#125;, &amp;ListNode&#123;Val: <span class="number">-1</span>&#125;</span><br><span class="line">dummy = newHead</span><br><span class="line"><span class="keyword">for</span> list1 != <span class="literal">nil</span> &amp;&amp; list2 != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> list1.Val &lt;= list2.Val &#123;</span><br><span class="line">dummy.Next = list1</span><br><span class="line">list1 = list1.Next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dummy.Next = list2</span><br><span class="line">list2 = list2.Next</span><br><span class="line">&#125;</span><br><span class="line">dummy = dummy.Next</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> list1 != <span class="literal">nil</span> &#123;</span><br><span class="line">dummy.Next = list1</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dummy.Next = list2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.141 环形链表</title>
      <link href="/interview/juan/neet150/linked-list/leet-141-linked-list-cycle/"/>
      <url>/interview/juan/neet150/linked-list/leet-141-linked-list-cycle/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></p><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png"></p><pre><code>输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png"></p><pre><code>输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png"></p><pre><code>输入：head = [1], pos = -1输出：false解释：链表中没有环。</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Next *ListNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// 快慢指针，一个双倍步数</span></span><br><span class="line"><span class="comment">// 如果有环，迟早能碰上</span></span><br><span class="line"><span class="comment">// 如果没有环，会碰到下一个为空的情况</span></span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">slow, fast := head, head.Next</span><br><span class="line"><span class="keyword">for</span> slow != fast &#123;</span><br><span class="line"><span class="comment">// 判断 fast 的情况即可，fast 没到 nil，slow 一定安全</span></span><br><span class="line"><span class="keyword">if</span> fast == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next</span><br><span class="line">fast = fast.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.206. 反转链表</title>
      <link href="/interview/juan/neet150/linked-list/leet-206-reverse-linked-list/"/>
      <url>/interview/juan/neet150/linked-list/leet-206-reverse-linked-list/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg"></p><pre><code>输入：head = [1,2,3,4,5]输出：[5,4,3,2,1]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg"></p><pre><code>输入：head = [1,2]输出：[2,1]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：head = []输出：[]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Next *ListNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> pre *ListNode</span><br><span class="line">curr := head</span><br><span class="line"><span class="keyword">for</span> curr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 记录下一个节点</span></span><br><span class="line">next := curr.Next</span><br><span class="line"><span class="comment">// 修改上一个节点</span></span><br><span class="line">curr.Next = pre</span><br><span class="line"><span class="comment">// 记录头结点</span></span><br><span class="line">pre = curr</span><br><span class="line"><span class="comment">// 走到下一个节点</span></span><br><span class="line">curr = next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet435</title>
      <link href="/interview/juan/neet150/interval/leet435/"/>
      <url>/interview/juan/neet150/interval/leet435/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Intervals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.57 插入区间</title>
      <link href="/interview/juan/neet150/interval/leet-57-insert-interval/"/>
      <url>/interview/juan/neet150/interval/leet-57-insert-interval/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/insert-interval/description/">Leetcode.57 插入区间</a></p><p>给你一个 <strong>无重叠的</strong> _，_按照区间起始端点排序的区间列表 <code>intervals</code>，其中 <code>intervals[i] = [starti, endi]</code> 表示第 <code>i</code> 个区间的开始和结束，并且 <code>intervals</code> 按照 <code>starti</code> 升序排列。同样给定一个区间 <code>newInterval = [start, end]</code> 表示另一个区间的开始和结束。</p><p>在 <code>intervals</code> 中插入区间 <code>newInterval</code>，使得 <code>intervals</code> 依然按照 <code>starti</code> 升序排列，且区间之间不重叠（如果有必要的话，可以合并区间）。</p><p>返回插入之后的 <code>intervals</code>。</p><p><strong>注意</strong> 你不需要原地修改 <code>intervals</code>。你可以创建一个新数组然后返回它。</p><p><strong>示例 1：</strong></p><pre><code>输入：intervals = [[1,3],[6,9]], newInterval = [2,5]输出：[[1,5],[6,9]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出：[[1,2],[3,10],[12,16]]解释：这是因为新的区间 `[4,8]` 与 `[3,5],[6,7],[8,10]` 重叠。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 105</code></li><li><code>intervals</code> 根据 <code>starti</code> 按 <strong>升序</strong> 排列</li><li><code>newInterval.length == 2</code></li><li><code>0 &lt;= start &lt;= end &lt;= 105</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(intervals [][]<span class="type">int</span>, newInterval []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">left, right := newInterval[<span class="number">0</span>], newInterval[<span class="number">1</span>]</span><br><span class="line">merged := <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> ans [][]<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> _, inter := <span class="keyword">range</span> intervals &#123;</span><br><span class="line"><span class="keyword">if</span> inter[<span class="number">1</span>] &lt; left &#123;</span><br><span class="line">ans = <span class="built_in">append</span>(ans, inter)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> inter[<span class="number">0</span>] &gt; right &#123;</span><br><span class="line"><span class="keyword">if</span> !merged &#123;</span><br><span class="line">ans = <span class="built_in">append</span>(ans, []<span class="type">int</span>&#123;left, right&#125;)</span><br><span class="line">merged = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">append</span>(ans, inter)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">left = min(left, inter[<span class="number">0</span>])</span><br><span class="line">right = max(right, inter[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !merged &#123;</span><br><span class="line"><span class="comment">// left, right 为原值</span></span><br><span class="line">ans = <span class="built_in">append</span>(ans, []<span class="type">int</span>&#123;left, right&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Intervals </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.128 最长连续序列</title>
      <link href="/interview/juan/neet150/arrays-hashing/leet-128-longest-consecutive-sequence/"/>
      <url>/interview/juan/neet150/arrays-hashing/leet-128-longest-consecutive-sequence/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/">Leetcode.128 最长连续序列</a></p><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [100,4,200,1,3,2]输出：4解释：最长数字连续序列是 `[1, 2, 3, 4]。它的长度为 4。`</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,3,7,2,5,8,4,6,0,1]输出：9</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestConsecutive</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">hs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>, <span class="number">0</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">hs[nums[i]] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> num, _ := <span class="keyword">range</span> hs &#123;</span><br><span class="line"><span class="comment">// 找前一个数字，存在则当前数字不是开头</span></span><br><span class="line"><span class="keyword">if</span> _, ok := hs[num<span class="number">-1</span>]; ok &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// num 是开头</span></span><br><span class="line">cn := num</span><br><span class="line">cnt := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> hs[cn+<span class="number">1</span>] &#123;</span><br><span class="line">cn += <span class="number">1</span></span><br><span class="line">cnt += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, cnt)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Arrays &amp; Hashing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.200 岛屿数量</title>
      <link href="/interview/juan/neet150/graphs/leet-200-number-of-islands/"/>
      <url>/interview/juan/neet150/graphs/leet-200-number-of-islands/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></p><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1：</strong></p><pre><code>输入：grid = [  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]]输出：1</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：grid = [  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]输出：3</code></pre><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><p>很标准的dfs<br>可以省略 visited 标记数组，改为直接修改 grid 中已遍历的元素为 0， 1 之外的任意值即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">visited := <span class="built_in">make</span>([][]<span class="type">bool</span>, <span class="built_in">len</span>(grid))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> visited &#123;</span><br><span class="line">visited[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>]))</span><br><span class="line">&#125;</span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(m, n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 到达边界</span></span><br><span class="line"><span class="keyword">if</span> m &gt;= <span class="built_in">len</span>(grid) || n &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) || m&lt;<span class="number">0</span> || n&lt;<span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 到达岛边界</span></span><br><span class="line"><span class="keyword">if</span> grid[m][n] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 已访问的陆地跳过</span></span><br><span class="line"><span class="keyword">if</span> visited[m][n] &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标记陆地访问</span></span><br><span class="line"><span class="keyword">if</span> grid[m][n] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">visited[m][n] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">dfs(m<span class="number">-1</span>, n)</span><br><span class="line">dfs(m+<span class="number">1</span>, n)</span><br><span class="line">dfs(m, n+<span class="number">1</span>)</span><br><span class="line">dfs(m, n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(grid); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(grid[<span class="number">0</span>]); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> !visited[i][j] &amp;&amp; grid[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">ans += <span class="number">1</span></span><br><span class="line">dfs(i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Graphs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet417</title>
      <link href="/interview/juan/neet150/graphs/leet417/"/>
      <url>/interview/juan/neet150/graphs/leet417/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Graphs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.207 课程表</title>
      <link href="/interview/juan/neet150/graphs/leet-207-course-schedule/"/>
      <url>/interview/juan/neet150/graphs/leet-207-course-schedule/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></p><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程  <code>bi</code> 。</p><ul><li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li></ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：numCourses = 2, prerequisites = [[1,0]]输出：true解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：numCourses = 2, prerequisites = [[1,0],[0,1]]输出：false解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= numCourses &lt;= 2000</code></li><li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li><code>prerequisites[i]</code> 中的所有课程对 <strong>互不相同</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="type">int</span>, prerequisites [][]<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">edges := <span class="built_in">make</span>([][]<span class="type">int</span>, numCourses)</span><br><span class="line">visited := <span class="built_in">make</span>([]<span class="type">int</span>, numCourses) <span class="comment">// 0 未搜索 1 搜索中 2 搜索完毕</span></span><br><span class="line">res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">valid := <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">  </span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(c <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">visited[c] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> edges[c] &#123;</span><br><span class="line"><span class="keyword">if</span> visited[v] == <span class="number">0</span> &#123;</span><br><span class="line">dfs(v)</span><br><span class="line"><span class="keyword">if</span> !valid &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> visited[v] == <span class="number">1</span> &#123; <span class="comment">// 有环了</span></span><br><span class="line">valid = <span class="literal">false</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visited[c] = <span class="number">2</span></span><br><span class="line">res = <span class="built_in">append</span>(res, c)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">edges[item[<span class="number">1</span>]] = <span class="built_in">append</span>(edges[item[<span class="number">1</span>]], item[<span class="number">0</span>])</span><br><span class="line"><span class="comment">// 依赖 i 课程的课程存放在 edge[i]中</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> visited[i] == <span class="number">0</span> &#123;</span><br><span class="line">dfs(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> valid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Graphs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet133</title>
      <link href="/interview/juan/neet150/graphs/leet133/"/>
      <url>/interview/juan/neet150/graphs/leet133/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Graphs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.55 跳跃游戏</title>
      <link href="/interview/juan/neet150/greedy/leet-55-jump-game/"/>
      <url>/interview/juan/neet150/greedy/leet-55-jump-game/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/jump-game/">Leetcode.55 跳跃游戏</a></p><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>思路：</strong><br>每一步找从当前出发所能到达的最大距离，如果哪个点到不了了，说明不能到达终点。本质是贪心</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">var</span> dis = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; dis &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">dis = max(dis, i + nums[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.62 不同路径</title>
      <link href="/interview/juan/neet150/2-d-dp/leet-62-unique-paths/"/>
      <url>/interview/juan/neet150/2-d-dp/leet-62-unique-paths/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/unique-paths/description/">Leetcode.62 不同路径</a></p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><p><img src="https://pic.leetcode.cn/1697422740-adxmsI-image.png"></p><pre><code>输入：m = 3, n = 7输出：28</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：m = 3, n = 2输出：3解释：从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向下</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：m = 7, n = 3输出：28</code></pre><p><strong>示例 4：</strong></p><pre><code>输入：m = 3, n = 3输出：6</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 <code>2 * 109</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePaths</span><span class="params">(m <span class="type">int</span>, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m)</span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> dp &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;n; j++ &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;m; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;n; j++ &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> 2-D DP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.63 不同路径ii</title>
      <link href="/interview/juan/neet150/2-d-dp/leet-63-unique-paths-ii/"/>
      <url>/interview/juan/neet150/2-d-dp/leet-63-unique-paths-ii/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/unique-paths-ii/description/">Leetcode.63 不同路径ii</a></p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg"></p><pre><code>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]输出：2解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 `2` 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg"></p><pre><code>输入：obstacleGrid = [[0,1],[0,0]]输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; </span><br><span class="line">n, m := <span class="built_in">len</span>(obstacleGrid), <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>]) </span><br><span class="line">f := <span class="built_in">make</span>([]<span class="type">int</span>, m) </span><br><span class="line"><span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span> &#123; </span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; </span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; m; j++ &#123; </span><br><span class="line"><span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span> &#123; </span><br><span class="line">f[j] = <span class="number">0</span> </span><br><span class="line"><span class="keyword">continue</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; obstacleGrid[i][j<span class="number">-1</span>] == <span class="number">0</span> &#123; </span><br><span class="line">f[j] += f[j<span class="number">-1</span>] </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> f[<span class="built_in">len</span>(f)<span class="number">-1</span>] </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> 2-D DP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.91 解码方法</title>
      <link href="/interview/juan/neet150/1-d-dp/leet-91-decode-ways/"/>
      <url>/interview/juan/neet150/1-d-dp/leet-91-decode-ways/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/decode-ways/">91. 解码方法</a></p><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><p>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”</p><p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li></ul><p>注意，消息不能分组为  <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p><p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p><p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;12&quot;输出：2解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;226&quot;输出：3解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;06&quot;输出：0解释：&quot;06&quot; 无法映射到 &quot;F&quot; ，因为存在前导零（&quot;6&quot; 和 &quot;06&quot; 并不等价）。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含数字，并且可能包含前导零。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numDecodings</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(s)</span><br><span class="line">f := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 空字符串解码结果</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=n; i++ &#123;</span><br><span class="line"><span class="comment">// 单字符解码</span></span><br><span class="line"><span class="keyword">if</span> s[i<span class="number">-1</span>] != <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">f[i] += f[i<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 双字符解码</span></span><br><span class="line"><span class="keyword">if</span> i&gt;<span class="number">1</span> &amp;&amp; s[i<span class="number">-2</span>] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; (s[i<span class="number">-2</span>]-<span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span> &lt;= <span class="number">26</span> &#123;</span><br><span class="line">f[i] += f[i<span class="number">-2</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> 1-D DP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.198 打家劫舍</title>
      <link href="/interview/juan/neet150/1-d-dp/leet-198-house-robber/"/>
      <url>/interview/juan/neet150/1-d-dp/leet-198-house-robber/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><pre><code>输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。     偷窃到的最高金额 = 1 + 3 = 4 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line"><span class="comment">// 前一间是 nums[0]，前两间房是 max（nums[0], nums[1]）</span></span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">2</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="comment">// 要么已经偷了 i-2，可以继续偷当前 i</span></span><br><span class="line"><span class="comment">// 要么已经偷了 i-1，不可以继续偷当前 i</span></span><br><span class="line">dp[i] = max(dp[i<span class="number">-2</span>] + nums[i], dp[i<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="built_in">len</span>(nums)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> 1-D DP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.39 组合总和</title>
      <link href="/interview/juan/neet150/backtracking/leet-39-combination-sum/"/>
      <url>/interview/juan/neet150/backtracking/leet-39-combination-sum/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/combination-sum/description/">Leetcode.39 组合总和</a></p><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><pre><code>输入：candidates = `[2,3,6,7],` target = `7`输出：[[2,2,3],[7]]解释：2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。7 也是一个候选， 7 = 7 。仅有这两种组合。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入: candidates = [2,3,5]`,` target = 8输出: [[2,2,2,2],[2,3,3],[3,5]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入: candidates = `[2],` target = 1输出: []</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul><p><strong>思路：</strong><br>用 <em>dfs(i,left)</em> 来回溯，设当前枚举到 *candidates[i]*，剩余要选的元素之和为 <em>left</em>，按照选或不选分类讨论：</p><p>不选：递归到 *dfs(i+1,left)*。<br>选：递归到 *dfs(i,left−candidates[i])*。注意 <em>i</em> 不变，表示在下次递归中可以继续选 *candidates[i]*。<br>注：这个思路类似 <strong>完全背包</strong>。</p><p>如果递归中发现 <em>left&#x3D;0</em> 则说明找到了一个合法组合，复制一份 <em>path</em> 加入答案。</p><p>递归边界：如果 <em>i&#x3D;n</em>-1 或者 <em>left&lt;0</em> 则返回。</p><p>递归入口：*dfs(0,target)*。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">ans := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span></span><br><span class="line">  </span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, left <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> left == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 找到解了，注意需要拷贝结果</span></span><br><span class="line">p1 := <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, path...)</span><br><span class="line">ans = <span class="built_in">append</span>(ans, p1)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> i == <span class="built_in">len</span>(candidates) || left &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不选当前数字，选下一个</span></span><br><span class="line">dfs(i+<span class="number">1</span>, left)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 选中当前数字，left-candidates[i]</span></span><br><span class="line">path = <span class="built_in">append</span>(path, candidates[i])</span><br><span class="line">dfs(i, left - candidates[i])</span><br><span class="line">path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>] <span class="comment">// 恢复现场</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">dfs(<span class="number">0</span>, target)</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.40 组合总和 II</title>
      <link href="/interview/juan/neet150/backtracking/leet-40-combination-sum%20ii/"/>
      <url>/interview/juan/neet150/backtracking/leet-40-combination-sum%20ii/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></p><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><p><strong>示例 1:</strong></p><pre><code>输入: candidates = `[10,1,2,7,6,1,5]`, target = `8`,输出:[[1,1,6],[1,2,5],[1,7],[2,6]]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: candidates = [2,5,2,1,2], target = 5,输出:[[1,2,2],[5]]</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 100</code></li><li><code>1 &lt;= candidates[i] &lt;= 50</code></li><li><code>1 &lt;= target &lt;= 30</code></li></ul><p><strong>思路：</strong><br>用 <em>dfs(i,left)</em> 来回溯，设当前枚举到 *candidates[i]*，剩余要选的元素之和为 <em>left</em>，按照选或不选分类讨论：</p><p>不选：递归到 *dfs(i+1,left)*。<br>选：递归到 *dfs(i,left−candidates[i])*。注意 <em>i</em> 不变，表示在下次递归中可以继续选 *candidates[i]*。<br>注：这个思路类似 <strong>完全背包</strong>。</p><p>如果递归中发现 <em>left&#x3D;0</em> 则说明找到了一个合法组合，复制一份 <em>path</em> 加入答案。</p><p>递归边界：如果 <em>i&#x3D;n</em>-1 或者 <em>left&lt;0</em> 则返回。</p><p>递归入口：*dfs(0,target)*。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">path := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">ans := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span></span><br><span class="line">  </span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, left <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> left == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 找到解了，注意需要拷贝结果</span></span><br><span class="line">p1 := <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, path...)</span><br><span class="line">ans = <span class="built_in">append</span>(ans, p1)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> i == <span class="built_in">len</span>(candidates) || left &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不选当前数字，选下一个</span></span><br><span class="line">dfs(i+<span class="number">1</span>, left)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 选中当前数字，left-candidates[i]</span></span><br><span class="line">path = <span class="built_in">append</span>(path, candidates[i])</span><br><span class="line">dfs(i, left - candidates[i])</span><br><span class="line">path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>] <span class="comment">// 恢复现场</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">dfs(<span class="number">0</span>, target)</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.139 单词拆分</title>
      <link href="/interview/juan/neet150/1-d-dp/leet-139-word-break/"/>
      <url>/interview/juan/neet150/1-d-dp/leet-139-word-break/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></p><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p><p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p><strong>示例 1：</strong></p><pre><code>输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。     注意，你可以重复使用字典中的单词。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 300</code></li><li><code>1 &lt;= wordDict.length &lt;= 1000</code></li><li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li><li><code>s</code> 和 <code>wordDict[i]</code> 仅由小写英文字母组成</li><li><code>wordDict</code> 中的所有字符串 <strong>互不相同</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(s <span class="type">string</span>, wordDict []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">wordMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line"><span class="keyword">for</span> _, w := <span class="keyword">range</span> wordDict &#123;</span><br><span class="line">wordMap[w] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(s) + <span class="number">1</span>)</span><br><span class="line">dp[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="comment">// 遍历某个字符之前的区间是否有在字典中的，发现的话标记边界。再从下个字符开始找</span></span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;i; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> dp[j] &amp;&amp; wordMap[s[j:i]] &#123;</span><br><span class="line">dp[i] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="built_in">len</span>(s)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> 1-D DP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.1143 最长公共子序列</title>
      <link href="/interview/juan/neet150/2-d-dp/leet-1143-longest-common-subsequence/"/>
      <url>/interview/juan/neet150/2-d-dp/leet-1143-longest-common-subsequence/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></p><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><p><strong>示例 1：</strong></p><pre><code>输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3  解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;输出：3解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;输出：0解释：两个字符串没有公共子序列，返回 0 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul><p>简单讲是轮着比一圈，但是有一个向外扩散的过程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1 <span class="type">string</span>, text2 <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">m, n := <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="keyword">range</span> dp &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i, c1 := <span class="keyword">range</span> text1 &#123;</span><br><span class="line"><span class="keyword">for</span> j, c2 := <span class="keyword">range</span> text2 &#123;</span><br><span class="line"><span class="keyword">if</span> c1 == c2 &#123;</span><br><span class="line">dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = max(dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> 2-D DP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.300. 最长递增子序列</title>
      <link href="/interview/juan/neet150/1-d-dp/leet-300-longest-increasing-subsequence/"/>
      <url>/interview/juan/neet150/1-d-dp/leet-300-longest-increasing-subsequence/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">Leetcode.300. 最长递增子序列</a></p><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p> </p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,1,0,3,2,3]输出：4</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [7,7,7,7,7,7,7]输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li></ul><p>详细解析：</p><p><a href="https://writings.sh/post/longest-increasing-subsequence-revisited">最长递增子序列（nlogn 二分法、DAG 模型 和 延伸问题）</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLIS</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> dp []<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="comment">// dp 为 0 或者 当前值大于 dp 的最后一个元素，入 dp</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(dp) == <span class="number">0</span> || nums[i] &gt; dp[<span class="built_in">len</span>(dp)<span class="number">-1</span>] &#123;</span><br><span class="line">dp = <span class="built_in">append</span>(dp, nums[i])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 二分查找 dp 中第一个大于 nums[i] 的数，更换之</span></span><br><span class="line">l, r := <span class="number">0</span>, <span class="built_in">len</span>(dp)<span class="number">-1</span></span><br><span class="line">tar := r</span><br><span class="line"><span class="keyword">for</span> l&lt;=r &#123;</span><br><span class="line">mid := (l+r) / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> dp[mid] &gt;= nums[i] &#123;</span><br><span class="line">tar = mid</span><br><span class="line">r = mid<span class="number">-1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = mid+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[tar] = nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(dp)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(dp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> 1-D DP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.70 爬楼梯</title>
      <link href="/interview/juan/neet150/1-d-dp/leet-70-climbing-stairs/"/>
      <url>/interview/juan/neet150/1-d-dp/leet-70-climbing-stairs/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 2输出：2解释：有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 3输出：3解释：有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><p>第 n 阶是 第 n-1 阶 + 1步；或者第 n-2 阶 + 2步。其中第 n-2 阶 + 1步 + 1步 这个被包含在了 第 n-1 阶 + 1 步 中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">choice := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 对应0阶1阶和2阶</span></span><br><span class="line"><span class="keyword">if</span> n&lt;<span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">return</span> choice[n]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">3</span>; i&lt;=n; i++ &#123;</span><br><span class="line">cur := choice[i<span class="number">-1</span>] + choice[i<span class="number">-2</span>]</span><br><span class="line">choice = <span class="built_in">append</span>(choice, cur)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> choice[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> 1-D DP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leet190</title>
      <link href="/interview/juan/neet150/bit/leet190/"/>
      <url>/interview/juan/neet150/bit/leet190/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.268 丢失的数字</title>
      <link href="/interview/juan/neet150/bit/leet-268-missing-number/"/>
      <url>/interview/juan/neet150/bit/leet-268-missing-number/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/missing-number/">Leetcode.268 丢失的数字</a></p><p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [3,0,1]输出：2解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</code></pre><p><strong>示例 2：</strong></p><pre><code>**输入：nums = [0,1]**输出：2**解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。</code></pre><p><strong>示例 3：</strong></p><pre><code>**输入：nums = [9,6,4,2,3,5,7,0,1]**输出：8**解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。</code></pre><p><strong>示例 4：</strong></p><pre><code>**输入：nums = [0]**输出：1**解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。</code></pre><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= n</code></li><li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求和取差值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">missingNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> total <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;=<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">total += i</span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">sum += nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> total - sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异或思路</span></span><br><span class="line"><span class="comment">// xor 将 nums 中元素异或一遍，然后再异或一遍 0-n，由异或的特性可知，出现两次的数据会消失，最终留下的就是未出现的那个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">missingNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> xor <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">xor ^= i</span><br><span class="line">xor ^= n</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> xor ^ <span class="built_in">len</span>(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.338 比特位计数</title>
      <link href="/interview/juan/neet150/bit/leet-338-counting-bits/"/>
      <url>/interview/juan/neet150/bit/leet-338-counting-bits/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/counting-bits/">338. 比特位计数</a></p><p>给你一个整数 <code>n</code> ，对于 <code>0 &lt;= i &lt;= n</code> 中的每个 <code>i</code> ，计算其二进制表示中 <strong><code>1</code> 的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组 <code>ans</code> 作为答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 2输出：[0,1,1]解释：0 --&gt; 01 --&gt; 12 --&gt; 10</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 5输出：[0,1,1,2,1,2]解释：0 --&gt; 01 --&gt; 12 --&gt; 103 --&gt; 114 --&gt; 1005 --&gt; 101</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 105</code></li></ul><p><strong>进阶：</strong></p><ul><li>很容易就能实现时间复杂度为 <code>O(n log n)</code> 的解决方案，你可以在线性时间复杂度 <code>O(n)</code> 内用一趟扫描解决此问题吗？</li><li>你能不使用任何内置函数解决此问题吗？（如，C++ 中的 <code>__builtin_popcount</code> ）</li></ul><p>根据二进制特性，前面的位数和  i&#x2F;2 一致，最后新增的一位是 i%2</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countBits</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">retirn []<span class="type">int</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">2</span>; i&lt;=n; i++ &#123;</span><br><span class="line">t1, t2 := i/<span class="number">2</span>, i%<span class="number">2</span></span><br><span class="line">ans = <span class="built_in">append</span>(ans, ans[t1] + t2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Brian-Kernighan-算法"><a href="#Brian-Kernighan-算法" class="headerlink" title="Brian Kernighan 算法"></a>Brian Kernighan 算法</h4><p>Brian Kernighan 算法的原理是：对于任意整数 xxx，令 x&#x3D;x &amp; (x−1)x&#x3D;x<del>&amp;</del>(x-1)x&#x3D;x &amp; (x−1)，该运算将 xxx 的二进制表示的最后一个 111 变成 000。因此，对 xxx 重复该操作，直到 xxx 变成 000，则操作次数即为 xxx 的「一比特数」。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">onesCount</span><span class="params">(x <span class="type">int</span>)</span></span> (ones <span class="type">int</span>) &#123; </span><br><span class="line"><span class="keyword">for</span> ; x &gt; <span class="number">0</span>; x &amp;= x - <span class="number">1</span> &#123; </span><br><span class="line">ones++ </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countBits</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123; </span><br><span class="line"><span class="comment">// 0-n 共 n+1 个数</span></span><br><span class="line">bits := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>) </span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> bits &#123; </span><br><span class="line">bits[i] = onesCount(i) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> bits </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.191 位1的个数</title>
      <link href="/interview/juan/neet150/bit/leet-191-number-of-1-bits/"/>
      <url>/interview/juan/neet150/bit/leet-191-number-of-1-bits/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/number-of-1-bits/description/">Leetcode.191 位1的个数</a></p><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中 设置位 的个数（也被称为<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F">汉明重量</a>）。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 11输出：3解释：输入的二进制串 `1011 中，共有 3 个设置位。`</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 128输出：1解释：输入的二进制串 10000000 中，共有 1 个设置位。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：n = 2147483645输出：30解释：输入的二进制串 11111111111111111111111111111101 中，共有 30 个设置位。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hammingWeight</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> ones <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span>&lt;&lt;i &amp; num &gt; <span class="number">0</span> &#123;</span><br><span class="line">ones += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ones</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Bit Manipulation </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>math</title>
      <link href="/uncategorized/math/"/>
      <url>/uncategorized/math/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/jzj_c_love/article/details/122279703">https://blog.csdn.net/jzj_c_love/article/details/122279703</a></p><h1 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h1><h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p>$$<br>A_1^2<br>\<br>B_{12}<br>\<br>2^{x^2+y}<br>$$</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">A_1^2</span><br><span class="line">\\</span><br><span class="line">B_&#123;12&#125;</span><br><span class="line">\\</span><br><span class="line">2^&#123;x^2+y&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h2 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h2><p>$$<br>\frac{x}{1+x^2}<br>\<br>\frac{\frac{1}{2}+x}{y}<br>\<br>\tfrac{a}{b}<br>\frac{a}{b}<br>$$</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\frac&#123;x&#125;&#123;1+x^2&#125;</span><br><span class="line">\\</span><br><span class="line">\frac&#123;\frac&#123;1&#125;&#123;2&#125;+x&#125;&#123;y&#125;</span><br><span class="line">\\</span><br><span class="line">\tfrac&#123;a&#125;&#123;b&#125;</span><br><span class="line">\frac&#123;a&#125;&#123;b&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h2 id="开根"><a href="#开根" class="headerlink" title="开根"></a>开根</h2><p>$$<br>\sqrt{x}<br>\sqrt[3]{x}<br>$$</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\sqrt&#123;x&#125;</span><br><span class="line">\sqrt[3]&#123;x&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>$$<br>\binom{n}{k}<br>\tbinom{n}{k}<br>$$</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\binom&#123;n&#125;&#123;k&#125;</span><br><span class="line">\tbinom&#123;n&#125;&#123;k&#125;</span><br></pre></td></tr></table></figure><h2 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h2><p>$$<br>a′a′′a′<br>$$</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">𝑎′𝑎″𝑎′</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h2 id="偏微分"><a href="#偏微分" class="headerlink" title="偏微分"></a>偏微分</h2><p>$$<br>∂∇∂∇<br>$$</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">a&#x27;</span><br><span class="line">a&#x27;&#x27;</span><br><span class="line">a^&#123;\prime&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h2 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h2><p>$$<br>x(moda)2modx𝑥(mod𝑎)2mod𝑥<br>$$</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">x \pmod a</span><br><span class="line">\\</span><br><span class="line">2\mod&#123;x&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h2><p>$$<br>∫211∫2∮∫∬∯∭∰∫12∫21∮⁡∫∬∯⁡∭∰<br>$$</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">$</span><span class="operator">$</span></span><br><span class="line">\<span class="keyword">int_</span>&#123;<span class="number">1</span>&#125;<span class="operator">^</span>&#123;<span class="number">2</span>&#125;</span><br><span class="line">\<span class="keyword">intop_</span>&#123;<span class="number">2</span>&#125;<span class="operator">^</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">\oint</span><br><span class="line">\smallint</span><br><span class="line">\\</span><br><span class="line">\iint</span><br><span class="line">\oiint</span><br><span class="line">\iiint</span><br><span class="line">\oiiint</span><br></pre></td></tr></table></figure><h2 id="累加-x2F-累乘-x2F-极限"><a href="#累加-x2F-累乘-x2F-极限" class="headerlink" title="累加&#x2F;累乘&#x2F;极限"></a>累加&#x2F;累乘&#x2F;极限</h2><p>k∑i&#x3D;1n∑i&#x3D;1∑ni&#x3D;1k∏i&#x3D;1n∏i&#x3D;1∏ni&#x3D;1limk→∞limk→∞limk→∞∑𝑖&#x3D;1𝑘∑𝑖&#x3D;1𝑛∑𝑖&#x3D;1𝑛∏𝑖&#x3D;1𝑘∏𝑖&#x3D;1𝑛∏𝑖&#x3D;1𝑛lim𝑘→∞lim𝑘→∞lim𝑘→∞</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\<span class="keyword">sum_</span>&#123;i<span class="operator">=</span><span class="number">1</span>&#125;<span class="operator">^</span>&#123;k&#125;</span><br><span class="line">\displaystyle\<span class="keyword">sum_</span>&#123;i<span class="operator">=</span><span class="number">1</span>&#125;<span class="symbol">^n</span></span><br><span class="line">\textstyle\<span class="keyword">sum_</span>&#123;i<span class="operator">=</span><span class="number">1</span>&#125;<span class="symbol">^n</span></span><br><span class="line">\\</span><br><span class="line">\<span class="keyword">prod_</span>&#123;i<span class="operator">=</span><span class="number">1</span>&#125;<span class="operator">^</span>&#123;k&#125;</span><br><span class="line">\displaystyle\<span class="keyword">prod_</span>&#123;i<span class="operator">=</span><span class="number">1</span>&#125;<span class="symbol">^n</span></span><br><span class="line">\textstyle\<span class="keyword">prod_</span>&#123;i<span class="operator">=</span><span class="number">1</span>&#125;<span class="symbol">^n</span></span><br><span class="line">\\</span><br><span class="line">\<span class="keyword">lim_</span>&#123;k \<span class="keyword">to</span> \infty&#125;</span><br><span class="line">\lim\<span class="keyword">limits_</span>&#123;k \<span class="keyword">to</span> \infty&#125;</span><br><span class="line">\lim\<span class="keyword">nolimits_</span>&#123;k \<span class="keyword">to</span> \infty&#125;</span><br></pre></td></tr></table></figure><h1 id="修饰符号"><a href="#修饰符号" class="headerlink" title="修饰符号"></a>修饰符号</h1><p><strong>简单的帽子</strong></p><p>^θˆAB¯y¯¯¯¯¯¯¯¯AB<del>a˜ac¯a´aˇa&#96;a˙a¨a𝜃^𝐴𝐵^𝑦¯𝐴𝐵¯𝑎</del>𝑎𝑐~𝑎¯𝑎´𝑎ˇ𝑎&#96;𝑎˙𝑎¨</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">\hat&#123;\theta&#125;</span><br><span class="line">\widehat&#123;AB&#125;</span><br><span class="line">\\</span><br><span class="line">\bar&#123;y&#125;</span><br><span class="line">\overline&#123;AB&#125;</span><br><span class="line">\\</span><br><span class="line">\tilde&#123;a&#125;</span><br><span class="line">\widetilde&#123;ac&#125;</span><br><span class="line">\\</span><br><span class="line">\bar&#123;a&#125;</span><br><span class="line">\acute&#123;a&#125;</span><br><span class="line">\check&#123;a&#125;</span><br><span class="line">\grave&#123;a&#125;</span><br><span class="line">\\</span><br><span class="line">\dot&#123;a&#125;</span><br><span class="line">\ddot&#123;a&#125;</span><br></pre></td></tr></table></figure><p><strong>帽子和袜子</strong></p><p>←−−AB−−→AB←→ABAB←−−AB−−→AB←→ABAB¯¯¯¯¯¯¯¯ABAB––––𝐴𝐵←𝐴𝐵→𝐴𝐵↔𝐴𝐵←𝐴𝐵→𝐴𝐵↔𝐴𝐵⏞𝐴𝐵⏟𝐴𝐵¯𝐴𝐵_</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\overleftarrow&#123;AB&#125;</span><br><span class="line">\overrightarrow&#123;AB&#125;</span><br><span class="line">\overleftrightarrow&#123;AB&#125;</span><br><span class="line">\\</span><br><span class="line">\underleftarrow&#123;AB&#125;</span><br><span class="line">\underrightarrow&#123;AB&#125;</span><br><span class="line">\underleftrightarrow&#123;AB&#125;</span><br><span class="line">\\</span><br><span class="line">\overbrace&#123;AB&#125;</span><br><span class="line">\underbrace&#123;AB&#125;</span><br><span class="line">\\</span><br><span class="line">\overline&#123;AB&#125;</span><br><span class="line">\underline&#123;AB&#125;</span><br></pre></td></tr></table></figure><p><strong>盖子和盒子</strong></p><p>notea+b+ca+b+cnoteπ&#x3D;3.14𝑎+𝑏+𝑐⏞note𝑎+𝑏+𝑐⏟note𝜋&#x3D;3.14</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\<span class="keyword">overbrace</span>&#123;a<span class="operator">+</span>b<span class="operator">+</span>c&#125;<span class="operator">^</span>&#123;\<span class="keyword">text</span>&#123;note&#125;&#125;</span><br><span class="line">\\</span><br><span class="line">\<span class="keyword">underbrace</span>&#123;a<span class="operator">+</span>b<span class="operator">+</span>c&#125;<span class="keyword">_</span>&#123;\<span class="keyword">text</span>&#123;note&#125;&#125;</span><br><span class="line">\\</span><br><span class="line">\<span class="keyword">boxed</span>&#123;\pi<span class="operator">=</span><span class="number">3.14</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="各种括号"><a href="#各种括号" class="headerlink" title="各种括号"></a>各种括号</h1><p>((((((((((</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">\<span class="keyword">big(</span></span><br><span class="line"><span class="keyword"></span>\<span class="keyword">Big(</span></span><br><span class="line"><span class="keyword"></span>\<span class="keyword">bigg(</span></span><br><span class="line"><span class="keyword"></span>\<span class="keyword">Bigg(</span></span><br></pre></td></tr></table></figure><p>[]&lt;&gt;|−2|{}[]&lt;&gt;|−2|{}</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br><span class="line"><span class="tag">&lt;&gt;</span></span><br><span class="line">|-2|</span><br><span class="line">\&#123;\&#125;</span><br></pre></td></tr></table></figure><p>⟮x⟯∥a∥⌈2.6⌉⌊1.2⌋⟮𝑥⟯‖𝑎‖⌈2.6⌉⌊1.2⌋</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\lgroup <span class="attribute">x</span> \rgroup</span><br><span class="line">\lVert <span class="selector-tag">a</span> \rVert</span><br><span class="line">\lceil <span class="number">2.6</span> \rceil</span><br><span class="line">\lfloor <span class="number">1.2</span> \rfloor</span><br></pre></td></tr></table></figure><p>┌┐└┘⌜⌝⌞⌟</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\ulcorner</span><br><span class="line">\urcorner</span><br><span class="line">\<span class="keyword">llcorner</span></span><br><span class="line"><span class="keyword"></span>\lrcorner</span><br></pre></td></tr></table></figure><h1 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h1><p><img src="https://img2020.cnblogs.com/blog/2068113/202008/2068113-20200816212452725-1705310605.jpg" alt="希腊字母"></p><h1 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h1><p>+−×&#x2F;÷⋅#%+−×&#x2F;÷⋅#%</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+</span><br><span class="line">-</span><br><span class="line">\<span class="built_in">times</span></span><br><span class="line">/</span><br><span class="line">\div</span><br><span class="line">\cdot</span><br><span class="line">\#</span><br><span class="line">\%</span><br></pre></td></tr></table></figure><p>∩∪∧∨⊔⊓∩∪∧∨⊔⊓</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\<span class="built_in">cap</span></span><br><span class="line">\cup</span><br><span class="line">\land</span><br><span class="line">\lor</span><br><span class="line">\sqcup</span><br><span class="line">\sqcap</span><br></pre></td></tr></table></figure><p>∘∗⋆⊗⊕⊙∘∗⋆⊗⊕⊙</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\circ</span><br><span class="line">\ast</span><br><span class="line">\star</span><br><span class="line">\otimes</span><br><span class="line">\oplus</span><br><span class="line">\odot</span><br></pre></td></tr></table></figure><p>±∓∔⋇±∓∔⋇</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\pm</span><br><span class="line">\mp</span><br><span class="line">\dotplus</span><br><span class="line">\<span class="keyword">divideontimes</span></span><br></pre></td></tr></table></figure><h1 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h1><p>&#x3D;&#x3D;≢≈≊≅∼&#x3D;&#x3D;≢≈≊≅∼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=</span><br><span class="line">= \not</span><br><span class="line">\equiv</span><br><span class="line">\approx</span><br><span class="line">\approxeq</span><br><span class="line">\cong</span><br><span class="line">\sim</span><br></pre></td></tr></table></figure><p>&lt;&gt;≤≥≫≪&lt;&gt;≤≥≫≪</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;</span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">\le</span></span><br><span class="line">\ge</span><br><span class="line">\gg</span><br><span class="line">\ll</span><br></pre></td></tr></table></figure><p>⋞⋟≺≻⪯⪰⋞⋟≺≻⪯⪰</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\curlyeqprec</span><br><span class="line">\curlyeqsucc</span><br><span class="line">\prec</span><br><span class="line">\succ</span><br><span class="line">\preceq</span><br><span class="line">\succeq</span><br></pre></td></tr></table></figure><h1 id="集合-x2F-逻辑相关"><a href="#集合-x2F-逻辑相关" class="headerlink" title="集合&#x2F;逻辑相关"></a>集合&#x2F;逻辑相关</h1><p>∈∋⊄⊅⊆⊇∩∪∧∨¬∅∅∵∀∃∴∈∋⊄⊅⊆⊇∩∪∧∨¬∅∅∵∀∃∴</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">\in</span><br><span class="line">\owns \not</span><br><span class="line">\<span class="keyword">subset </span>\not</span><br><span class="line">\supset</span><br><span class="line">\<span class="keyword">subseteq</span></span><br><span class="line"><span class="keyword"></span>\supseteq</span><br><span class="line">\\</span><br><span class="line">\cap</span><br><span class="line">\cup</span><br><span class="line">\land</span><br><span class="line">\lor</span><br><span class="line">\\</span><br><span class="line">\neg</span><br><span class="line">\emptyset</span><br><span class="line">\varnothing</span><br><span class="line">\\</span><br><span class="line">\<span class="keyword">because</span></span><br><span class="line"><span class="keyword"></span>\forall</span><br><span class="line">\exists</span><br><span class="line">\therefore</span><br></pre></td></tr></table></figure><h1 id="各种箭头"><a href="#各种箭头" class="headerlink" title="各种箭头"></a>各种箭头</h1><p><strong>细箭头</strong></p><p>←←→→↔↑↓↕←←→→↔↑↓↕</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\gets</span><br><span class="line">\leftarrow</span><br><span class="line">\<span class="selector-tag">to</span></span><br><span class="line">\rightarrow</span><br><span class="line">\leftrightarrow</span><br><span class="line">\\</span><br><span class="line">\uparrow</span><br><span class="line">\downarrow</span><br><span class="line">\updownarrow</span><br></pre></td></tr></table></figure><p><strong>粗箭头</strong></p><p>⇐⇒⇔⟺⇑⇓⇕⇐⇒⇔⟺⇑⇓⇕</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\Leftarrow</span><br><span class="line">\Rightarrow</span><br><span class="line">\Leftrightarrow</span><br><span class="line">\<span class="keyword">iff</span></span><br><span class="line">\\</span><br><span class="line">\Uparrow</span><br><span class="line">\Downarrow</span><br><span class="line">\Updownarrow</span><br></pre></td></tr></table></figure><p><strong>斜箭头</strong></p><p>↗↘↙↖↗↘↙↖</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\nearrow</span><br><span class="line">\searrow</span><br><span class="line">\<span class="keyword">swarrow</span></span><br><span class="line"><span class="keyword"></span>\nwarrow</span><br></pre></td></tr></table></figure><p><strong>半边箭头</strong></p><p>↼↽⇀⇁⇌↼↽⇀⇁⇌</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\leftharpoonup</span><br><span class="line">\leftharpoondown</span><br><span class="line">\rightharpoonup</span><br><span class="line">\rightharpoondown</span><br><span class="line">\rightleftharpoons</span><br></pre></td></tr></table></figure><p><strong>特殊箭头</strong></p><p>↦⇝↩↪↦⇝↩↪</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\mapsto</span><br><span class="line">\leadsto</span><br><span class="line">\hookleftarrow</span><br><span class="line">\hookrightarrow</span><br></pre></td></tr></table></figure><p><strong>加长箭头</strong></p><p>⟵⟶⟷⟸⟹⟺⟼⟵⟶⟷⟸⟹⟺⟼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\longleftarrow</span><br><span class="line">\longrightarrow</span><br><span class="line">\longleftrightarrow</span><br><span class="line">\Longleftarrow</span><br><span class="line">\Longrightarrow</span><br><span class="line">\Longleftrightarrow</span><br><span class="line">\longmapsto</span><br></pre></td></tr></table></figure><p><strong>带文本箭头</strong></p><p>over−−→−−→overover−−−→underover←−−←−−−underover←−−−under→𝑜𝑣𝑒𝑟→𝑜𝑣𝑒𝑟→𝑢𝑛𝑑𝑒𝑟𝑜𝑣𝑒𝑟←𝑜𝑣𝑒𝑟←𝑢𝑛𝑑𝑒𝑟←𝑢𝑛𝑑𝑒𝑟𝑜𝑣𝑒𝑟</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\xrightarrow&#123;over&#125;</span><br><span class="line">\xrightarrow<span class="selector-attr">[over]</span>&#123;&#125;</span><br><span class="line">\xrightarrow<span class="selector-attr">[under]</span>&#123;over&#125;</span><br><span class="line">\xleftarrow<span class="selector-attr">[]</span>&#123;over&#125;</span><br><span class="line">\xleftarrow<span class="selector-attr">[under]</span>&#123;&#125;</span><br><span class="line">\xleftarrow<span class="selector-attr">[under]</span>&#123;over&#125;</span><br></pre></td></tr></table></figure><h1 id="空格间距"><a href="#空格间距" class="headerlink" title="空格间距"></a>空格间距</h1><p>ABABABABA BABABAB𝐴𝐵𝐴𝐵𝐴𝐵𝐴𝐵𝐴 𝐵𝐴𝐵𝐴𝐵𝐴𝐵</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">A\!B</span><br><span class="line">\\</span><br><span class="line">AB</span><br><span class="line">\\</span><br><span class="line">A\thinspace B</span><br><span class="line">\\</span><br><span class="line">A\:B</span><br><span class="line">\\</span><br><span class="line">A\ B</span><br><span class="line">\\</span><br><span class="line">A \enspace B</span><br><span class="line">\\</span><br><span class="line">A\quad B</span><br><span class="line">\\</span><br><span class="line">A\qquad B</span><br></pre></td></tr></table></figure><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p>A&#x3D;abcd𝐴&#x3D;𝑎𝑏𝑐𝑑</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = \<span class="keyword">begin</span>&#123;matrix&#125;</span><br><span class="line">a &amp; b\\</span><br><span class="line">c &amp; d</span><br><span class="line">\<span class="keyword">end</span>&#123;matrix&#125;</span><br></pre></td></tr></table></figure><p>B&#x3D;(abcd)𝐵&#x3D;(𝑎𝑏𝑐𝑑)</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">B </span>= \<span class="keyword">begin&#123;pmatrix&#125;</span></span><br><span class="line"><span class="keyword"></span>a &amp; <span class="keyword">b\\</span></span><br><span class="line"><span class="keyword"></span>c &amp; d</span><br><span class="line">\end&#123;pmatrix&#125;</span><br></pre></td></tr></table></figure><p>C&#x3D;∣∣∣abcd∣∣∣𝐶&#x3D;|𝑎𝑏𝑐𝑑|</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C = \<span class="keyword">begin</span>&#123;vmatrix&#125;</span><br><span class="line">a &amp; b\\</span><br><span class="line">c &amp; d</span><br><span class="line">\<span class="keyword">end</span>&#123;vmatrix&#125;</span><br></pre></td></tr></table></figure><p>D&#x3D;[abcd]𝐷&#x3D;[𝑎𝑏𝑐𝑑]</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D = \<span class="keyword">begin&#123;bmatrix&#125;</span></span><br><span class="line"><span class="keyword"></span>a &amp; <span class="keyword">b\\</span></span><br><span class="line"><span class="keyword"></span>c &amp; d</span><br><span class="line">\end&#123;<span class="keyword">bmatrix&#125;</span></span><br></pre></td></tr></table></figure><p>E&#x3D;∥∥∥abcd∥∥∥𝐸&#x3D;‖𝑎𝑏𝑐𝑑‖</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E = \<span class="keyword">begin</span>&#123;<span class="title class_">Vmatrix</span>&#125;</span><br><span class="line">a &amp; b\\</span><br><span class="line">c &amp; d</span><br><span class="line">\<span class="keyword">end</span>&#123;<span class="title class_">Vmatrix</span>&#125;</span><br></pre></td></tr></table></figure><p>F&#x3D;{abcd}𝐹&#x3D;{𝑎𝑏𝑐𝑑}</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F = \<span class="keyword">begin&#123;Bmatrix&#125;</span></span><br><span class="line"><span class="keyword"></span>a &amp; <span class="keyword">b\\</span></span><br><span class="line"><span class="keyword"></span>c &amp; d</span><br><span class="line">\end&#123;<span class="keyword">Bmatrix&#125;</span></span><br></pre></td></tr></table></figure><p>[A b]&#x3D;⎡⎢ ⎢⎣a11a12a13b1a21a22a23b2a31a32a33b3⎤⎥ ⎥⎦[𝐴 𝑏]&#x3D;[𝑎11𝑎12𝑎13𝑏1𝑎21𝑎22𝑎23𝑏2𝑎31𝑎32𝑎33𝑏3]</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[A\ b] <span class="operator">=</span> </span><br><span class="line">\<span class="keyword">begin</span>&#123;bmatrix&#125;</span><br><span class="line">\<span class="keyword">begin</span>&#123;array&#125;&#123;c c c<span class="operator">|</span>c&#125;</span><br><span class="line"><span class="keyword">a_</span>&#123;<span class="number">11</span>&#125; <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">12</span>&#125; <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">13</span>&#125; <span class="operator">&amp;</span> b_1\\</span><br><span class="line"><span class="keyword">a_</span>&#123;<span class="number">21</span>&#125; <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">22</span>&#125; <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">23</span>&#125; <span class="operator">&amp;</span> b_2\\</span><br><span class="line"><span class="keyword">a_</span>&#123;<span class="number">31</span>&#125; <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">32</span>&#125; <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">33</span>&#125; <span class="operator">&amp;</span> b_3\\</span><br><span class="line">\<span class="keyword">end</span>&#123;array&#125;</span><br><span class="line">\<span class="keyword">end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure><p>abcdefghi𝑎𝑏𝑐𝑑𝑒𝑓𝑔ℎ𝑖</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;array&#125;&#123;c:c:c&#125;</span><br><span class="line"><span class="selector-tag">a</span> &amp; <span class="selector-tag">b</span> &amp; c \\ </span><br><span class="line">\hline</span><br><span class="line">d &amp; e &amp; f \\</span><br><span class="line">\hdashline</span><br><span class="line"> <span class="selector-tag">g</span> &amp; h &amp; <span class="selector-tag">i</span></span><br><span class="line">\end&#123;array&#125;</span><br></pre></td></tr></table></figure><p>Ln×n&#x3D;⎡⎢ ⎢ ⎢ ⎢ ⎢⎣a11a12⋯a1na21a22⋯a2n⋮⋮⋱⋮an1an2⋯ann⎤⎥ ⎥ ⎥ ⎥ ⎥⎦𝐿𝑛×𝑛&#x3D;[𝑎11𝑎12⋯𝑎1𝑛𝑎21𝑎22⋯𝑎2𝑛⋮⋮⋱⋮𝑎𝑛1𝑎𝑛2⋯𝑎𝑛𝑛]</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L_&#123;n\times n&#125; <span class="operator">=</span> \<span class="keyword">begin</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">a_</span>&#123;<span class="number">11</span>&#125; <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">12</span>&#125; <span class="operator">&amp;</span> \cdots <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">1</span>n&#125; \\ </span><br><span class="line"><span class="keyword">a_</span>&#123;<span class="number">21</span>&#125; <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">22</span>&#125; <span class="operator">&amp;</span> \cdots <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;<span class="number">2</span>n&#125; \\ </span><br><span class="line">\vdots <span class="operator">&amp;</span> \vdots <span class="operator">&amp;</span>\ddots <span class="operator">&amp;</span> \vdots\\</span><br><span class="line"><span class="keyword">a_</span>&#123;n1&#125; <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;n2&#125; <span class="operator">&amp;</span> \cdots <span class="operator">&amp;</span> <span class="keyword">a_</span>&#123;nn&#125; \\ </span><br><span class="line">\<span class="keyword">end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure><h1 id="列式-x2F-方程组"><a href="#列式-x2F-方程组" class="headerlink" title="列式&#x2F;方程组"></a>列式&#x2F;方程组</h1><p>f(x)&#x3D;(x+1)2&#x3D;x2+2x+1𝑓(𝑥)&#x3D;(𝑥+1)2&#x3D;𝑥2+2𝑥+1</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\<span class="keyword">begin</span>&#123;aligned&#125;</span><br><span class="line">f(x) &amp;= (x+<span class="number">1</span>)^<span class="number">2</span>\\</span><br><span class="line">&amp;= x^<span class="number">2</span> + 2x + <span class="number">1</span></span><br><span class="line">\<span class="keyword">end</span>&#123;aligned&#125;</span><br></pre></td></tr></table></figure><p>f(x)&#x3D;{aif bbif a𝑓(𝑥)&#x3D;{𝑎if b𝑏if a</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(x) <span class="operator">=</span> \<span class="keyword">begin</span>&#123;cases&#125;</span><br><span class="line">a <span class="operator">&amp;</span>\<span class="keyword">text</span>&#123;<span class="keyword">if</span> b&#125;\\</span><br><span class="line">b <span class="operator">&amp;</span>\<span class="keyword">text</span>&#123;<span class="keyword">if</span> a&#125;\\</span><br><span class="line">\<span class="keyword">end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure><p>{x+2y&#x3D;13x−y&#x3D;5{𝑥+2𝑦&#x3D;13𝑥−𝑦&#x3D;5</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\<span class="keyword">begin</span>&#123;cases&#125;</span><br><span class="line">\<span class="keyword">begin</span>&#123;aligned&#125;</span><br><span class="line">x + 2y &amp;= <span class="number">1</span>\\</span><br><span class="line">3x - y &amp;= <span class="number">5</span></span><br><span class="line">\<span class="keyword">end</span>&#123;aligned&#125;</span><br><span class="line">\<span class="keyword">end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure><h1 id="字体操作"><a href="#字体操作" class="headerlink" title="字体操作"></a>字体操作</h1><h2 id="修改字体"><a href="#修改字体" class="headerlink" title="修改字体"></a>修改字体</h2><p><img src="https://img2020.cnblogs.com/blog/2068113/202008/2068113-20200816212537331-1196114732.jpg"></p><h2 id="修改大小"><a href="#修改大小" class="headerlink" title="修改大小"></a>修改大小</h2><p>dABddAB𝑑𝐴𝐵𝑑𝑑𝐴𝐵</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\Huge AB</span><br><span class="line">d</span><br><span class="line">\\</span><br><span class="line">d</span><br><span class="line">\<span class="keyword">normalsize </span>AB</span><br></pre></td></tr></table></figure><p>修改字体的操作影响效果到行末。</p><p>ABABABABABABABABABAB𝐴𝐵𝐴𝐵𝐴𝐵𝐴𝐵𝐴𝐵𝐴𝐵𝐴𝐵𝐴𝐵𝐴𝐵𝐴𝐵</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AB</span><br><span class="line">\Huge AB</span><br><span class="line">\huge AB</span><br><span class="line">\\</span><br><span class="line">AB</span><br><span class="line">\<span class="keyword">LARGE</span> AB</span><br><span class="line">\<span class="keyword">Large</span> AB</span><br><span class="line">\<span class="keyword">large</span> AB</span><br><span class="line">\\</span><br><span class="line">AB</span><br><span class="line">\small AB</span><br><span class="line">\tiny AB</span><br></pre></td></tr></table></figure><h2 id="修改颜色"><a href="#修改颜色" class="headerlink" title="修改颜色"></a>修改颜色</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\textcolor&#123;blue&#125;&#123;F=ma&#125;  </span><br><span class="line">\\  </span><br><span class="line">\textcolor&#123;#00ff00&#125;&#123;F=ma&#125;  </span><br><span class="line">\\  </span><br><span class="line">\textcolor&#123;#ff0000&#125;&#123;F=ma&#125;  </span><br><span class="line">\\  </span><br><span class="line">\color&#123;blue&#125; one\ line  </span><br><span class="line">\\  </span><br><span class="line">nothing\textcolor&#123;blue&#125;&#123;F=ma&#125;\\\textcolor&#123;#00ff00&#125;&#123;F=ma&#125;\\\textcolor&#123;#ff0000&#125;&#123;F=ma&#125;\\\color&#123;blue&#125; one\ line\\nothing</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>博客园的MD不能使用，给大伙一张在typora中的演示图康康</p><p><img src="https://img2020.cnblogs.com/blog/2068113/202008/2068113-20200816212700467-21726386.jpg"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">\textcolor&#123;<span class="keyword">blue&#125;&#123;F=ma&#125;</span></span><br><span class="line"><span class="keyword"></span>\\</span><br><span class="line">\textcolor&#123;<span class="comment">#00ff00&#125;&#123;F=ma&#125;</span></span><br><span class="line">\\</span><br><span class="line">\textcolor&#123;<span class="comment">#ff0000&#125;&#123;F=ma&#125;</span></span><br><span class="line">\\</span><br><span class="line">\color&#123;<span class="keyword">blue&#125; </span>one\ line</span><br><span class="line">\\</span><br><span class="line">nothing</span><br><span class="line"></span><br><span class="line">\colorbox&#123;<span class="comment">#00ff00&#125;&#123;F=ma&#125;  </span></span><br><span class="line">\\  </span><br><span class="line">\colorbox&#123;aqua&#125;&#123;A&#125;  </span><br><span class="line">\\  </span><br><span class="line">\fcolorbox&#123;red&#125;&#123;aqua&#125;&#123;A&#125;\colorbox&#123;<span class="comment">#00ff00&#125;&#123;F=ma&#125;\\\colorbox&#123;aqua&#125;&#123;A&#125;\\\fcolorbox&#123;red&#125;&#123;aqua&#125;&#123;A&#125;</span></span><br></pre></td></tr></table></figure><p>博客园的MD同样不能使用<br><img src="https://img2020.cnblogs.com/blog/2068113/202008/2068113-20200816212823358-551538593.jpg"></p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\<span class="keyword">colorbox</span>&#123;#<span class="number">00</span>ff00&#125;&#123;F<span class="operator">=</span>ma&#125;</span><br><span class="line">\\</span><br><span class="line">\<span class="keyword">colorbox</span>&#123;aqua&#125;&#123;A&#125;</span><br><span class="line">\\</span><br><span class="line">\<span class="keyword">fcolorbox</span>&#123;red&#125;&#123;aqua&#125;&#123;A&#125;</span><br></pre></td></tr></table></figure><h2 id="划掉"><a href="#划掉" class="headerlink" title="划掉"></a>划掉</h2><p>\cancel5\bcancel5\xcancelABC≠\cancel5\bcancel5\xcancel𝐴𝐵𝐶≠</p><p>博客园的MD同样不能使用<br><img src="https://img2020.cnblogs.com/blog/2068113/202008/2068113-20200816212841764-646057837.jpg"></p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\<span class="keyword">cancel</span>&#123;<span class="number">5</span>&#125;</span><br><span class="line">\<span class="keyword">bcancel</span>&#123;<span class="number">5</span>&#125;</span><br><span class="line">\<span class="keyword">xcancel</span>&#123;ABC&#125;</span><br><span class="line">\<span class="built_in">not</span> <span class="operator">=</span></span><br></pre></td></tr></table></figure><h1 id="常见图形"><a href="#常见图形" class="headerlink" title="常见图形"></a>常见图形</h1><p>□□■△▽▲⋄◊⋆★∘∙◯⨀◻◻◼△▽▴⋄◊⋆★∘∙◯⨀</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\<span class="keyword">Box</span></span><br><span class="line"><span class="keyword"></span>\square</span><br><span class="line">\<span class="keyword">blacksquare</span></span><br><span class="line"><span class="keyword"></span>\triangle</span><br><span class="line">\triangledown</span><br><span class="line">\<span class="keyword">blacktriangle</span></span><br><span class="line"><span class="keyword"></span>\<span class="keyword">diamond</span></span><br><span class="line"><span class="keyword"></span>\<span class="keyword">Diamond</span></span><br><span class="line"><span class="keyword"></span>\star</span><br><span class="line">\<span class="keyword">bigstar</span></span><br><span class="line"><span class="keyword"></span>\circ</span><br><span class="line">\<span class="keyword">bullet</span></span><br><span class="line"><span class="keyword"></span>\<span class="keyword">bigcirc</span></span><br><span class="line"><span class="keyword"></span>\<span class="keyword">bigodot</span></span><br></pre></td></tr></table></figure><p>♢♣♡♠♢♣♡♠</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\<span class="keyword">diamondsuit</span></span><br><span class="line"><span class="keyword"></span>\clubsuit</span><br><span class="line">\heartsuit</span><br><span class="line">\spadesuit</span><br></pre></td></tr></table></figure><p>∠∡⊤⊥∞∠∡⊤⊥∞</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\angle</span><br><span class="line">\measuredangle</span><br><span class="line">\<span class="attribute">top</span></span><br><span class="line">\bot</span><br><span class="line">\infty</span><br></pre></td></tr></table></figure><p>✓†‡¥$✓†‡¥$</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\checkmark</span><br><span class="line">\dagger</span><br><span class="line">\ddagger</span><br><span class="line">\yen</span><br><span class="line">\$</span><br></pre></td></tr></table></figure><h1 id="声明宏"><a href="#声明宏" class="headerlink" title="声明宏"></a>声明宏</h1><p>对于一些复杂但只是有少许不同的表达式，可以声明一个函数来调用，提高原码的可读性，减少出错。</p><p>基本的语法为</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\def\macroname#1#2&#123;</span><br><span class="line">your command</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宏允许带任意数量的参数（也可以不带参），必须是<code>#1,#2,……</code>这样的命名格式，同时注意再定义宏的时候注意让<code>#1</code>与<code>\</code>中间隔一个空格，否则会解析成#。再调用的时候格式为<code>\macroname&#123;x&#125;&#123;y&#125;&#123;z&#125;</code>，可以参考一下的例子：</p><p>f(x)&#x3D;1√2π σ1exp[−(x−u1)22 σ21]f(y)&#x3D;1√2π σ2exp[−(y−u2)22 σ22]𝑓(𝑥)&#x3D;12𝜋 𝜎1exp⁡[−(𝑥−𝑢1)22 𝜎12]𝑓(𝑦)&#x3D;12𝜋 𝜎2exp⁡[−(𝑦−𝑢2)22 𝜎22]</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">\</span>def<span class="punctuation">\</span>Normal<span class="comment">#1#2#3&#123;</span></span><br><span class="line"><span class="punctuation">\</span>frac<span class="punctuation">&#123;</span><span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">&#123;</span><span class="punctuation">\</span><span class="built_in">sqrt</span><span class="punctuation">&#123;</span><span class="number">2</span><span class="punctuation">\</span><span class="built_in">pi</span><span class="punctuation">&#125;</span><span class="punctuation">\</span> <span class="comment">#3&#125;\exp&#123;[-\frac&#123;(#1 - #2)^2&#125;&#123;2\ #3^2&#125;]&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">f<span class="punctuation">(</span>x<span class="punctuation">)</span><span class="operator">=</span><span class="punctuation">\</span>Normal<span class="punctuation">&#123;</span>x<span class="punctuation">&#125;</span><span class="punctuation">&#123;</span>u_1<span class="punctuation">&#125;</span><span class="punctuation">&#123;</span><span class="punctuation">\</span>sigma_1<span class="punctuation">&#125;</span><span class="punctuation">\</span><span class="punctuation">\</span></span><br><span class="line">f<span class="punctuation">(</span>y<span class="punctuation">)</span><span class="operator">=</span><span class="punctuation">\</span>Normal<span class="punctuation">&#123;</span>y<span class="punctuation">&#125;</span><span class="punctuation">&#123;</span>u_2<span class="punctuation">&#125;</span><span class="punctuation">&#123;</span><span class="punctuation">\</span>sigma_2<span class="punctuation">&#125;</span><span class="punctuation">\</span><span class="punctuation">\</span></span><br></pre></td></tr></table></figure><p>ex&#x3D;1+x+12!x2+13!x3+⋯𝑒𝑥&#x3D;1+𝑥+12!𝑥2+13!𝑥3+⋯</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\def\EXP&#123;</span><br><span class="line">e<span class="operator">^</span>x <span class="operator">=</span> <span class="number">1</span> <span class="operator">+</span> x <span class="operator">+</span> \<span class="keyword">frac</span>&#123;<span class="number">1</span>&#125;&#123;<span class="number">2</span><span class="operator">!</span>&#125;x<span class="operator">^</span><span class="number">2</span> <span class="operator">+</span> \<span class="keyword">frac</span>&#123;<span class="number">1</span>&#125;&#123;<span class="number">3</span><span class="operator">!</span>&#125;x<span class="operator">^</span><span class="number">3</span>  <span class="operator">+</span> \cdots</span><br><span class="line">&#125;</span><br><span class="line">\EXP</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode121. 买卖股票的最佳时间</title>
      <link href="/interview/juan/neet150/s-window/leet-121-best-time-to-buy-and-sell-stock/"/>
      <url>/interview/juan/neet150/s-window/leet-121-best-time-to-buy-and-sell-stock/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">Leetcode121. 买卖股票的最佳时间</a></p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><p>遍历的过程当中找到 cost 最小的那一天 or 那一天的成本，用当前的 price 减去 cost，就是在这一天所能达到的最大收益</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">cost, profit := prices[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, n := <span class="number">0</span>, <span class="built_in">len</span>(prices); i&lt;n; i++ &#123;</span><br><span class="line">cost = min(cost, prices[i])</span><br><span class="line">profit = max(profit, prices[i] - cost)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> profit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line"><span class="keyword">if</span> a &lt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.217 存在重复元素</title>
      <link href="/interview/juan/neet150/arrays-hashing/leet-217-contains-duplicate/"/>
      <url>/interview/juan/neet150/arrays-hashing/leet-217-contains-duplicate/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/contains-duplicate/description/">Leetcode.217 存在重复元素</a></p><p>给你一个整数数组 <code>nums</code> 。如果任一值在数组中出现 <strong>至少两次</strong> ，返回 <code>true</code> ；如果数组中每个元素互不相同，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3,1]输出：true</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,2,3,4]输出：false</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1,1,1,3,3,4,3,2,4,2]输出：true</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><p>哈希表，秒了！<br>直接排序，秒了！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsDuplicate</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; </span><br><span class="line">sort.Ints(nums) </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123; </span><br><span class="line"><span class="keyword">if</span> nums[i] == nums[i<span class="number">-1</span>] &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsDuplicate</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; </span><br><span class="line">set := <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125; </span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123; </span><br><span class="line"><span class="keyword">if</span> _, has := set[v]; has &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">&#125; </span><br><span class="line">set[v] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Arrays &amp; Hashing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.238 除自身以外数组的乘积</title>
      <link href="/interview/juan/neet150/arrays-hashing/leet-238-product-of-array-except-self/"/>
      <url>/interview/juan/neet150/arrays-hashing/leet-238-product-of-array-except-self/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/product-of-array-except-self/description/">Leetcode.238 除自身以外数组的乘积</a></p><p>给你一个整数数组 <code>nums</code>，返回 <em>数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。</p><p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在  <strong>32 位</strong> 整数范围内。</p><p>请 <strong>不要使用除法，</strong>且在 <code>O(_n_)</code> 时间复杂度内完成此题。</p><p><strong>示例 1:</strong></p><pre><code>输入: nums = `[1,2,3,4]`输出: `[24,12,8,6]`</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: nums = [-1,1,0,-3,3]输出: [0,0,9,0,0]</code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>-30 &lt;= nums[i] &lt;= 30</code></li><li><strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在  <strong>32 位</strong> 整数范围内</li></ul><p><strong>进阶：</strong>你可以在 <code>O(1)</code> 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 <strong>不被视为</strong> 额外空间。）</p><p>主要思路是想办法计算当前位置的前缀和后缀乘积</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productExceptSelf</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123; </span><br><span class="line">length := <span class="built_in">len</span>(nums) </span><br><span class="line"></span><br><span class="line"><span class="comment">// L 和 R 分别表示左右两侧的乘积列表 </span></span><br><span class="line">L, R, answer := <span class="built_in">make</span>([]<span class="type">int</span>, length), <span class="built_in">make</span>([]<span class="type">int</span>, length), <span class="built_in">make</span>([]<span class="type">int</span>, length) </span><br><span class="line"><span class="comment">// L[i] 为索引 i 左侧所有元素的乘积 </span></span><br><span class="line"><span class="comment">// 对于索引为 &#x27;0&#x27; 的元素，因为左侧没有元素，所以 L[0] = 1 </span></span><br><span class="line">L[<span class="number">0</span>] = <span class="number">1</span> </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123; </span><br><span class="line">L[i] = nums[i<span class="number">-1</span>] * L[i<span class="number">-1</span>] </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// R[i] 为索引 i 右侧所有元素的乘积 </span></span><br><span class="line"><span class="comment">// 对于索引为 &#x27;length-1&#x27; 的元素，因为右侧没有元素，所以 R[length-1] = 1 </span></span><br><span class="line">R[length<span class="number">-1</span>] = <span class="number">1</span> </span><br><span class="line"><span class="keyword">for</span> i := length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123; </span><br><span class="line">R[i] = nums[i+<span class="number">1</span>] * R[i+<span class="number">1</span>] </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积 </span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123; </span><br><span class="line">answer[i] = L[i] * R[i] </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> answer </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// O(1) 版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productExceptSelf</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(nums)</span><br><span class="line">ans := <span class="built_in">make</span>([]<span class="type">int</span>, length)</span><br><span class="line"><span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ans[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">    <span class="comment">// 因为索引为 &#x27;0&#x27; 的元素左侧没有元素， 所以 ans[0] = 1</span></span><br><span class="line">ans[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">ans[i] = nums[i<span class="number">-1</span>] * ans[i<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x 为右侧所有元素的乘积</span></span><br><span class="line"><span class="comment">// 刚开始右边没有元素，所以 x = 1</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j:=length<span class="number">-1</span>; j &gt;=<span class="number">0</span>; j-- &#123;</span><br><span class="line"><span class="comment">// 对于索引 i，左边的乘积为 ans[i]，右边的乘积为 x</span></span><br><span class="line">ans[j] = ans[j] * x</span><br><span class="line"><span class="comment">// x 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 x 上</span></span><br><span class="line">x = nums[j] * x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Arrays &amp; Hashing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode53. 最大子数组和</title>
      <link href="/interview/juan/neet150/greedy/leet-53-maximum-subarray/"/>
      <url>/interview/juan/neet150/greedy/leet-53-maximum-subarray/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/maximum-subarray/description/">Leetcode53. 最大子数组和</a></p><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong></p><p>是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1]输出：1</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [5,4,-1,7,8]输出：23</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p>思路和算法</p><p>假设 nums 数组的长度是 n，下标从 0 到 n−1。</p><p>我们用 f(i) 代表以第 i 个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：</p><p>$$max0≤i≤n−1​{f(i)}$$</p><p>因此我们只需要求出每个位置的 f(i)，然后返回 f 数组中的最大值即可。那么我们如何求 f(i) 呢？我们可以考虑 nums[i] 单独成为一段还是加入 f(i−1) 对应的那一段，这取决于 nums[i] 和 f(i−1)+nums[i] 的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：</p><p>$$f(i)&#x3D;max{f(i−1)+nums[i],nums[i]}$$</p><p>不难给出一个时间复杂度 O(n)、空间复杂度 O(n) 的实现，即用一个 f 数组来保存 f(i) 的值，用一个循环求出所有 f(i)。考虑到 f(i) 只和 f(i−1) 相关，于是我们可以只用一个变量 pre 来维护对于当前 f(i) 的 f(i−1) 的值是多少，从而让空间复杂度降低到 O(1)，这有点类似「滚动数组」的思想。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; </span><br><span class="line">max := nums[<span class="number">0</span>] </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123; </span><br><span class="line"><span class="keyword">if</span> nums[i] + nums[i<span class="number">-1</span>] &gt; nums[i] &#123; </span><br><span class="line">nums[i] += nums[i<span class="number">-1</span>] </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> nums[i] &gt; max &#123; </span><br><span class="line">max = nums[i] </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> max </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// -2,1,-3,4,-1,2,1,-5,4</span></span><br><span class="line"><span class="comment">// -2,1,-2,4,3,5,6,1,5</span></span><br></pre></td></tr></table></figure><p>简单来说就是看前一个元素是否大于 0 ，如果符合条件，那么就加到当前位置上</p><p>另一种方法是前缀和，找到每个位置的前缀和，那么某两个前缀和的最大差值就是我们要找的 子数组 区间和最大值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">ans := math.MinInt64</span><br><span class="line">minPreSum, preSum := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">preSum += num</span><br><span class="line">ans = max(ans, preSum-minPreSum)</span><br><span class="line">minPreSum = min(minPreSum, preSum)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Greedy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.152 乘积最大子数组</title>
      <link href="/interview/juan/neet150/1-d-dp/leet-152-maximum-product-subarray/"/>
      <url>/interview/juan/neet150/1-d-dp/leet-152-maximum-product-subarray/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/maximum-product-subarray/description/">Leetcode.152 乘积最大子数组</a></p><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>测试用例的答案是一个 <strong>32-位</strong> 整数。</p><p><strong>示例 1:</strong></p><pre><code>输入: nums = [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: nums = [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 的任何前缀或后缀的乘积都 <strong>保证</strong> 是一个 <strong>32-位</strong> 整数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> 1-D DP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.153 寻找旋转排序数组中的最小值</title>
      <link href="/interview/juan/neet150/b-search/leet-153-find-minimum-in-rotated-sorted-array/"/>
      <url>/interview/juan/neet150/b-search/leet-153-find-minimum-in-rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">Leetcode.153 寻找旋转排序数组中的最小值</a></p><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [3,4,5,1,2]输出：1解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [4,5,6,7,0,1,2]输出：0解释：原数组为 [0,1,2,4,5,6,7] ，旋转 3 次得到输入数组。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [11,13,15,17]输出：11解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</code></pre><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li><li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li></ul><p>类比 <a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">Leetcode.33 搜索旋转排序数组</a> 也可以用二分查找的思路</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">low, high := <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line">pivot := low + (high - low) / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> nums[pivot] &lt; nums[high] &#123;</span><br><span class="line">high = pivot</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">low = pivot + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[low]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.33 搜索旋转排序数组</title>
      <link href="/interview/juan/neet150/b-search/leet-33-search-in-rotated-sorted-array/"/>
      <url>/interview/juan/neet150/b-search/leet-33-search-in-rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">Leetcode.33 搜索旋转排序数组</a></p><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [`4,5,6,7,0,1,2]`, target = 0输出：4</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [`4,5,6,7,0,1,2]`, target = 3输出：-1</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1], target = 0输出：-1</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><p>二分查找嗷</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">if</span> nums[<span class="number">0</span>] != target &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> l&lt;=r &#123;</span><br><span class="line">mid := (r + l)/<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左侧递增</span></span><br><span class="line"><span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= nums[mid] &#123;</span><br><span class="line"><span class="comment">// 落在左，从左侧找</span></span><br><span class="line"><span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid] &#123;</span><br><span class="line">r = mid<span class="number">-1</span></span><br><span class="line"><span class="comment">// mid 左侧非递增，尝试从右边找</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = mid+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 落在右区间内，从右侧找</span></span><br><span class="line"><span class="keyword">if</span> nums[mid] &lt; target &amp;&amp; target &lt;= nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>] &#123;</span><br><span class="line">l = mid+<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r = mid<span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路和算法</p><p>对于有序数组，可以使用二分查找的方法查找元素。</p><p>但是这道题中，数组本身不是有序的，进行旋转后只保证了数组的局部是有序的，这还能进行二分查找吗？答案是可以的。</p><p>可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从 6 这个位置分开以后数组变成了 [4, 5, 6] 和 [7, 0, 1, 2] 两个部分，其中左边 [4, 5, 6] 这个部分的数组是有序的，其他也是如此。</p><p>这启示我们可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分：</p><p>如果 [l, mid - 1] 是有序数组，且 target 的大小满足 [nums[l],nums[mid])[\textit{nums}[l],\textit{nums}[mid])[nums[l],nums[mid])，则我们应该将搜索范围缩小至 [l, mid - 1]，否则在 [mid + 1, r] 中寻找。<br>如果 [mid, r] 是有序数组，且 target 的大小满足 (nums[mid+1],nums[r]](\textit{nums}[mid+1],\textit{nums}[r]](nums[mid+1],nums[r]]，则我们应该将搜索范围缩小至 [mid + 1, r]，否则在 [l, mid - 1] 中寻找。</p><p><img src="https://assets.leetcode-cn.com/solution-static/33/33_fig1.png"></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Binary Search </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.15 三数之和</title>
      <link href="/interview/juan/neet150/two-ptr/leet-15-3sum/"/>
      <url>/interview/juan/neet150/two-ptr/leet-15-3sum/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/3sum/description/">Leetcode.15 三数之和</a></p><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。</code></pre><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><p>流程可以参考 <a href="https://leetcode.cn/problems/two-sum/">两数之和</a> 和 <a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/">两数之和 II</a></p><p>设置 a，b，c 三个指针，首先固定 a 指针，可以确定当前目标求和为 - nums[a]<br>在 a 指针后续的位置设置 b 指针，通过 c 指针遍历 b 后面的位置，确定符合的三元组<br>c 指针遍历一轮之后，可以将 b 指针向后移动，直到当前从 a 指针出发的所有三元组都被找到<br>然后再移动 a 指针</p><p>比较关键的点是，结果中的三元组不能重复，那么我们可以通过先排序的方法，在求解过程中提前将重复结果过滤掉</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123; </span><br><span class="line">n := <span class="built_in">len</span>(nums) </span><br><span class="line">sort.Ints(nums) </span><br><span class="line">ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举 a </span></span><br><span class="line"><span class="keyword">for</span> first := <span class="number">0</span>; first &lt; n; first++ &#123; </span><br><span class="line"><span class="comment">// 需要和上一次枚举的数不相同 </span></span><br><span class="line"><span class="keyword">if</span> first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>] &#123; </span><br><span class="line"><span class="keyword">continue</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// c 对应的指针初始指向数组的最右端 </span></span><br><span class="line">third := n - <span class="number">1</span> </span><br><span class="line">target := <span class="number">-1</span> * nums[first] </span><br><span class="line"><span class="comment">// 枚举 b </span></span><br><span class="line"><span class="keyword">for</span> second := first + <span class="number">1</span>; second &lt; n; second++ &#123; </span><br><span class="line"><span class="comment">// 需要和上一次枚举的数不相同 </span></span><br><span class="line"><span class="keyword">if</span> second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>] &#123; </span><br><span class="line"><span class="keyword">continue</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 需要保证 b 的指针在 c 的指针的左侧 </span></span><br><span class="line"><span class="keyword">for</span> second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target &#123; </span><br><span class="line">third-- </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果指针重合，随着 b 后续的增加 </span></span><br><span class="line"><span class="comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环 </span></span><br><span class="line"><span class="keyword">if</span> second == third &#123; </span><br><span class="line"><span class="keyword">break</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> nums[second] + nums[third] == target &#123; </span><br><span class="line">ans = <span class="built_in">append</span>(ans, []<span class="type">int</span>&#123;nums[first], nums[second], nums[third]&#125;) </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> ans </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.11 盛最多水的容器</title>
      <link href="/interview/juan/neet150/two-ptr/leet-11-container-with-most-water/"/>
      <url>/interview/juan/neet150/two-ptr/leet-11-container-with-most-water/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/container-with-most-water/description/">Leetcode.11 盛最多水的容器</a></p><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg"></p><pre><code>输入：[1,8,6,2,5,4,8,3,7]输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：height = [1,1]输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= height[i] &lt;= 104</code></li></ul><p>采用双指针方式，每次移动短边<br>移动短边可能变得更好，一定不会变得更坏</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">l, r := <span class="number">0</span>, <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> l&lt;r &#123;</span><br><span class="line">area := min(height[l], height[r]) * (r-l)</span><br><span class="line">ans = max(area, ans)</span><br><span class="line"><span class="keyword">if</span> height[l] &lt;= height[r] &#123;</span><br><span class="line">l += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Two Pointers </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode.1 两数之和</title>
      <link href="/interview/juan/neet150/arrays-hashing/leet-1-2sum/"/>
      <url>/interview/juan/neet150/arrays-hashing/leet-1-2sum/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/two-sum/description/">Leetcode.1 两数之和</a></p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [3,2,4], target = 6输出：[1,2]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [3,3], target = 6输出：[0,1]</code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><p>暴力法 O(N^2)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">for</span> first:=<span class="number">0</span>; first&lt;<span class="built_in">len</span>(nums)<span class="number">-1</span>; first++ &#123;</span><br><span class="line"><span class="keyword">for</span> second := first + <span class="number">1</span>; second&lt;<span class="built_in">len</span>(nums); second ++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[first] + nums[second] == target &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;first, second&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈希法 O(N)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">hashTable := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> p, ok := hashTable[target-x]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;p, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hashTable[x] = i</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
          <category> NeetCode150 </category>
          
          <category> Arrays &amp; Hashing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>go 八股</title>
      <link href="/interview/go/go-eight-part-frame/"/>
      <url>/interview/go/go-eight-part-frame/</url>
      
        <content type="html"><![CDATA[<h1 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h1><h3 id="golang-中原生的-map-本身是线程不安全的，主要表现在以下方面："><a href="#golang-中原生的-map-本身是线程不安全的，主要表现在以下方面：" class="headerlink" title="golang 中原生的 map 本身是线程不安全的，主要表现在以下方面："></a>golang 中原生的 map 本身是线程不安全的，主要表现在以下方面：</h3><ol><li>对于 map 结构的并发访问，会报错 panic。</li><li>即使通过某种方式不同时写一个 key，在 map 扩容的时候也会有问题，因为 map 的扩容是线程不安全的</li></ol><h3 id="sync-Map-相对-map-的优势："><a href="#sync-Map-相对-map-的优势：" class="headerlink" title="sync.Map 相对 map 的优势："></a>sync.Map 相对 map 的优势：</h3><ol><li>一写多读</li><li>空间换时间 &#x3D; read 和 dirty</li><li>double-checking</li><li>缓存思路</li><li>延时删除</li></ol><h3 id="关于-dirty-的提升"><a href="#关于-dirty-的提升" class="headerlink" title="关于 dirty 的提升"></a>关于 dirty 的提升</h3><p>Map 中维持了一个 int 类型的 <code>misses</code> 每当 Map 未命中 read 时，会将该值自增 1， 当该值大于 dirty 的长度后，dirty 就会被提升为 read，提升之后，dirty 和 misses 会被重置，等下一次插入新值时，会将 read 中未删除的数据复制到 dirty 中。<br>除此之外，执行 <code>Range</code> 时，也会先进行一次提升。</p><h3 id="关于延迟删除"><a href="#关于延迟删除" class="headerlink" title="关于延迟删除"></a>关于延迟删除</h3><p>当执行 <code>Delete</code> 时，如果 read 没有击中， 就会直接从 dirty 中删除，否则如果键值在 read 中，会先将其 Value 的指针（enter.p）标记为 nil, 等下一次执行复制时，这些被标记为 nil 的键值会被重新标记为 expunged，即 enter.p 有三种可能的值：</p><ol><li>nil: 表示 键值已经被删除，但这一版的 read 还没有被复制到 dirty 中，所以 dirty 此时为 nil, 遇到要重新插入这个key时，可以直接修改 read，之后进行复制时，这个最新的值会被同步回 dirty。</li><li>expunged: 表示该键值已经被删除并且经历了复制， dirty 不为 nil， 这时需要同时修改 read 和 dirty， 避免 read 的数据比 dirty 中的数据新，导致下一次提升时丢失新数据。</li><li><code>!= nil</code>: 表示存储的是具体的 value 的指针。</li></ol><p>sync.Map 具有以下结构和方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123; </span><br><span class="line">mu sync.Mutex <span class="comment">// 互斥锁</span></span><br><span class="line">read atomic.Value <span class="comment">// 原子化只读操作</span></span><br><span class="line">dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry <span class="comment">// 新增的 kv 会存储到这里</span></span><br><span class="line">misses <span class="type">int</span> <span class="comment">// 当 read 中查询失败时，misses+=1，当 miss 的数量超过 dirty 时，会触发将 dirty 转化到 read</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 Map 中取出一个 value </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Load(key <span class="keyword">interface</span>&#123;&#125;) (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>) &#123; </span><br><span class="line">read, _ := m.read.Load().(readOnly) </span><br><span class="line"><span class="comment">// 优先从 read 中读取</span></span><br><span class="line">e, ok := read.m[key] </span><br><span class="line"><span class="comment">// 当读不到且 amended = true 时，再互斥的从 dirty 中查找</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; </span><br><span class="line">m.mu.Lock() </span><br><span class="line"><span class="comment">// double-checking， 避免在加锁过程中有其他 goroutine 将 dirty 提升为 read 的情况</span></span><br><span class="line">read, _ = m.read.Load().(readOnly) e, ok = read.m[key] </span><br><span class="line"><span class="comment">// 双重查找后还找不到，再去 dirty 中查找，同时 misses += 1</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; </span><br><span class="line">e, ok = m.dirty[key] <span class="comment">// 修改 misses，尝试提升 dirty </span></span><br><span class="line">m.missLocked() </span><br><span class="line">&#125; </span><br><span class="line">m.mu.Unlock()</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span> !ok &#123; <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span> &#125; </span><br><span class="line"><span class="comment">// 需要注意这里取到的是指向真实 value 的指针，还需要读取出真正的 value</span></span><br><span class="line"><span class="keyword">return</span> e.load() </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> missLocked() &#123; </span><br><span class="line">m.misses++ </span><br><span class="line"><span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 将 dirty 提升为 read </span></span><br><span class="line">m.read.Store(readOnly&#123;m: m.dirty&#125;) </span><br><span class="line"><span class="comment">// 重置相关字段 </span></span><br><span class="line">m.dirty = <span class="literal">nil</span> </span><br><span class="line">m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 Map 中 存入一个 KV 对 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line"><span class="comment">// 优先从 read 中读取</span></span><br><span class="line"><span class="comment">// 如果 read 中找到了，利用 entry 的 tryStore 方法更新 value</span></span><br><span class="line">read, _ := m.read.Load().(readOnly) </span><br><span class="line"><span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁， 二次检查</span></span><br><span class="line">m.mu.Lock() </span><br><span class="line">read, _ = m.read.Load().(readOnly) </span><br><span class="line"><span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line"><span class="comment">// 当对已经存在于 `read` 中的键值对执行删除操作时，而是会把其暂时标记为 `nil`,</span></span><br><span class="line"><span class="comment">// 等 dirty 升级为 read 后再插入新值时会把 read 中标记为 `nil` 的值标记为 `expunged`, </span></span><br><span class="line"><span class="comment">// 而其他的值会被重新复制到 dirty 中，当这时插入刚被删除的键后，就会直接把之前标记为 `expunged` 的键的值赋为新值</span></span><br><span class="line"><span class="keyword">if</span> e.unexpungeLocked() &#123; </span><br><span class="line">m.dirty[key] = e </span><br><span class="line">&#125; </span><br><span class="line">e.storeLocked(&amp;value) </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line"><span class="comment">// 如果 dirty 中找到了，通过 storeLocked 修改 dirty 中的 entry</span></span><br><span class="line">e.storeLocked(&amp;value) </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="comment">// dirty 中也没有，那么就直接插入到 dirty 中</span></span><br><span class="line"><span class="keyword">if</span> !read.amended &#123; </span><br><span class="line"><span class="comment">// 此时如果 amended == false，对应两种情况</span></span><br><span class="line"><span class="comment">// 1. 第一次插入数据，read 和 dirty 都为空，此时需要对 read 进行初始化</span></span><br><span class="line"><span class="comment">// 2. 之前的 dirty 刚刚升级成为 read，此时 dirty 为空，需要将之前有可能存在的已标记删除的进行惰性删除</span></span><br><span class="line">m.dirtyLocked() </span><br><span class="line">m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;) </span><br><span class="line">&#125; </span><br><span class="line">m.dirty[key] = newEntry(value) </span><br><span class="line">&#125; </span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 Map 中存在 key,覆盖并返回 (旧值, true), 否则返回 (新值, false) </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadOrStore(key, value <span class="keyword">interface</span>&#123;&#125;) (actual <span class="keyword">interface</span>&#123;&#125;, loaded <span class="type">bool</span>) </span><br><span class="line"><span class="comment">// 从 Map 中删除一个 KV 对 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line"><span class="comment">// 二次检查 read</span></span><br><span class="line">read, _ := m.read.Load().(readOnly) </span><br><span class="line">e, ok := read.m[key] </span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; </span><br><span class="line">m.mu.Lock() </span><br><span class="line">read, _ = m.read.Load().(readOnly) </span><br><span class="line">e, ok = read.m[key] </span><br><span class="line"><span class="comment">// 不存在，就从 dirty 中删除</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; </span><br><span class="line"><span class="built_in">delete</span>(m.dirty, key) </span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock() </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 存在的话就调用 entry 的 delete() 从 read 中删除</span></span><br><span class="line"><span class="keyword">if</span> ok &#123; e.<span class="built_in">delete</span>() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 Map 中的所有 KV 执行 f, 直到 f 返回 false </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>) &#123; </span><br><span class="line">read, _ := m.read.Load().(readOnly) </span><br><span class="line"><span class="keyword">if</span> read.amended &#123; </span><br><span class="line"><span class="comment">// double-checking</span></span><br><span class="line">m.mu.Lock() </span><br><span class="line">read, _ = m.read.Load().(readOnly) </span><br><span class="line"><span class="keyword">if</span> read.amended &#123; </span><br><span class="line"><span class="comment">// 提升 dirty</span></span><br><span class="line">read = readOnly&#123;m: m.dirty&#125; </span><br><span class="line">m.read.Store(read) </span><br><span class="line">m.dirty = <span class="literal">nil</span> </span><br><span class="line">m.misses = <span class="number">0</span> </span><br><span class="line">&#125; </span><br><span class="line">m.mu.Unlock() </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123; </span><br><span class="line">v, ok := e.load() </span><br><span class="line"><span class="keyword">if</span> !ok &#123; </span><br><span class="line"><span class="keyword">continue</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> !f(k, v) &#123; </span><br><span class="line"><span class="keyword">break</span> </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> dirtyLocked() &#123; </span><br><span class="line"><span class="comment">// 对应情况 1 </span></span><br><span class="line"><span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123; <span class="keyword">return</span> &#125; </span><br><span class="line"><span class="comment">// 情况 2 </span></span><br><span class="line">read, _ := m.read.Load().(readOnly) </span><br><span class="line">m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry, <span class="built_in">len</span>(read.m)) </span><br><span class="line"><span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line"><span class="comment">// 没有被删除，复制到 dirty 中 </span></span><br><span class="line"><span class="keyword">if</span> !e.tryExpungeLocked() &#123; m.dirty[k] = e &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123; </span><br><span class="line"><span class="comment">// m 和 dirty 中的 value 是同一块内存 </span></span><br><span class="line">m <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry </span><br><span class="line"><span class="comment">// 如果 dirty 和 read 中的数据不一致时，amended 为 true。若此时 read 中读不到，就要去 dirty 中查询</span></span><br><span class="line">amended <span class="type">bool</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read 和 dirty 中的 entry 指向的是同一地址，修改会同时生效；减少空间浪费</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">p unsafe.Pointer <span class="comment">// *interface&#123;&#125; </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> load() (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>) &#123; </span><br><span class="line">p := atomic.LoadPointer(&amp;e.p) </span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123; <span class="comment">// 由于 Map 的延时删除策略，出现这两种情况均代表 kv 已经不存在了</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> *(*<span class="keyword">interface</span>&#123;&#125;)(p), <span class="literal">true</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> <span class="built_in">delete</span>() (hadValue <span class="type">bool</span>) &#123; </span><br><span class="line"><span class="comment">// 这里不是真的删除嗷，只是将对应 value 的 p 指向了 nil。直到下一次 dirty 升级时才会真正的删除，aka Map 的延时删除策略</span></span><br><span class="line"><span class="keyword">for</span> &#123; p := atomic.LoadPointer(&amp;e.p) </span><br><span class="line"><span class="comment">// 不存在或被删除</span></span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125; </span><br><span class="line"><span class="comment">// CAS 将 enter.p 指向 nil </span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryStore(i *<span class="keyword">interface</span>&#123;&#125;) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123; </span><br><span class="line">p := atomic.LoadPointer(&amp;e.p) <span class="comment">// 被删除 </span></span><br><span class="line"><span class="keyword">if</span> p == expunged &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125; <span class="comment">// 比较 e.p 与 p, 相等赋新值，否则自旋比较 </span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> storeLocked(i *<span class="keyword">interface</span>&#123;&#125;) &#123; </span><br><span class="line">atomic.StorePointer(&amp;e.p, unsafe.Pointer(i)) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用来判断 `entry` 是否被删除，当 `entry.p == nil` 时，说明这个 value 被标记为删除，这时会把它重新标记为 `expunged` 返回 true， 否则返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryExpungeLocked() (isExpunged <span class="type">bool</span>) &#123; </span><br><span class="line">p := atomic.LoadPointer(&amp;e.p) </span><br><span class="line"><span class="keyword">for</span> p == <span class="literal">nil</span> &#123; </span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, <span class="literal">nil</span>, expunged) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">&#125; </span><br><span class="line">p = atomic.LoadPointer(&amp;e.p) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> p == expunged </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h1><p>用于执行一次性操作，通常用于初始化只需执行一次的任务。它的作用是确保某个操作只会执行一次，无论是在单线程环境还是多线程环境下都可以保证。<br>比较值得学习的是使用到的<strong>快慢路径</strong>这个编程范式。</p><h4 id="慢路径（Slow-Path）"><a href="#慢路径（Slow-Path）" class="headerlink" title="慢路径（Slow Path）"></a>慢路径（Slow Path）</h4><p>慢路径（Slow Path）指一种更加保守、安全但性能较低的解决方案。代码会使用互斥锁等同步原语来确保并发安全性。慢路径会导致性能开销增加，因为它需要在多个线程之间进行显式的同步和互斥操作，以确保数据的一致性和正确性。</p><h4 id="快路径（Fast-Path）"><a href="#快路径（Fast-Path）" class="headerlink" title="快路径（Fast Path）"></a>快路径（Fast Path）</h4><p>快路径（Fast Path）指一种更加高效但风险较高的解决方案。代码会使用原子操作等非阻塞的同步机制来尽量减少同步开销。快路径会更高效，因为它避免了显式的同步和互斥操作，但在某些情况下会导致竞态条件或数据不一致的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123; </span><br><span class="line">done <span class="type">uint32</span> </span><br><span class="line">m    Mutex </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123; </span><br><span class="line"><span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123; </span><br><span class="line">o.doSlow(f) </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> doSlow(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123; </span><br><span class="line">o.m.Lock() </span><br><span class="line"><span class="keyword">defer</span> o.m.Unlock() </span><br><span class="line"><span class="keyword">if</span> o.done == <span class="number">0</span> &#123; </span><br><span class="line"><span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>) </span><br><span class="line">f() </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h1><p>比较常见的问题是 slice 和普通 array 的区别：array 是值类型；slice 是引用类型，指向底层的数组地址<br>子切片：引用的底层数组是一致的，但是 slice 本身对应的内存地址不一致；当子切片长度超过原切片的时候，会产生扩容，替换掉原来的底层数组。<br>有一个特性是，如果使用 append 语句一次性加入多个元素，且新增元素数量超过了原始 slice 的容量，那么 golang 会自动根据总元素数量来申请新的容量进行扩容。其中还涉及到了申请时内存对齐的问题，可能申请到的容量会稍大于元素数量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span> <span class="comment">// nil 未分配内存</span></span><br><span class="line"></span><br><span class="line">s1 := []<span class="type">int</span>&#123;&#125; <span class="comment">// 声明 + 初始化 一个长度为 0 的 slice</span></span><br><span class="line"></span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">// 声明 + 初始化 一个长度为 3 的 slice</span></span><br></pre></td></tr></table></figure><h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p>Channel是异步进行的, channel存在3种状态：</p><ul><li>nil，未初始化的状态，只进行了声明，或者手动赋值为nil</li><li>active，正常的channel，可读或者可写</li><li>closed，已关闭，千万不要误认为关闭channel后，channel的值是nil</li></ul><table><thead><tr><th>操作</th><th>一个零值nil通道</th><th>一个非零值但已关闭的通道</th><th>一个非零值且尚未关闭的通道</th></tr></thead><tbody><tr><td>关闭</td><td>产生恐慌</td><td>产生恐慌</td><td>成功关闭</td></tr><tr><td>发送数据</td><td>永久阻塞</td><td>产生恐慌</td><td>阻塞或者成功发送</td></tr><tr><td>接收数据</td><td>永久阻塞</td><td>永不阻塞</td><td>阻塞或者成功接收</td></tr></tbody></table><ol><li>Channel本质上是由三个FIFO（First In FirstOut，先进先出）队列组成的用于协程之间传输数据的协程安全的通道；FIFO的设计是为了保障公平，让事情变得简单，原则是让等待时间最长的协程最有资格先从channel发送或接收数据；</li><li>三个FIFO队列依次是buf循环队列，sendq待发送者队列，recvq待接收者队列。buf循环队列是大小固定的用来存放channel接收的数据的队列；sendq待发送者队列，用来存放等待发送数据到channel的goroutine的双向链表，recvq待接收者队列，用来存放等待从channel读取数据的goroutine的双向链表；sendq和recvq可以认为不限大小；</li><li>跟函数调用传参本质都是传值一样，channel传递数据的本质就是值拷贝，引用类型数据的传递也是地址拷贝；有从缓冲区buf地址拷贝数据到接收者receiver栈内存地址，也有从发送者sender栈内存地址拷贝数据到缓冲区buf；</li><li>Channel里面参数的修改不是并发安全的，包括对三个队列及其他参数的访问，因此需要加锁，本质上，channel就是一个有锁队列；</li><li>Channel 的性能跟 sync.Mutex 差不多，没有谁比谁强。Go官方之所以推荐使用Channel进行并发协程的数据交互，是因为channel的设计理念能让程序变得简单，在大型程序、高并发复杂的运行状况中也是如此。</li></ol><p>关注下方代码 <code>makechan</code> 中 <code>switch-case</code> 相关语句，可以发现当存储在 buf 中的元素不包含指针时，hchan 中也不包含 GC 关心的指针。buf 指向一段相同元素类型的内存，elemtype 固定不变。受到垃圾回收器的限制，指针类型的缓冲 buf 需要单独分配内存。<br>channel 本身是引用类型，其创建全部调用的是 mallocgc()，在<em>堆</em>上开辟的内存空间，说明 channel 本身会被 GC 自动回收。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123; </span><br><span class="line">qcount <span class="type">uint</span> <span class="comment">// 队列中所有数据总数 </span></span><br><span class="line">dataqsiz <span class="type">uint</span> <span class="comment">// 循环队列大小 </span></span><br><span class="line">buf unsafe.Pointer <span class="comment">// 指向循环队列的指针 </span></span><br><span class="line">elemsize <span class="type">uint16</span> <span class="comment">// 循环队列中元素的大小 </span></span><br><span class="line">closed <span class="type">uint32</span> <span class="comment">// chan是否关闭的标识 </span></span><br><span class="line">elemtype *_type <span class="comment">// 循环队列中元素的类型 </span></span><br><span class="line">sendx <span class="type">uint</span> <span class="comment">// 已发送元素在循环队列中的位置 </span></span><br><span class="line">recvx <span class="type">uint</span> <span class="comment">// 已接收元素在循环队列中的位置 </span></span><br><span class="line">recvq waitq <span class="comment">// 等待接收的goroutine的等待队列 </span></span><br><span class="line">sendq waitq <span class="comment">// 等待发送的goroutine的等待队列 </span></span><br><span class="line">lock mutex <span class="comment">// 控制chan并发访问的互斥锁 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123; </span><br><span class="line">elem := t.elem </span><br><span class="line"><span class="comment">// 检查数据项大小不能超过 64KB </span></span><br><span class="line"><span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123; throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>) &#125; <span class="comment">// 检查内存对齐是否正确 </span></span><br><span class="line"><span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123; </span><br><span class="line">throw(<span class="string">&quot;makechan: bad alignment&quot;</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 缓冲区大小检查，判断是否溢出 </span></span><br><span class="line">mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size)) </span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123; </span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>)) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> c *hchan </span><br><span class="line"><span class="keyword">switch</span> &#123; </span><br><span class="line"><span class="comment">// 当队列或者元素大小为 0 时，调用 mallocgc() 在堆上为 channel 开辟一段大小为 hchanSize 的内存空间；</span></span><br><span class="line"><span class="keyword">case</span> mem == <span class="number">0</span>: </span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>)) </span><br><span class="line"><span class="comment">// 竞态检查，利用这个地址进行同步操作. </span></span><br><span class="line">c.buf = c.raceaddr() </span><br><span class="line"><span class="comment">// 当元素类型不是指针类型时，调用 mallocgc() 在堆上为 channel 和底层 buf 缓冲区数组开辟一段大小为 hchanSize + mem 连续的内存空间；</span></span><br><span class="line"><span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>: </span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>)) </span><br><span class="line"><span class="comment">// 表示hchan后面在内存里紧跟着就是buf环形队列 </span></span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize) </span><br><span class="line"><span class="comment">// 默认情况元素类型中有指针类型，调用 mallocgc() 在堆上分别为 channel 和 buf 缓冲区分配内存。</span></span><br><span class="line"><span class="keyword">default</span>:  </span><br><span class="line">c = <span class="built_in">new</span>(hchan) c.buf = mallocgc(mem, elem, <span class="literal">true</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 设置元素个数、元素类型给创建的chan </span></span><br><span class="line">c.elemsize = <span class="type">uint16</span>(elem.size) </span><br><span class="line">c.elemtype = elem </span><br><span class="line">c.dataqsiz = <span class="type">uint</span>(size) </span><br><span class="line">lockInit(&amp;c.lock, lockRankHchan) </span><br><span class="line"><span class="keyword">if</span> debugChan &#123; </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.size, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> c </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><ol><li>首先 select 非阻塞的发送，需要判断两种情况；</li><li>一般的阻塞调用，先判断 recvq 等待接收队列是否为空，如果不为空，那么说明缓冲区为空 or 无缓冲 Channel；</li><li>如果 recvq 有接收者，则属于缓冲区空，从 recvq 中取出一个 goroutine，然后写入数据，接着唤醒 goroutine，结束发送过程；</li><li>如果缓冲区有空位，写入数据到缓冲区，完成发送；</li><li>如果缓冲区满，将发送数据的 goroutine 放到 sendq 中，进入睡眠，等待唤醒。<h3 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h3></li><li>也是先判断select这种非阻塞接收的两种情况（block为false）；然后是加锁进行阻塞调用的逻辑；</li><li>同步接收：如果发送者队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出一个 goroutine，读取消息，唤醒该 goroutine，结束读取；</li><li>同步接收：如果发送者队列 sendq 不为空，有缓冲区，说明缓冲区已经满了，移动 recvx 指针的位置，取出一个数据，同时从 sendq 中取出一个 goroutine，拷贝里面的数据到 buf 中，结束读取；</li><li>异步接收：如果发送者队列 sendq 为空，且缓冲区有数据（有缓冲 channel），直接从缓冲区取出数据，结束读取；</li><li>阻塞接收：如果发送者队列 sendq 为空，且缓冲区无数据（无缓冲 channel），就将当前的 goroutine 加入 recvq，进入睡眠等待唤醒。</li></ol><h3 id="关闭-Chan"><a href="#关闭-Chan" class="headerlink" title="关闭 Chan"></a>关闭 Chan</h3><ol><li>判断 channel 当前状态，如果 channel &#x3D;&#x3D; nil || channel 已经关闭，会直接 panic；</li><li>关闭的主要工作是释放所有的接收者和发送者：先回收接收者，因为从一个关闭的 channel 中读数据，不会发生 panic，顶多读到一个默认零值。再回收发送者。注意这里可能会产生 panic，因为往一个关闭的 channel 中发送数据，会产生 panic。</li></ol><h3 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(data <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123; </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123; </span><br><span class="line">data &lt;- i </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 这里记得要关闭channel，不然会发生阻塞，因为消费者的数量没有限制， </span></span><br><span class="line"><span class="comment">// 当消费者从空的channel取值的时候会阻塞 </span></span><br><span class="line"><span class="built_in">close</span>(data) </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(data &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123; </span><br><span class="line"><span class="keyword">defer</span> wg.Done() </span><br><span class="line"><span class="keyword">for</span> &#123; </span><br><span class="line">v, ok := &lt;-data </span><br><span class="line"><span class="keyword">if</span> !ok &#123; </span><br><span class="line"><span class="keyword">break</span> </span><br><span class="line">&#125; </span><br><span class="line">fmt.Println(<span class="string">&quot;---:&quot;</span>, v, <span class="string">&quot; ===:&quot;</span>, ok) </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">data := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) </span><br><span class="line"><span class="keyword">go</span> producer(data) </span><br><span class="line">wg.Add(<span class="number">1</span>) </span><br><span class="line"><span class="keyword">go</span> consumer(data) </span><br><span class="line">wg.Wait() </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// Output // ---: 0 ===: true // ---: 1 ===: true // ---: 2 ===: true // ---: 3 ===: true</span></span><br></pre></td></tr></table></figure><h3 id="发布订阅模型"><a href="#发布订阅模型" class="headerlink" title="发布订阅模型"></a>发布订阅模型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Broker <span class="keyword">struct</span> &#123; </span><br><span class="line">consumers []*Consumer </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">type</span> Consumer <span class="keyword">struct</span> &#123; </span><br><span class="line">ch <span class="keyword">chan</span> <span class="type">string</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Broker)</span></span> produce(msg <span class="type">string</span>) &#123; </span><br><span class="line"><span class="comment">// 轮询给消费者发送消息 </span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> b.consumers &#123; </span><br><span class="line">v.ch &lt;- msg </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Broker)</span></span> subscribe(consumer *Consumer) &#123; </span><br><span class="line">b.consumers = <span class="built_in">append</span>(b.consumers, consumer) </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMq1</span><span class="params">(t *testing.T)</span></span> &#123; </span><br><span class="line"><span class="comment">// 初始化一个Broker节点 </span></span><br><span class="line">b := &amp;Broker&#123; </span><br><span class="line">consumers: <span class="built_in">make</span>([]*Consumer, <span class="number">0</span>, <span class="number">4</span>), </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 创建2个消费者 </span></span><br><span class="line">consumer1 := &amp;Consumer&#123; ch: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>), &#125; </span><br><span class="line">consumer2 := &amp;Consumer&#123; ch: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>), &#125; </span><br><span class="line"><span class="comment">// 这2个消费者订阅Broker </span></span><br><span class="line">b.subscribe(consumer1) </span><br><span class="line">b.subscribe(consumer2) </span><br><span class="line"><span class="comment">// 生产者发送一个消息 </span></span><br><span class="line">b.produce(<span class="string">&quot;一条消息&quot;</span>) </span><br><span class="line"><span class="comment">// 2个消费者拿到了刚才生产者发送的消息 </span></span><br><span class="line">fmt.Println(&lt;-consumer1.ch) </span><br><span class="line">fmt.Println(&lt;-consumer2.ch) </span><br><span class="line"><span class="comment">// Output </span></span><br><span class="line"><span class="comment">// 一条消息 </span></span><br><span class="line"><span class="comment">// 一条消息 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环打印abc"><a href="#循环打印abc" class="headerlink" title="循环打印abc"></a>循环打印abc</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">5</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   wg := sync.WaitGroup&#123;&#125;  </span><br><span class="line">   chanA := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)  </span><br><span class="line">   chanB := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">2</span>)  </span><br><span class="line">   chanC := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">3</span>)  </span><br><span class="line">   chanA &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  </span><br><span class="line">   wg.Add(<span class="number">3</span>)  </span><br><span class="line">   <span class="keyword">go</span> printA(&amp;wg, chanA, chanB)  </span><br><span class="line">   <span class="keyword">go</span> printB(&amp;wg, chanB, chanC)  </span><br><span class="line">   <span class="keyword">go</span> printC(&amp;wg, chanC, chanA)  </span><br><span class="line">   wg.Wait()  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printA</span><span class="params">(wg *sync.WaitGroup, chanA <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, chanB <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">defer</span> wg.Done()  </span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;  </span><br><span class="line">      &lt;-chanA  </span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;A&quot;</span>)  </span><br><span class="line">      chanB &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printB</span><span class="params">(wg *sync.WaitGroup, chanB <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, chanC <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">defer</span> wg.Done()  </span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;  </span><br><span class="line">      &lt;-chanB  </span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;B&quot;</span>)  </span><br><span class="line">      chanC &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printC</span><span class="params">(wg *sync.WaitGroup, chanC <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, chanA <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">defer</span> wg.Done()  </span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;  </span><br><span class="line">      &lt;-chanC  </span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;C&quot;</span>)  </span><br><span class="line">      chanA &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="另一种循环打印"><a href="#另一种循环打印" class="headerlink" title="另一种循环打印"></a>另一种循环打印</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前的写法是可运行的，注意 可能会造成死锁，main 协程无法退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)  </span><br><span class="line">   c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)  </span><br><span class="line">   c3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)  </span><br><span class="line">  </span><br><span class="line">   stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)   </span><br><span class="line">   <span class="comment">// c1 &lt;- 1  // 不可以放到这里，会造成死锁，目前我还没明白原理</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">go</span> print1(c1, c2, stop)  </span><br><span class="line">   <span class="keyword">go</span> print2(c2, c3, stop)  </span><br><span class="line">   <span class="keyword">go</span> print3(c3, c1, stop)  </span><br><span class="line">   c1 &lt;- <span class="number">1</span>  <span class="comment">// </span></span><br><span class="line">   time.Sleep(time.Millisecond)  </span><br><span class="line">   <span class="comment">// go func() &#123; stop &lt;- 1 &#125;()  </span></span><br><span class="line">   stop &lt;- <span class="number">1</span>  </span><br><span class="line">   <span class="keyword">return</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print1</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>, c2 <span class="keyword">chan</span> <span class="type">int</span>, stop <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">for</span> &#123;  </span><br><span class="line">      <span class="keyword">select</span> &#123;  </span><br><span class="line">      <span class="keyword">case</span> &lt;-stop:  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line">      <span class="keyword">case</span> &lt;-c:  </span><br><span class="line">         fmt.Println(<span class="string">&quot;1&quot;</span>)  </span><br><span class="line">         c2 &lt;- <span class="number">1</span>  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print2</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>, c2 <span class="keyword">chan</span> <span class="type">int</span>, stop <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">for</span> &#123;  </span><br><span class="line">      <span class="keyword">select</span> &#123;  </span><br><span class="line">      <span class="keyword">case</span> &lt;-stop:  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line">      <span class="keyword">case</span> &lt;-c:  </span><br><span class="line">         fmt.Println(<span class="string">&quot;2&quot;</span>)  </span><br><span class="line">         c2 &lt;- <span class="number">1</span>  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print3</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>, c2 <span class="keyword">chan</span> <span class="type">int</span>, stop <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">for</span> &#123;  </span><br><span class="line">      <span class="keyword">select</span> &#123;  </span><br><span class="line">      <span class="keyword">case</span> &lt;-stop:  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line">      <span class="keyword">case</span> &lt;-c:  </span><br><span class="line">         fmt.Println(<span class="string">&quot;3&quot;</span>)  </span><br><span class="line">         c2 &lt;- <span class="number">1</span>  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h4><p>定时任务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123; </span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">100</span> * time.Millisecond): </span><br><span class="line"><span class="keyword">case</span> &lt;-s.stopc: </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制并发数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> limit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>) </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line"><span class="comment">// ………… </span></span><br><span class="line"><span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123; </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">limit &lt;- <span class="number">1</span> </span><br><span class="line">w() </span><br><span class="line">&lt;-limit </span><br><span class="line">&#125;() </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// ………… </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:= <span class="keyword">range</span> ch</span><br><span class="line"><span class="comment">// 这里需要注意的是 会一直尝试从 ch 中取数据，直到 ch 被关闭位置，期间状态为阻塞</span></span><br><span class="line"><span class="comment">// 可以结合以下代码 理解</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)  </span><br><span class="line">  </span><br><span class="line">wg := sync.WaitGroup&#123;&#125;  </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;  </span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">         wg.Add(<span class="number">1</span>)  </span><br><span class="line">         <span class="keyword">if</span> i &gt; <span class="number">6</span> &#123;  </span><br><span class="line">            time.Sleep(time.Second)  </span><br><span class="line">         &#125;  </span><br><span class="line">         ch &lt;- i  </span><br><span class="line">         <span class="keyword">defer</span> wg.Done()  </span><br><span class="line">      &#125;(i)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   time.Sleep(time.Second * <span class="number">8</span>)  </span><br><span class="line">  </span><br><span class="line">   wg.Wait()  </span><br><span class="line">   <span class="built_in">close</span>(ch)  <span class="comment">// 如果不关闭，下方会一直阻塞，造成死锁</span></span><br><span class="line">&#125;()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123;  </span><br><span class="line">   fmt.Printf(<span class="string">&quot;printing: %d at %d \n&quot;</span>, i, time.Now().Unix())  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Golang-atomic"><a href="#Golang-atomic" class="headerlink" title="Golang atomic"></a>Golang atomic</h1><h4 id="常规总结"><a href="#常规总结" class="headerlink" title="常规总结"></a>常规总结</h4><p>1、  原子指针函数和类型+方法的两种方式都可以执行原子操作，我更建议用类型+方法的方式，因为更简单更清晰。<br>2、  原子操作比互斥锁更轻便，但使用也是有限制的，原子操作仅提供有限的数据类型，使用时要珍酌清楚。<br>3、  atomic.Value 原子值中存储引用类型时，使用一定要注意否则会有安全性问题哈，最好别存引用类型。<br>4、  atomic.Value 不要存 nil，后续添加的类型一定要是第一次添加的类型，否则会 Panic。<br>5、  不要对外暴露原子变量（原子变量控制在包内访问）、不要将原子值及其指针值通过参数、通道等传递。</p><h1 id="原生-Map"><a href="#原生-Map" class="headerlink" title="原生 Map"></a>原生 Map</h1><p>实际使用中需要注意以下几点：</p><ol><li>并发读写不安全</li><li>迭代中修改 map 会造成迭代器失效和不确定的结果</li><li>对 map 的遍历认为是无序的</li><li>对 nil 的 map 操作不当会造成 panic</li><li>内存泄漏：向 map 中添加键值对会增加底层哈希表的大小。对于不用的或者已删除的键值对，推荐使用 delete() 删除，释放内存。</li></ol><p>Golang 中 map 是一个指针，占用 8 个字节。当使用 make 创建 map 时，底层调用的是 makemap() 函数，makemap() 函数返回的是一个指针，因为返回的是指针，所以 map 作为参数的时候，函数内部能修改map。<br>golang 中 map 底层使用的是哈希查找表，用链表来解决哈希冲突。每个 map 的底层结构是 hmap，是由若干个结构为 bmap 的 bucket 组成的数组，每个 bucket 底层都采用链表结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">count      <span class="type">int</span>            <span class="comment">// map中元素的数量，调用len()直接返回此值</span></span><br><span class="line">flags      <span class="type">uint8</span>          <span class="comment">// 状态标识符，key和value是否包指针、是否正在扩容、是否已经被迭代</span></span><br><span class="line">B          <span class="type">uint8</span>          <span class="comment">// map中桶数组的数量，桶数组的长度的对数，len(buckets) == 2^B，可以最多容纳 6.5 * 2 ^ B 个元素，6.5为装载因子</span></span><br><span class="line">noverflow  <span class="type">uint16</span>         <span class="comment">// 溢出桶的大概数量，当B小于16时是准确值，大于等于16时是大概的值</span></span><br><span class="line">hash0      <span class="type">uint32</span>         <span class="comment">// 哈希种子，用于计算哈希值，为哈希函数的结果引入一定的随机性</span></span><br><span class="line">buckets    unsafe.Pointer <span class="comment">// 指向桶数组的指针，长度为 2^B ，如果元素个数为0，就为 nil</span></span><br><span class="line">oldbuckets unsafe.Pointer <span class="comment">// 指向一个旧桶数组，用于扩容，它的长度是当前桶数组的一半</span></span><br><span class="line">nevacuate  <span class="type">uintptr</span>        <span class="comment">// 搬迁进度，小于此地址的桶数组迁移完成</span></span><br><span class="line">extra      *mapextra      <span class="comment">// 可选字段，用于gc，指向所有的溢出桶，避免gc时扫描整个map，仅扫描所有溢出桶就足够了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 溢出桶结构</span></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">overflow    *[]*bmap <span class="comment">// 指针数组，指向所有溢出桶</span></span><br><span class="line">oldoverflow *[]*bmap <span class="comment">// 指针数组，发生扩容时，指向所有旧的溢出桶</span></span><br><span class="line">nextOverflow *bmap <span class="comment">// 指向所有溢出桶中下一个可以使用的溢出桶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bmap的结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [bucketCnt]<span class="type">uint8</span>    <span class="comment">// bucketCnt=8，// 存放key哈希值的高8位，用于决定kv键值对放在桶内的哪个位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上编辑期间会动态生成一个新的结构体</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">topbits  [<span class="number">8</span>]<span class="type">uint8</span>     <span class="comment">// 存放key哈希值的高8位，用于决定kv键值对放在桶内的哪个位置</span></span><br><span class="line">keys     [<span class="number">8</span>]keytype   <span class="comment">// 存放key的数组</span></span><br><span class="line">values   [<span class="number">8</span>]valuetype <span class="comment">// 存放value的数组</span></span><br><span class="line">pad      <span class="type">uintptr</span>      <span class="comment">// 用于对齐内存</span></span><br><span class="line">overflow <span class="type">uintptr</span>      <span class="comment">// 指向下一个桶，即溢出桶，拉链法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buckets是一个bmap数组，数组的长度就是 2^B。每个bucket固定包含8个key和value，实现上面是一个固定的大小连续内存块，分成四部分：tophash 值，8个key值，8个value值，指向下个bucket的指针。<br>tophash 值用于快速查找key是否在该bucket中，当插入和查询运行时都会使用哈希哈数对key做哈希运算，获取一个hashcode，取高8位存放在bmap tophash字段中。<br>桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置）<br>桶结构的很多字段得在编译时才会动态生成，比如key和values等<br>桶结构中，之所以所有的key放一起，所有的value放一起，而不是key&#x2F;value一对对的一起存放，目的便是在某些情况下可以省去pad字段，节省内存空间。由于内存对齐的原因，key0&#x2F;value0&#x2F;key1&#x2F;value1… 这样的形式可能需要更多的补齐空间，比如 map[int64]int8 ，1字节的value后面需要补齐7个字节才能保证下一个key是 int64 对齐的。<br>golang中的map使用的内存是不会收缩的，只会越用越多。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ol><li>触发 map 扩容的时机（插入、删除key）<ul><li>当装载因子超过6.5时，扩容一倍，属于增量扩容；</li><li>当使用的溢出桶过多时，重新分配一样大的内存空间，属于等量扩容；（实际上没有扩容，主要是为了回收空闲的溢出桶，节省空间，提高 map 的查找和插入效率）</li></ul><ol><li>为什么会出现这种情况？<br>   这种情况可能是因为 map 删除的特性导致的。当我们不断向哈希表中插入数据，并且将他们又全部删除时，其内存占用并不会减少，因为删除只是将桶对应位置的 tophash 置 nil 而已。<br>   这种情况下，就会不断的积累溢出桶造成内存泄露，为了解决这种情况，采用了等量扩容的机制，一旦哈希表中出现了过多的溢出桶，会创建新桶保存数据，gc 会清理掉老的溢出桶，从而避免内存泄露。</li><li>如何定义溢出桶是否太多需要等量扩容呢？两种情况：<ul><li>当 B 小于 15时，溢出桶的数量超过 2^B，属于溢出桶数量太多，需要等量扩容；</li><li>当 B 大于等于 15 时，溢出桶数量超过 2^15，属于溢出桶数量太多，需要等量扩容。</li></ul></li></ol></li><li>扩容策略（怎么扩容？）<br>  Go 会创建一个新的 buckets 数组，新的 buckets 数组的容量是旧buckets数组的两倍（或者和旧桶容量相同），将原始桶数组中的所有元素重新散列到新的桶数组中。这样做的目的是为了使每个桶中的元素数量尽可能平均分布，以提高查询效率。<br>  旧的 buckets 数组不会被直接删除，而是会把原来对旧数组的引用去掉，让 GC 来清除内存。<br>  在 map 进行扩容迁移的期间，不会触发第二次扩容。只有在前一个扩容迁移工作完成后，map 才能进行下一次扩容操作。</li><li>搬迁策略<br>  由于 map 扩容需要将原有的 kv 键值对搬迁到新的内存地址，如果一下子全部搬完，会非常的影响性能。go 中 map 的扩容采用渐进式的搬迁策略，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket，将搬迁的O(N)开销均摊到O(1)的赋值和删除操作上。<br>  hashGrow() 只是分配了新的 buckets，并将老 buckets 挂在到 oldbuckets 字段上。<br>  而且实际的搬迁并不在 hashGrow() 而是在 growWork() 函数中，而调用 growWork() 函数的动作是在 mapassign 和 mapdelete 函数中，所以真正的‘搬迁’操作被离散在了 map 插入修改、删除 key 的动作中。会尝试检查 oldbucket，有待执行的数据，则‘搬迁’。</li></ol><h1 id="Sync-Mutex"><a href="#Sync-Mutex" class="headerlink" title="Sync.Mutex"></a>Sync.Mutex</h1><h3 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h3><p>当一个 goroutine 持有锁时，后续的 goroutine 会以先进先出的方式排队等待，当锁被释放时，队列中第一个 goroutine 会被唤醒。但是它需要和新到来的 goroutine 争夺锁，由于新来的 goroutine 已经在 CPU 中，刚刚唤醒的大概率会竞争失败，重新被放到队首。这种情况有可能导致 goroutine 迟迟不能被执行而被“饿死”</p><h3 id="饥饿模式"><a href="#饥饿模式" class="headerlink" title="饥饿模式"></a>饥饿模式</h3><p>为了解决“饿死”的问题，如果一个等待的 goroutine 超过 1 ms (starvationThresholdNs) 没有得到锁，这个锁就会被转换为饥饿模式。饥饿模式下，锁会直接交给队列中的第一个 goroutine，而新来的 goroutine 会放到队尾等待。正常状态下的性能是高于饥饿模式的，所以在大部分情况下，还是应该回到正常模式去的。<br>当队列中最后一个 goroutine 被执行或者它的等待时间低于 1 ms 时，会将该锁的状态切换回正常模式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123; </span><br><span class="line"><span class="comment">// +---------------------------------+-----------+</span></span><br><span class="line"><span class="comment">// |        WaitersCount             |  status   | </span></span><br><span class="line"><span class="comment">// +---------------------------------+-----------+ </span></span><br><span class="line"><span class="comment">// &lt;-----------+ 29 +---------------&gt; &lt;--+ 3 +---&gt;</span></span><br><span class="line">state <span class="type">int32</span> <span class="comment">// 锁状态，其中低三位用来表示锁状态，高 29 位用来记录等待当前互斥锁的 goroutine 个数</span></span><br><span class="line">sema <span class="type">uint32</span> <span class="comment">// 控制锁状态的信号量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ( </span><br><span class="line">mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 0001 表示互斥锁处于锁定状态 </span></span><br><span class="line">mutexWoken <span class="comment">// 0010 表示从正常模式被唤醒 </span></span><br><span class="line">mutexStarving <span class="comment">// 0100 饥饿模式 </span></span><br><span class="line">mutexWaiterShift = <span class="literal">iota</span> <span class="comment">// 3 表示除 WaitersCount 外，状态占用了三个 bite </span></span><br><span class="line">starvationThresholdNs = <span class="number">1e6</span> <span class="comment">// 饥饿的阈值， 1ms </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>通过 CAS 判断 <code>m.state == 0</code> 时，意味着当前锁处于正常的解锁状态，只需要将锁设置为 <code>mutexLocked</code> 即可，否则就需要进入 <code>lockSlow</code> 通过自旋等方式等待锁释放。<code>lockslow</code> 大致分为以下几个部分：</p><ol><li>判断是否可以自旋：自旋需要满足两个条件：<ul><li>处于正常模式，且锁已经被锁定</li><li><code>runtime_canSpin</code> 返回 true:<ul><li>运行在多 CPU 的机器上；</li><li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li><li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li></ul></li></ul></li><li>一旦进入自旋，会通过 <code>runtime_doSpin</code> ,去执行 30 次的 <code>PAUSE</code> 指令，该指令只会占用 CPU 并消耗 CPU 时间，一旦不满足上面的两个条件了，就会去计算当前锁的最新状态，导致其不满足的原因有很多，如：<ul><li>其他 goroutine 已经释放锁</li><li>其他 goroutine 导致该锁进入饥饿模式</li><li>自旋次数超过 4 次</li></ul></li><li>计算和更新状态其实就是去更新 <code>state</code> 中的四个值；一旦计算完毕后，通过 CAS 尝试更新<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123; </span><br><span class="line"><span class="comment">// Fast path: grab unlocked mutex. </span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123; </span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123; </span><br><span class="line">race.Acquire(unsafe.Pointer(m)) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// Slow path (outlined so that the fast path can be inlined) </span></span><br><span class="line">m.lockSlow() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123; </span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123; </span><br><span class="line">_ = m.state race.Release(unsafe.Pointer(m)) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果 m.state - mutexLocked == 0 说明没人等待该锁，同时该锁处于正常状态 </span></span><br><span class="line"><span class="comment">// 这时可以快速解锁，即锁状态会直接赋成 0 </span></span><br><span class="line"><span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked) </span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123; </span><br><span class="line"><span class="comment">// 否则则需要慢速解锁 </span></span><br><span class="line">m.unlockSlow(<span class="built_in">new</span>) </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) &#123; </span><br><span class="line"><span class="comment">// 如果锁没锁定，直接抛出异常 </span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123; </span><br><span class="line">throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 正常模式下 </span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123; </span><br><span class="line">old := <span class="built_in">new</span> </span><br><span class="line"><span class="keyword">for</span> &#123; </span><br><span class="line"><span class="comment">// 如果没有其他等待者或者锁不处于空闲状态，直接返回，不需要唤醒其他等待着 </span></span><br><span class="line"><span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123; </span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 唤醒新的等待者 </span></span><br><span class="line"><span class="comment">// 等待者减一，设置唤醒标志 woken </span></span><br><span class="line"><span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken </span><br><span class="line"><span class="comment">// 设置 state, 唤醒一个阻塞着的 goroutine </span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123; </span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>) </span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 设置失败，重新获取状态设置 </span></span><br><span class="line">old = m.state </span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 饥饿模式下，直接唤醒队首的 goroutine，这时 mutexLocked 位依然是 0 </span></span><br><span class="line"><span class="comment">// 但由于处在饥饿状态下，锁不会被其他新来的 goroutine 抢占 </span></span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>) </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">// Context 提供跨越API的截止时间获取，取消信号，以及请求范围值的功能。 </span></span><br><span class="line"><span class="comment">// 它的这些方案在多个 goroutine 中使用是安全的 </span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;     </span><br><span class="line"><span class="comment">// 如果设置了截止时间，这个方法ok会是true，并返回设置的截止时间  </span></span><br><span class="line">Deadline() (deadline time.Time, ok <span class="type">bool</span>)     </span><br><span class="line"><span class="comment">// 如果 Context 超时或者主动取消返回一个关闭的channel，如果返回的是nil，表示这个     </span></span><br><span class="line"><span class="comment">// context 永远不会关闭，比如：Background()  </span></span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;     </span><br><span class="line"><span class="comment">// 返回发生的错误  </span></span><br><span class="line">Err() <span class="type">error</span>     </span><br><span class="line"><span class="comment">// 它的作用就是传值  </span></span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用方法</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;Goroutine canceled&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Working...&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(ctx)</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">cancel()</span><br><span class="line"></span><br><span class="line">ctx := context.Background()  </span><br><span class="line">fmt.Printf(<span class="string">&quot;ctx: %p \n&quot;</span>, &amp;ctx)  <span class="comment">// ctx: 0xc0000103f0 </span></span><br><span class="line">ctx1 := ctx  <span class="comment">// 深拷贝</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;ctx1: %p \n&quot;</span>, &amp;ctx1) <span class="comment">// ctx1: 0xc000010400 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h1><h3 id="1、浅拷贝"><a href="#1、浅拷贝" class="headerlink" title="1、浅拷贝"></a>1、浅拷贝</h3><p>浅拷贝是指对地址的拷贝<br>浅拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化，释放内存地址时，同时释放内存地址<br>引用类型的都是浅拷贝：<code>slice</code>、<code>map</code>、<code>function</code><br>浅拷贝的特点：</p><ul><li>拷贝的时候仅仅拷贝地址，地址指向的都是同一个值</li><li>在<code>a</code>中修改，则<code>b</code>中也跟着变化</li><li>内存销毁是一致的</li></ul><h3 id="2、深拷贝"><a href="#2、深拷贝" class="headerlink" title="2、深拷贝"></a>2、深拷贝</h3><p>深拷贝是指将地址指向的值进行拷贝<br>深拷贝的是数据本身，创造一个一样的新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值。既然内存地址不同，释放内存地址时，可分别释放<br>值类似的都是深拷贝：<code>int</code>、<code>float</code>、<code>bool</code>、<code>array</code>、<code>struct</code><br>深拷贝的特点：</p><ul><li>复制的时候会新创建一个对象</li><li>指向完全不同的内存地址</li><li>修改是互不影响的<br>通过指针求值，将值拷贝实现，修改拷贝的值不影响原来的值<h3 id="3、结构体的深拷贝"><a href="#3、结构体的深拷贝" class="headerlink" title="3、结构体的深拷贝"></a>3、结构体的深拷贝</h3>默认情况下，结构体类型中的字段是值类型，拷贝时都是深拷贝<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Per <span class="keyword">struct</span> &#123; </span><br><span class="line">Name <span class="type">string</span> </span><br><span class="line">Age <span class="type">int</span> </span><br><span class="line">HouseIds [<span class="number">2</span>]<span class="type">int</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">p1 := Per&#123; Name: <span class="string">&quot;ssgeek&quot;</span>, Age: <span class="number">24</span>, HouseIds: [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">22</span>, <span class="number">33</span>&#125;, &#125; </span><br><span class="line">p2 := p1 </span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p1, &amp;p1) <span class="comment">// &#123;ssgeek 24 [22 33]&#125; 0xc000180030 </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p2, &amp;p2) <span class="comment">// &#123;ssgeek 24 [22 33]&#125; 0xc000180060 </span></span><br><span class="line">p2.Age = <span class="number">19</span> </span><br><span class="line">p2.Name = <span class="string">&quot;likui&quot;</span> </span><br><span class="line">p2.HouseIds[<span class="number">1</span>] = <span class="number">44</span> </span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p1, &amp;p1) <span class="comment">// &#123;ssgeek 24 [22 33]&#125; 0xc000098180 </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p2, &amp;p2) <span class="comment">// &#123;likui 19 [22 44]&#125; 0xc0000981b0 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、结构体的浅拷贝"><a href="#4、结构体的浅拷贝" class="headerlink" title="4、结构体的浅拷贝"></a>4、结构体的浅拷贝</h3>使用指针进行浅拷贝，浅拷贝中，可以看到<code>p1</code>和<code>p2</code>的内存地址是相同的，修改其中一个对象的属性时，另一个也会产生变化<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span> </span><br><span class="line"><span class="keyword">type</span> Per <span class="keyword">struct</span> &#123; </span><br><span class="line">Name <span class="type">string</span> </span><br><span class="line">Age <span class="type">int</span> </span><br><span class="line">HouseIds [<span class="number">2</span>]<span class="type">int</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">p1 := Per&#123; Name: <span class="string">&quot;ssgeek&quot;</span>, Age: <span class="number">24</span>, HouseIds: [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">22</span>, <span class="number">33</span>&#125;, &#125; </span><br><span class="line">p2 := &amp;p1 </span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p1, &amp;p1) <span class="comment">// &#123;ssgeek 24 [22 33]&#125; 0xc000076180 </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p2, p2) <span class="comment">// &amp;&#123;ssgeek 24 [22 33]&#125; 0xc000076180 </span></span><br><span class="line">p2.Age = <span class="number">19</span> </span><br><span class="line">p2.Name = <span class="string">&quot;likui&quot;</span> </span><br><span class="line">p2.HouseIds[<span class="number">1</span>] = <span class="number">44</span> </span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p1, &amp;p1) <span class="comment">// &#123;likui 19 [22 44]&#125; 0xc000076180 </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %p \n&quot;</span>, p2, p2) <span class="comment">// &amp;&#123;likui 19 [22 44]&#125; 0xc000076180 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5、结构体值类型的浅拷贝"><a href="#5、结构体值类型的浅拷贝" class="headerlink" title="5、结构体值类型的浅拷贝"></a>5、结构体值类型的浅拷贝</h3><p>使用<code>new</code>函数实现值类型的浅拷贝<br>值类型的默认是深拷贝，想要实现值类型的浅拷贝，一般是两种方法</p><ul><li>使用指针</li><li>使用new函数（new函数返回的是指针）</li></ul><h3 id="6、结构体引用类型的浅拷贝"><a href="#6、结构体引用类型的浅拷贝" class="headerlink" title="6、结构体引用类型的浅拷贝"></a>6、结构体引用类型的浅拷贝</h3><p>结构体默认是深拷贝，但如果结构体中包含map、slice等这些引用类型，默认也还是浅拷贝<br>map是引用类型，引用类型浅拷贝是默认的情况</p><h3 id="7、结构体引用类型的深拷贝"><a href="#7、结构体引用类型的深拷贝" class="headerlink" title="7、结构体引用类型的深拷贝"></a>7、结构体引用类型的深拷贝</h3><p>结构体中含有引用类型的字段，那么这个字段就是浅拷贝，但是往往希望的是深拷贝，解决方案如下</p><ul><li>方法一：挨个把可导致浅拷贝的引用类型字段自行赋值。赋值后，修改值就相互不影响了</li><li>方法二：使用<code>json</code>或反射。简单来说：<code>json</code>将引用类型的数据进行<code>dump</code>，<code>dump</code>后就和原来的引用类型没有关系了</li></ul><h1 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h1><h3 id="Go-协程为什么快？"><a href="#Go-协程为什么快？" class="headerlink" title="Go 协程为什么快？"></a>Go 协程为什么快？</h3><p>这就要从进程，线程，协程三者的关系讲起。<br>最早的进程时代，是单 CPU 单进程，一切皆是串行执行；到了多进程&#x2F;线程时代，当一个进程阻塞时，切换到另外等候的进程，时间片轮转法保证了等待的进程都能够被运行，但是进程间的调度会占用CPU大部分时间；而到了高并发的场景下，为每个任务都去创建一个线程显然是不合理的，那么，golang 将原来的线程分为了两部分，一个是用户级别的线程（轻量级的线程，运行在用户态，即 goroutine），一个是内核级的线程（即一般意义上的线程，运行在内核态），这样，对于协程的切换和调度都是在用户态进行，不涉及内核级别的调度，因此这是 goroutine 能够很好地支持高并发的场景的基础。</p><ul><li>进程: 进程是具有一定独立功能的程序，进程是系统资源分配和调度的最小单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</li><li>线程: 线程是进程的一个实体,线程是内核态,而且是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。创建一个 goroutine 的栈内存消耗为 2-4 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存，而且还需要一个被称为 “a guard page” 的区域用于和其他 thread 的栈空间进行隔离。</li><li>协程: 协程是一种用户态的轻量级线程，协程的调度完全是由用户来控制的。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</li></ul><p>线程的时间成本主要来自于切换线程上下文时，用户态与内核态的切换、线程的调度、寄存器变量以及状态信息的存储。</p><p>Goroutine采用的是半抢占式的协作调度，只有在当前Goroutine发生阻塞时才会导致调度；同时发生在用户态，调度器会根据具体函数只保存必要的寄存器，切换的代价要比系统线程低得多。运行时有一个runtime.GOMAXPROCS变量，用于控制当前运行正常非阻塞Goroutine的系统线程数目。<br>goroutine 只是由官方实现的超级”线程池”。<br>goroutine 的栈空间是从堆内存中分配的。</p><p>每个实例2KB (在1.4新版本发布的运行时信息当中明确指出,从以前的1.2版本到1.3版本协程占用大小4kb到8kb，到现在的2kb左右，是一个性能上和的大跃进。)的栈内存占用和由于实现机制而大幅减少的创建和销毁开销是go高并发的根本原因。</p><h3 id="调度器的三个基本对象："><a href="#调度器的三个基本对象：" class="headerlink" title="调度器的三个基本对象："></a>调度器的三个基本对象：</h3><ul><li>G（Goroutine），代表协程，go关键字创建的对象</li><li>M（Work Thread），工作线程，一个 M 关联一个内核级线程</li><li>P（Processor），代表一个 处理器，又称上下文<h3 id="G-M-P三者的关系与特点："><a href="#G-M-P三者的关系与特点：" class="headerlink" title="G-M-P三者的关系与特点："></a>G-M-P三者的关系与特点：</h3></li><li>每一个运行的 M 必须绑定一个 P，线程 M 创建后会检查并执行G（goroutine）对象。</li><li>每一个 P 保存着一个协程 G 的队列。</li><li>除了每个 P 自身保存的G的队列外，调度器还有一个全局的G队列</li><li>M 从队列中提取 G，并执行</li><li>P 的个数就是 GOMAXPROCS（最大256），启动时固定，一般不修改</li><li>M 的个数和 P 的个数不一定一样多（会有sleep的M或者P不绑定M）(最大10000)</li><li>P 是用一个全局数组(255)来保存的，并维护一个全局的 P 的空闲链表</li></ul><h3 id="局部G队列与全局G队列的关系"><a href="#局部G队列与全局G队列的关系" class="headerlink" title="局部G队列与全局G队列的关系"></a>局部G队列与全局G队列的关系</h3><ul><li>全局G任务队列会和本地G任务队列按照一定策略互相交换。</li><li>G的执行顺序，先从本地队列找，本地没有则从全局队列找</li><li>转移：局部与全局，全局G个数&#x2F;P个数   局部与局部，一次性转移一半</li></ul><h3 id="Gorutine-从入队到执行"><a href="#Gorutine-从入队到执行" class="headerlink" title="Gorutine 从入队到执行"></a>Gorutine 从入队到执行</h3><ol><li>当我们创建一个G对象，就是 gorutine，它会加入到本地队列或者全局队列</li><li>如果还有空闲的P，则创建一个M 绑定该 P ，注意！这里，P 此前必须还没绑定过M 的，否则不满足空闲的条件<ol><li>先找到一个空闲的P，如果没有则直接返回</li><li>P 个数不会占用超过自己设定的cpu个数</li><li>P 在被 M 绑定后，就会初始化自己的 G 队列，此时是一个空队列</li></ol></li><li>M 会启动一个底层线程，循环执行能找到的 G 任务。这里的寻找的 G 从下面几方面找：<ol><li>当前 M 所绑的 P 队列中找</li><li>去别的 P 的队列中找</li><li>去全局 G 队列中找</li></ol></li><li>G任务的执行顺序是，先从本地队列找，本地没有则从全局队列找</li><li>程序启动的时候，首先跑的是主线程，然后这个主线程会绑定第一个 P</li><li>入口 main 函数，其实是作为一个 goroutine 来执行</li></ol><h3 id="Gorutine-从入队到执行详细流程"><a href="#Gorutine-从入队到执行详细流程" class="headerlink" title="Gorutine 从入队到执行详细流程"></a>Gorutine 从入队到执行详细流程</h3><ol><li>runtime创建第一个线程M0：M0是启动进程后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G，在之后M0就和其他的M一样了。</li><li>runtime创建第一个Go协程G0：G0是每次启动一个M都会第一个创建的 goroutine，G0仅用于负责调度G，G0不指向任何可执行函数，每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间，全局变量的G0是M0的G0。一般的G0放在本地队列中。</li><li>关联M0和G0。</li><li>调度初始化初始化M0、栈、垃圾回收，以及创建和初始化由 GOMAXPROCS 个P构成的P列表。</li><li>创建 main() 中的 goroutine，即 runtime.main 创建 goroutine。</li><li>启动M0，此时M0已经绑定了P，从P的本地队列中获取G，获取到 main goroutine。</li><li>M绑定P。</li><li>循环判断M通过P是否能够获取到G。</li><li>获取不到则M进入休眠队列，等待被唤醒后再重新与P绑定。</li><li>能够获取到G，则M根据G中的栈信息和调度信息设置运行环境。</li><li>M执行G。</li><li>G退出，runtime.main 执行 Defer 和 Panic 处理，或调用 runtime.exit 退出程序。</li></ol><h4 id="中断挂起与恢复"><a href="#中断挂起与恢复" class="headerlink" title="中断挂起与恢复"></a>中断挂起与恢复</h4><p>goroutine协程的中断挂起与恢复 ：协程的切换时间片是10ms，也就是说 goroutine 最多执行10ms就会被 M 切换到下一个 G。这个过程，又被称为 中断，挂起<br>go程序启动时会首先创建一个特殊的内核线程 sysmon，用来监控和管理，其内部是一个循环：</p><ol><li>记录所有 P 的 G 任务的计数 schedtick，schedtick 会在每执行一个G任务后递增</li><li>如果检查到 schedtick 一直没有递增，说明这个 P 一直在执行同一个 G 任务，如果超过10ms，就在这个G任务的栈信息里面加一个 tag 标记</li><li>然后这个 G 任务在执行的时候，如果遇到非内联函数调用，就会检查一次这个标记，然后中断自己，把自己加到队列末尾，执行下一个G</li><li>如果没有遇到非内联函数 调用（有时候正常的小函数会被优化成内联函数）的话，那就会一直执行这个G任务，直到它自己结束；如果是个死循环，并且 GOMAXPROCS&#x3D;1 的话。那么一直只会只有一个 P 与一个 M，且队列中的其他 G 不会被执行！</li></ol><p>中断后的恢复</p><ol><li>中断的时候将寄存器里的栈信息，保存到自己的 G 对象里面</li><li>当再次轮到自己执行时，将自己保存的栈信息复制到寄存器里面，这样就接着上次之后运行<h5 id="GOMAXPROCS–性能调优"><a href="#GOMAXPROCS–性能调优" class="headerlink" title="GOMAXPROCS–性能调优"></a>GOMAXPROCS–性能调优</h5></li></ol><p>看完上面的内容，相信你已经知道，<code>GOMAXPROCS</code> 就是 go 中 runtime 包的一个函数。它设置了 P 的最多的个数。这也就直接导致了 M 最多的个数是多少，而 M 的个数就决定了各个 G 队列能同时被多少个 M 线程来进行调取执行！</p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count)，Go 语言 采用的是标记清除算法。1.5 版本以后在此基础上使用了三色标记法和写屏障技术，提高了效率。</p><p>标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p><ul><li>标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；</li><li>清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。</li></ul><p>标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW，这也是 GC 算法优化的重点），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。</p><p>三色标记算法将程序中的对象分成白色、黑色和灰色三类。</p><ul><li>白色：不确定对象。</li><li>灰色：存活对象，子对象待处理。</li><li>黑色：存活对象。</li></ul><p>标记开始时，所有内存加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入待扫描队列（灰色集合）；使用并发的 goroutine 扫描队列，取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入队列。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。</p><p>三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。</p><p>三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A (黑) -&gt; B (灰) -&gt; C (白) -&gt; D (白)  </span><br></pre></td></tr></table></figure><p>正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A (黑) -&gt; B (灰) -&gt; C (白)   </span><br><span class="line"> ↓  </span><br><span class="line">D (白)  </span><br></pre></td></tr></table></figure><p>为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，这个计数会拦截将白色指针插入黑色对象的操作，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。</p><p>写屏障破坏两个条件其一即可</p><ul><li>破坏条件1：Dijistra写屏障</li></ul><p>满足强三色不变性：黑色节点不允许引用白色节点 当黑色节点新增了白色节点的引用时，将对应的白色节点改为灰色</p><ul><li>破坏条件2：Yuasa写屏障</li></ul><p>满足弱三色不变性：黑色节点允许引用白色节点，但是该白色节点有其他灰色节点间接的引用（确保不会被遗漏） 当白色节点被删除了一个引用时，悲观地认为它一定会被一个黑色节点新增引用，所以将它置为灰色</p><h4 id="一次完整的-GC-分为四个阶段："><a href="#一次完整的-GC-分为四个阶段：" class="headerlink" title="一次完整的 GC 分为四个阶段："></a>一次完整的 GC 分为四个阶段：</h4><ul><li>标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)，开启辅助 GC （mutator assist），统计 root 对象的任务数量</li><li>使用三色标记法标记（Marking, 并发）</li><li>标记结束(Mark Termination，需 STW)，关闭写屏障。</li><li>清理(Sweeping, 并发)</li></ul><h4 id="GC-的触发时机"><a href="#GC-的触发时机" class="headerlink" title="GC 的触发时机"></a>GC 的触发时机</h4><p>使用系统监控，该触发条件由 <code>runtime.forcegcperiod</code> 变量控制，默认为 2 分 钟。当超过两分钟没有产生任何 GC 时，强制触发 GC。 使用步调（Pacing）算法，其核心思想是控制内存增长的比例。如 Go 的 GC 是一种比例 GC, 下一次 GC 结束时的堆大小和上一次 GC <code>存活</code>堆大小成比例。一般来说，当前申请的内存是上一次 GC 两倍时触发。</p><h2 id="一些细碎知识点"><a href="#一些细碎知识点" class="headerlink" title="一些细碎知识点"></a>一些细碎知识点</h2><h4 id="Golang-传参"><a href="#Golang-传参" class="headerlink" title="Golang 传参"></a>Golang 传参</h4><ol><li>理论上来说，Golang 只有值传递，所有协程的入参都是值拷贝，协程内部的修改，无法影响原参数</li><li>对于指针类型的参数，是对其指向地址的拷贝，因此可以使用地址来修改原参数</li><li>Slice 底层是引用数组，因此对于 Slice 的修改可以反映到原数组；注意 扩容相关内容</li></ol><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><ol><li>在编译期间压入操作栈</li><li>多个 defer 的执行顺序为“后进先出”；</li><li>所有函数在执行 RET 返回指令之前，都会先检查是否存在 defer 语句，若存在则先逆序调用 defer 语句进行收尾工作再退出返回；</li><li>匿名返回值是在 return 执行时被声明，有名返回值则是在函数声明的同时被声明，因此在 defer 语句中只能访问有名返回值，而不能直接访问匿名返回值；</li><li>return 其实应该包含前后两个步骤：第一步是给返回值赋值（若为有名返回值则直接赋值，若为匿名返回值则先声明再赋值）；第二步是调用 RET 返回指令并传入返回值，而 RET 则会检查 defer 是否存在，若存在就先逆序插播 defer 语句，最后 RET 携带返回值退出函数；</li><li>defer 声明时会先确定函数参数，推迟执行的仅仅是函数体</li></ol><h4 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h4><p>一般的解决办法是通过 pprof 进行内存分析，发现瓶颈</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof http://123.456.789.1:1234/debug/pprof/heap</span><br></pre></td></tr></table></figure><h4 id="interface-比较"><a href="#interface-比较" class="headerlink" title="interface 比较"></a>interface 比较</h4><h4 id="Struct-能否比较"><a href="#Struct-能否比较" class="headerlink" title="Struct 能否比较"></a>Struct 能否比较</h4><p>不同类型的 struct 无法进行比较，而同一个 struct 的两个实例需要判断其成员能否比较，如果是 slice、map、func 中的一种就无法比较。同时无法比较的类型无法作为 map 的键。</p><h4 id="不能比较的类型如何比较是否相等"><a href="#不能比较的类型如何比较是否相等" class="headerlink" title="不能比较的类型如何比较是否相等"></a>不能比较的类型如何比较是否相等</h4><p>string，int，float，interface 等可以通过 reflect.DeepEqual 和 等于号进行比较<br>而 slice、struct、map 一般使用 reflect.DeepEqual 进行比较。</p><h4 id="标准化输入"><a href="#标准化输入" class="headerlink" title="标准化输入"></a>标准化输入</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line">input1, _ := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 读到的是 string 类型的一行数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="使用-goroutine-有没有遇到什么问题？"><a href="#使用-goroutine-有没有遇到什么问题？" class="headerlink" title="使用 goroutine 有没有遇到什么问题？"></a>使用 goroutine 有没有遇到什么问题？</h4><ol><li>内存泄漏：goroutine 没有适当的结束，被文件或链接句柄阻塞，有死锁或者 channel 阻塞，造成内存泄露<ol><li>确保明确退出</li><li>使用 defer 结束句柄</li><li>使用 context 管理生命周期</li></ol></li><li>并发访问数据，造成数据竞争。<ol><li>sync.mutex 或者 channel 来同步访问</li></ol></li><li>死锁<ol><li>多个 goroutine 互相等待对方的 channel 信道，造成死锁</li><li>主线程 channel 阻塞，造成死锁</li></ol></li><li>过量创建 goroutine <ol><li>使用 waitgroup 或者 channel  控制并发量</li></ol></li><li>panic 传播：goroutine 中的 panic 无法传播到主协程，可能导致程序停止工作<ol><li>使用 defer recover 收集 panic</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> go </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>todo</title>
      <link href="/uncategorized/todo/"/>
      <url>/uncategorized/todo/</url>
      
        <content type="html"><![CDATA[<p>raft<br><a href="https://cloud.tencent.com/developer/article/2168468">https://cloud.tencent.com/developer/article/2168468</a><br><a href="https://www.infoq.cn/article/us5gjqqz8bmbeha25io0">https://www.infoq.cn/article/us5gjqqz8bmbeha25io0</a></p><p>kafka<br><a href="https://cloud.tencent.com/developer/article/2240297?areaId=106001">https://cloud.tencent.com/developer/article/2240297?areaId=106001</a><br><a href="https://cloud.tencent.com/developer/article/2415900">https://cloud.tencent.com/developer/article/2415900</a><br><a href="https://cloud.tencent.com/developer/article/2203064">https://cloud.tencent.com/developer/article/2203064</a></p><p>sync.map<br><a href="https://cloud.tencent.com/developer/article/2140224">https://cloud.tencent.com/developer/article/2140224</a><br><a href="https://cloud.tencent.com/developer/article/2140226">https://cloud.tencent.com/developer/article/2140226</a><br>go.map<br><a href="https://blog.csdn.net/lp15929801907/article/details/130229409?utm_source=miniapp_weixin">https://blog.csdn.net/lp15929801907/article/details/130229409?utm_source=miniapp_weixin</a><br><a href="https://segmentfault.com/a/1190000023879178?utm_source=sf-similar-article">https://segmentfault.com/a/1190000023879178?utm_source=sf-similar-article</a></p><p>sync.Mutex<br><a href="https://cloud.tencent.com/developer/article/2140227">https://cloud.tencent.com/developer/article/2140227</a></p><p>defer<br><a href="https://cloud.tencent.com/developer/article/1410243">https://cloud.tencent.com/developer/article/1410243</a></p><p>gmp<br><a href="https://cloud.tencent.com/developer/article/2191347">https://cloud.tencent.com/developer/article/2191347</a><br><a href="https://cloud.tencent.com/developer/article/1680164">https://cloud.tencent.com/developer/article/1680164</a></p><p>redis<br><a href="https://blog.csdn.net/qq1515312832/article/details/113880849">https://blog.csdn.net/qq1515312832/article/details/113880849</a><br><a href="https://cloud.tencent.com/developer/article/2077086">https://cloud.tencent.com/developer/article/2077086</a><br><a href="https://cloud.tencent.com/developer/article/1796102">https://cloud.tencent.com/developer/article/1796102</a><br>skiplist<br><a href="https://lotabout.me/2018/max-level-of-skiplist/">https://lotabout.me/2018/max-level-of-skiplist/</a></p><p>channel<br><a href="https://cloud.tencent.com/developer/article/1651356">https://cloud.tencent.com/developer/article/1651356</a><br><a href="https://cloud.tencent.com/developer/article/2078995?areaId=106001">https://cloud.tencent.com/developer/article/2078995?areaId=106001</a><br><a href="https://cloud.tencent.com/developer/article/2366292">https://cloud.tencent.com/developer/article/2366292</a></p><p>sync.singleflight<br><a href="https://cloud.tencent.com/developer/article/2064811">https://cloud.tencent.com/developer/article/2064811</a></p><p>pprof<br><a href="https://cloud.tencent.com/developer/article/2369200">https://cloud.tencent.com/developer/article/2369200</a></p><p>并发<br><a href="https://cloud.tencent.com/developer/article/2366295">https://cloud.tencent.com/developer/article/2366295</a></p><p>拷贝<br><a href="https://cloud.tencent.com/developer/article/1870553">https://cloud.tencent.com/developer/article/1870553</a></p><p>位运算<br><a href="https://cloud.tencent.com/developer/article/2046380">https://cloud.tencent.com/developer/article/2046380</a></p><p>context<br><a href="https://cloud.tencent.com/developer/article/2259772">https://cloud.tencent.com/developer/article/2259772</a></p><p>排序<br><a href="https://www.cnblogs.com/onepixel/p/7674659.html">https://www.cnblogs.com/onepixel/p/7674659.html</a></p><p>dns<br><a href="https://cloud.tencent.com/developer/article/2018599">https://cloud.tencent.com/developer/article/2018599</a></p><p>mysql<br><a href="https://blog.csdn.net/qq_44918090/article/details/120278339">https://blog.csdn.net/qq_44918090/article/details/120278339</a></p><p>刷题 Leetcode<br>152</p><p>go<br><a href="https://github.com/KeKe-Li/For-learning-Go-Tutorial/blob/master/src/spec/02.0.md">https://github.com/KeKe-Li/For-learning-Go-Tutorial/blob/master/src/spec/02.0.md</a><br><a href="https://cloud.tencent.com/developer/article/2358698">https://cloud.tencent.com/developer/article/2358698</a><br>gmp<br><a href="https://cloud.tencent.com/developer/article/1343134">https://cloud.tencent.com/developer/article/1343134</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a><br><a href="https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a><br><a href="https://www.digitalocean.com/community/tutorials/http-1-1-vs-http-2-what-s-the-difference">https://www.digitalocean.com/community/tutorials/http-1-1-vs-http-2-what-s-the-difference</a><br><a href="https://hit-alibaba.github.io/interview/basic/network/HTTPS.html">https://hit-alibaba.github.io/interview/basic/network/HTTPS.html</a><br><a href="https://hit-alibaba.github.io/interview/basic/network/HTTP.html">https://hit-alibaba.github.io/interview/basic/network/HTTP.html</a><br>进程间通信<br><a href="https://mp.weixin.qq.com/s/mblyh6XrLj1bCwL0Evs-Vg">https://mp.weixin.qq.com/s/mblyh6XrLj1bCwL0Evs-Vg</a></p><p>es<br><a href="https://cloud.tencent.com/developer/article/2199065">https://cloud.tencent.com/developer/article/2199065</a><br><a href="https://cloud.tencent.com/developer/article/2134425">https://cloud.tencent.com/developer/article/2134425</a></p><p>数据库<br><a href="https://cloud.tencent.com/developer/article/2184186">https://cloud.tencent.com/developer/article/2184186</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/interview/simulation/%E8%AF%9D%E6%9C%AF/"/>
      <url>/interview/simulation/%E8%AF%9D%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="自我介绍："><a href="#自我介绍：" class="headerlink" title="自我介绍："></a>自我介绍：</h3><p>您好，我是王鑫宇，非常感谢给我的这次面试机会，拥有几年k12教育公司负责增长业务相关的系统和模型设计，其中主要包括活动营销平台的开发，以及相关系统的重构与升级，有过多次大型系统研发经验，有过多次跨部门系统研发经验。有过5人小组的管理经验。</p><h3 id="您在前一家公司的离职原因是什么？"><a href="#您在前一家公司的离职原因是什么？" class="headerlink" title="您在前一家公司的离职原因是什么？"></a>您在前一家公司的离职原因是什么？</h3><p>政策限制后，公司尝试了多种方向，比如海外业务、多学科等探索，初步是有一些成果的。我自身来说还是想要和公司一同发展的，但是随着时间的推移，各方向业务收缩，研发工作以维护为主，对于系统层面的迭代实际上是在不断地做减法。并且家人生病，需要人照顾，综合考虑下就出来了</p><h3 id="项目-STAR原则！（Situation、Task、Action、Result）"><a href="#项目-STAR原则！（Situation、Task、Action、Result）" class="headerlink" title="项目 STAR原则！（Situation、Task、Action、Result）"></a>项目 STAR原则！（Situation、Task、Action、Result）</h3><h4 id="广告平台"><a href="#广告平台" class="headerlink" title="广告平台"></a>广告平台</h4><p><strong>Situation：</strong><br>初衷是这样的，做活动的时候需要在公司内部多个 app 做展示推送，那么涉及到了不同业务方的展示规则不尽相同，需求提过去又需要结合其他业务方评估是否支持，以及研发周期，对于所有人来说都是很高的成本，并且数据统计也是各管各的，从活动角度很难一键式的获取营销数据，需要额外的再提一些数据需求；再者，有一些 ab 实验的展示要求，也很难推广，基本上只能选取最大流量的来做评估，但是最大流量的 app 从付费模式上来说又不一样，所以其实获取的数据很难得到想要的结果。<br><strong>Task：</strong><br>为了解决上述的问题，首先要做的是先收集各种广告的样式以及投放规则，然后做整合和分类。并且由于新系统目标要支持整个公司多个 App 的访问流量，可以预见的是相关并发量会比常规的活动要高。一个用户单 app 大概有十几个位置需要拉取信息，绘本的用户因为没有严格的上课时间，所以虽然用户量大，日活高，但是理论上不会短时间集中访问。但是一对一就不一样了，用户一般上下课时间是固定的，那么这一段短时间内，可能会有2-3w用户并发的来获取广告内容，双减前高峰期也能有 5w+ 的用户，估算大概至少是百万级别的 qps。<br>其次是要做好与各个第三方功能系统的交互，关键的是数据怎么流通和冗余。<br><strong>Action：</strong><br>大概整理出来的分类有：轮播、点播、弹窗、开屏（轮换）、首页条、金刚位、浮窗（常驻）等。<br>大概的筛选项有：静默期、轮播、最近N（小时&#x2F;天&#x2F;周&#x2F;月）最多投放M次、每日活跃区间等。还有关联的第三方 用户属性、ab实验分组、简单的版本控制等。<br>广告位：定义分类和展示内容规则（大小、多少等）<br>广告组：定义一批广告的内容素材，以及广告点击后跳转地址等<br>广告：组和位 多对多 的单个组合，是用户可见营销内容的基本单位<br>为了保证服务的质量和稳定性，采用了 内存-redis-tidb 三层缓存结构，系统启动时，将相关广告配置加载到内存和 redis 中，如果是活动或者营销高峰，还会针对热点数据再缓存一层到 redis 中，第三层是 tidb 持久化的数据。为了减少前两层同时失效的情况，内存缓存做了随机定时更新，更新阶段会请求会透传到 redis 这一层。由于是读多写少的场景，redis 层一般会随配置更新而更新，除此之外也有自己的随机刷新时间，间隔相较于内存缓存会长一点。整体的刷新时间基本在1-2分钟，从业务上评估的话，对于这种延时是可以接受且影响不大的。<br>容灾：为了应对极端情况，比如数据库挂掉，会在动态配置和前端分别做默认数据的相关处理，保证业务基本可用；如果是配置错误造成的缓存污染的情况，如果比较紧急，也提供了强制刷新的动态配置开关。在配置正确的情况下，一般会在 1-2 分钟内完成缓存更新。</p><p>能够支持的配置维度大概有：</p><ol><li>静默期</li><li>最近N（小时&#x2F;天&#x2F;周&#x2F;月）最多投放M次、<ol><li>按照自然周期设置一个桶，用户a在该周期1展示的广告x，用户每次展示成功了就往该 key 中添加一个元素，最后判断是否达到 M 来确定是否继续展示</li><li>zset 结构</li></ol></li><li>每日投放区间<ol><li>可以配置多个</li><li>设计上比较像 leet 合并区间，</li><li>最后判断当前时间即可</li></ol></li><li>用户标签 or 用户身份规则<br>并且对接了 ab 测试系统，可以自动的参与实验。且使用广告的唯一标识来串联了数据漏斗，可以很好地查看投放的效果。</li></ol><p>一个比较有意思的功能是轮播，用户每次进来都能看到不同的广告，实现方式是利用了redis中zset的结构。首先用户有一个可见广告的集合，用户+广告位来标识一个桶，每次访问将广告的唯一id加入桶内，利用 zscore 来做判断，访问一轮以后清除桶重新计数。当时也是想了一些缓存计数方案，但是都不如 zset 来的方便。<br><strong>Result：</strong><br>最终的效果是可以支持多 app 多种类型广告位，多种展示规则，多种过滤规则，对接了ab实验，以及串联起来前后端数据流统计和漏斗统计，方便运营优化策略。<br>能够很好的支持百万级别的访问量</p><h4 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h4><p>很明确的排行榜需求嘛<br><strong>Task：</strong><br>提供总排名，查询用户个人排名，查询排行榜分数，以及可能相关的翻页需求。基础的分数计数器。<br><strong>Action：</strong><br>分数变动入口由计数器处理，计数器设计上是单实例串行的逻辑，相关接口配用户维度的分布式锁，且接入消息队列，对于大量 or 并发高的数据，可以考虑接入队列。用户的个人分数也有计数器来提供功能。<br>使用 zset 来存储，对于简单的活动，一般一个排行榜就是一个 zset。里面是用户和分数。对于同分选手，需要按照先达到该分数的排名靠前（方案可以是到达时间与基准时间做差值，当做score的小数部分参与排序。执行<code>时间排序值 =（基准时间 - 玩家达到分数时间）/ 基准时间</code>公式计算，得到的结果值一定小于 1，正好可作为 score 小数部分。越早达到，这个值就越大，满足排序。）<br>ZREVRANGE 命令来获取排行榜，其中成员的位置按 score 值递减 (从大到小) 来排列。具有相同 score 值的成员按字典序的反序排列。<br>还可以用负分数参与排序，使用 zrange 命令<br>对于参与人数大的排行榜，全部放到一起显然是不可行的。一般会根据业务形态，如果是短期营销，用户的分数分布更可能是金字塔型<br>前几页热门排行，会再加一层缓存数据，随业务更新异步刷新，展示相对实时内容；<br>或者前几页单独配置一个排行榜，但是会涉及到多个排行榜之间的排名及翻页的复杂计算，还有用户积分变化后从榜a出来进入榜b等，这个需要看情况要不要做成这么复杂的。<br>如果还不够支持，可以考虑做成内存缓存。<br>可以按照分段分成不同的 zset ，并且配合缓存每个 zset 的用户数量。那么用户自身排名就是他之前的 bucket 数量和 + 本 bucket 排名。<br>积分变动可能有两种，一种是 bucket 不变，积分变化，那么 zset 可以支持；另一种积分变化导致 bucket 变化，需要有 出榜 和 入榜 的操作。<br>还有一种不太要求实时排名的情况，可以定时去拉积分变动的 binlog ，来做更新。</p><p>本质上是读取和写入两个部分嘛，读取就要做好防击穿和雪崩的应对。写入的话分两种，一种是队列每一种是接口调用，都要保证并发安全；另外还可以每天晚上根据 binlog 对账。<br>还有一个是需要注意 bucket 中的人数数量级，及时准备应对方案。<br><strong>Result：</strong></p><h2 id="长链转短链"><a href="#长链转短链" class="headerlink" title="长链转短链"></a>长链转短链</h2><p>长链转短链是日常很容易碰到的场景嘛，可用于消息触达、解决关键词屏蔽问题或者域名屏蔽问题，可以统计用户点击等；另外可能的情景是分享二维码的时候长连接会影响生成的二维码密度，也需要转链服务的支持。</p><p>主要流程是：</p><ol><li>用户访问某域名下短链，例：<a href="https://short.com/1a2b3c">https://short.com/1a2b3c</a></li><li>短链服务收到请求后，去相应的缓存或者 db 中查找 kv 对，找到原始长链接</li><li>返回状态码 302（临时重定向），并将响应头中的Location设置为原长链接地址（301永久重定向，不好统计点击次数）</li><li>浏览器重新请求原链接</li><li>返回响应</li></ol><p>理论上不可能存在将所有长链一一对应成短链；也不存在某种 hash 函数，可以不重复的计算出长链对应的短链<br>所以问题就回归到发号器上边，来一个长地址，就给分配一个短地址。简单的方案，使用自增ID即可，从10进制往62进制转换即可；</p><p>但是在分布式场景下，这个方案就变得不那么可行了。改进方案可以参考 tidb 的自增id，为每个实例分配不同的号段，或者设定某种取模方案均衡号段</p><h4 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h4><p>短链接标识一般是 [0-9, a-z, A-Z] 随机组合而成的字符串，字符一共有 62 个，因此短链接标识可以用 62 进制的字符串表示。</p><p>首先维护一个自增的 ID，当生成短链接时，将 10 进制的自增 ID 转换成 62 进制字符串，这个字符串就可以唯一标识一个长链接。由于 ID 是自增的，对应的 62 进制字符串是不同的，这样就不会出现一个短链接对应多个长链接的问题，62 个字符排列组合，可以保证短链接是用不完的，就算仅限于 6 位长度标识的短链接，也有 558 亿多种情况，这种算法在网上被称为自增序列算法。</p><p>1、62 进制的顺序并不一定严格按照 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 的顺序来表示，这个顺序可以是打乱的，这样生成的短链接标识更随机不易被破解。</p><p>2、长链接与短链接是否需要一对多关系，同一个长链接使用自增主键 ID 算法生成的短链接是不同的，因为自增主键 ID 不同，生成的 62 进制字符串自然也不同。如果我们有一个长链接唯一对应一个短链接需求，可以将长链接进行 md5 加密，将加密后的 md5 值存储在 DB 中，每次生成短链接前都根据长链接 md5 值查询 DB，如果存在，则直接返回短链接，当然也可以使用其他方式维护这种关系。</p><p>如果创建一个短链系统，我们应该做什么呢？</p><ol><li>将长链接变为短链；</li><li>用户访问短链接，会跳转到正确的长链接上去。</li></ol><p>查找到对应的长网址，并跳转到对应的页面。</p><h5 id="短链生成方法"><a href="#短链生成方法" class="headerlink" title="短链生成方法"></a>短链生成方法</h5><p>短码一般是由 <code>[a - z, A - Z, 0 - 9]</code> 这62 个字母或数字组成，短码的长度也可以自定义，但一般不超过8位。比较常用的都是6位，6位的短码已经能有568亿种的组合：(26+26+10)^6 &#x3D; 56800235584，已满足绝大多数的使用场景。</p><p>目前比较流行的生成短码方法有：<code>自增id</code>、<code>摘要算法</code>、<code>普通随机数</code>。</p><h6 id="自增id"><a href="#自增id" class="headerlink" title="自增id"></a>自增id</h6><p>该方法是一种无碰撞的方法，原理是，每新增一个短码，就在上次添加的短码id基础上加1，然后将这个10进制的id值，转化成一个62进制的字符串。</p><p>一般利用数据表中的自增id来完成：每次先查询数据表中的自增id最大值max，那么需要插入的长网址对应自增id值就是 max+1，将max+1转成62进制即可得到短码。</p><p>但是短码 id 是从一位长度开始递增，短码的长度不固定，不过可以用 id 从指定的数字开始递增的方式来处理，确保所有的短码长度都一致。同时，生成的短码是有序的，可能会有安全的问题，可以将生成的短码id，结合长网址等其他关键字，进行md5运算生成最后的短码。</p><h6 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h6><p>摘要算法又称哈希算法，它表示输入任意长度的数据，输出固定长度的数据。相同的输入数据始终得到相同的输出，不同的输入数据尽量得到不同的输出。</p><p>算法过程：</p><ol><li>将长网址md5生成32位签名串,分为4段, 每段8个字节；</li><li>对这四段循环处理, 取8个字节, 将他看成16进制串与0x3fffffff(30位1)与操作, 即超过30位的忽略处理；</li><li>这30位分成6段, 每5位的数字作为字母表的索引取得特定字符, 依次进行获得6位字符串；</li><li>总的md5串可以获得4个6位串；取里面的任意一个就可作为这个长url的短url地址；</li></ol><p>这种算法,虽然会生成4个,但是仍然存在重复几率。</p><p>虽然几率很小，但是该方法依然存在碰撞的可能性，解决冲突会比较麻烦。不过该方法生成的短码位数是固定的，也不存在连续生成的短码有序的情况。</p><h6 id="普通随机数"><a href="#普通随机数" class="headerlink" title="普通随机数"></a>普通随机数</h6><p>该方法是从62个字符串中随机取出一个6位短码的组合，然后去<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>中查询该短码是否已存在。如果已存在，就继续循环该方法重新获取短码，否则就直接返回。</p><p>该方法是最简单的一种实现，不过由于 <code>Math.round()</code>方法生成的随机数属于伪随机数，碰撞的可能性也不小。在数据比较多的情况下，可能会循环很多次，才能生成一个不冲突的短码。</p><h1 id="对于分布式系统，有哪些新认识？"><a href="#对于分布式系统，有哪些新认识？" class="headerlink" title="对于分布式系统，有哪些新认识？"></a>对于分布式系统，有哪些新认识？</h1><ol><li>cap原理，可用性和数据一致性和分区容忍性三者不可兼得嘛。需要根据业务做权衡，数据的一致性也有 最终一致性、强一致性等不同要求。</li><li>数据跟随微服务，放在靠近使用者的位置，可以减少网络延时</li><li>多实例就会涉及到分布式架构的弹性伸缩和自动恢复，也会涉及到熔断降级等应对操作</li><li>微服务架构大致会按照功能或者业务划分成不同的微服务，方便各自拓展边界和维护。但是要注意微服务之间的调用链和依赖路径。</li><li>一致性协议包括 paxos 和 raft 。raft 是增加了任期概念的 paxos。保证多节点之间的数据一致性和容错性。</li><li>rpc：使用 http2 协议，传输文本为 protobuffer 二进制序列化，</li><li>多服务多实例的话就需要可观测和监控，比如访问量、访问延时、调用数据库延时、堆栈内存变化等指标，及时应对异常</li><li>大数据流量和高并发场景下，kafka 这种流式处理组件就很重要了。</li><li>故障隔离和容错，增加熔断、降级机制，避免故障扩散</li><li></li></ol><p>使用 etcd 来完成微服务注册和发现，使用 thrift 和 grpc 作为微服务的框架。<br>rpc访问量、耗时，sql耗时等关键指标暴露给 Prometheus，并通过 Grafana 展示，便于监控服务质量，以及出现问题时可以帮助快速定位异常接口</p><p>context多数用来进行上下文信息传递，在实际开发中，会记录整条调用链路。一般来说，需要注意的是超时机制；context只能自顶向下传值；context一定不能为nil，在不确定的情况下可以使用 context.TODO() 或者 context.Background()</p><p>etcd中的分布式锁一般用来在集群系统启动时确定由哪一个系统来全局单例业务操作，比如数据刷新、业务数据清洗等<br>依据当前接口的唯一标识数据来实现幂等<br>不同系统间调用顺序可以用消息队列保证<br>分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p><p>分布式系统一般使用 redis 来做分布式锁（缺点：redis主从切换时可能丢失数据）<br>redis分布式锁，我们使用的业务场景，加锁时间一般为1s-3s，根据场景浮动，其中3s是我们设定的最长响应时间。</p><p>如果加锁后，过期时间内业务由于某种原因还没执行完，下一次请求再次加锁后打进来，而此时上一次的请求还未执行完毕，这时候需要对锁进行延期。可以采用协程的方法来设置一个ticker，在执行完毕的channel中如果没有收到通知，那么就需要对这个锁进行有限次的续期，来保证不会出现超卖这类情况。</p><p>另一种情况是如果当前锁是全局的，那么可能会出现锁被其他集群的进程解锁的情况，这种一般针对加锁的key进行处理即可</p><p>对于活动呢，由于运营提出的活动形式有很多，且对于上线时间有强要求，所以一般初次出现的活动形式，会采取敏捷开发的方式，以达到最快且稳定上线的目的</p><p>任务系统，初期设计呢是很死板的，根据运营设计的任务动作从涉及到的多个方向拉取或者等待信息推送，但是这个方案对于其他业务的侵入性太高，风险极高。针对这一点，我将所有的业务动作全部转移到消息队列来获取，这样对于其他业务线或者系统来说，大部分是已经支持的</p><p>抽奖系统，可以讲讲分布式锁相关，</p><p>slice底层实现方法，map底层实现方法</p><p>redis 跳表</p><p>golang 语言的优势：静态语言，编译阶段可以发现一些问题；并发支持好，耗时随并发数线性增加；垃圾回收处理好</p><p>golang 文件操作使用比较少，了解不多</p><p>golang channel 利用协程通信来共享内存</p><p>常见排序：快排，堆排，归并</p><p>内核线程才是并行的基本单位</p><p>k8s 运维同学可以用运营商的相关配置</p><h2 id="如果你现在重头来看当时的一个设计-或者当时遇到的一些困难的问题-有没有更好的做法？"><a href="#如果你现在重头来看当时的一个设计-或者当时遇到的一些困难的问题-有没有更好的做法？" class="headerlink" title="如果你现在重头来看当时的一个设计 或者当时遇到的一些困难的问题 有没有更好的做法？"></a>如果你现在重头来看当时的一个设计 或者当时遇到的一些困难的问题 有没有更好的做法？</h2><p>哥，我想的是可以拿团购来说，就是不要把业务流程和功能绑定太死，尽量要抽取主框架，然后往上边填模块<br>可以结合业务发展来讲。主流程就是开团参团嘛，还有自动脚本成团啥的，成员分成团长团员机器人三个嘛，不同身份在流程节点的动作是抽象在成员的函数内的；成员会挂载到一个团概念上，团又会有啥阶梯、普通这种分类，在成团发奖方面也有自己的抽象方法。甚至开团参团也可以抽象成一个 tunnel，一条购买消息来了，根据上下文走不通的逻辑，执行不同的pre校验和post动作。就这种方案的话，以后加入加个别的什么功能或者概念，往上边套就行</p><p>您提供的描述已经非常详细和专业，但如果想要进一步优化，可以考虑以下几个方面：</p><ol><li><strong>精简和突出重点</strong>：将最重要的技能和经验放在前面，以便快速抓住读者的注意力。</li><li><strong>使用专业术语</strong>：确保使用行业内广泛认可的术语，以显示您的专业性。</li><li><strong>量化成果</strong>：如果可能，提供具体的例子或数字来量化您的成果和经验。</li><li><strong>个人特质</strong>：强调您的个人特质和工作态度，让读者了解您作为团队成员的价值。</li></ol><p>以下是优化后的版本：</p><hr><p><strong>技术专长</strong>：</p><ul><li>精通 Golang 编程语言，具备扎实的编程基础和优秀的逻辑思维能力。</li><li>熟练掌握 MySQL、TiDB 等主流关系型数据库，以及 MongoDB、Redis 等 NoSQL 数据库的应用。</li><li>深入理解 Kafka 等消息中间件的工作原理。</li></ul><p><strong>架构与设计</strong>：</p><ul><li>熟悉微服务架构，具有丰富的系统设计经验，能够高效地进行系统架构规划和设计。</li><li>强大的系统设计能力，能够应对复杂系统的设计挑战。</li></ul><p><strong>项目管理</strong>：</p><ul><li>拥有5人团队的项目管理经验，曾作为项目负责人成功主持跨部门项目的设计、研发和上线。</li><li>强烈的团队合作意识，能够在团队中发挥领导作用。</li></ul><p><strong>个人素质</strong>：</p><ul><li>认真负责，具备出色的执行力和良好的抗压能力。</li><li>对编程充满热情，面对挑战和问题时表现出高度的积极性和解决问题的能力。</li></ul><hr><p>这样的描述更加精炼，同时突出了您的专业技能、项目管理能力和个人素质。</p><p>离职原因</p><p>当时更看好做教育方向，也想换语言到 golang ，更支持微服务这个方向</p><p>双减算是黑天鹅事件了</p><p>职业规划：这次看机会就几个方向，一个是看有没有搭建基础中台的机会</p><p>另一个是看有没有机会入行 ai 方向，毕竟这也算是未来一段时间的主流蓝海了</p><p>继续提升技术，寻找一些大型项目的机会（搭建基础中台的机会），进而看有没有成为项目 leader 或者架构的方向。</p><p>个人优势？<br>golang 语言，微服务，活动营销平台，总结抽象系统，喜欢重构，喜欢研究有需求的东西并做一些自己的理解和发散。</p><p>家人原因离职</p><p>学科探索 新加坡数学，中英，国学（流量池但不大）<br>有现金流的话其实就很好，可以在稳定的前提下再探索嘛，这部分相对来说也是可控的。</p><p>伴鱼的话，感觉1对1还算可以，能有相对稳定的流水，但是增长的话目前是没什么好的方案</p><p>其他业务线绘本啊、自然拼读啊，因为本身付费周期相对较短，而且结合一些头部主播做专场，流水倒是还行。</p><p>获客成本高，直播流量对于1对1的增长感觉有折扣。活动角度的话，很多时候为了活动而活动，感觉对于产品本身的一些特性没有很突出，后期大多数时候是成为了一个促单促销的工具，又受限于营销成本，可能用户角度的优惠也没有那么大。</p><p>有没有涉及翻译功能？学习交流的是目标语言还是？学习者是在纯目标语言环境中体验虚拟情景？<br>有没有一些预设的学习目标？口语这个感觉不好找量化指标？<br>结合社交与游戏玩法让用户练习口语。目标人群是 青少年 还是成人方向？内容和虚拟形象是否会做差异化？<br>语音识别？</p><p>会往 vrchat 的方向发展么？</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 实录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常见排序</title>
      <link href="/library/algorithm/algorithm-sort/"/>
      <url>/library/algorithm/algorithm-sort/</url>
      
        <content type="html"><![CDATA[<p>![[img&#x2F;elementary-sort.png]]</p><h2 id="常考排序"><a href="#常考排序" class="headerlink" title="常考排序"></a>常考排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 思路：把一个数组分为左右两段，左段小于右段</span></span><br><span class="line">    quickSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原地交换，所以传入交换索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="type">int</span>, start, end <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> start &lt; end &#123;</span><br><span class="line">        <span class="comment">// 分治法：divide</span></span><br><span class="line">        pivot := partition(nums, start, end)</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, pivot<span class="number">-1</span>)</span><br><span class="line">        quickSort(nums, pivot+<span class="number">1</span>, end)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(nums []<span class="type">int</span>, start, end <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 选取最后一个元素作为基准pivot</span></span><br><span class="line">    p := nums[end]</span><br><span class="line">    i := start</span><br><span class="line">    <span class="comment">// 最后一个值就是基准所以不用比较</span></span><br><span class="line">    <span class="keyword">for</span> j := start; j &lt; end; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[j] &lt; p &#123;</span><br><span class="line">            swap(nums, i, j)</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把基准值换到中间</span></span><br><span class="line">    swap(nums, i, end)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换两个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(nums []<span class="type">int</span>, i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    t := nums[i]</span><br><span class="line">    nums[i] = nums[j]</span><br><span class="line">    nums[j] = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergeSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mergeSort(nums)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分治法：divide 分为两段</span></span><br><span class="line">    mid := <span class="built_in">len</span>(nums) / <span class="number">2</span></span><br><span class="line">    left := mergeSort(nums[:mid])</span><br><span class="line">    right := mergeSort(nums[mid:])</span><br><span class="line">    <span class="comment">// 合并两段数据</span></span><br><span class="line">    result := merge(left, right)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="type">int</span>)</span></span> (result []<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 两边数组合并游标</span></span><br><span class="line">    l := <span class="number">0</span></span><br><span class="line">    r := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 注意不能越界</span></span><br><span class="line">    <span class="keyword">for</span> l &lt; <span class="built_in">len</span>(left) &amp;&amp; r &lt; <span class="built_in">len</span>(right) &#123;</span><br><span class="line">        <span class="comment">// 谁小合并谁</span></span><br><span class="line">        <span class="keyword">if</span> left[l] &gt; right[r] &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, right[r])</span><br><span class="line">            r++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, left[l])</span><br><span class="line">            l++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剩余部分合并</span></span><br><span class="line">    result = <span class="built_in">append</span>(result, left[l:]...)</span><br><span class="line">    result = <span class="built_in">append</span>(result, right[r:]...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>用数组表示的完美二叉树 complete binary tree</p><blockquote><p>完美二叉树 VS 其他二叉树</p></blockquote><p><img src="https://greyireland.gitbook.io/~gitbook/image?url=https://img.fuiboom.com/img/tree_type.png&width=768&dpr=4&quality=100&sign=da697a19f8b79e11953a90709485d8e615dda884e21047841e538aa29ce671d3"></p><p>核心代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(a []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 1、无序数组a</span></span><br><span class="line">    <span class="comment">// 2、将无序数组a构建为一个大根堆</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(a)/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        sink(a, i, <span class="built_in">len</span>(a))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、交换a[0]和a[len(a)-1]</span></span><br><span class="line">    <span class="comment">// 4、然后把前面这段数组继续下沉保持堆结构，如此循环即可</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(a) - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 从后往前填充值</span></span><br><span class="line">        swap(a, <span class="number">0</span>, i)</span><br><span class="line">        <span class="comment">// 前面的长度也减一</span></span><br><span class="line">        sink(a, <span class="number">0</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sink</span><span class="params">(a []<span class="type">int</span>, i <span class="type">int</span>, length <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 左节点索引(从0开始，所以左节点为i*2+1)</span></span><br><span class="line">        l := i*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="comment">// 右节点索引</span></span><br><span class="line">        r := i*<span class="number">2</span> + <span class="number">2</span></span><br><span class="line">        <span class="comment">// idx保存根、左、右三者之间较大值的索引</span></span><br><span class="line">        idx := i</span><br><span class="line">        <span class="comment">// 存在左节点，左节点值较大，则取左节点</span></span><br><span class="line">        <span class="keyword">if</span> l &lt; length &amp;&amp; a[l] &gt; a[idx] &#123;</span><br><span class="line">            idx = l</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在右节点，且值较大，取右节点</span></span><br><span class="line">        <span class="keyword">if</span> r &lt; length &amp;&amp; a[r] &gt; a[idx] &#123;</span><br><span class="line">            idx = r</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果根节点较大，则不用下沉</span></span><br><span class="line">        <span class="keyword">if</span> idx == i &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果根节点较小，则交换值，并继续下沉</span></span><br><span class="line">        swap(a, i, idx)</span><br><span class="line">        <span class="comment">// 继续下沉idx节点</span></span><br><span class="line">        i = idx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a []<span class="type">int</span>, i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 必看必会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度</title>
      <link href="/library/algorithm/algorithm-time-complixty/"/>
      <url>/library/algorithm/algorithm-time-complixty/</url>
      
        <content type="html"><![CDATA[<h2 id="时间复杂度-大-O"><a href="#时间复杂度-大-O" class="headerlink" title="时间复杂度 (大 O)"></a>时间复杂度 (大 O)</h2><p>![[Pasted image 20240429194251.png]]</p><p>![[Pasted image 20240429194302.png]]</p><p>首先，我们来谈谈常用操作的时间复杂度，按数据结构&#x2F;算法划分。然后，我们将讨论给定输入大小的合理复杂性。</p><h4 id="数组（动态数组-x2F-列表）"><a href="#数组（动态数组-x2F-列表）" class="headerlink" title="数组（动态数组&#x2F;列表）"></a>数组（动态数组&#x2F;列表）</h4><p>规定 <em>n &#x3D; arr.length</em>,</p><ul><li>结尾添加或删除元素: 𝑂(1)</li><li>从任意索引中添加或删除元素: 𝑂(𝑛)</li><li>访问或修改任意索引处的元素: 𝑂(1)</li><li>检查元素是否存在: 𝑂(𝑛)</li><li>双指针: 𝑂(𝑛⋅𝑘), 𝑘 是每次迭代所做的工作，包括滑动窗口</li><li>构建前缀和: 𝑂(𝑛)</li><li>求给定前缀和的子数组的和：𝑂(1)</li></ul><h4 id="字符串-不可变"><a href="#字符串-不可变" class="headerlink" title="字符串 (不可变)"></a>字符串 (不可变)</h4><p>规定 <em>n &#x3D; s.length</em>,</p><ul><li>添加或删除字符: 𝑂(𝑛)</li><li>任意索引处的访问元素: 𝑂(1)</li><li>两个字符串之间的连接: 𝑂(𝑛+𝑚), 𝑚 是另一个字符串的长度</li><li>创建子字符串: 𝑂(𝑚), 𝑚 是子字符串的长度</li><li>双指针: 𝑂(𝑛⋅𝑘), 𝑘 是每次迭代所做的工作，包括滑动窗口</li><li>通过连接数组、stringbuilder 等构建字符串：𝑂(𝑛)</li></ul><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>给定 𝑛n 作为链表中的节点数，</p><ul><li>给定指针位置的后面添加或删除元素: 𝑂(1)</li><li>如果是双向链表，给定指针位置添加或删除元素: 𝑂(1)</li><li>在没有指针的任意位置添加或删除元素: 𝑂(𝑛)</li><li>无指针任意位置的访问元素: 𝑂(𝑛)</li><li>检查元素是否存在: 𝑂(𝑛)</li><li>在位置 i 和 j 之间反转: 𝑂(𝑗−𝑖)</li><li>使用快慢指针或哈希映射完成一次遍历: 𝑂(𝑛)</li></ul><h4 id="哈希表-x2F-字典"><a href="#哈希表-x2F-字典" class="headerlink" title="哈希表&#x2F;字典"></a>哈希表&#x2F;字典</h4><p>给定 <em>n &#x3D; dic.length</em>,</p><ul><li>添加或删除键值对: 𝑂(1)</li><li>检查 key 是否存在: 𝑂(1)</li><li>检查值是否存在: 𝑂(𝑛)</li><li>访问或修改与 key 相关的值: 𝑂(1)</li><li>遍历所有键值: 𝑂(𝑛)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意: 𝑂(1)O(1) 操作相对于 n 是常数.实际上，哈希算法可能代价很高。例如，如果你的键是字符串，那么它将花费 𝑂(𝑚)O(m)，其中 𝑚m 是字符串的长度。 这些操作只需要相对于哈希映射大小的常数时间。</span><br></pre></td></tr></table></figure></li></ul><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>给定 <em>n &#x3D; set.length</em>,</p><ul><li>添加或删除元素: 𝑂(1)</li><li>检测元素是否存在: 𝑂(1)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面的说明也适用于这里。</span><br></pre></td></tr></table></figure></li></ul><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈操作依赖于它们的实现。栈只需要支持弹出和推入。如果使用动态数组实现:给定 <em>n &#x3D; stack.length</em>,</p><ul><li>推入元素: 𝑂(1)</li><li>弹出元素: 𝑂(1)</li><li>查看 (查看栈顶元素): 𝑂(1)</li><li>访问或修改任意索引处的元素: 𝑂(1)</li><li>检测元素是否存在: 𝑂(𝑛)</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列操作依赖于它们的实现。队列只需要支持出队列和入队列。如果使用双链表实现:给定 <em>n &#x3D; queue.length</em>,</p><ul><li>入队的元素: 𝑂(1)</li><li>出队的元素: 𝑂(1)</li><li>查看 (查看队列前面的元素): 𝑂(1)</li><li>访问或修改任意索引处的元素: 𝑂(𝑛)</li><li>检查元素是否存在: 𝑂(𝑛)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意:大多数编程语言实现队列的方式比简单的双链表更复杂。根据实现的不同，通过索引访问元素可能比 𝑂(𝑛)O(n) 快，但有一个重要的常量除数。</span><br></pre></td></tr></table></figure></li></ul><h4 id="二叉树问题-DFS-x2F-BFS"><a href="#二叉树问题-DFS-x2F-BFS" class="headerlink" title="二叉树问题 (DFS&#x2F;BFS)"></a>二叉树问题 (DFS&#x2F;BFS)</h4><p>给定  𝑛 作为树的节点数，大多数算法的时间复杂度为 𝑂(𝑛⋅𝑘), 𝑘 是在每个节点上做的操作数, 通常是 𝑂(1)。这只是一个普遍规律，并非总是如此。我们在这里假设 BFS 是用高效队列实现的。</p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>给定 𝑛 作为树中的节点数，</p><ul><li>添加或删除元素：最坏的情况下 𝑂(𝑛),平均情况 𝑂(log⁡𝑛)</li><li>检查元素是否存在：最坏的情况下 𝑂(𝑛), 平均情况 𝑂(log⁡𝑛)<br>平均情况是当树很平衡时 —— 每个深度都接近满。最坏的情况是树只是一条直线。</li></ul><h4 id="堆-x2F-优先队列"><a href="#堆-x2F-优先队列" class="headerlink" title="堆&#x2F;优先队列"></a>堆&#x2F;优先队列</h4><p>给定 <em>n &#x3D; heap.length</em> 并讨论最小堆,</p><ul><li>添加一个元素: 𝑂(log⁡𝑛)</li><li>删除最小的元素: 𝑂(log⁡𝑛)</li><li>找到最小的元素: 𝑂(1)</li><li>查看元素是否存在: 𝑂(𝑛)</li></ul><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>在最坏的情况下，二分查找的时间复杂度为 𝑂(log⁡𝑛)，其中 𝑛 是初始搜索空间的大小。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>排序: 𝑂(𝑛⋅log⁡𝑛), 其中 𝑛 是要排序的数据的大小</li><li>图上的 DFS 和 BFS：𝑂(𝑛⋅𝑘+𝑒)，其中 𝑛 是节点数，𝑒 是边数，前提是每个节点处理花费都是 𝑂(1)，不需要重复遍历。</li><li>DFS 和 BFS 空间复杂度：通常为 𝑂(𝑛)，但如果它在图形中，则可能为 𝑂(𝑛+𝑒) 来存储图形</li><li>动态规划时间复杂度：𝑂(𝑛⋅𝑘)，其中 𝑛 是状态数，𝑘 是每个状态所需要的操作数</li><li>动态规划空间复杂度：𝑂(𝑛)，其中 𝑛 是状态数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 必看必会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raft 面试必备</title>
      <link href="/interview/raft-interview/"/>
      <url>/interview/raft-interview/</url>
      
        <content type="html"><![CDATA[<p>Raft<br>Raft协议呢，一般包括这三种节点：Follower、Candidate、Leader；其中，候选人是只有在选举期间才存在的节点，一旦选举结束，那么集群中就只有 Leader，Follower</p><p>节点之间使用 rpc 来通信，包括 投票rpc，复制日志心跳rpc，快照rpc</p><p>选举过程如下：<br>选举时机：当网络刚刚启动或者集群节点变更，或者上一任期结束后。所有节点进入选举阶段，每个人持有一个随机的选举时钟，时钟结束后，节点优先给自己投票，然后广播投票rpc。会有三种结果：赢得多数选票成为 Leader； 其他人当选，自己成为 follower；没有人当选，开启下一轮投票。<br>由于raft的机制，可以认为能够成为 Leader 的节点，一定是包含所有日志的节点<br>leader选举的过程是：1、增加term号；2、给自己投票；3、重置选举超时计时器；4、发送请求投票的RPC给其它节点</p><p>Leader 被选举出来以后，就开始接收客户端的消息。Leader 会将这一条消息作为日志记录下来，并将其通过心跳包同步给集群中的 follower，当大部分节点都同步这条日志以后，Leader 将这个请求应用到自身的状态机并回复客户端。follower 如果发生宕机或者丢包，Leader 会不断尝试直到所有节点都同步了这条日志。<br>日志由有序编号（log index）的日志条目组成。每个日志条目包含它被创建时的任期号（term）和用于状态机执行的命令。</p><p>日志复制的过程有两条保证：</p><ol><li>如果不同节点的两条日志有相同的索引和任期，那么他们存储的命令是一致的（由于主从同步的特性，Leader 节点上的日志和命令落库后就不会更改）</li><li>如果不同节点的两条日志有相同的索引和任期，那么他们之前存储的日志也是一致的（由于日志的一致性检查，当 follower 收到来自 Leader 的心跳包以后，会与本地的日志索引和任期做匹配，如果有不一致，那么会拒绝掉这个心跳包）</li></ol><p>日志复制的异常情况包括：<br>Leader 宕机或者崩溃，旧 Leader 没有复制完所有的日志。可能多，可能少，可能不一致</p><p>日志复制的过程，需要通过与 Leader 保证强一致性来保证安全复制。当日志产生不一致时，Leader 会从后往前尝试同步日志心跳包给其他节点，直到找到一个双方都符合的日志，然后 Leader 会把从这条日志以后的所有内容同步给该节点，将不一致的部分覆盖掉，直到与 Leader 保持完全一致<br><strong>当 leader 和 follower 日志冲突的时候</strong>，leader 将<strong>校验 follower 最后一条日志是否和 leader 匹配</strong>，如果不匹配，<strong>将递减查询，直到匹配，匹配后，删除冲突的日志</strong></p><p>那么像之前提到 Leader 中的日志可能也不是最新的，会不会同步出去的日志本身就是异常的呢？<br>这个就是 raft 通过两条限制来保证了日志复制的安全性：</p><ol><li>只有log索引和任期是最新的节点才有可能成为 Leader，这个在选举投票期间是可以判断的，非最新的就不给他投票</li><li>Leader 只能推进日志的索引进行提交，以前任期的要在检查一致性的过程中同步过去。</li></ol><p>那么在实际使用过程中，为了保证日志不会无限增长，每隔一段时间，每个节点独立的进行快照，将某个时间点以前的日志落库后丢弃。<br>当 Leader 在同步日志的过程中发现某个节点的日志特别老，那么这时候，Leader 会发送快照rpc来将日志打包复制。<br>当然实际使用中，需要控制间隔的时间，和快照的频率（防止发生 io 阻塞），一般达到固定大小发生一次。<br>同时可以使用 copy-on-write 技术来保证正常的日志同步</p><p>脑裂问题是说一次性在集群中增加了太多的节点，比如超过了原来节点数量的一半，那么就有可能产生双主的现象，即一个集群中有两个 Leader，彼此成员之间没有交集。解决办法是一次变更一个节点，少量多次的来完成。<br>另外还有一个情况是，如果发生了网络分区故障或者异常，导致老 Leader 失联了，剩下的节点会重新选举出一个新 Leader，并与客户端继续交流。当老 Leader 恢复连接以后，他上面的 commit 都会被视作失效，本身会转化为 follower 接收从新 Leader 来的日志。</p><p>另外一种还有一个 <strong>Prevote</strong> 机制<br>当有一个 follower 与集群隔离后，他会自己进入候选阶段，并由于无法获得投票成为 Leader 而一直刷新任期，导致该节点任期非常大。当该节点重进集群以后，会由于任期导致选举混乱，因此 raft 采用 prevote 机制，是一个类似于两阶段提交的协议，第一阶段先征求其他节点是否同意选举，如果同意选举则发起真正的选举操作，否则降为Follower角色。这样就避免了网络分区节点重新加入集群，触发不必要的选举操作</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>simulation02</title>
      <link href="/interview/simulation/simulation02/"/>
      <url>/interview/simulation/simulation02/</url>
      
        <content type="html"><![CDATA[<p>深维：<br>一面：</p><h4 id="1-用过哪些分布式锁-redis-key用什么类型-用string有什么坏处-？没抢到的都在干等着，浪费cpu？如何规避。-etcd如何分布式锁"><a href="#1-用过哪些分布式锁-redis-key用什么类型-用string有什么坏处-？没抢到的都在干等着，浪费cpu？如何规避。-etcd如何分布式锁" class="headerlink" title="1.用过哪些分布式锁 redis key用什么类型 用string有什么坏处 ？没抢到的都在干等着，浪费cpu？如何规避。 etcd如何分布式锁"></a>1.用过哪些分布式锁 redis key用什么类型 用string有什么坏处 ？没抢到的都在干等着，浪费cpu？如何规避。 etcd如何分布式锁</h4><p>redis 锁 可能存在的问题：</p><ul><li>业务超时，导致锁失效，造成多实例持有锁：延长过期时间（不推荐）；类似 java 的看门狗机制，另外启用一个协程对锁续约。</li><li>redis 主从切换时可能造成多实例持有锁，这个是用的 redlock 来解决的，不过具体的方案我就没有看过了<br>用过redis锁， setnx属于原子操作，上锁失败一般认为是锁已经存在了。一般使用string类型作为key，string类型有一个缺点是会占用比较大的空间，<br>可以根据业务具体情况使用 hset ，但是需要保证单个集合中的 kv 数量，如果超过某个界限，redis 就不会用 ziplist 来存储这个集合了</li></ul><h4 id="2-数据库-隔离级别-没有解决什么问题-幻读是什么"><a href="#2-数据库-隔离级别-没有解决什么问题-幻读是什么" class="headerlink" title="2.数据库 隔离级别 没有解决什么问题 幻读是什么"></a>2.数据库 隔离级别 没有解决什么问题 幻读是什么</h4><p>一共有五种：<br>不使用事务<br>read uncommitted 允许脏读<br>read committed 防止脏读 最常用<br>repeatable read 防止脏读，不可重复读 mysql 默认<br>serilized 串行事务，防止幻读，脏读，不可重复读<br>级别越高，安全性越好，并发性能约低</p><p>幻读就是在一个事务过程中用相同条件查询时，获取的结果不一致<br>事务A获取的结果集，事务B对其中的数据进行了修改并提交，事务A在重新执行查询时，可能会发现原本不存在的数据行（幻影），或者原本存在的数据行消失了</p><h4 id="5-slice和数组的区别-各自的好处-地址引用和值引用的好处"><a href="#5-slice和数组的区别-各自的好处-地址引用和值引用的好处" class="headerlink" title="5.slice和数组的区别 各自的好处 地址引用和值引用的好处"></a>5.slice和数组的区别 各自的好处 地址引用和值引用的好处</h4><p>区别仅在于数据在声明时定长，切片可拓展长度<br>值引用是对原数据进行了一份拷贝后传入函数，一般用于函数改值不影响原数据的场景；地址引用是对原数据地址指针的引用，一般函数中对于这个引用的改动会反映到原数据上</p><h4 id="6-mysql的索引如何实现的，二级索引如何实现的"><a href="#6-mysql的索引如何实现的，二级索引如何实现的" class="headerlink" title="6.mysql的索引如何实现的，二级索引如何实现的"></a>6.mysql的索引如何实现的，二级索引如何实现的</h4><p>由于聚集索引是利用表的主键构建的，所以每张表只能拥有一个聚集索引。</p><p>聚集索引的叶子节点就是数据页。换句话说，数据页上存放的是完整的每行记录。因此聚集索引的一个优点就是：通过过聚集索引能获取完整的整行数据。另一个优点是：对于主键的排序查找和范围查找速度非常快。<br>使用B+树作为索引结构，其中聚集索引（Primary Index）的叶子节点包含行数据，而非聚集索引（Secondary Index）的叶子节点包含主键值。<br>二级索引（也称为辅助索引）实现方式与主索引类似，只是它不是主键。在InnoDB中，二级索引的叶子节点包含指向主键的指针，这个指针用于回表查询获取完整的数据行。</p><h4 id="7-map的底层如何实现的-什么类型不能用做map的key"><a href="#7-map的底层如何实现的-什么类型不能用做map的key" class="headerlink" title="7.map的底层如何实现的 什么类型不能用做map的key"></a>7.map的底层如何实现的 什么类型不能用做map的key</h4><h4 id="9-如何实现LRU"><a href="#9-如何实现LRU" class="headerlink" title="9.如何实现LRU"></a>9.如何实现LRU</h4><p>双向链表 + 哈希表<br>双向链表存储节点，哈希表存储节点值到节点地址的映射</p><h4 id="10-索引（a-b-c-a-x3D-b-x3D-c-x3D-c-x3D-b-x3D-a-x3D-a-x3D-b-gt-c-x3D-命中索引的哪一段"><a href="#10-索引（a-b-c-a-x3D-b-x3D-c-x3D-c-x3D-b-x3D-a-x3D-a-x3D-b-gt-c-x3D-命中索引的哪一段" class="headerlink" title="10.索引（a,b,c) a&#x3D; b&#x3D; c&#x3D;, c&#x3D; b&#x3D; a&#x3D;, a&#x3D; b&gt; c&#x3D;命中索引的哪一段"></a>10.索引（a,b,c) a&#x3D; b&#x3D; c&#x3D;, c&#x3D; b&#x3D; a&#x3D;, a&#x3D; b&gt; c&#x3D;命中索引的哪一段</h4><h4 id="11-数据库间隙锁是什么"><a href="#11-数据库间隙锁是什么" class="headerlink" title="11.数据库间隙锁是什么"></a>11.数据库间隙锁是什么</h4><p>MySQL InnoDB支持三种行锁定方式：</p><p>行锁（Record Lock）：锁直接加在索引记录上面。<br>间隙锁（Gap Lock）：锁加在不存在的空闲空间，可以是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。<br>Next-Key Lock：行锁与间隙锁组合起来用就叫做Next-Key Lock。</p><p>在一般范围区间查询数据时，会对命中的行加行锁，但是对于条件范围内但是还不存在的行也会加间隙锁。如果上一次区间查询没有执行完毕，那么针对该表区间内的insert操作会因为间隙锁而阻塞，直到查询执行完毕才会继续执行<br>可以解决幻读问题</p><p>可以防止数据误删改</p><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>T0</td><td>BEGIN;</td><td>BEGIN;</td></tr><tr><td>T1</td><td>delete from t_student where id &lt; 4;</td><td></td></tr><tr><td>T2</td><td></td><td>insert into t_student VALUES(2,‘戏子111’,1,“杭州”);</td></tr><tr><td>T3</td><td></td><td>commit;</td></tr><tr><td>T4</td><td>commit;</td><td></td></tr><tr><td>会对插入性能有一定影响</td><td></td><td></td></tr></tbody></table><h4 id="12-分布式事务了解过哪些-如何实现"><a href="#12-分布式事务了解过哪些-如何实现" class="headerlink" title="12.分布式事务了解过哪些 如何实现"></a>12.分布式事务了解过哪些 如何实现</h4><h4 id="13-电商系统如何防止超买超卖"><a href="#13-电商系统如何防止超买超卖" class="headerlink" title="13.电商系统如何防止超买超卖"></a>13.电商系统如何防止超买超卖</h4><p>一般来说，超买超卖发生在高并发的情况下。那么针对高并发的情况，可以通过加并发锁控制并发；采用队列方式改为顺序执行；利用数据库的原子语句（不推荐）<br>一般减库存区分 下单、付款、预扣（例如下单后保留10分钟）这几个节点</p><h4 id="14-悲观锁和乐观锁分别适合什么样的场景"><a href="#14-悲观锁和乐观锁分别适合什么样的场景" class="headerlink" title="14.悲观锁和乐观锁分别适合什么样的场景"></a>14.悲观锁和乐观锁分别适合什么样的场景</h4><p>悲观锁：担心数据被他人修改，因此每次修改都期望加锁，适合写大于读的情况。主要利用数据库中的读锁，行锁，写锁<br>乐观锁因为不担心数据修改问题，更多适合读大于写的场景，使用版本号或者时间戳（updatetime）</p><h4 id="15-负载均衡-etcd如何做-NGINX如何做-k8s如何做"><a href="#15-负载均衡-etcd如何做-NGINX如何做-k8s如何做" class="headerlink" title="15.负载均衡 etcd如何做 NGINX如何做 k8s如何做"></a>15.负载均衡 etcd如何做 NGINX如何做 k8s如何做</h4><p>轮询和加权轮询；权重可以根据节点的状态来动态调整。要注意权重的上下限<br>一致性哈希： 哈希环，服务端节点在环上，距离哈希结果最近的下一个节点<br>最少连接数<br>最快响应等</p><h4 id="16-普罗米修斯"><a href="#16-普罗米修斯" class="headerlink" title="16.普罗米修斯"></a>16.普罗米修斯</h4><h4 id="17-traceid系统怎么做的-如何从前端传到后端各个服务"><a href="#17-traceid系统怎么做的-如何从前端传到后端各个服务" class="headerlink" title="17.traceid系统怎么做的 如何从前端传到后端各个服务"></a>17.traceid系统怎么做的 如何从前端传到后端各个服务</h4><p>伴鱼使用的是jager，最初的采集方式是每隔一段时间采集一次。主要用来排查异常，解决业务问题，但是有间隔的采样命中相关异常的概率很小，经常是遇到了问题但是采集不到。后期结合社区内的一些组件，更新了采集方式，</p><p>二面：<br>1.挑一个项目能代表你的架构设计或者解决问题的能力（需要偏技术而不是业务）</p><p>2.如何做服务治理</p><p>3.etcd是ap系统还是cp系统<br>&#x3D;&#x3D;<strong>etcd是CP实现</strong>&#x3D;&#x3D;,它保证一致性与分区容错性,一定程度上牺牲了可用性。</p><p>4.etcd如何做负载均衡</p><p>5.K8S+docker A服务调用B服务是怎么知道B服务的地址的 </p><p>6.降级限流熔断怎么做的 熔断的原理是什么</p><ol><li>降级（Degradation）<br>概念：降级是指在系统遇到异常或高负载等情况下，暂时关闭或者切换到一些功能简化的模式，以保证核心流程的可用性和稳定性。<br>作用：通过舍弃一些非核心或不重要的功能，保护核心功能的正常运行。<br>示例：在高负载情况下，关闭一些消耗较大的查询功能，只提供基本的读写操作。</li><li>熔断（Circuit Breaker）<br>概念：熔断是指在服务调用过程中，当某个服务出现故障或不可用时，暂时停止调用该服务，直到服务恢复正常。<br>作用：通过熔断机制，保护系统免受故障服务的影响，避免雪崩效应。<br>示例：监控服务调用的失败率或错误率，当达到一定阈值时，打开熔断器，停止对该服务的调用。一段时间后，再进行尝试，如果调用成功，则关闭熔断器，继续正常调用。</li><li>限流（Rate Limiting）<br>概念：限流是指在系统的请求流量过大时，对请求进行控制和限制，使得系统在可接受的范围内进行处理，避免系统超出处理能力而崩溃。<br>作用：通过限制请求的数量或速度，保护系统免受过载的影响。<br>示例：设置每秒最大请求数或最大并发数，当请求数或并发数达到阈值时，拒绝额外的请求或者将其放入等待队列，直到系统能够处理。</li></ol><p>7.post报文由什么组成</p><p>8.tcp如何定位双方 三次握手</p><p>9.如果有M个东西，每8个为一组，每两组之间有两个重叠，会分成多少组</p><p>10.人才管理</p><p>11.逃逸分析</p><p>12.设计模式</p><h4 id="grpc-和-http-的区别"><a href="#grpc-和-http-的区别" class="headerlink" title="grpc 和 http 的区别"></a>grpc 和 http 的区别</h4><p>grpc的话是使用 http&#x2F;2 协议进行通信，传输内容为二进制内容，因此grpc的关键算法是 payload 的序列化和反序列化，一般使用 protocol buffer 序列化库。服务之间使用 rpc 调用</p><h5 id="数据序列化："><a href="#数据序列化：" class="headerlink" title="数据序列化："></a>数据序列化：</h5><p>gRPC使用Protocol Buffers对数据进行序列化和反序列化，实现跨语言、跨平台的数据交换。Protocol Buffers的序列化和反序列化过程可以通过以下公式表示：</p><ul><li>序列化(M)&#x3D;Encode(M)</li><li>反序列化(M)&#x3D;Decode(M)<br>其中，$M$ 是数据结构，$Encode$ 和 $Decode$ 分别表示序列化和反序列化操作。</li></ul><h5 id="RPC调用："><a href="#RPC调用：" class="headerlink" title="RPC调用："></a>RPC调用：</h5><p>gRPC的RPC调用过程可以分为以下步骤：</p><ul><li>客户端通过Protocol Buffers序列化请求数据，并使用HTTP&#x2F;2发送请求。</li><li>服务器接收请求，使用Protocol Buffers反序列化请求数据。</li><li>服务器执行RPC方法，并将结果序列化为Protocol Buffers格式。</li><li>服务器使用HTTP&#x2F;2发送响应给客户端。</li><li>客户端使用Protocol Buffers反序列化响应数据，并处理结果。</li></ul><ol><li>通信方式</li></ol><ul><li>RPC:远程过程调用,是一种进程间通信方式。双方建立链接后,一个进程可以直接调用另一个进程的函数。</li><li>HTTP:超文本传输协议,是一种客户端和服务器之间的请求-响应模式。客户端发送请求,服务器返回响应,两者连接后立即断开。</li></ul><ol start="2"><li>传输协议</li></ol><ul><li>RPC:可以使用TCP或UDP作为传输协议。</li><li>HTTP:使用TCP作为传输协议。</li></ul><ol start="3"><li>数据格式</li></ol><ul><li>RPC:通常使用自定义的数据格式,比如XML、JSON等。</li><li>HTTP:使用标准的MIME类型,如HTML、XML、JSON、图片等多种格式。</li></ul><ol start="4"><li>连接方式</li></ol><ul><li>RPC:双方在通信期间会持续连接。</li><li>HTTP:采用无连接的传输协议,每次连接后立即断开,下次通信需要重新建立连接。</li></ul><ol start="5"><li>应用场景</li></ol><ul><li>RPC:适用于内部系统集成,提供服务的调用和响应。</li><li>HTTP:适用于Web应用,网页访问和文件传输。</li></ul><p>总结一下</p><ul><li>RPC是一种进程内通信机制,HTTP是一种网络应用协议。</li><li>RPC使用TCP或UDP,HTTP只使用TCP。 </li><li>RPC使用自定义的数据格式,HTTP使用标准MIME类型。</li><li>RPC是持续连接,HTTP是短连接。</li><li>RPC用于内部集成,HTTP用于Web应用。</li></ul><p>伊对</p><ol><li>项目，活动营销平台，感觉没有什么技术难点。。。</li><li>slice 底层实现是什么，源代码里面有哪些结构，是否是线程安全的</li><li>sync.map 怎么实现的？为什么他是线程安全的，做了哪些处理</li><li>redis zset，是什么数据结构，redis怎么存的</li><li>redis 大key问题？</li><li>mysql 慢查询怎么解决？除了索引（创建合适的索引和修改语句）+数据量 还有哪些方法？</li><li>go 内存泄漏？ 哪些情况会产生内存泄漏<ol><li>内存泄漏可能是因为长期运行的后台服务，或者是因为对象没有被适当地清理。</li><li>比如写入超过channel缓冲区间的 goroutine，但是没有人消费，后续写入全部阻塞</li><li>比如读取channel数据时，由于写入端已经执行完毕，造成饥饿阻塞</li><li>多个协程由于通信问题造成死锁</li><li>某些链接句柄采用了无限循环的方式来保证链接成功<br> 解决方法：</li><li>检查代码中是否有全局变量或长生命周期对象持有小对象的引用，导致小对象不能被垃圾回收。  </li><li>确保使用了智能指针（如<code>sync.Pool</code>）来管理共享资源的生命周期。</li><li>使用工具如<code>go tool pprof</code>分析内存使用情况，找出内存泄漏的位置。</li><li>定期重启服务以清理内存中的无用数据。</li><li>如果使用了第三方库，确保它们在使用后释放所有资源。</li><li>在代码中使用<code>defer</code>语句释放资源，如文件句柄、数据库连接等。</li><li>如果可能，使用上下文（Context）管理和取消长时间运行的操作，以便在操作完成前取消，释放资源。</li></ol></li></ol><p>题：283 移动0 改为 移动target；移动至末尾改为移动至前面</p><p>给定一个字符串str，返回字符串中字母顺序最大的而且同时在字符串中出现大写和小写的字母。 如果不存在这样的字母，返回‘~‘。<br>请返回大写字母<br>|str|&lt;&#x3D;1000<br>‘aAbBcD’ 返回 B</p><p>leetcode 931</p><p>需要自己写输入输出</p><h3 id="昆仑万维"><a href="#昆仑万维" class="headerlink" title="昆仑万维"></a>昆仑万维</h3><ol><li>gc流程？gc触发时机？</li><li>channel底层实现？</li><li>mutex底层实现？ 自旋？</li><li>mysql 多主多从？</li><li>raft协议，怎么同步日志？脑裂？怎么解决？</li><li>Kafka 为什么不支持读写分离？</li></ol><p>leet 71<br>leet 三数之和</p><p>Go channel mutex map slice 源码解析 check<br>Go gc gmp check<br>mysql B+树<br>redis raft<br>kafka<br>elasticsearch<br>etcd<br>grpc<br>zookeeper</p><p>微服务拆分。服务治理（服务发现，管理配置？流量控制，日志监控？容错容灾？）<br>网络协议：tcp&#x2F;ip，http，<br>高并发，高可用，数据一致性</p><p>dau 1-2w 上课人数，绘本 20w+<br>广告位：十几个位置 乘 dau 差不多 百万级别 qps；活动高峰期总参与差不多百万，日均大概能有10-20w，任务接口大概10-20个，综合起来差不多大几百万qps<br>相关系统 差不多 4核8g，4实例</p><p>区块链<br>1.接口加密怎么做<br>2.https是安全的么？<br>3.map为什么是线程不安全的，添加kv的流程是怎么样的？<br>4.channel区满，剩下阻塞状态的 routine 是怎么调度的？<br>5.redis 大key<br>6.go内存对齐<br>7.mysql B+树<br>8.雪崩，穿透（互斥锁 + 空缓存；布隆，但是怎么给所有接口加？）是什么？怎么解决？<br>9.kafka为什么读取比较快？<br>10.10个G的手机号，内存1G，怎么排序？</p><p>newstart 做企业erp的，说是tob但是有点像外包了<br>1.go for 和 for range 有什么区别？哪个好？<br>2.go context 过期、复制<br>3.go slice底层有哪些结构？ 扩容怎么扩的<br>4.做工资报表，有一批人员，有一批第三方考勤数据，有一批历史工资数据。你会怎么设计数据库？</p><p>区块链<br>接口怎么加密？可以用类似 sign ，对接口参数前后端同时加密对比<br>https 安全么？抓包？<br>k8s 崩溃了 有什么恢复手段？自动重启靠什么？<br>map 为什么线程不安全？ 扩容不是原子性<br>channel 10缓冲区，100 协程，写满了以后，阻塞的协程会被调度到哪里？归谁管？<br>redis 大key 问题。kv 中的 v 大，主因还是在于 redis 中 string 类型是用 sds 结构存储，最大一块内存区是 128k，更大的 value 会造成不连续的磁盘存储，影响取值速度；另一个会影响io，但相对不是主要原因<br>kafka 为什么会快呢？因为他的存储是在一段连续的区域<br>go 内存对齐<br>tidb 用的底层是啥？<br>mysql b+树，叶子节点存在哪里<br>缓存雪崩？<br>击穿怎么解决？<br>10个G的手机号文件，内存1个G，怎么排序？：拆文件，然后可以根据手机号特性，排序第一位第二位，分别放到不同的文件内</p><p>阿里：<br>1.服务拆分 原则 为什么要拆 方法论  颗粒度的粗细 数据一致性 上线之后遇到的问题<br>2.mongo mysql tidb 有什么优劣<br>3.kafka pulsuar 有什么优劣<br>4.数据库迁移遇到过哪些问题 怎么解决的<br>5.幂等 如何设计<br>6.给一个视频评论页面，数据库如何设计 索引 缓存<br>7.二分查找一个小于X的最大数<br>8.ES的原理</p><p>conviva:<br>1.网址敲了之后会发生什么<br>2.为什么用tidb<br>3.数据统计怎么做的<br>4.算法题 有向无环图求经过三个点的路径总数</p><p>旷视：<br>1.写一个结构体的快排<br>2.append的第二个参数是什么<br>3.append了之后会发生什么<br>3.用var 初始化一个slice 容量有多大 占多少字节<br>4.随机写一个leetcode中等难度的题</p><p>作业帮<br>1.讲项目，问了问活动数据<br>2.压力测试怎么做的<br>3.怎么避免高并发的请求到数据库（我讲了缓存）<br>4.数据迁移怎么做的？<br>5.算法题：不重叠的区间<br>6.go interface 能不能比较？<br>7.go 协程为什么快？</p><p>海纳AI<br>1.打开文件 应该是打开了才关，没打开不用关<br>2.for range 是复制出来的<br>3.协程传参<br>4.你写代码的层级架构是什么样<br>5.update where 如果没有索引会发生什么 跟隔离级别有关系吗<br>6.如何保证数据库和缓存的一致性：<br>    读缓存失败读sql的时候同时更新缓存<br>    对于更新频繁且一致性要求高的场景：更新时先更新缓存，再同步更新sql<br>    更新频繁但是一致性要求低：优先更新缓存，异步更新sql<br>    事务方式双写<br>    使用乐观锁 + 版本控制<br>7.缓存雪崩的解决办法<br>8.限流是怎么做的 令牌桶算法 有什么特点<br>    控制请求速率<br>    定时生成令牌，请求需要拿取令牌来执行<br>    漏桶算法：未满入桶，定速漏出来执行<br>9.假设有一场几十万人的在线考试，如何做到数据持久化数据一致性和高可用<br>10.什么是k8s的hpa<br>11.这种场景下redis和数据库的一致性<br>12.假如有一个表有几百个字段 这时候怎么办</p><p>进程，线程，协程的区别<br>进程间怎么通信<br>http，socket，rpc 概念和区别？优缺点<br>微服务怎么分的<br>raft</p><p>n个数，任取 0-k 个求和，求有多少种可能的结果</p><p>与爱为舞</p><p>项目<br>微服务<br>数据库<br>redis<br>es<br>kafka</p><p>缓存怎么做的<br>消息触达平台 - kafka - 延时队列，<br>mysql 数据怎么落到磁盘上的<br>前后端加密 session 鉴权怎么做的<br>服务治理<br>dns 和 ip 怎么弄得？如果是自建站，是什么流程<br>redis 相关结构底层 跳表，压缩表，跳表怎么确定层级<br>由概率问到了项目里面的抽奖</p><p>tcp和udp区别<br>TCP 面向连接（如打电话要先拨号建立连接）提供可靠的服务，UDP 是无连接的，即发送数据之前不需要建立连接，UDP 尽最大努力交付，即不保证可靠交付。<br>UDP 具有较好的实时性，工作效率比 TCP 高，适用于对高速传输和实时性有较高的通信或广播通信。<br>每一条 TCP 连接只能是一对一的，UDP 支持一对一，一对多，多对一和多对多的交互通信。<br>UDP 分组首部开销小，TCP 首部开销 20 字节，UDP 的首部开销小，只有 8 个字节。<br>TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流，UDP 是面向报文的一次交付一个完整的报文，报文不可分割，报文是 UDP 数据报处理的最小单位。<br>UDP 适合一次性传输较小数据的网络应用，如 DNS，SNMP 等。</p><p>华为二<br>go map 底层结构<br>gc 写屏障<br>gmp<br>看过哪些源码？讲讲 slice<br>go 性能分析工具和方法<br>为什么要加 redis 这一层，为什么他们快？</p><p>什么情况下会存在分布式锁误删的情况</p><p>docker 多实例，服务发现 etcd，负载均衡，hpa（自动伸缩），docker file<br>监控 普罗米修斯、心跳包。限流（令牌桶） 熔断，降级（用的什么中间件）</p><p>服务怎么保证稳定性和可用性：报警，服务等级（报警标准），慢查询，监控<br>微服务设计方式，分区部署，故障隔离<br>注意流量控制和负载均衡<br>实例数量自动伸缩 and 服务降级<br>数据容错和备份<br>定期健康检查、心跳包<br>普罗米修斯监控（CPU，内存，堆栈，磁盘使用，请求数，错误率，慢查询统计，数据库连接数量，数据库响应时间，接口响应时间）<br>日志和钉钉报警，<br>持续集成和持续部署<br>身份验证和授权等<br>性能优化：缓存 and sql</p><p>线上有没有经历过内存泄漏，怎么解决？发现（监控指标，堆数量，）， + 定位 + 解决</p><p>在Go语言的线上应用中，内存泄漏虽然不常见，但确实可能发生，特别是在高并发和长期运行的服务中。以下是一些常见的内存泄漏问题及其解决方法：</p><h3 id="常见内存泄漏原因"><a href="#常见内存泄漏原因" class="headerlink" title="常见内存泄漏原因"></a>常见内存泄漏原因</h3><ol><li><p><strong>长生命周期的对象持有短生命周期对象的引用</strong>：</p><ul><li><strong>描述</strong>：全局变量、单例模式等长生命周期对象持有短生命周期对象的引用，导致短生命周期对象无法被垃圾回收（GC）。</li><li><strong>解决方法</strong>：尽量避免使用全局变量，或在使用完毕后及时将引用置为nil。</li></ul></li><li><p><strong>未关闭的Goroutine</strong>：</p><ul><li><strong>描述</strong>：未正确关闭的Goroutine会继续占用内存。</li><li><strong>解决方法</strong>：确保在适当的时机通过通道（channel）或上下文（context）关闭Goroutine。</li></ul></li><li><p><strong>未释放的资源</strong>：</p><ul><li><strong>描述</strong>：未正确关闭文件、数据库连接等资源，导致内存占用。</li><li><strong>解决方法</strong>：使用<code>defer</code>语句确保资源在使用完毕后被正确关闭。</li></ul></li><li><p><strong>缓冲区无限增长</strong>：</p><ul><li><strong>描述</strong>：使用缓冲区（如slice、map）时，未对其增长进行限制，导致内存占用不断增加。</li><li><strong>解决方法</strong>：对缓冲区大小进行合理限制，并定期清理过期或无用的数据。</li></ul></li></ol><h3 id="检测内存泄漏"><a href="#检测内存泄漏" class="headerlink" title="检测内存泄漏"></a>检测内存泄漏</h3><ol><li><p><strong>pprof工具</strong>：</p><ul><li>Go自带的pprof工具可以用来检测内存使用情况和内存泄漏。</li><li>使用方法：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    _ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.Println(http.ListenAndServe(<span class="string">&quot;localhost:6060&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>运行应用后，可以通过<code>http://localhost:6060/debug/pprof/heap</code>查看内存使用情况。</li></ul></li><li><p><strong>go-torch工具</strong>：</p><ul><li>用于生成火焰图（flame graph），帮助分析Goroutine和内存分配。</li><li>使用方法：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-torch -u http://localhost:6060 -f torch.svg</span><br></pre></td></tr></table></figure></li><li>生成的torch.svg可以用浏览器打开查看内存分配情况。</li></ul></li></ol><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li><p><strong>定期检查和优化代码</strong>：</p><ul><li>定期进行代码审查，确保所有资源都在使用完毕后被正确释放。</li><li>对长生命周期的对象进行检查，确保不会持有不必要的引用。</li></ul></li><li><p><strong>使用上下文管理Goroutine</strong>：</p><ul><li>通过context包管理Goroutine的生命周期，确保在需要时正确关闭Goroutine。</li><li>示例：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">go</span> worker(ctx)</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">    cancel()  <span class="comment">// 关闭Goroutine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>限制缓冲区大小</strong>：</p><ul><li>对slice、map等缓冲区进行合理大小限制，避免无限增长。</li><li>定期清理过期或无用的数据，确保内存使用不会不断增加。</li></ul></li><li><p><strong>使用内存分析工具</strong>：</p><ul><li>定期使用pprof和go-torch等工具进行内存分析，及时发现和解决内存泄漏问题。</li></ul></li></ol><p>通过以上方法，可以有效检测和解决Go语言中的内存泄漏问题，确保线上服务的稳定运行。</p><p>k8s </p><p>kafka 线上有没有遇到什么问题？怎么解决的？<br>消息堆积：消费者并发处理，消费者自主转发再消费，优化消费逻辑，增加消费者服务实例和 kafka 分区<br>kafka broker宕机：利用多副本机制，确保宕机时仍有数据可用；定期监控和维护<br>磁盘空间不足：定期清理过期消息；增加存储或者拓展集群；优化消息存储策略<br>数据丢失：确保所有副本确认消息接收；启用消息日志压缩和快照功能，保证数据恢复</p><p>es</p><p>高内聚低耦合，</p><p>update where 不走索引 和隔离级别有关么？</p><p>项目数据？怎么造一下？亮点<br>排行榜，@马哥<br>奖励库存</p><p>go routine有没有遇到什么问题<br>panic 传播<br>内存泄漏<br>过量创建<br>死锁<br>并发读写造成数据竞争</p><p>微服务的层级结构是怎么划分的？架构设计<br>api网关层：接入 http 接口，处理 post get 等请求，请求转发给相应的微服务，处理某些数据整合逻辑<br>    分为内部接口和外部接口，可能会涉及到不同的鉴权和身份，需要互相隔离<br>服务层：实现业务逻辑，提供核心功能<br>数据层：与数据库交互，一般这一层会放到服务层内部<br>基础运维层：</p><p>golang 的缺点？？<br>不支持泛型<br>错误处理需要层层收集和显示处理<br>第三方库待完善<br>gc 的 stw </p><p>mysql 数据怎么 放到磁盘里的</p><p>B+ 多路查找树是怎么构建的？<br>那条数据构建出来的 b+ 树有多高？<br>二级索引和一级索引的区别？</p><p>负载均衡算法?</p><p>ab测试原理</p><p>cpu跑多少并发量</p><p>map 为什么不安全</p><p>kafka 为什么会重复消费，<br>partition 和 消费组的关系？<br>为什么消息要均分到 partition 上<br>mysql 有哪些锁？都是怎么实现的？<br>有哪些索引，外键和主键的区别，联合索引是怎么存的？为什么要弄联合索引这个东西？最左匹配是什么原理？<br>mysql 分库分表大概的数量级？<br>zset 做排行榜是怎么排序的？</p><p>kafka 的同步方式？kafka 写入是否是顺序的？<br>redis 持久化？宕机了怎么恢复数据</p><p>字节<br>一面<br>自我介绍<br>讲一个感觉技术难度比较高的，重点介绍下项目背景和你的角色<br>题的话就是 <a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/description/">https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/description/</a><br>问了最左匹配，然后讨论下具体原理<br>redis zset 具体结构，问 zrange 是怎么查出来数据的。讲完结构还问了查询复杂度。<br>主播订阅场景：有订阅周期，怎么设计用户订阅表？订阅失效怎么修改状态？</p><p>二面<br>讲项目的架构设计，需求是什么，怎么分模块设计的<br>会问服务器数量和qps<br>mysql acid 具体怎么保证的，持久性怎么实现的？为什么需要redolog，为什么不直接把数据刷盘<br>系统设计：订单表，日两千万，怎么存？我答分库分表，问怎么分；按照用户查询订单列表怎么查<br>题：leet3</p><p>AI 大模型应用落地 AI口语教练 AI虚拟角色社交 这些东西 然后围绕上面提到的东西思考一下 看一下邮件里那个公司介绍的文档<br>什么是AI agent 什么是RAG 通用的应用落地一般是怎么做的 然后发散性的思考就行了 就是用GPT教法国人学英语 东西不难<br>![[Pasted image 20240623123910.png]]</p><h3 id="Detailed-Analysis-of-Work-Experience-Continued"><a href="#Detailed-Analysis-of-Work-Experience-Continued" class="headerlink" title="Detailed Analysis of Work Experience (Continued)"></a>Detailed Analysis of Work Experience (Continued)</h3><h4 id="北京读我科技有限公司"><a href="#北京读我科技有限公司" class="headerlink" title="北京读我科技有限公司"></a>北京读我科技有限公司</h4><p><strong>资深服务端开发工程师 (Go)</strong><br><strong>2019.02 - 2023.10</strong></p><p><strong>重构转介绍节点奖励平台</strong></p><ol><li><p>重新梳理了转介绍双方的映射关系，奖励的配置、更新以及发放等多种规则。  </p><ul><li><strong>Problem Identified:</strong> Needs more specific methodology and quantification.</li><li><strong>Improved Version:</strong> 重构了转介绍节点奖励平台，通过重新梳理映射关系和优化奖励配置，实现奖励发放效率提升50%。</li></ul></li><li><p>对多表多关联的历史数据进行迁移，并完善了迁移算法实现与验证、风险评估、数据备份、实时双写、线上实时报错与熔断、并发压力测试、数据比对、操作实施方案制定等任务。  </p><ul><li><strong>Problem Identified:</strong> Very detailed, consider breaking into multiple points.</li><li><strong>Improved Version:</strong> <ul><li>实施了多表多关联的历史数据迁移，优化了迁移算法并进行了风险评估和数据备份。</li><li>确保数据迁移的准确性和系统稳定性，通过实时双写和并发压力测试等手段提高了迁移效率和安全性。</li></ul></li></ul></li></ol><p><strong>一对一增长业务</strong></p><ol><li><p>项目负责人，负责一对一业务线增长业务的业务模型设计、接口交互设计以及日常需求的迭代。  </p><ul><li><strong>Problem Identified:</strong> Lacks quantification and more detailed accomplishments.</li><li><strong>Improved Version:</strong> 作为项目负责人，设计并迭代一对一业务线的增长业务模型和接口交互设计，带领团队实现增长率提高20%。</li></ul></li><li><p>承接一对一和绘本等多个业务线的节日节点和大型活动：新年，618，教师节，双11等大型活动，高效稳定地完成了预期的促活、转介绍、促课消等目标。  </p><ul><li><strong>Problem Identified:</strong> Needs specific examples of achievements and methodology.</li><li><strong>Improved Version:</strong> 组织并执行了一对一和绘本业务线的新年、618、教师节、双11等节日活动，实现了促活、转介绍和促课消目标，提高用户参与率30%。</li></ul></li></ol><p><strong>研发消息触达配置平台</strong></p><ol><li><p>规范不同触达方式，提升研发效率，支持运营侧个性化触达方案。  </p><ul><li><strong>Problem Identified:</strong> Lacks specific achievements and quantification.</li><li><strong>Improved Version:</strong> 开发了消息触达配置平台，规范不同触达方式，提高研发效率50%，支持个性化触达方案，实现用户触达率提升25%。</li></ul></li><li><p>通过 Kafka 进行系统间通信，同时支持了多业务、万级别 TPS 的用户触达。  </p><ul><li><strong>Problem Identified:</strong> Lacks specific methodology and impact.</li><li><strong>Improved Version:</strong> 利用 Kafka 进行系统间通信，支持多业务和万级别 TPS 的用户触达，提高系统通信效率和稳定性。</li></ul></li></ol><p><strong>搭建海报平台</strong></p><ol><li><p>针对用户拉新中重要的海报分享行为搭建，为运营同学高效快速更新海报内容及落地页活动提供支持。  </p><ul><li><strong>Problem Identified:</strong> Needs more quantification and specific achievements.</li><li><strong>Improved Version:</strong> 搭建了海报平台，优化用户拉新分享流程，支持快速更新海报内容和活动页面，提高新用户转化率20%。</li></ul></li><li><p>对新老用户扫码行为进行数据监控与识别，提升 leads 激活效率；与营销活动结合，利用识别结果协助优化拉新路径。  </p><ul><li><strong>Problem Identified:</strong> Needs specific impact and achievements.</li><li><strong>Improved Version:</strong> 实施了新老用户扫码行为的数据监控与识别，提高 leads 激活效率30%，优化用户拉新路径。</li></ul></li></ol><p><strong>搭建活动营销平台</strong></p><ol><li><p>抽象总结承接的各种营销活动，将其拆分为：任务，抽奖，奖品发放，数据统计，分享，签到，问卷，团购，基础配置等多个组件。  </p><ul><li><strong>Problem Identified:</strong> Very detailed, consider breaking into multiple points.</li><li><strong>Improved Version:</strong> <ul><li>构建了活动营销平台，将活动拆分为多个组件，提高活动配置灵活性和开发效率。</li><li>实现活动上线速度提升50%，支持多项百万级并发活动，提高系统稳定性和性能。</li></ul></li></ul></li><li><p>组件间使用消息队列进行通信，打通了业务节点、用户标签、用户动作、前端配置化体系、数据中心等多个系统、多个业务线的路径。  </p><ul><li><strong>Problem Identified:</strong> Lacks specific achievements and quantification.</li><li><strong>Improved Version:</strong> 使用消息队列进行组件间通信，打通多个系统和业务线路径，提高数据处理效率和系统整合能力。</li></ul></li></ol><p><strong>搭建广告投放平台</strong></p><ol><li><p>抽象和整理了公司各 app 30+ 投放位置的多种展示模式；支持用户标签、访问渠道、业务线、版本等多种筛选模式；支持静默期、投放区间、投放频率等等多种细分功能；结合前端，支持投放数据上报与检测。  </p><ul><li><strong>Problem Identified:</strong> Very detailed, consider breaking into multiple points, lacks specific impact.</li><li><strong>Improved Version:</strong> 搭建了广告投放平台，支持多种展示和筛选模式，提高广告投放灵活性和效率，实现广告点击率提高20%。</li></ul></li><li><p>采用内存 - Redis - TiDB 三级缓存结构支持高并发访问。  </p><ul><li><strong>Problem Identified:</strong> Needs more specific impact and achievements.</li><li><strong>Improved Version:</strong> 采用三级缓存结构，支持高并发访问，提高系统响应速度和稳定性。</li></ul></li><li><p>平台上线3个月内对接至全部 app 展示位置，运行稳定，最高支持百万级别的用户访问，在提升业务侧配置效率的同时，协助搭建运营模型和升级运营策略。  </p><ul><li><strong>Problem Identified:</strong> Needs specific impact and more detailed accomplishments.</li><li><strong>Improved Version:</strong> 平台上线3个月内完成对接，运行稳定，支持百万级用户访问，提高配置效率和运营策略。</li></ul></li></ol><p><strong>负责第三方广告商的对接和维护</strong></p><ol><li><p>对接小红书、华为、头条、OPPO、百度等多个广告商。  </p><ul><li><strong>Problem Identified:</strong> Needs more specific impact and achievements.</li><li><strong>Improved Version:</strong> 对接小红书、华为、头条、OPPO、百度等广告商，提高广告投放效果，实现广告转化率提升20%。</li></ul></li><li><p>针对注册、登录、业务意向、付款等关键节点进行监控和数据上报，生成数据漏斗协助运营优化投放方案。  </p><ul><li><strong>Problem Identified:</strong> Needs more specific methodology and impact.</li><li><strong>Improved Version:</strong> 监控关键节点并生成数据漏斗，协助运营优化广告投放方案，提高投放效果和转化率。</li></ul></li></ol><p><strong>领导五人团队开发增长业务相关项目</strong></p><ol><li>把控研发进度，合理分配人员工作，确保项目顺利进行。  <ul><li><strong>Problem Identified:</strong> Lacks specific achievements and quantification.</li><li><strong>Improved Version:</strong> 领导五人团队开发增长业务项目，合理分配工作，确保项目按时完成，带领团队实现增长目标。</li></ul></li></ol><p><strong>搭建分销系统</strong></p><ol><li>管理和维护第三方分销员，管理和维护分销商品，管理和维护分销员与用户的映射关系，并提供海报、链接、分享话术等相关分销工具。  <ul><li><strong>Problem Identified:</strong> Needs more specific achievements and quantification.</li><li><strong>Improved Version:</strong> 搭建分销系统，管理分销员和商品，提供分销工具，提高分销效率和转化率，实现分销目标。</li></ul></li></ol><p><strong>负责搭建背诗小程序后台</strong></p><ol><li><p>支持后台古诗文导入；支持用户分句分段多种背诵模式。  </p><ul><li><strong>Problem Identified:</strong> Lacks specific achievements and quantification.</li><li><strong>Improved Version:</strong> 开发背诗小程序后台，支持古诗文导入和多种背诵模式，提高用户学习效率和参与度。</li></ul></li><li><p>提供好友排位、拉新分享等营销功能。  </p><ul><li><strong>Problem Identified:</strong> Lacks specific achievements and quantification.</li><li><strong>Improved Version:</strong> 提供好友排位和拉新分享功能，提高用户互动和参与度，实现拉新目标。</li></ul></li></ol><p><strong>一对一 CRM 业务</strong></p><ol><li><p>负责 leads 激活的流量管理与提纯，销售路径数据收集与反馈。  </p><ul><li><strong>Problem Identified:</strong> Lacks specific achievements and quantification.</li><li><strong>Improved Version:</strong> 负责 leads 激活的流量管理与提纯，优化销售路径数据收集和反馈，提高销售转化率20%。</li></ul></li><li><p>优化销售数据分配规则；在用户拉新、激活、维护、售卖等节点为销售人员提供数据和工具支持。  </p><ul><li><strong>Problem Identified:</strong> Lacks specific achievements and quantification.</li><li><strong>Improved Version:</strong> 优化销售数据分配规则，为销售人员提供数据和工具支持，提高销售效率和转化率</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 实录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ETCD 面试必备</title>
      <link href="/interview/etcd-interview/"/>
      <url>/interview/etcd-interview/</url>
      
        <content type="html"><![CDATA[<h1 id="etcd分布式锁的实现流程"><a href="#etcd分布式锁的实现流程" class="headerlink" title="etcd分布式锁的实现流程"></a>etcd分布式锁的实现流程</h1><ol><li><p>建立连接<br>客户端连接 etcd，以 &#x2F;etcd&#x2F;lock 为前缀创建全局唯一的 key， 假设第一个客户端对应的 key&#x3D;“&#x2F;etcd&#x2F;lock&#x2F;UUID1”，第二个为 key&#x3D;“&#x2F;etcd&#x2F;lock&#x2F;UUID2”； 客户端分别为自己的 key 创建租约 - Lease，租约的长度根据业务耗时确定；</p></li><li><p>创建定时任务作为租约的“心跳”<br>当一个客户端持有锁期间，其它客户端只能等待，为了避免等待期间租约失效， 客户端需创建一个定时任务作为“心跳”进行续约。此外，如果持有锁期间客户端崩溃， 心跳停止，key 将因租约到期而被删除，从而锁释放，避免死锁；</p></li><li><p>客户端将自己全局唯一的 key 写入 etcd<br>执行 put 操作，将步骤 1 中创建的 key 绑定租约写入 Etcd，根据 Etcd 的 Revision 机制， 假设两个客户端 put 操作返回的 Revision 分别为 1、2，客户端需记录 Revision 用以 接下来判断自己是否获得锁；</p></li><li><p>客户端判断是否获得锁<br>客户端以前缀 &#x2F;etcd&#x2F;lock&#x2F; 读取 key-Value 列表，判断自己 key 的 Revision 是否为当前列表中 最小的，如果是则认为获得锁；否则监听列表中前一个 Revision 比自己小的 key 的删除事件，一旦监听到删除事件或者因租约失效而删除的事件，则自己获得锁；</p></li><li><p>执行业务<br>获得锁后，操作共享资源，执行业务代码</p></li><li><p>释放锁<br>完成业务流程后，删除对应的key释放锁</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 面试 </tag>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 面试必备</title>
      <link href="/interview/kafka-interview/"/>
      <url>/interview/kafka-interview/</url>
      
        <content type="html"><![CDATA[<h2 id="消费者消费流程"><a href="#消费者消费流程" class="headerlink" title="消费者消费流程"></a>消费者消费流程</h2><p>消费流程：</p><ol><li>从zk获取要消费的partition 的leader的位置 以及 offset位置</li><li>拉数据，这里拉数据是直接从broker的pagecash拉取，零拷贝（应用程序可以直接把磁盘中的数据从内核中，直接传输到socket，不用互相拷贝） ，所以很快。</li><li>如果pagecash数据不全，就会从磁盘中拉取，并发送</li><li>消费完成后，可以手动提交offset，也可以自动提交offset。</li></ol><h2 id="如何避免重复消费？"><a href="#如何避免重复消费？" class="headerlink" title="如何避免重复消费？"></a>如何避免重复消费？</h2><h3 id="分析原因："><a href="#分析原因：" class="headerlink" title="分析原因："></a>分析原因：</h3><p>1.生产者重复提交 2.rebalence引起重复消费</p><p>超过一定时间（max.poll.interval.ms设置的值，默认5分钟）未进行poll拉取消息，则会导致客户端主动离开队列，而引发Rebalance，提交offset失败。其他消费者会从没有提交的位置消费，从而导致重复消费。</p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>1.提高消费速度</p><ul><li>增加消费者</li><li>多线程消费</li><li>异步消费</li><li>调整消费处理时间</li></ul><p>2.幂等处理</p><ul><li>消费者设置幂等校验</li><li>开启kafka幂等配置，生产者开启幂等配置，将消息生成md5，然后保存到redis中，处理新消息的时候先校验。这个尽量不要开启，消耗性能。</li></ul><h5 id="Kafka-线上消息积压怎么解决"><a href="#Kafka-线上消息积压怎么解决" class="headerlink" title="Kafka 线上消息积压怎么解决"></a>Kafka 线上消息积压怎么解决</h5><ol><li>消费端拿到的消息并发消耗掉</li><li>转发到一个新的队列</li></ol><h5 id="kafka-消息重复消费？怎么解决？"><a href="#kafka-消息重复消费？怎么解决？" class="headerlink" title="kafka 消息重复消费？怎么解决？"></a>kafka 消息重复消费？怎么解决？</h5><ol><li>如果发送端使用了重试机制，由于网络原因没有收到发送成功的 ACK</li><li>消费者手动提交 offset，拉取一批数据，没有执行完但是服务宕机，这部分会再次拉出来执行<br>解决方法：幂等处理，自动提交</li></ol><h5 id="Kafka-消息丢失？怎么解决？"><a href="#Kafka-消息丢失？怎么解决？" class="headerlink" title="Kafka 消息丢失？怎么解决？"></a>Kafka 消息丢失？怎么解决？</h5><p>学习 kafka 呢需要明确几个概念<br>生产者发送消息到 broker 中某一个 topic 的具体分区里，消费者从一个或多个分区中拉取数据进行消费</p><p>这里整理了 Kafka 的一些关键术语：</p><ul><li>Producer：生产者，消息产生和发送端。</li><li>Broker：Kafka 实例，多个 broker 组成一个 Kafka 集群，通常一台机器部署一个 Kafka 实例，一个实例挂了不影响其他实例。</li><li>Consumer：消费者，拉取消息进行消费。 一个 topic 可以让若干个消费者进行消费，若干个消费者组成一个 Consumer Group 即消费组，一条消息只能被消费组中一个 Consumer 消费。</li><li>Topic：主题，服务端消息的逻辑存储单元。一个 topic 通常包含若干个 Partition 分区。</li><li>Partition：topic 的分区，分布式存储在各个 broker 中， 实现发布与订阅的负载均衡。若干个分区可以被若干个 Consumer 同时消费，达到消费者高吞吐量。一个分区拥有多个副本（Replica），这是Kafka在可靠性和可用性方面的设计，后面会重点介绍。</li><li>message：消息，或称日志消息，是 Kafka 服务端实际存储的数据，每一条消息都由一个 key、一个 value 以及消息时间戳 timestamp 组成。</li><li>offset：偏移量，分区中的消息位置，由 Kafka 自身维护，Consumer 消费时也要保存一份 offset 以维护消费过的消息位置。</li></ul><p>消费队列呢一般用来实现 同步到异步的转换，削峰，解耦 等目标</p><h5 id="kafka-设计特性"><a href="#kafka-设计特性" class="headerlink" title="kafka 设计特性"></a>kafka 设计特性</h5><ul><li>高吞吐、低延迟：kakfa 最大的特点就是收发消息非常快，kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒。</li><li>高伸缩性： 每个主题(topic) 包含多个分区(partition)，主题中的分区可以分布在不同的主机(broker)中。</li><li>持久性、可靠性： Kafka 能够允许数据的持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，Kafka 底层的数据存储是基于 Zookeeper 存储的，Zookeeper 我们知道它的数据能够持久存储。</li><li>容错性： 允许集群中的节点失败，某个节点宕机，Kafka 集群能够正常工作</li><li>高并发： 支持数千个客户端同时读写</li></ul><h2 id="Kafka-方案及其痛点"><a href="#Kafka-方案及其痛点" class="headerlink" title="Kafka 方案及其痛点"></a>Kafka 方案及其痛点</h2><p>之前，我们采用 Apache Kafka 作为消息平台， 为了让业务在高峰期（晚上八点到十点）不受影响，我们根据消息业务量的大小， 分别搭建了不同的集群。对于一些业务场景的需求， 比如需要重置 offset 来消费过去几天的消息，使用 Kafka 需要停掉消费者才可以进行， 这种方式对大量在线业务非常不利，只能采用重写消息或者一些不太灵活的方式来实现， 极大降低了使用体验。</p><p>我们在使用 Kafka 集群过程中，主要遇到以下问题：  </p><ol><li>Kafka 没有租户概念，需要手动维护多个集群，不方便运维。</li><li>Kafka 集群扩容后需要做 Reassign Partitions，IO 消耗大。</li><li>Kafka 监控体系不完善，排查问题较为繁琐。</li><li>在线业务消息重置不方便，实现起来较为麻烦，需要停掉消费组。</li><li>Kafka 不支持死信队列和延迟队列。</li><li>Kafka 没有官方维护和支持的 Go 语言客户端。</li><li>在 Kafka 中支持 schema，需要引入额外组件，不方便维护。</li></ol><h2 id="为什么选择-Pulsar"><a href="#为什么选择-Pulsar" class="headerlink" title="为什么选择 Pulsar"></a>为什么选择 Pulsar</h2><ul><li>Pulsar 采用云原生的架构，存储和计算分离。</li><li>Pulsar 支持多租户，我们可以按照不同的业务线、业务小组和对应的服务级别来管理消息保存时间、持久化、堆积清除策略等，统一维护一套 Pulsar 集群。</li><li>Pulsar 支持灵活的水平扩容。当存储不够时，直接增加 bookie 进行扩容，不会对用户产生任何影响。</li><li>Pulsar 自带监控体系，broker，bookie 相关指标清晰，方便快速定位问题，给出解决方案。</li><li>Pulsar cursor 方便重置消息，给业务带来很好的体验。</li><li>Pulsar 支持死信队列和延迟队列。</li><li>Pulsar schema 集成在 broker 中，不需要引入单独的组件。Golang client 支持 schema，减少了维护成本。</li></ul><p>1 什么是kafka</p><blockquote><p>Kafka是分布式发布-订阅消息系统，它最初是由LinkedIn公司开发的，之后成为Apache项目的一部分，Kafka是一个分布式，可划分的，冗余备份的持久性的<a href="https://cloud.tencent.com/product/cls?from_column=20065&from=20065">日志服务</a>，它主要用于处理流式数据。</p></blockquote><p>2 为什么要使用 kafka，为什么要使用<a href="https://cloud.tencent.com/product/cmq?from_column=20065&from=20065">消息队列</a></p><blockquote><p>缓冲和削峰：上游数据时有突发流量，下游可能扛不住，或者下游没有足够多的机器来保证冗余，kafka在中间可以起到一个缓冲的作用，把消息暂存在kafka中，下游服务就可以按照自己的节奏进行慢慢处理。 解耦和扩展性：项目开始的时候，并不能确定具体需求。消息队列可以作为一个接口层，解耦重要的业务流程。只需要遵守约定，针对数据编程即可获取扩展能力。 冗余：可以采用一对多的方式，一个生产者发布消息，可以被多个订阅topic的服务消费到，供多个毫无关联的业务使用。 健壮性：消息队列可以堆积请求，所以消费端业务即使短时间死掉，也不会影响主要业务的正常进行。 异步通信：很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p></blockquote><p>3.Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么</p><blockquote><p>ISR:In-Sync Replicas 副本同步队列 AR:Assigned Replicas 所有副本<br>ISR是由leader维护，follower从leader同步数据有一些延迟（包括延迟时间replica.lag.time.max.ms和延迟条数replica.lag.max.messages两个维度, 当前最新的版本0.10.x中只支持replica.lag.time.max.ms这个维度），任意一个超过阈值都会把follower剔除出ISR, 存入OSR（Outof-Sync Replicas）列表，新加入的follower也会先存放在OSR中。AR&#x3D;ISR+OSR。</p></blockquote><p>4.kafka中的broker 是干什么的</p><blockquote><p>broker 是消息的代理，Producers往Brokers里面的指定Topic中写消息，Consumers从Brokers里面拉取指定Topic的消息，然后进行业务处理，broker在中间起到一个代理保存消息的中转站。</p></blockquote><p>5.kafka中的 zookeeper 起到什么作用，可以不用zookeeper么</p><blockquote><p>zookeeper 是一个分布式的协调组件，早期版本的kafka用zk做meta信息存储，consumer的消费状态，group的管理以及 offset的值。考虑到zk本身的一些因素以及整个架构较大概率存在单点问题，新版本中逐渐弱化了zookeeper的作用。新的consumer使用了kafka内部的group coordination协议，也减少了对zookeeper的依赖， 但是broker依然依赖于ZK，zookeeper 在kafka中还用来选举controller 和 检测broker是否存活等等。</p></blockquote><p>6.kafka follower如何与leader同步数据</p><blockquote><p>Kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。完全同步复制要求All Alive Follower都复制完，这条消息才会被认为commit，这种复制方式极大的影响了吞吐率。而异步复制方式下，Follower异步的从Leader复制数据，数据只要被Leader写入log就被认为已经commit，这种情况下，如果leader挂掉，会丢失数据，kafka使用ISR的方式很好的均衡了确保数据不丢失以及吞吐率。Follower可以批量的从Leader复制数据，而且Leader充分利用磁盘顺序读以及send file(zero copy)机制，这样极大的提高复制性能，内部批量写磁盘，大幅减少了Follower与Leader的消息量差。</p></blockquote><p>7.什么情况下一个 broker 会从 isr中踢出去</p><blockquote><p>leader会维护一个与其基本保持同步的Replica列表，该列表称为ISR(in-sync Replica)，每个Partition都会有一个ISR，而且是由leader动态维护 ，如果一个follower比一个leader落后太多，或者超过一定时间未发起数据复制请求，则leader将其重ISR中移除 。</p></blockquote><p>8.kafka 为什么那么快</p><ul><li>Cache Filesystem Cache PageCache缓存</li><li>顺序写 由于现代的操作系统提供了预读和写技术，磁盘的顺序写大多数情况下比随机写内存还要快。</li><li>Zero-copy 零拷技术减少拷贝次数</li><li>Batching of Messages 批量量处理。合并小的请求，然后以流的方式进行交互，直顶网络上限。</li><li>Pull 拉模式 使用拉模式进行消息的获取消费，与消费端处理能力相符。</li></ul><p>9.kafka producer如何优化打入速度</p><ul><li>增加线程</li><li>提高 batch.size</li><li>增加更多 producer 实例</li><li>增加 partition 数</li><li>设置 acks&#x3D;-1 时，如果延迟增大：可以增大 num.replica.fetchers（follower 同步数据的线程数）来调解；</li><li>跨数据中心的传输：增加 socket 缓冲区设置以及 OS tcp 缓冲区设置。</li></ul><p>10.kafka producer 打数据，ack 为 0， 1， -1 的时候代表啥， 设置 -1 的时候，什么情况下，leader 会认为一条消息 commit了</p><ol><li>1（默认） 数据发送到Kafka后，经过leader成功接收消息的的确认，就算是发送成功了。在这种情况下，如果leader宕机了，则会丢失数据。</li><li>0 生产者将数据发送出去就不管了，不去等待任何返回。这种情况下数据传输效率最高，但是数据可靠性确是最低的。</li><li>-1 producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高。当ISR中所有Replica都向Leader发送ACK时，leader才commit，这时候producer才能认为一个请求中的消息都commit了。</li></ol><p>11.kafka unclean 配置代表啥，会对 spark streaming 消费有什么影响</p><blockquote><p>unclean.leader.election.enable 为true的话，意味着非ISR集合的broker 也可以参与选举，这样有可能就会丢数据，spark streaming在消费过程中拿到的 end offset 会突然变小，导致 spark streaming job挂掉。如果unclean.leader.election.enable参数设置为true，就有可能发生数据丢失和数据不一致的情况，Kafka的可靠性就会降低；而如果unclean.leader.election.enable参数设置为false，Kafka的可用性就会降低。</p></blockquote><p>12.如果leader crash时，ISR为空怎么办</p><blockquote><p>kafka在Broker端提供了一个配置参数：unclean.leader.election,这个参数有两个值： true（默认）：允许不同步副本成为leader，由于不同步副本的消息较为滞后，此时成为leader，可能会出现消息不一致的情况。 false：不允许不同步副本成为leader，此时如果发生ISR列表为空，会一直等待旧leader恢复，降低了可用性。</p></blockquote><p>13.kafka的message格式是什么样的</p><blockquote><p>一个Kafka的Message由一个固定长度的header和一个变长的消息体body组成 header部分由一个字节的magic(文件格式)和四个字节的CRC32(用于判断body消息体是否正常)构成。 当magic的值为1的时候，会在magic和crc32之间多一个字节的数据：attributes(保存一些相关属性， 比如是否压缩、压缩格式等等);如果magic的值为0，那么不存在attributes属性 body是由N个字节构成的一个消息体，包含了具体的key&#x2F;value消息</p></blockquote><p>14.kafka中consumer group 是什么概念</p><blockquote><p>同样是逻辑上的概念，是Kafka实现单播和广播两种消息模型的手段。同一个topic的数据，会广播给不同的group；同一个group中的worker，只有一个worker能拿到这个数据。换句话说，对于同一个topic，每个group都可以拿到同样的所有数据，但是数据进入group后只能被其中的一个worker消费。group内的worker可以使用多线程或多进程来实现，也可以将进程分散在多台机器上，worker的数量通常不超过partition的数量，且二者最好保持整数倍关系，因为Kafka在设计时假定了一个partition只能被一个worker消费（同一group内）。</p></blockquote><p>15.Kafka中的消息是否会丢失和重复消费？</p><blockquote><p>要确定Kafka的消息是否丢失或重复，从两个方面分析入手：消息发送和消息消费。 1、消息发送 Kafka消息发送有两种方式：同步（sync）和异步（async），默认是同步方式，可通过producer.type属性进行配置。Kafka通过配置request.required.acks属性来确认消息的生产：</p></blockquote><ol><li><em>0—表示不进行消息接收是否成功的确认；</em></li><li><em>1—表示当Leader接收成功时确认；</em></li><li><em>-1—表示Leader和Follower都接收成功时确认；</em></li></ol><p>综上所述，有6种消息生产的情况，下面分情况来分析消息丢失的场景： （1）acks&#x3D;0，不和Kafka集群进行消息接收确认，则当网络异常、缓冲区满了等情况时，消息可能丢失； （2）acks&#x3D;1、同步模式下，只有Leader确认接收成功后但挂掉了，副本没有同步，数据可能丢失； 2、消息消费 Kafka消息消费有两个consumer接口，Low-level API和High-level API：</p><ol><li>Low-level API：消费者自己维护offset等值，可以实现对Kafka的完全控制；</li><li>High-level API：封装了对parition和offset的管理，使用简单；</li></ol><p>如果使用高级接口High-level API，可能存在一个问题就是当消息消费者从集群中把消息取出来、并提交了新的消息offset值后，还没来得及消费就挂掉了，那么下次再消费时之前没消费成功的消息就“_诡异_”的消失了； 解决办法： 针对消息丢失：同步模式下，确认机制设置为-1，即让消息写入Leader和Follower之后再确认消息发送成功；异步模式下，为防止缓冲区满，可以在配置文件设置不限制阻塞超时时间，当缓冲区满时让生产者一直处于阻塞状态； 针对消息重复：将消息的唯一标识保存到外部介质中，每次消费时判断是否处理过即可。 消息重复消费及解决参考：<a href="https://www.javazhiyin.com/22910.html">https://www.javazhiyin.com/22910.html</a></p><p>16.为什么Kafka不支持读写分离？</p><blockquote><p>在 Kafka 中，生产者写入消息、消费者读取消息的操作都是与 leader 副本进行交互的，从 而实现的是一种主写主读的生产消费模型。 Kafka 并不支持主写从读，因为主写从读有 2 个很明 显的缺点:</p></blockquote><ul><li>(1)数据一致性问题。数据从主节点转到从节点必然会有一个延时的时间窗口，这个时间 窗口会导致主从节点之间的数据不一致。某一时刻，在主节点和从节点中 A 数据的值都为 X， 之后将主节点中 A 的值修改为 Y，那么在这个变更通知到从节点之前，应用读取从节点中的 A 数据的值并不为最新的 Y，由此便产生了数据不一致的问题。</li><li>(2)延时问题。类似 <a href="https://cloud.tencent.com/product/crs?from_column=20065&from=20065">Redis</a> 这种组件，数据从写入主节点到同步至从节点中的过程需要经 历网络→主节点内存→网络→从节点内存这几个阶段，整个过程会耗费一定的时间。而在 Kafka 中，主从同步会比 Redis 更加耗时，它需要经历网络→主节点内存→主节点磁盘→网络→从节 点内存→从节点磁盘这几个阶段。对延时敏感的应用而言，主写从读的功能并不太适用。</li></ul><p>17.Kafka中是怎么体现消息顺序性的？</p><blockquote><p>kafka每个partition中的消息在写入时都是有序的，消费时，每个partition只能被每一个group中的一个消费者消费，保证了消费时也是有序的。 整个topic不保证有序。如果为了保证topic整个有序，那么将partition调整为1.</p></blockquote><p>18.消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1?</p><blockquote><p>offset+1</p></blockquote><p>19.kafka如何实现延迟队列？</p><blockquote><p>Kafka并没有使用JDK自带的Timer或者DelayQueue来实现延迟的功能，而是基于时间轮自定义了一个用于实现延迟功能的定时器（SystemTimer）。JDK的Timer和DelayQueue插入和删除操作的平均时间复杂度为O(nlog(n))，并不能满足Kafka的高性能要求，而基于时间轮可以将插入和删除操作的时间复杂度都降为O(1)。时间轮的应用并非Kafka独有，其应用场景还有很多，在Netty、Akka、Quartz、Zookeeper等组件中都存在时间轮的踪影。 底层使用数组实现，数组中的每个元素可以存放一个TimerTaskList对象。TimerTaskList是一个环形双向链表，在其中的链表项TimerTaskEntry中封装了真正的定时任务TimerTask. Kafka中到底是怎么推进时间的呢？Kafka中的定时器借助了JDK中的DelayQueue来协助推进时间轮。具体做法是对于每个使用到的TimerTaskList都会加入到DelayQueue中。Kafka中的TimingWheel专门用来执行插入和删除TimerTaskEntry的操作，而DelayQueue专门负责时间推进的任务。再试想一下，DelayQueue中的第一个超时任务列表的expiration为200ms，第二个超时任务为840ms，这里获取DelayQueue的队头只需要O(1)的时间复杂度。如果采用每秒定时推进，那么获取到第一个超时的任务列表时执行的200次推进中有199次属于“空推进”，而获取到第二个超时任务时有需要执行639次“空推进”，这样会无故空耗机器的性能资源，这里采用DelayQueue来辅助以少量空间换时间，从而做到了“精准推进”。Kafka中的定时器真可谓是“知人善用”，用TimingWheel做最擅长的任务添加和删除操作，而用DelayQueue做最擅长的时间推进工作，相辅相成。</p></blockquote><h2 id="Kafka集群leader选举"><a href="#Kafka集群leader选举" class="headerlink" title="Kafka集群leader选举"></a>Kafka集群leader选举</h2><ol><li>在kafka集群中，第一个启动的broker会在zk中创建一个临时节点&#x2F;controller让自己成为控制器。其他broker启动时也会试着创建这个节点当然他们会失败，因为已经有人创建过了。那么这些节点会在控制器节点上创建zk watch对象，这样他们就可以收到这个节点变更的通知。任何时刻都确保集群中只有一个leader的存在。</li><li>如果控制器被关闭或者与zk断开连接，zk上的KB是节点马上就会消失。那么其他订阅了leader节点的broker也会收到通知随后他们会尝试让自己成为新的leader，重复第一步的操作。</li><li>如果leader完好但是别的broker离开了集群，那么leader会去确定离开的broker的分区并确认新的分区领导者(即分区副本列表里的下一个副本)。然后向所有包含该副本的follower或者observer发送请求。随后新的分区首领开始处理请求。</li></ol><h2 id="Kafka创建副本的2种模式——同步复制和异步复制"><a href="#Kafka创建副本的2种模式——同步复制和异步复制" class="headerlink" title="Kafka创建副本的2种模式——同步复制和异步复制"></a>Kafka创建副本的2种模式——同步复制和异步复制</h2><blockquote><p>Kafka动态维护了一个同步状态的副本的集合（a set of In-Sync Replicas），简称ISR，在这个集合中的节点都是和leader保持高度一致的，任何一条消息只有被这个集合中的每个节点读取并追加到日志中，才会向外部通知说“这个消息已经被提交”。</p><p>只有当消息被所有的副本加入到日志中时，才算是“committed”，只有committed的消息才会发送给consumer，这样就不用担心一旦leader down掉了消息会丢失。消息从leader复制到follower,我们可以通过决定Producer是否等待消息被提交的通知(ack)来区分同步复制和异步复制。</p></blockquote><h3 id="同步复制流程"><a href="#同步复制流程" class="headerlink" title="同步复制流程"></a>同步复制流程</h3><blockquote><p>同步复制流程：</p></blockquote><ul><li>producer联系zk识别leader；</li><li>向leader发送消息；</li><li>leadr收到消息写入到本地log；</li><li>follower从leader pull消息；</li><li>follower向本地写入log；</li><li>follower向leader发送ack消息；</li><li>leader收到所有follower的ack消息；</li><li>leader向producer回传ack。</li></ul><h3 id="异步复制流程"><a href="#异步复制流程" class="headerlink" title="异步复制流程"></a>异步复制流程</h3><blockquote><p>异步复制流程： 和同步复制的区别在于，leader写入本地log之后，直接向client回传ack消息，不需要等待所有follower复制完成。 既然kafka支持副本模式，那么其中一个Broker里的挂掉，一个新的leader就能通过ISR机制推选出来，继续处理读写请求。</p></blockquote><h2 id="Kafka判断一个broker节点是否存活"><a href="#Kafka判断一个broker节点是否存活" class="headerlink" title="Kafka判断一个broker节点是否存活"></a>Kafka判断一个broker节点是否存活</h2><blockquote><p>依据两个条件：</p></blockquote><ul><li>节点必须可以维护和ZooKeeper的连接，Zookeeper通过心跳机制检查每个节点的连接;</li><li>如果节点是个follower,他必须能及时的同步leader的写操作，延时不能太久。Leader会追踪所有“同步中”的节点，一旦一个down掉了，或是卡住了，或是延时太久，leader就会把它移除。</li></ul><h3 id="5-消息"><a href="#5-消息" class="headerlink" title="5. 消息"></a>5. 消息</h3><h5 id="5-1-请简述一下消息的顺序"><a href="#5-1-请简述一下消息的顺序" class="headerlink" title="5.1. 请简述一下消息的顺序"></a>5.1. 请简述一下消息的顺序</h5><ul><li>Kafka保证一个Partition内消息的有序性，但是并不保证多个Partition之间的数据有顺序。 每个Topic可以划分成多个分区( 每个Topic都至少有一个分区)，同一Topic下的不同分区包含的消息是不同的。每个消息在被添加到分区时，都会被分配一个offset，它是消息在此分区中的唯一编号，Kafka 通过offset保证消息在分区内的顺序， offset 的顺序性不跨分区，即Kafka只保证在同一个分区内的消息是有序的，同一Topic的多个分区内的消息，Kafka并不保证其顺序性</li><li>kafka消息有序。单分区可以。也可以使用key+多分区。保证同一个 Key 的所有消息都进入到相同的分区里面</li><li>防止乱序可以通过设置max.in.flight.requests.per.connection&#x3D;1来保证</li></ul><h5 id="5-2-如何保证消息的有序"><a href="#5-2-如何保证消息的有序" class="headerlink" title="5.2. 如何保证消息的有序"></a>5.2. 如何保证消息的有序</h5><ul><li>一个生产者，发两次消息，但是网络原因，消息到达的顺序和消息发送的顺序不一致<ul><li>设置max.in.flight.requests.per.connection&#x3D;1来保证</li></ul></li></ul><h5 id="5-3-消息堆积可能原因"><a href="#5-3-消息堆积可能原因" class="headerlink" title="5.3. 消息堆积可能原因"></a>5.3. 消息堆积可能原因</h5><ol><li>生产速度大于消费速度<ol><li>可以适当增加分区，增加consumer数量，提升消费TPS；</li></ol></li><li>consumer消费性能低<ol><li>查一下是否有很重的消费逻辑，看看是否可以优化consumer TPS；</li></ol></li><li>确保consumer端没有因为异常而导致消费hang住;</li><li>如果你使用的是消费者组，确保没有频繁地发生rebalance</li></ol><h5 id="5-4-有哪些情况下会出现生产消息重复"><a href="#5-4-有哪些情况下会出现生产消息重复" class="headerlink" title="5.4. 有哪些情况下会出现生产消息重复"></a>5.4. 有哪些情况下会出现生产消息重复</h5><ul><li>一个consumer正在消费一个分区的一条消息，还没有消费完，发生了rebalance(加入了一个consumer)，从而导致这条消息没有消费成功，rebalance后，另一个consumer又把这条消息消费一遍</li><li>生产者重复发送。比如说你的业务在发送消息的时候，收到了一个超时响应，这个时候你很难确定这个消息是否真的发送出去了，那么你就会考虑重试，重试就可能导致同一个消息发送了多次。</li></ul><h5 id="5-5-那些情景下会造成消息漏消费"><a href="#5-5-那些情景下会造成消息漏消费" class="headerlink" title="5.5. 那些情景下会造成消息漏消费"></a>5.5. 那些情景下会造成消息漏消费</h5><ol><li>自动提交 设置offset为自动定时提交，当offset被自动定时提交时，数据还在内存中未处理，此时刚好把线程kill掉，那么offset已经提交，但是数据未处理，导致这部分内存中的数据丢失。</li><li>生产者发送消息 发送消息设置的是fire-and-forget（发后即忘），它只管往 Kafka 中发送消息而并不关心消息是否正确到达。不过在某些时候（比如发生不可重试异常时）会造成消息的丢失。这种发送方式的性能最高，可靠性也最差。</li><li>消费者端 先提交位移，但是消息还没消费完就宕机了，造成了消息没有被消费。自动位移提交同理</li><li>acks没有设置为all 如果在broker还没把消息同步到其他broker的时候宕机了，那么消息将会丢失</li></ol><h5 id="5-6-有哪些情形会造成重复消费？"><a href="#5-6-有哪些情形会造成重复消费？" class="headerlink" title="5.6. 有哪些情形会造成重复消费？"></a>5.6. 有哪些情形会造成重复消费？</h5><ol><li>Rebalance 一个consumer正在消费一个分区的一条消息，还没有消费完，发生了rebalance(加入了一个consumer)，从而导致这条消息没有消费成功，rebalance后，另一个consumer又把这条消息消费一遍。</li><li>消费者端手动提交 如果先消费消息，再更新offset位置，导致消息重复消费。</li><li>消费者端自动提交 设置offset为自动提交，关闭kafka时，如果在close之前，调用 consumer.unsubscribe() 则有可能部分offset没提交，下次重启会重复消费。</li><li>生产者端 生产者因为业务问题导致的宕机，在重启之后可能数据会重发</li></ol><h5 id="5-7-Kafka中是怎么体现消息顺序性的？"><a href="#5-7-Kafka中是怎么体现消息顺序性的？" class="headerlink" title="5.7. Kafka中是怎么体现消息顺序性的？"></a>5.7. Kafka中是怎么体现消息顺序性的？</h5><ul><li>可以通过分区策略体现消息顺序性。 分区策略有轮询策略、随机策略、按消息键保序策略。</li></ul><p>按消息键保序策略：一旦消息被定义了 Key，那么你就可以保证同一个 Key 的所有消息都进入到相同的分区里面，由于每个分区下的消息处理都是有顺序的，故这个策略被称为按消息键保序策略</p><h5 id="5-8-Kafka-中最基本的数据单元是消息-message-Kafka-中的消息理解成数据库里的一条行或者一条记录"><a href="#5-8-Kafka-中最基本的数据单元是消息-message-Kafka-中的消息理解成数据库里的一条行或者一条记录" class="headerlink" title="5.8. Kafka 中最基本的数据单元是消息 message(Kafka 中的消息理解成数据库里的一条行或者一条记录)"></a>5.8. Kafka 中最基本的数据单元是消息 message(Kafka 中的消息理解成数据库里的一条行或者一条记录)</h5><h5 id="5-9-Kafka中的幂等是怎么实现的"><a href="#5-9-Kafka中的幂等是怎么实现的" class="headerlink" title="5.9. Kafka中的幂等是怎么实现的"></a>5.9. Kafka中的幂等是怎么实现的</h5><ul><li>在 Kafka 中，Producer 默认不是幂等性的，可以创建幂等性 Producer。它其实是 0.11.0.0 版本引入的新功能。在此之前，Kafka 向分区发送数据时，可能会出现同一条消息被发送了多次，导致消息重复的情况。在 0.11 之后，指定 Producer 幂等性的方法很简单，仅需要设置一个参数即可，即props.put(“enable.idempotence”, ture)，或 props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG， true)。</li><li>底层具体的原理，就是经典的用空间去换时间的优化思路，即在 Broker 端多保存一些字段。当 Producer 发送了具有相同字段值的消息后，Broker 能够自动知晓这些消息已经重复了</li></ul><h5 id="5-10-幂等性-Producer-作用范围"><a href="#5-10-幂等性-Producer-作用范围" class="headerlink" title="5.10. 幂等性 Producer 作用范围"></a>5.10. 幂等性 Producer 作用范围</h5><ul><li>它只能保证单分区上的幂等性，即一个幂等性 Producer 能够保证某个主题的一个分区上不出现重复消息，它无法实现多个分区的幂等性。其次，它只能实现单会话上的幂等性，不能实现跨会话的幂等性。这里的会话，你可以理解为 Producer 进程的一次运行。当你重启了 Producer 进程之后，这种幂等性保证就丧失了。</li></ul><h5 id="5-11-解释Kafka的用户如何消费信息"><a href="#5-11-解释Kafka的用户如何消费信息" class="headerlink" title="5.11. 解释Kafka的用户如何消费信息?"></a>5.11. 解释Kafka的用户如何消费信息?</h5><ul><li>在Kafka中传递消息是通过使用sendfile API完成的。它支持将字节从套接口转移到磁盘，通过内核空间保存副本，并在内核用户之间调用内核。</li></ul><h5 id="5-12-Kafka中怎么做消息轨迹"><a href="#5-12-Kafka中怎么做消息轨迹" class="headerlink" title="5.12. Kafka中怎么做消息轨迹"></a>5.12. Kafka中怎么做消息轨迹</h5><ul><li>消息轨迹指的是一条消息从生产者发出，经由 broker 存储，再到消费者消费的整个过程中，各个相关节点的状态、时间、地点等数据汇聚而成的完整链路信息。生产者、broker、消费者这3个角色在处理消息的过程中都会在链路中增加相应的信息，将这些信息汇聚、处理之后就可以查询任意消息的状态，进而为生产环境中的故障排除提供强有力的数据支持。对消息轨迹而言，最常见的实现方式是封装客户端，在保证正常生产消费的同时添加相应的轨迹信息埋点逻辑。无论生产，还是消费，在执行之后都会有相应的轨迹信息，我们需要将这些信息保存起来。同样可以将轨迹信息保存到 Kafka 的某个主题中，比如下图中的主题 trace_topic。生产者在将消息正常发送到用户主题 real_topic 之后（或者消费者在拉取到消息消费之后）会将轨迹信息发送到主题 trace_topic 中。</li></ul><h5 id="5-13-Kafka为什么这么快"><a href="#5-13-Kafka为什么这么快" class="headerlink" title="5.13. Kafka为什么这么快"></a>5.13. Kafka为什么这么快</h5><ul><li>Kafka重度依赖底层操作系统提供的PageCache功能。当上层有写操作时，操作系统只是将数据写入PageCache，同时标记Page属性为Dirty。当读操作发生时，先从PageCache中查找，如果发生缺页才进行磁盘调度，最终返回需要的数据。实际上PageCache是把尽可能多的空闲内存都当做了磁盘缓存来使用。同时如果有其他进程申请内存，回收PageCache的代价又很小，所以现代的OS都支持PageCache。 使用PageCache功能同时可以避免在JVM内部缓存数据，JVM为我们提供了强大的GC能力，同时也引入了一些问题不适用与Kafka的设计。</li></ul><h5 id="5-14-kafka为什么不像MySQL那样允许追随者副本对外提供读服务"><a href="#5-14-kafka为什么不像MySQL那样允许追随者副本对外提供读服务" class="headerlink" title="5.14. kafka为什么不像MySQL那样允许追随者副本对外提供读服务"></a>5.14. kafka为什么不像MySQL那样允许追随者副本对外提供读服务</h5><ul><li>kafka的分区已经让读是从多个broker读从而<a href="https://cloud.tencent.com/product/clb?from_column=20065&from=20065">负载均衡</a>，不是MySQL的主从，压力都在主上</li><li>kafka保存的数据和数据库的性质有实质的区别就是数据具有消费的概念，是流数据，kafka是消息队列，所以消费需要位移，而数据库是实体数据不存在这个概念，如果从kafka的follower读，消费端offset控制更复杂</li><li>生产者来说，kafka可以通过配置来控制是否等待follower对消息确认的，如果从上面读，也需要所有的follower都确认了才可以回复生产者，造成性能下降，如果follower出问题了也不好处理</li><li>首先会存在数据一致性的问题，消息从主节点同步到从节点需要时间，可能造成主从节点的数据不一致。主写从读无非就是为了减轻leader节点的压力，将读请求的负载均衡到follower节点，如果Kafka的分区相对均匀地分散到各个broker上，同样可以达到负载均衡的效果，没必要刻意实现主写从读增加代码实现的复杂程度</li></ul><h5 id="5-15-Producer端，网络，数据格式等因素，会不会导致Kafka只有一个分区接收到数据顺序跟Producer发送数据顺序不一致"><a href="#5-15-Producer端，网络，数据格式等因素，会不会导致Kafka只有一个分区接收到数据顺序跟Producer发送数据顺序不一致" class="headerlink" title="5.15. Producer端，网络，数据格式等因素，会不会导致Kafka只有一个分区接收到数据顺序跟Producer发送数据顺序不一致"></a>5.15. Producer端，网络，数据格式等因素，会不会导致Kafka只有一个分区接收到数据顺序跟Producer发送数据顺序不一致</h5><ul><li>如果retries&gt;0并且max.in.flight.requests.per.connection&gt;1有可能出现消息乱序的情况</li></ul><h5 id="5-16-replica的leader和follower之间如何复制数据保证消息的持久化的问题"><a href="#5-16-replica的leader和follower之间如何复制数据保证消息的持久化的问题" class="headerlink" title="5.16. replica的leader和follower之间如何复制数据保证消息的持久化的问题"></a>5.16. replica的leader和follower之间如何复制数据保证消息的持久化的问题</h5><ul><li>follower副本不断地从leader处拉取消息。</li><li>生产者消息发过来以后，写leader成功后即告知生产者成功，然后异步的将消息同步给其他follower，这种方式效率最高，但可能丢数据；</li><li>同步等待所有follower都复制成功后通知生产者消息发送成功，这样不会丢数据，但效率不高；</li></ul><h5 id="5-17-在partition增加或减少消息路由重新hash的情况下，消息的顺序性不就没有办法保证了。特别是在相同key的情况下，有状态变更顺序要求的场景。不知道对于类似场景有什么好的解决方案"><a href="#5-17-在partition增加或减少消息路由重新hash的情况下，消息的顺序性不就没有办法保证了。特别是在相同key的情况下，有状态变更顺序要求的场景。不知道对于类似场景有什么好的解决方案" class="headerlink" title="5.17. 在partition增加或减少消息路由重新hash的情况下，消息的顺序性不就没有办法保证了。特别是在相同key的情况下，有状态变更顺序要求的场景。不知道对于类似场景有什么好的解决方案"></a>5.17. 在partition增加或减少消息路由重新hash的情况下，消息的顺序性不就没有办法保证了。特别是在相同key的情况下，有状态变更顺序要求的场景。不知道对于类似场景有什么好的解决方案</h5><ul><li>可以自己写个partitioner，让相同的key用于去到相同的分区</li></ul><h5 id="5-18-如果长时间不消费，提交的位移会过期吗？或者提交的位移的数据被清理了，下次启动重新消费时从什么位移开始消费？"><a href="#5-18-如果长时间不消费，提交的位移会过期吗？或者提交的位移的数据被清理了，下次启动重新消费时从什么位移开始消费？" class="headerlink" title="5.18. 如果长时间不消费，提交的位移会过期吗？或者提交的位移的数据被清理了，下次启动重新消费时从什么位移开始消费？"></a>5.18. 如果长时间不消费，提交的位移会过期吗？或者提交的位移的数据被清理了，下次启动重新消费时从什么位移开始消费？</h5><ul><li>提交的位移会过期。一旦被清理，从哪里消费取决于auto.offset.reset参数值</li></ul><h5 id="5-19-异步发送消息，如果retry，是否会造成消息乱序？"><a href="#5-19-异步发送消息，如果retry，是否会造成消息乱序？" class="headerlink" title="5.19. 异步发送消息，如果retry，是否会造成消息乱序？"></a>5.19. 异步发送消息，如果retry，是否会造成消息乱序？</h5><ul><li>是可能的，所以有max.in.flight.requests.per.connection这个参数</li></ul><h5 id="5-20-消息经常堆积起来，不能消费了。大概会有一些什么情况。如何解决"><a href="#5-20-消息经常堆积起来，不能消费了。大概会有一些什么情况。如何解决" class="headerlink" title="5.20. 消息经常堆积起来，不能消费了。大概会有一些什么情况。如何解决"></a>5.20. 消息经常堆积起来，不能消费了。大概会有一些什么情况。如何解决</h5><ul><li>生产速度大于消费速度，这样可以适当增加分区，增加consumer数量，提升消费TPS</li><li>consumer消费性能低，查一下是否有很重的消费逻辑（比如拿到消息后写HDFS或HBASE这种逻辑就挺重的），看看是否可以优化consumer TPS</li><li>确保consumer端没有因为异常而导致消费hang住</li><li>如果你使用的是消费者组，确保没有频繁地发生rebalance</li></ul><h5 id="5-21-如何判定-生产者速度大于消费者"><a href="#5-21-如何判定-生产者速度大于消费者" class="headerlink" title="5.21. 如何判定 生产者速度大于消费者"></a>5.21. 如何判定 生产者速度大于消费者</h5><ul><li>用kafka自带的<a href="https://cloud.tencent.com/product/cli?from_column=20065&from=20065">命令行工具</a>kafka-consumer-groups.sh。可以查看指定消费者组对其消费的所有partition的位移落后情况(也就是业务上的堆积量)。在一段时间内多次使用这个工具查看消费位移落后的情况，如果越来越大，就说明消费慢于生产。</li></ul><h5 id="5-22-在规划消息磁盘的时候会考虑什么"><a href="#5-22-在规划消息磁盘的时候会考虑什么" class="headerlink" title="5.22. 在规划消息磁盘的时候会考虑什么"></a>5.22. 在规划消息磁盘的时候会考虑什么</h5><ul><li>新增消息数</li><li>消息留存时间</li><li>平均消息大小</li><li>备份数</li><li>是否启用压缩</li></ul><h5 id="5-23-Kafka-无消息丢失的配置"><a href="#5-23-Kafka-无消息丢失的配置" class="headerlink" title="5.23. Kafka 无消息丢失的配置"></a>5.23. Kafka 无消息丢失的配置</h5><ul><li>不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。</li><li>设置 acks &#x3D; all。acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</li><li>设置 retries 为一个较大的值。这里的 retries 同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。</li><li>设置 unclean.leader.election.enable &#x3D; false。这是 Broker 端的参数，它控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。</li><li>设置 replication.factor &gt;&#x3D; 3。这也是 Broker 端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。</li><li>设置 min.insync.replicas &gt; 1。这依然是 Broker 端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。</li><li>确保 replication.factor &gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor &#x3D; min.insync.replicas + 1。</li><li>确保消息消费完成再提交。Consumer 端有个参数 enable.auto.commit，最好把它设置成 false，并采用手动提交位移的方式。就像前面说的，这对于单 Consumer 多线程处理的场景而言是至关重要的。</li></ul><h5 id="5-24-如何保证消息的不丢"><a href="#5-24-如何保证消息的不丢" class="headerlink" title="5.24. 如何保证消息的不丢"></a>5.24. 如何保证消息的不丢</h5><h3 id="6-消费组"><a href="#6-消费组" class="headerlink" title="6. 消费组"></a>6. 消费组</h3><ol><li>简述消费者与消费组之间的关系<ol><li>Consumer Group 下可以有一个或多个 Consumer 实例。这里的实例可以是一个单独的进程，也可以是同一进程下的线程。在实际场景中，使用进程更为常见一些</li><li>Group ID 是一个字符串，在一个 Kafka 集群中，它标识唯一的一个 Consumer Group</li><li>Consumer Group 下所有实例订阅的主题的单个分区，只能分配给组内的某个 Consumer 实例消费。这个分区当然也可以被其他的 Group 消费。</li></ol></li></ol><h3 id="7-位移"><a href="#7-位移" class="headerlink" title="7. 位移"></a>7. 位移</h3><ol><li>消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1?<ul><li>在旧消费者客户端中，消费位移是存储在 ZooKeeper 中的。而在新消费者客户端中，消费位移存储在 Kafka 内部的主题__consumer_offsets 中。 当前消费者需要提交的消费位移是offset+1</li></ul></li><li>主题有4个分区，消费者组有2个实例，发布应用的时候，会先新启动一个服务节点，加入消费组，通过重平衡分配到到至少1个最多2个分区，消费者的偏移量是 0 还是啥<ul><li>假设C1消费P0,P1, C2消费P2,P3。如果C1从未提交，C1挂掉，C2开始消费P0,P1，发现没有对应提交位移，那么按照C2的auto.offset.reset值决定从那里消费，如果是earliest，从P0，P1的最小位移值（可能不是0）开始消费，如果是latest，从P0, P1的最新位移值（分区高水位值）开始消费。但如果C1之前提交了位移，那么C1挂掉之后C2从C1最新一次提交的位移值开始消费。 所谓的重复消费是指，C1消费了一部分数据，还没来得及提交这部分数据的位移就挂了。C2承接过来之后会重新消费这部分数据。</li></ul></li><li>为什么位移主题写入消息时，不直接替换掉原来的数据，像 HashMap 一样呢？而是要堆积起来，另起线程来维护位移主题<ul><li>位移主题也是主题，也要遵循Kafka底层的日志设计思路，即append-only log</li></ul></li><li>位移主题用来记住位移，那么这个位移主题的位移由谁来记住呢?<ul><li>位移主题的位移由Kafka内部的Coordinator自行管理</li></ul></li><li>消费者提交的位移消息，保存到位移主题分区是随机的吗？<ul><li>不是随机的。通常来说，同一个group下的所有消费者提交的位移数据保存在位移主题的同一个分区下</li></ul></li></ol><h3 id="8-rebalance"><a href="#8-rebalance" class="headerlink" title="8. rebalance"></a>8. rebalance</h3><ol><li>如何缩短rebalance时间<ul><li>减少consumer个数</li></ul></li></ol><p>当消费者拉取消息或者提交时，便会发送心跳。如果消费者超过一定时间没有发送心跳，那么它的会话（Session）就会过期，组协调者会认为该消费者已经宕机，然后触发重平衡。</p><p>另外更高版本的 Kafka 支持配置一个消费者多长时间不拉取消息但仍然保持存活，这个配置可以避免活锁（livelock）。活锁，是指应用没有故障但是由于某些原因不能进一步消费。</p><ol><li><p>缩短单条消息处理的时间：这个涉及业务流程的优化或者改造，得具体问题具体分析，在 bps 这个场景，暂时没有优化的空间 2. 增加消费者端允许下游系统消费一批消息的最大时长：当消费者组完成重平衡之后，每个消费者实例都会定期地向协调者发送心跳请求，表明它还存活着。如果某个消费者实例不能及时地发送这些心跳请求，协调者就会认为该消费者已经“死”了，从而将其从组中移除，然后开启新一轮重平衡。消费者端有个参数，叫 session.timeout.ms，就是被用来表征此事的。该参数的默认值是 10 秒，即如果协调者在 10 秒之内没有收到组内某个消费者实例的心跳，它就会认为这个消费者实例已经挂了。可以这么说，session.timeout.ms 决定了消费者存活性的时间间隔 3. 控制发送心跳请求频率：消费者还提供了一个允许你控制发送心跳请求频率的参数，就是 heartbeat.interval.ms。这个值设置得越小，消费者实例发送心跳请求的频率就越高。频繁地发送心跳请求会额外消耗带宽资源，但好处是能够更加快速地知晓当前是否开启重平衡 4. 减少下游系统一次性消费的消息总数：这取决于消费者端参数 max.poll.records 的值。当前该参数的默认值是 500 条，表明调用一次 KafkaConsumer.poll 方法，最多返回 500 条消息。可以说，该参数规定了单次 poll 方法能够返回的消息总数的上限。如果前两种方法对你都不适用的话，降低此参数值是避免 CommitFailedException 异常最简单的手段 5. 调整两次调用 poll 方法的最大时间间隔：消费者端还有一个参数，用于控制消费者实际消费能力对重平衡的影响，即 max.poll.interval.ms 参数。它限定了消费者端应用程序两次调用 poll 方法的最大时间间隔。它的默认值是 5 分钟，表示你的消费者程序如果在 5 分钟之内无法消费完 poll 方法返回的消息，那么消费者会主动发起“离开组”的请求，协调者也会开启新一轮重平衡 6. 下游系统使用多线程来加速消费：具体的思路就是，让下游系统手动创建多个消费线程处理 poll 方法返回的一批消息。之前你使用 Kafka 消费者消费数据更多是单线程的，所以当消费速度无法匹及 Kafka 消费者消息返回的速度时，它就会抛出 CommitFailedException 异常。如果是多线程，你就可以灵活地控制线程数量，随时调整消费承载能力，再配以目前多核的硬件条件，该方法可谓是防止 CommitFailedException 最高档的解决之道。事实上，很多主流的大数据流处理框架使用的都是这个方法，比如 Apache Flink 在集成 Kafka 时，就是创建了多个 KafkaConsumerThread 线程，自行处理多线程间的数据消费。不过，凡事有利就有弊，这个方法实现起来并不容易，特别是在多个线程间如何处理位移提交这个问题上，更是极容易出错。</p></li><li><p>什么情况下会Rebalance</p><ul><li>只有consumer成员数量、订阅topic分区数发生增减才会触发</li></ul></li></ol><h3 id="9-Producer"><a href="#9-Producer" class="headerlink" title="9. Producer"></a>9. Producer</h3><h5 id="9-1-谈一谈-Kafka-Producer-的-acks-参数的作用。（producer发个broker）"><a href="#9-1-谈一谈-Kafka-Producer-的-acks-参数的作用。（producer发个broker）" class="headerlink" title="9.1. 谈一谈 Kafka Producer 的 acks 参数的作用。（producer发个broker）"></a>9.1. 谈一谈 Kafka Producer 的 acks 参数的作用。（producer发个broker）</h5><ul><li>acks&#x3D;0<ul><li>Producer不会等待Broker的确认反馈，不关心Broker是否正确的将发送来的数据持久化，所以在这种模式下，很有可能会丢失数据。因为如果Broker挂了，Producer不会被通知到，所以还会不停的发送数据导致数据丢失。在对数据完整性需求不强烈的场景下，这种模式可以提高性能。</li></ul></li><li>acks&#x3D;1<ul><li>默认采用的模式，该模式下Producer会等待Leader Broker的确认反馈，当Broker确实将数据持久化到至少一个Partition中后，给予Producer确认反馈，Producer才会继续发送数据。该模式下有几点需要注意：<ul><li>不保证Replicas也持久化了数据。</li><li>当Producer没有收到Broker的确认反馈时，Producer会尝试重新发送数据。</li><li>当Leader Broker挂了，但是Replicas又没有持久化数据时，还是会丢失数据。</li><li>该模式只能说是可以有效防止数据丢失。</li></ul></li></ul></li><li>acks&#x3D;all<ul><li>Producer同样需要等待Broker的确认，但是确认更为严格，需要所有的Partition（Leader + Replicas）都持久化数据后才返回确认信息。这种模式下，只要Replicas足够多，数据基本不会丢失。</li><li>在该模式下，还有一个重要的参数min.insync.replicas需要配置。该参数的意思是当acks&#x3D;all时，至少有多少个Replicas需要确认已成功持久化数据，这个Replicas数量也包括Leader。</li></ul></li></ul><h5 id="9-2-对producer的retry理解"><a href="#9-2-对producer的retry理解" class="headerlink" title="9.2. 对producer的retry理解"></a>9.2. 对producer的retry理解</h5><ul><li>有时候Producer发送Message失败可能并不是因为Broker挂了，可能是因为网络问题，没有连接到Broker等。这种问题可能在很短暂的时间内就会自动修复，那么在这种情况下，我们希望Producer在发送失败后能重新尝试发送。这里就需要设置retries这个参数，意思就是重试的次数，默认是0次，可以根据实际业务情况设置。</li></ul><p>但是当设置了retries参数大于0后，有可能会带来新的问题。假如我们需要相同Key的Message进入特定的Partition，并且是要严格按照Producer生产Message的顺序排序。那么此时如果第一条Message发送失败，第二条Message发送成功了，第一条通过重试发送成功了，那Message的顺序就发生了变化。</p><p>这里又会引出一个参数max.in.flight.requests.per.connection，这个参数默认是5，意思是在被Broker阻止前，未通过acks确认的发送请求最大数，也就是在Broker处排队等待acks确认的Message数量。所以刚才那个场景，第一条和第二条Message都在Broker那排队等待确认放行，这时第一条失败了，等重试的第一条Message再来排队时，第二条早都通过进去了，所以排序就乱了。</p><p>如果想在设置了retries还要严格控制Message顺序，可以把max.in.flight.requests.per.connection设置为1。让Broker处永远只有一条Message在排队，就可以严格控制顺序了。但是这样做会严重影响性能（接收Message的吞吐量）。</p><p>Kafka在0.11版本之后，就为我们提供了定义幂等Producer的能力</p><ul><li>retries&#x3D;Integer.MAX_VALUE</li><li>max.in.flight.requests.per.connection&#x3D;1 (Kafka &gt;&#x3D; v0.11 &amp; &lt; v1.1)</li><li>max.in.flight.requests.per.connection&#x3D;5 (Kafka &gt;&#x3D; v1.1)</li><li>acks&#x3D;all</li></ul><h5 id="9-3-对Message-Batch的理解"><a href="#9-3-对Message-Batch的理解" class="headerlink" title="9.3. 对Message Batch的理解"></a>9.3. 对Message Batch的理解</h5><p>max.in.flight.requests.per.connection参数，默认会在Broker那排队5条Message，那么如果第六条来了怎么办呢？这时候Kafka会自动开启批量处理Message的模式，将这6条Message作为一个批次进行处理。这一个批次可以看作是一次Message处理请求。</p><p>开启批量模式后，会引出两个参数：</p><ul><li>linger.ms：每次批量处理的间隔时间。如果设为5，那么就是每5毫秒对Message进行一次批量处理。</li><li>batch.size：每个批次的最大字节数，默认是16KB，可以设置为32KB或者64KB，可以提高性能。</li></ul><h5 id="9-4-对-Producer-Buffer的理解"><a href="#9-4-对-Producer-Buffer的理解" class="headerlink" title="9.4. 对 Producer Buffer的理解"></a>9.4. 对 Producer Buffer的理解</h5><p>在大多数情况下，Consumer消费Message的速率是远不如Producer生产Message的速率的。所以Producer有一个缓存机制，将Broker还没来得及接收的Message缓存在内存中。缓存的大小可以通过buffer.memory配置，默认大小是32MB。默认存储时间为7天，这个时间可以通过设置Broker的offset.retention.minutes属性改变。</p><p>如果Producer的缓存被打满后，Producer会被阻塞，阻塞的最大时间可以通过max.block.ms配置，默认大小是60秒。</p><p>概括一下，就是当Producer生产Message的速率大于Broker接收Message（Consumer消费数据）的速率时，Producer会把Broker还没来得及接收的Message存在缓存里（内存），当存满设置的缓存大小后，Producer将不再发送Message给Broker，也就是进入阻塞状态，如果在设置的阻塞时间内，缓存还没有被释放出有用空间，那么Producer将抛出异常。</p><h5 id="9-5-幂等生产者"><a href="#9-5-幂等生产者" class="headerlink" title="9.5. 幂等生产者"></a>9.5. 幂等生产者</h5><p>消息交付可靠性保障 Kafka 对 Producer 和 Consumer 要处理的消息提供什么样的承诺。常见承诺有以下三种：</p><ul><li>最多一次（at most once）：消息可能会丢失，但绝不会被重复发送。</li><li>至少一次（at least once）：消息不会丢失，但有可能被重复发送。（kafka默认）</li><li>精确一次（exactly once）：消息不会丢失，也不会被重复发送。</li></ul><p>指定 Producer 幂等性的方法很简单，仅需要设置一个参数即可，即 props.put(“enable.idempotence”, ture)，或 props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG， true)。</p><p>底层具体的原理很简单，就是经典的用空间去换时间的优化思路，即在 Broker 端多保存一些字段。当 Producer 发送了具有相同字段值的消息后，Broker 能够自动知晓这些消息已经重复了</p><p>幂等性 Producer 作用范围</p><ul><li><strong>它只能保证单分区上的幂等性</strong>，即一个幂等性 Producer 能够保证某个主题的一个分区上不出现重复消息，它无法实现多个分区的幂等性。其次，它只能实现单会话上的幂等性，不能实现跨会话的幂等性。这里的会话，你可以理解为 Producer 进程的一次运行。当你重启了 Producer 进程之后，这种幂等性保证就丧失了。</li></ul><p>事务</p><p>事务型 Producer 能够保证将消息原子性地写入到多个分区中。这批消息要么全部写入成功，要么全部失败。另外，事务型 Producer 也不惧进程的重启。Producer 重启回来后，Kafka 依然保证它们发送消息的精确一次处理。</p><p>设置事务型 Producer 的方法也很简单，满足两个要求即可：</p><ul><li>和幂等性 Producer 一样，开启 enable.idempotence &#x3D; true。</li><li>设置 Producer 端参数 transactional. id。最好为其设置一个有意义的名字。</li></ul><p>producer端可能发送重复消息，broker端有一套机制来去重（幂等性依赖seq number机制，事务依赖各种marker来标记）</p><ul><li>Producer 发送消息到 Broker 时，会根据Paritition 机制选择将其存储到哪一个Partition。如果 Partition 机制设置合理，所有消息可以均匀分布到不同的 Partition里，这样就实现了负载均衡。指明 Partition 的情况下，直接将给定的 Value 作为 Partition 的值。没有指明 Partition 但有 Key 的情况下，将 Key 的 Hash 值与分区数取余得到 Partition 值。既没有 Partition 有没有 Key 的情况下，第一次调用时随机生成一个整数（后面每次调用都在这个整数上自增），将这个值与可用的分区数取余，得到 Partition 值，也就是常说的 Round-Robin 轮询算法。</li></ul><h3 id="10-调优"><a href="#10-调优" class="headerlink" title="10. 调优"></a>10. 调优</h3><h5 id="10-1-swap-的调优"><a href="#10-1-swap-的调优" class="headerlink" title="10.1. swap 的调优"></a>10.1. swap 的调优</h5><ul><li>swap 的调优。网上很多文章都提到设置其为 0，将 swap 完全禁掉以防止 Kafka 进程使用 swap 空间。我个人反倒觉得还是不要设置成 0 比较好，我们可以设置成一个较小的值。为什么？因为一旦设置成 0，当物理内存耗尽时，操作系统会触发 OOM killer 这个组件，它会随机挑选一个进程然后 kill 掉，即根本不给用户任何的预警。但如果设置成一个比较小的值，当开始使用 swap 空间时，你至少能够观测到 Broker 性能开始出现急剧下降，从而给你进一步调优和诊断问题的时间。基于这个考虑，建议将 swappniess 配置成一个接近 0 但不为 0 的值，比如 1。</li></ul><h3 id="11-其他"><a href="#11-其他" class="headerlink" title="11. 其他"></a>11. 其他</h3><ol><li>kafka如何支持延迟消息队列<ul><li>利用定时任务调度利用定时任务来实现延迟消息是最好、最简单的办法。对于一个延迟消息来说，一个延迟到 30 分钟后才可以被消费的消息，也可以认为是 30 分钟后才可以发送。也就是说，你可以设定一个定时任务，这个任务会在 30 分钟后把消息发送到消息服务器上。</li></ul></li></ol><p>每个分区独立一个文件存储，在分区数量较多时会退化成全局磁盘随机I&#x2F;O，这也是Kafka在多Partition时吞吐量大幅下降的原因~</p><ul><li>分区很多，并且都存在读写的场景才会触发。</li><li>为什么Kafka分区过多会导致顺序读写变为随机读写<ul><li>因为数据是写入到硬盘的。 如果同时有很多个文件在同时往硬盘去读写的话。从硬盘的角度来看的话，就是同时在硬盘的不同位置去读写，此时硬盘就得去调度不同位置的读写。即使是SSD和NVME的盘，这种在频繁的在硬盘不同位置的读写就是会降低性能。从硬盘角度来看，就是在不同位置的随机读写。</li></ul></li></ul><p>当 Topic 的消息写入存在倾斜，某些分区消息堆积很多，此时选择哪种分区消费模式可以解决问题？</p><ul><li>如果数据可以丢弃，那么可以通过重置消费位点到最新来解决历史堆积，让消费者可以消费新的数据。不过，这个方案有缺点，重置位点之前的数据会丢失，如果消费性能还是跟不上的话，那么后续还是会堆积。</li><li>如果数据不能丢弃，不用保证消费顺序，那么可以将消费模式切换到共享消费模式，则有多个消费者同时消费一个分区，可以极大地提升消费速度，还可以通过横向增加消费者，从根本上解决堆积问题。</li><li>如果数据不能丢弃，且需要保证消费顺序，那么就只能从发送端入手，分析为何发送端写入倾斜，然后解决写入倾斜的问题。</li></ul><p>Kafka 从生产到消费的全过程</p><p>Kafka 的生产到消费总共经过生产者、Broker、消费者三个模块。大致的流程如下：</p><ul><li>在生产端，客户端会先和 Broker 建立 TCP 连接，然后通过 Kafka 协议访问 Broker 的 Metadata 接口获取到集群的元数据信息。接着生产者会向 Topic 或分区发送数据，如果是发送到 Topic，那么在客户端会有消息分区分配的过程。因为 Kafka 协议具有批量发送语义，所以客户端会先在客户端缓存数据，然后根据一定的策略，通过异步线程将数据发送到 Broker。</li><li>Broker 接收到数据后，会根据 Kafka 协议解析出请求内容，做好数据校验，然后重整数据结构，将数据按照分区的维度写入到底层不同的文件中。如果分区配置了副本，则消息数据会被同步到不同的 Broker 中进行保存。</li><li>在消费端，Kafka 提供了消费分组消费和指定分区消费两种模式。消费端也会先经过寻址拿到完整的元数据信息，然后连接上不同的 Broker。如果是消费分组模式消费，则需要经过重平衡、消费分区分配流程，然后连接上对应的分区的 Leader，接着调用 Broker 的 Fetch 接口进行消费。最后一步也是需要提交消费进度来保存消费信息。</li></ul><p>哪些环节会存在性能瓶颈和数据可靠性风险？</p><p><img src="https://developer.qcloudimg.com/http-save/7060564/02f5e70a5fe0d0e3460fec7af2dafcfb.png"></p><p>影响消息队列性能和可靠性的因素很多</p><ul><li>网络带宽与延迟：消息队列本质上还是一个I&#x2F;O密集型系统，内部没有太多复杂的计算逻辑，因此网络无论对Producer、Broker还是Consumer来说都比较重要，网络一抖动，全链路的吞吐量可能就会受影响。</li><li>Producer的发送模式：选择Oneway&#x2F;Sync&#x2F;Async不同的发送模式，会直接影响Producer的性能和可靠性。</li><li>Broker的物理硬件：特别是磁盘和内存，会直接关系到Broker的存储和消费性能。</li><li>Consumer的Rebalance：在Rebalance期间，整个消费会暂停，因此如何最大程度降低Rebalance的影响，对Consumer端来说比较重要。</li></ul><p>Kafka 集群中修改配置 &#x2F; 权限操作的流程？</p><p>Kafka 修改配置 &#x2F; 权限的实现，是每个 Broker 直接去监听 Broker 中的节点。Broker 会直接监听 ZooKeeper 上的节点，然后根据 Hook 到的信息，做对应的操作。比如修改集群和 Topic 配置，就是 Broker 通过直接监听 ZooKeeper 的不同子节点来实现的。这种方式的好处是，Broker 直接监听 ZooKeeper，避免 Controller 转发一道，从而避免让 Controller 成为瓶颈，整体链路更短，出问题的概率也更低。</p><ol><li>同一个Group中的不同Consumer实例可以订阅不同的Topic吗</li></ol><p>可以的。虽然在实际使用中可能更多的还是同一个group的多个实例订阅相同的topic。</p><p>可能无法消费到这个 consumer 没有订阅的主题, 导致某个 consumer 挂掉之后, 有些消息无法消费</p><p>Kafka Broker 是如何持久化数据的。总的来说，Kafka 使用消息日志（Log）来保存数据，一个日志就是磁盘上一个只能追加写（Append-only）消息的物理文件。因为只能追加写入，故避免了缓慢的随机 I&#x2F;O 操作，改为性能较好的顺序 I&#x2F;O 写操作，这也是实现 Kafka 高吞吐量特性的一个重要手段。不过如果你不停地向一个日志写入消息，最终也会耗尽所有的磁盘空间，因此 Kafka 必然要定期地删除消息以回收磁盘。怎么删除呢？简单来说就是通过日志段（Log Segment）机制。在 Kafka 底层，一个日志又近一步细分成多个日志段，消息被追加写到当前最新的日志段中，当写满了一个日志段后，Kafka 会自动切分出一个新的日志段，并将老的日志段封存起来。Kafka 在后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。</p><p>消费组相关</p><p>开始分区1被消费者A消费，rebalance 后被消费者B消费，那么消费者B是对分区从头开始消费还是继承消费者A的位移继续消费？</p><ul><li>如果A提交了位移，那么rebalance过后B从A提交的位移处继续消费。如果A没有提交过位移，那么视consumer端参数auto.offset.reset值而定</li></ul><p>每次重启一个服务，都会产生下线一次rebalance，上线一次rebalance？</p><ul><li>社区于2.4引入了静态成员变量，可以规避这个问题</li></ul><p>rebalance时，全部实例都要参与重新分配。是否能参考 一致性哈希算法，尽量减少对全局的影响</p><p>———————————-分割线</p><ol><li>解释Kafka的Zookeeper是什么?我们可以在没有Zookeeper的情况下使用Kafka吗?<ul><li>Zookeeper是一个开放源码的、高性能的协调服务，它用于Kafka的分布式应用。不，不可能越过Zookeeper，直接联系Kafka broker。一旦Zookeeper停止工作，它就不能服务客户端请求。·Zookeeper主要用于在集群中不同节点之间进行通信</li></ul></li><li>Consumer的水平扩展是如何实现的呢？<ul><li>Kafka支持Consumer的水平扩展能力。可以让多个Consumer加入一个Consumer Group(消费组)，在一个Consumer Group中，每个分区只能分配给一个Consumer消费者，当Kafka服务端通过增加分区数量进行水平扩展后， 可以向Consumer Group中增加新的Consumer来提高整个Consumer Group的消费能力。当Consumer Group中的一个Consumer出现故障下线时，会通过Rebalance操作将下线Consumer，它负责处理的分区将分配给其他Consumer继续处理。当下线Consumer重新上线加人Consumer Group时，会再进行一次Rebalance操作，重新分配分区。</li></ul></li><li>为了避免磁盘被占满，Katka会周期性地删除陈旧的消息，删除策略是什么呢？<ul><li>Kafka中有两种“保留策略”：一种是根据消息保留的时间，当消息在Kafka中保存的时间超过了指定时间，就可以被删除; 另一种是根据Topic存储的数据大小，当Topic所占的日志文件大小大于一个阈值，则可以开始删除最旧的消息。Kafka会启动一个后台线程，定期检查是否存在可以删除的消息。“保留策略”的配置是非常灵活的，可以有全局的配置，也可以针对Topic进行配置覆盖全局配置。</li></ul></li><li>什么是broker？它的作用是什么？<ul><li>一个单独的Kafka Server就是一个Broker。Broker的主要工作就是接收生产者发过来的消息，分配offset，之后保存到磁盘中。同时，接收消费者、其他Broker的请求，根据请求类型进行相应处理并返回响应。在一般的生产环境中，一个Broker独占一台<a href="https://cloud.tencent.com/product/cpm?from_column=20065&from=20065">物理服务器</a>。</li></ul></li><li>同一分区的多个副本包括的消息是否是一致的？<ul><li>每个副本中包含的消息是一样的，但是在同一时刻，副本之间其实并不是完全一样的。</li></ul></li><li>Consumer Group中消费者的数量是不是越多越好呢？<ul><li>Consumer Group中消费者的数量并不是越多越好，当其中消费者数量超过分区的数量时，会导致有消费者分配不到分区，从而造成消费者的浪费。</li></ul></li><li>详述一下消息在kafka中的生命周期？<ul><li>生产者会根据业务逻辑产生消息，之后根据路由规则将消息发送到指定分区的Leader副本所在的Broker上。在Kafka服务端接收到消息后，会将消息追加到Log中保存，之后Follower副本会与Leader副本进行同步，当ISR集合中所有副本都完成了此消息的同步后，则Leader副本的HW会增加，并向生产者返回响应。 消费者加人到Consumer Group时，会触发Rebalance操作将分区分配给不同的消费者消费。随后，消费者会恢复其消费位置，并向Kafka服务端发送拉取消息的请求，Leader副本会验证请求的offset以及其他相关信息，最后返回消息。</li></ul></li></ol><p>某个分区的leader挂了，在切换选举到另外副本为leader时，这个副本还没同步之前的leader数据，这样数据就丢了 ？</p><p>对于producer而言，如果在乎数据持久性，那么应该设置acks&#x3D;all，这样当出现你说的这个情况时，producer会被显式通知消息发送失败，从而可以重试。</p><p>Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么</p><p>Kafka中的HW、LEO、LSO、LW等分别代表什么？</p><p>Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？</p><p>KafkaConsumer是非线程安全的，那么怎么样实现多线程消费？</p><p>如果我指定了一个offset，Kafka怎么查找到对应的消息？</p><p>聊一聊你对Kafka的Log Retention的理解</p><p>聊一聊你对Kafka的Log Compaction的理解</p><p>聊一聊你对Kafka底层存储的理解（页缓存、内核层、块层、设备层）</p><p>聊一聊Kafka的延时操作的原理</p><p>聊一聊Kafka控制器的作用</p><p>消费再均衡的原理是什么？（提示：消费者协调器和消费组协调器）</p><p>Kafka中的事务是怎么实现的（这题我去面试6加被问4次，照着答案念也要念十几分钟，面试官简直凑不要脸。实在记不住的话…只要简历上不写精通Kafka一般不会问到，我简历上写的是“熟悉Kafka，了解RabbitMQ….”）</p><p>Kafka中有那些地方需要选举？这些地方的选举策略又有哪些？</p><p>怎么计算Lag？(注意read_uncommitted和read_committed状态下的不同)</p><p>Kafka的那些设计让它有如此高的性能？</p><p>在使用Kafka的过程中遇到过什么困难？怎么解决的？</p><p>怎么样才能确保Kafka极大程度上的可靠性？</p><p>kafka认为写入成功是指写入页缓存成功还是数据刷到磁盘成功算成功呢？还是上次刷盘宕机失败的问题，页缓存的数据如果刷盘失败，是不是就丢了？这个异常会不会响应给生产者让其重发呢？</p><p>写入到页缓存即认为成功。如果在flush之前机器就宕机了，的确这条数据在broker上就算丢失了。producer端表现如何取决于acks的设定。如果是acks&#x3D;1而恰恰是leader broker在flush前宕机，那么的确有可能消息就丢失了，而且producer端不会重发——因为它认为是成功了。</p><p>Producer 通过 metadata.max.age.ms定期更新元数据，在连接多个broker的情况下，producer是如何决定向哪个broker发起该请求？</p><p>向它认为当前负载最少的节点发送请求，所谓负载最少就是指未完成请求数最少的broker</p><p>开始分区1被消费者A消费，rebalance 后被消费者B消费，那么消费者B是对分区从头开始消费还是继承消费者A的位移继续消费？</p><p>如果A提交了位移，那么rebalance过后B从A提交的位移处继续消费。如果A没有提交过位移，那么视consumer端参数auto.offset.reset值而定</p><ol><li>为了提高效率,Kafka以批量的方式写入。一个batch就是一组消息的集合,这一组的数据都会进入同一个topic 和 partition(这个是根据 producer的配置来定的)。每一个消息都进行一次网络传输会很消耗性能,因此把消息收集到一起,再同时处理就高效的多了。当然,这样会引入更高的延迟以及吞吐量: batch 越大,同一时间处理的消息就越多。batch 通常都会进行压缩,这样在传输以及存储的时候效率都更高一些。</li><li>消息都是以主题 Topic 的方式组织在一起,Topic 也可以理解成传统数据库里的表,或者文件系统里的一个目录。一个主题由 broker 上的一个或者多个 Partition 分区组成。在 Kafka 中数据是以 Log 的方式存储,一个 partition 就是一个单独的 Log。消息通过追加的方式写入日志文件,读取的时候则是从头开始 按照顺序读取。注意,一个主题通常都是由多个分区组成的,每个分区内部保证消息的顺序行,分区之间是不保证顺序的。如果你想要 kafka 中的数据按照时 间的先后顺序进行存储,那么可以设置分区数为 1。如下图所示,一个主题由 4 个分区组成,数据都以追加的方式写入这四个文件。分区的方式为 Kafka 提供 了良好的扩展性,每个分区都可以放在独立的服务器上,这样就相当于主题可以在多个机器间水平扩展,相对于单独的服务器,性能更好。</li><li>Kafka 中主要有两种使用者:Producer 和 consumer<ul><li>Producer 用来创建消息。在发布订阅系统中,他们也被叫做 Publisher 发布者或 writer 写作者。通常情况下,消息都会进入特定的主题。默认情况下,生产者 不关系消息到底进入哪个分区,它会自动在多个分区间负载均衡。也有的时候,消息会进入特定的一个分区中。一般都是通过消息的 key 使用哈希的方式确定 它进入哪一个分区。这就意味着如果所有的消息都给定相同的 key,那么他们最终会进入同一个分区。生产者也可以使用自定义的分区器,这样消息可以进入 特定的分区。</li></ul></li><li>Consumer 读取消息。在发布订阅系统中,也叫做 subscriber 订阅者或者 reader 阅读者。消费者订阅一个或者多个主题,然后按照顺序读取主题中的数据。消 费者需要记录已经读取到消息的位置,这个位置也被叫做 offset。每个消息在给定的分区中只有唯一固定的 offset。通过存储最后消费的 Offset,消费者应用 在重启或者停止之后,还可以继续从之前的位置读取。保存的机制可以是 zookeeper,或者 kafka 自己。</li><li>消费者是以 consumer group 消费者组的方式工作,由一个或者多个消费者组成一个组,共同消费一个 topic。每个分区在同一时间只能由 group 中的一个消费 者读取,在下图中,有一个由三个消费者组成的 grouop,有一个消费者读取主题中的两个分区,另外两个分别读取一个分区。某个消费者读取某个分区,也 可以叫做某个消费者是某个分区的拥有者。</li><li>在这种情况下,消费者可以通过水平扩展的方式同时读取大量的消息。另外,如果一个消费者失败了,那么其他的 group 成员会自动负载均衡读取之前失败的 消费者读取的分区。</li><li>单独的 kafka 服务器也叫做 broker,Broker 从生产者那里获取消息,分配 offset,然后提交存储到磁盘年。他也会提供消费者,让消费者读取分区上的消息, 并把存储的消息传给消费者。依赖于一些精简资源,单独的 broker 也可以轻松的支持每秒数千个分区和百万级的消息。</li><li>Kafka 的 broker 支持集群模式,在 Broker 组成的集群中,有一个节点也被叫做控制器(是在活跃的节点中自动选择的)。这个 controller 控制器负责管理整个 集群的操作,包括分区的分配、失败节点的检测等。一个 partition 只能出现在一个 broker 节点上,并且这个 Broker 也被叫做分区的 leader。一个分区可以分 配多个 Broker,这样可以做到多个机器之间备份的效果。这种多机备份在其中一个 broker 失败的时候,可以自动选举出其他的 broker 提供服务。然而, producer 和 consumer 都必须连接 leader 才能正常工作。</li><li>Kafka 的一个重要特性就是支持数据的过期删除,数据可以在 Broker 上保留一段时间。Kafka 的 broker 支持针对 topic 设置保存的机制,可以按照大小配置也 可以按照时间配置。一旦达到其中的一个限制,可能是时间过期也可能是大小超过配置的数值,那么这部分的数据都会被清除掉。每个 topic 都可以配置它自 己的过期配置,因此消息可以按照业务的需要进行持久化保留。比如,一个数据追踪分析的 topic 可以保留几天时间,一些应用的指标信息则只需要保存几个 小时。topic 支持日志数据的压缩,这样 kafka 仅仅会保留最后一条日志生成的 key。这在修改日志类型的时候会非常有用。</li></ol><p>假设有个 Kafka 集群由 2 台 Broker 组成，有个主题有 5 个分区，当一个消费该主题的消费者程序启动时，你认为该程序会创建多少个 Socket 连接？为什么？</p><ul><li>整个生命周期里会建立4个连接，进入稳定的消费过程后，同时保持3个连接，以下是详细。 第一类连接：确定协调者和获取集群元数据。 一个，初期的时候建立，当第三类连接建立起来之后，这个连接会被关闭。 第二类连接：连接协调者，令其执行组成员管理操作。 一个 第三类连接：执行实际的消息获取。 两个分别会跟两台broker机器建立一个连接，总共两个TCP连接，同一个broker机器的不同分区可以复用一个socket。只有2个 Broker，5个分区的领导者副本，由zookeeper分配Leader，所以默认是均匀的，故有4个TCP连接。</li></ul><p>你是如何解决有序消息这个问题的？用的是哪种方案？</p><ul><li>只需要确保同一个业务的消息发送到同一个分区就可以保证同一个业务的消息是有序的。</li></ul><p>怎么保证同一个业务的消息必然发送到同一个分区呢？</p><ul><li>只需要生产者在发送消息的时候，根据业务特征，比如说业务 ID 计算出目标分区，在发送的时候显式地指定分区就可以了。</li></ul><p>如果你用的是单分区解决方案，那么有没有消息积压问题？如果有，你是怎么解决的？</p><p>如果你用的是多分区解决方案，那么有没有分区负载不均衡的问题？如果有，你是怎么解决的？</p><p>增加分区会引起消息失序</p><ul><li>它还有另外一个缺点，就是如果中间有增加新的分区，那么就可能引起消息失序。比如说最开始 id 为 3 的订单消息 msg1 发到分区 0 上，但是这时候很不幸分区 0 上积攒了很多消息，所以 msg1 迟迟得不到消费。</li><li>紧接着我们扩容，增加了一个新的分区。如果这时候来了一个消息 msg2，那么它会被转发到分区 3 上。分区 3 上面没有积攒什么数据，所以消费者 3 直接就消费了这个消息。</li><li>这时候我们发现，本来 msg1 应该先于 msg2 被消费。而增加分区之后 msg2 反而被先消费了。这就是一个典型的消息失序场景。</li></ul><p>针对这个缺点我们也可以进一步提出解决方案。这个消息失序的场景解决起来倒也很简单，就是新增加了分区之后，这些新分区的消费者先等一段时间，比如说三分钟，确保同一个业务在其他分区上的消息已经被消费了。</p><p>要解决这个问题也很容易。对于新加入的分区，可以暂停消费一段时间。比如说在前面的例子中，如果我们估算 msg1 会在一分钟内被消费，那么新加入的分区的消费者可以在三分钟后再开始消费。那么大概率 msg1 就会先于 msg2 消费。不过这种等待的解决方式并不能解决根本问题，只能说是很大程度上缓解了问题。但是本身增加分区也是一个很不常见的操作，再叠加消息失序的概率也很低，所以我们也可以通过监控发现这种失序场景，然后再手工修复一下就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 面试 </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang语言面试题 - Grpc</title>
      <link href="/interview/go/go-grpc/"/>
      <url>/interview/go/go-grpc/</url>
      
        <content type="html"><![CDATA[<h3 id="grpc和http区别"><a href="#grpc和http区别" class="headerlink" title="grpc和http区别"></a>grpc和http区别</h3><p>gRPC和HTTP的主要区别在于它们的传输协议、序列化和反序列化方法、性能特性以及使用场景。具体如下：</p><ul><li>传输协议不同。gRPC使用基于二进制的HTTP&#x2F;2作为传输协议，支持多路复用、头部压缩和服务器推送等功能，提高了性能和效率，而HTTP通常使用文本协议，基于HTTP&#x2F;1.1或HTTP&#x2F;2，HTTP&#x2F;1.1是基于请求-响应模式的协议，每次请求都需要建立新的连接，HTTP&#x2F;2引入了多路复用和头部压缩等功能。</li><li>序列化和反序列化方法不同。gRPC使用Protocol Buffers（protobuf）作为默认的接口定义语言（IDL），用于描述数据结构和服务接口，protobuf是一种高效的二进制序列化格式，可以提供更小的数据包大小和更快的序列化&#x2F;反序列化速度，而HTTP使用普通文本格式进行数据交换，通常使用JSON或XML作为数据的表示格式。</li><li>性能特性不同。gRPC在性能方面优于HTTP，由于使用了二进制格式，因此传输速度更快、更稳定，而且gRPC通过使用连接池，实现客户端与服务端的长连接机制，使得延迟较低，在高网络带宽时表现更好，而HTTP设计目标是作为一种通用的、可扩展的协议，用于在客户端和服务器之间传输超文本数据，广泛用于Web应用程序和浏览器之间的通信。</li><li>使用场景不同。gRPC通常用于服务之间的通信，特别是分布式系统中，例如微服务框架等，具有高性能、低延迟、易扩展等特点，是一个理想的分布式系统通信协议，而HTTP主要用于Web中浏览器和服务器之间的交互，在Web应用程序中非常常见。</li></ul><p>1.grpc底层用的什么协议?</p><blockquote><p>http2.0</p></blockquote><p>2.http2.0和1.1的区别?</p><blockquote><ol><li>多路复用: 1.1每个请求必须是独立的TCP请求, 2.0采用多路复用, 一个TCP连接可以进行多次请求, 大大提升性能</li><li>数据传输: 2.0引入数据流的概念, 允许不同请求在同一连接交错发送</li><li>头部处理: 2.0 采用HPACK算法对头部数据进行压缩, 降低数据大小和网络开销</li><li>二进制协议: http&#x2F;1.1报文头信息必须是文本, 数据体可以是二进制,也可是文本。2.0 头信息和数据体都是二进制, 更加高效的处理数据</li><li>错误处理: 1.1处理错误需要关闭连接, 2.0引入可以在不关闭连接的情况下处理错误</li></ol></blockquote><p>3.gRPC有几种请求模式?</p><blockquote><ol><li>简单模式: 客户端发起请求, 等待服务端响应. (例如普通的grpc定义message, 一次请求一次响应)</li><li>服务端流式(长连接): 客户端发送请求, 服务端返回一个流, 客户端持续监听这个流, 反序列化其中的内容, 返回给用户,适用于客户端需要向服务端发送大量数据的情况, 如文件上传</li><li>客户端流式(长连接): 客户端创建一个流, 将请求参数以流的方式给服务端, 服务端再返回单个响应, 适合服务端向客户端发送大量数据的情况, 例如实时数据传输</li><li>双向流式: 允许客户端和服务端同时读写数据. 双方都可以随时开始和结束数据的发送. 适合双向数据传输模式</li></ol><p>传统的http连接时短连接, 一次请求一次响应后, 连接就断开了, 然而, 客户端流式RPC和服务端流式RPC模式基于TCP长连接, 用于多次数据交换.</p></blockquote><p>4.protobuf了解过吗? 和有什么区别? 对比json有什么优势? 压缩率对比json来说能达到多少?</p><blockquote><p>和json的对比:</p><ol><li>protobuf使用二进制格式, json为文本格式, 所以protobuf的序列化和反序列化更加高效</li><li>由于使用二进制传输, protobuf的体积通常更小</li><li>protobuf是强类型的, 定义数据结构时必须指定每个字段的类型, 可以减少解析时的错误, json是弱类型的, 不强制字段的类型</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> go </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go语言 Slice 结构的底层实现</title>
      <link href="/library/Golang/advanced-tutorial/go-slice/"/>
      <url>/library/Golang/advanced-tutorial/go-slice/</url>
      
        <content type="html"><![CDATA[<h4 id="append-性能损耗"><a href="#append-性能损耗" class="headerlink" title="append 性能损耗"></a>append 性能损耗</h4><p>未指定长度或者长度不足时，双倍扩容（cap &lt; 1024）; 1.25倍扩容(cap &gt; 1024)。把元内存空间的数据拷贝过来，然后在新的内存空间继续append数据</p><p>在 Go 1.18 以后，扩容使用threshold为临界点（源码中设置为256）<br>当slice容量 &lt; 256时， 每次扩容为原来的两倍。当slice容量 &gt; 256时， 每次增加(oldcap + 3*threshold) 3&#x2F;4</p><h4 id="母子切片共享内存问题"><a href="#母子切片共享内存问题" class="headerlink" title="母子切片共享内存问题"></a>母子切片共享内存问题</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slicem := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>) <span class="comment">// len = 3, cap = 5 分配了5个空间，置入了3个数据</span></span><br><span class="line">slices := slicem[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">// len = 2, cap = 4</span></span><br></pre></td></tr></table></figure><p>最开始时，子切片和母切片共享母切片的内存空间，对子切片的修改会反映到母切片上，对子切片的 append 操作，会将数据添加到母切片预留的内存空间内。<br>如持续进行 append 操作，直到将母切片预留的内存空间完全消耗完毕后，二者就会发生内存分离，从此再无关系</p><h4 id="切片导致内存泄漏"><a href="#切片导致内存泄漏" class="headerlink" title="切片导致内存泄漏"></a>切片导致内存泄漏</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Leak</span><span class="params">()</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">parent := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">son := parent[<span class="number">10</span>:<span class="number">20</span>]</span><br><span class="line"><span class="keyword">return</span> son</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>func 返回子切片，只要这个子切片没有被 GC 回收，子切片持有的母切片的内存空间就得不到释放，导致泄漏</p><h4 id="函数参数需要用切片指针么"><a href="#函数参数需要用切片指针么" class="headerlink" title="函数参数需要用切片指针么"></a>函数参数需要用切片指针么</h4><p>如果函数内部需要对切片的 len 和 cap 进行修改，且修改要反映在函数外部，那么需要传入切片的指针</p><h4 id="一边遍历一边修改切片"><a href="#一边遍历一边修改切片" class="headerlink" title="一边遍历一边修改切片"></a>一边遍历一边修改切片</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// go 中 for-range 遍历的是原集合的拷贝</span></span><br><span class="line"><span class="keyword">for</span> i, m := <span class="keyword">range</span> arr &#123;</span><br><span class="line">m += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下方这种才能修改成功</span></span><br><span class="line"><span class="keyword">for</span> i, m := <span class="keyword">range</span> arr &#123;</span><br><span class="line">arr[i] = m + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 进阶教程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 必看必会 </tag>
            
            <tag> go </tag>
            
            <tag> Slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式23-中介模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-act/23-mediator/"/>
      <url>/library/Golang/go-design-pattern/gdp-act/23-mediator/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式22-解释器模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-act/22-interpreter/"/>
      <url>/library/Golang/go-design-pattern/gdp-act/22-interpreter/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式21-命令模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-act/21-command/"/>
      <url>/library/Golang/go-design-pattern/gdp-act/21-command/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式20-备忘录模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-act/20-memento/"/>
      <url>/library/Golang/go-design-pattern/gdp-act/20-memento/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式19-访问者模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-act/19-visitor/"/>
      <url>/library/Golang/go-design-pattern/gdp-act/19-visitor/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式18-迭代器模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-act/18-iterator/"/>
      <url>/library/Golang/go-design-pattern/gdp-act/18-iterator/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式17-状态模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-act/17-state/"/>
      <url>/library/Golang/go-design-pattern/gdp-act/17-state/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言 Map 结构的底层实现</title>
      <link href="/library/Golang/advanced-tutorial/go-map/"/>
      <url>/library/Golang/advanced-tutorial/go-map/</url>
      
        <content type="html"><![CDATA[<h2 id="Golang-中的-map-详解"><a href="#Golang-中的-map-详解" class="headerlink" title="Golang 中的 map 详解"></a>Golang 中的 map 详解</h2><h3 id="一、什么是-map？"><a href="#一、什么是-map？" class="headerlink" title="一、什么是 map？"></a>一、什么是 map？</h3><h4 id="1、map-的定义"><a href="#1、map-的定义" class="headerlink" title="1、map 的定义"></a>1、map 的定义</h4><p>  在计算机科学里，被称为相关数组、map、符号表或者字典，是由一组 &lt;key, value&gt; 对组成的抽象数据结构，并且同一个 key 只会出现一次。<br>  两个关键点：map 是由 key-value 对组成的；key 只会出现一次。<br>  map 的设计也被称为 “The dictionary problem（字典问题）”，它的任务是设计一种数据结构用来维护一个集合的数据，并且可以同时对集合进行增删查改的操作。</p><h4 id="2、map-的数据结构"><a href="#2、map-的数据结构" class="headerlink" title="2、map 的数据结构"></a>2、map 的数据结构</h4><p>  最主要的数据结构有两种：哈希查找表（Hash table）、搜索树（Search tree）。</p><p>哈希查找表（Hash table）<br>  哈希查找表使用哈希函数将 key 分配到不同的桶（bucket，也就是数组的不同 index），开销主要在哈希函数的计算以及数组的常数访问时间，在很多场景下，哈希查找表的性能很高。</p><p>搜索树（Search tree）<br>  搜索树一般采用自平衡搜索树，包括：AVL 树，红黑树。<br>  哈希查找表的平均查找效率是 O(1)，最差是 O(N)，如果哈希函数设计的很好，最坏的情况基本不会出现。自平衡搜索树法的最差搜索效率是 O(logN)。遍历自平衡搜索树，返回的 key 序列，一般会按照从小到大的顺序；而哈希查找表则是乱序的。</p><h3 id="二、Golang-中-map-的类型"><a href="#二、Golang-中-map-的类型" class="headerlink" title="二、Golang 中 map 的类型"></a>二、Golang 中 map 的类型</h3><p>  Golang 中 map 是一个指针，占用 8 个字节。当使用 make 创建 map 时，底层调用的是 makemap() 函数，makemap() 函数返回的是一个指针，因为返回的是指针，所以 map 作为参数的时候，函数内部能修改map。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="三、map-的底层实现"><a href="#三、map-的底层实现" class="headerlink" title="三、map 的底层实现"></a>三、map 的底层实现</h3><p>   源码位于 src\runtime\map.go 中。</p><p>  golang 中 map 底层使用的是哈希查找表，用链表来解决哈希冲突。每个 map 的底层结构是 hmap，是由若干个结构为 bmap 的 bucket 组成的数组，每个 bucket 底层都采用链表结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.  </span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;  </span><br><span class="line"><span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.   </span></span><br><span class="line"><span class="comment">// Make sure this stays in sync with the compiler&#x27;s definition.   </span></span><br><span class="line">count     <span class="type">int</span>    <span class="comment">// map中元素的数量，调用len()直接返回此值  </span></span><br><span class="line">flags     <span class="type">uint8</span>  <span class="comment">// 状态标识符，key和value是否包指针、是否正在扩容、是否已经被迭代</span></span><br><span class="line">B         <span class="type">uint8</span>  <span class="comment">// map中桶数组的数量，桶数组的长度的对数，len(buckets) == 2^B，可以最多容纳 6.5 * 2 ^ B 个元素，6.5为装载因子  </span></span><br><span class="line">noverflow <span class="type">uint16</span> <span class="comment">// 溢出桶的大概数量，当B小于16时是准确值，大于等于16时是大概的值</span></span><br><span class="line">hash0     <span class="type">uint32</span> <span class="comment">// 哈希种子，用于计算哈希值，为哈希函数的结果引入一定的随机性</span></span><br><span class="line"></span><br><span class="line">buckets    unsafe.Pointer <span class="comment">// 指向桶数组的指针，长度为 2^B ，如果元素个数为0，就为 nil  </span></span><br><span class="line">oldbuckets unsafe.Pointer <span class="comment">// 指向一个旧桶数组，用于扩容，它的长度是当前桶数组的一半, 扩容时非空  </span></span><br><span class="line">nevacuate  <span class="type">uintptr</span>        <span class="comment">// 搬迁进度，小于此地址的桶数组迁移完成  </span></span><br><span class="line"></span><br><span class="line">extra *mapextra <span class="comment">// 可选字段，用于gc，指向所有的溢出桶，避免gc时扫描整个map，仅扫描所有溢出桶就足够了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mapextra holds fields that are not present on all maps.type </span></span><br><span class="line">mapextra <span class="keyword">struct</span> &#123;  </span><br><span class="line">   <span class="comment">// If both key and elem do not contain pointers and are inline, then we mark bucket  </span></span><br><span class="line">   <span class="comment">// type as containing no pointers. This avoids scanning such maps.  </span></span><br><span class="line">   <span class="comment">// However, bmap.overflow is a pointer. In order to keep overflow buckets   </span></span><br><span class="line">   <span class="comment">// alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow.   </span></span><br><span class="line">   <span class="comment">// overflow and oldoverflow are only used if key and elem do not contain pointers.   </span></span><br><span class="line">   <span class="comment">// overflow contains overflow buckets for hmap.buckets.  </span></span><br><span class="line">   <span class="comment">// oldoverflow contains overflow buckets for hmap.oldbuckets.  </span></span><br><span class="line">   <span class="comment">// The indirection allows to store a pointer to the slice in hiter.  </span></span><br><span class="line">   overflow    *[]*bmap  <span class="comment">// 指针数组，指向所有溢出桶</span></span><br><span class="line">   oldoverflow *[]*bmap  <span class="comment">// 指针数组，发生扩容时，指向所有旧的溢出桶</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// nextOverflow holds a pointer to a free overflow bucket.  </span></span><br><span class="line">   nextOverflow *bmap  <span class="comment">// 指向所有溢出桶中下一个可以使用的溢出桶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bmap的结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [bucketCnt]<span class="type">uint8</span>    <span class="comment">// bucketCnt=8，// 存放key哈希值的高8位，用于决定kv键值对放在桶内的哪个位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上编辑期间会动态生成一个新的结构体</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">topbits  [<span class="number">8</span>]<span class="type">uint8</span>     <span class="comment">// 存放key哈希值的高8位，用于决定kv键值对放在桶内的哪个位置</span></span><br><span class="line">keys     [<span class="number">8</span>]keytype   <span class="comment">// 存放key的数组</span></span><br><span class="line">values   [<span class="number">8</span>]valuetype <span class="comment">// 存放value的数组</span></span><br><span class="line">pad      <span class="type">uintptr</span>      <span class="comment">// 用于对齐内存</span></span><br><span class="line">overflow <span class="type">uintptr</span>      <span class="comment">// 指向下一个桶，即溢出桶，拉链法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buckets是一个bmap数组，数组的长度就是 2^B。每个bucket固定包含8个key和value，实现上面是一个固定的大小连续内存块，分成四部分：tophash 值，8个key值，8个value值，指向下个bucket的指针。</p><p>tophash 值用于快速查找key是否在该bucket中，当插入和查询运行时都会使用哈希哈数对key做哈希运算，获取一个hashcode，取高8位存放在bmap tophash字段中。</p><p>桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置）。</p><p>如图，B&#x3D;5 表示hmap的有2^5&#x3D;32个bmap，buckets是一个bmap数组，其长度为32，每个bmap有8个key。</p><p>桶结构的很多字段得在编译时才会动态生成，比如 key 和 values 等</p><p>桶结构中，之所以所有的 key 放一起，所有的 value 放一起，而不是 key&#x2F;value 一对对的一起存放，目的便是在某些情况下可以省去pad字段，节省内存空间。由于内存对齐的原因，key0&#x2F;value0&#x2F;key1&#x2F;value1… 这样的形式可能需要更多的补齐空间，比如 map[int64]int8 ，1字节的value后面需要补齐7个字节才能保证下一个key是 int64 对齐的。</p><p>golang中的map使用的内存是不会收缩的，只会越用越多。</p><p>每个 bucket 设计成最多只能放 8 个 key-value 对，如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个溢出桶 bucket ，通过 overflow 指针连接起来。</p><h3 id="四、map-的扩容"><a href="#四、map-的扩容" class="headerlink" title="四、map 的扩容"></a>四、map 的扩容</h3><h4 id="1、装载因子（平均每个桶存储的元素个数）"><a href="#1、装载因子（平均每个桶存储的元素个数）" class="headerlink" title="1、装载因子（平均每个桶存储的元素个数）"></a>1、装载因子（平均每个桶存储的元素个数）</h4><p>  Go的装载因子阈值常量：6.5，map 最多可容纳 6.5*2^B 个元素。</p><p>  装载因子等于 map中元素的个数 &#x2F; map的容量，即len(map) &#x2F; 2^B。装载因子用来表示空闲位置的情况，装载因子越大，表明空闲位置越少，冲突也越多。随着装载因子的增大，哈希表线性探测的平均用时就会增加，这会影响哈希表的性能，当装载因子大于70%，哈希表的性能就会急剧下降，当装载因子达到100%，整个哈希表就会完全失效，这个时候，查找和插入任意元素的复杂度都是O(N),因为需要遍历所有元素。</p><p>  另外装载因子与扩容、迁移等重新散列(rehash) 行为有直接关系：</p><p>在程序运行时，会不断地进行插入、删除等，会导致 bucket 不均，内存利用率低，需要迁移。<br>在程序运行时，出现装载因子过大，需要做扩容，解决 bucket 过大的问题。<br>为什么装载因子是6.5？不是8？不是1？<br>  装载因子是哈希表中的一个重要指标，主要目的是为了平衡 buckets 的存储空间大小和查找元素时的性能高低。实际上这是 Go 官方的经过认真的测试得出的数字，一起来看看官方的这份测试报告。包含四个指标：</p><p>loadFactor：负载因子，也叫装载因子；<br>%overflow：溢出率，有溢出 bukcet 的百分比；<br>bytes&#x2F;entry：平均每对 key&#x2F;alue 的开销字节数；<br>hitprobe：查找一个存在的 key 时，要查找的平均个数；<br>missprobe：查找一个不存在的 key 时，要查找的平均个数。</p><p>  Go 官方发现：装载因子越大，填入的元素越多，空间利用率就越高，但发生冲突的几率就变大；反之，装数因子越小，填入的元素越少，冲突发生的几率减小，但空间利用率低，而且还会提高扩容操作的次数。</p><p>  根据这份测试结果和讨论，Go 官方取了一个相对适中的值，把 Go 中的 map 的负数因子硬编码为 6.5，这就是 6.5 的选择缘由。这意味着在 Go 语言中，当 map存储的元素个数大于或等于 6.5*桶个数 时，就会发扩容行为。</p><h4 id="2、触发-map-扩容的时机（插入、删除key）"><a href="#2、触发-map-扩容的时机（插入、删除key）" class="headerlink" title="2、触发 map 扩容的时机（插入、删除key）"></a>2、触发 map 扩容的时机（插入、删除key）</h4><p>当装载因子超过6.5时，扩容一倍，属于增量扩容；<br>当使用的溢出桶过多时，重新分配一样大的内存空间，属于等量扩容；<br>（实际上没有扩容，主要是为了回收空闲的溢出桶，节省空间，提高 map 的查找和插入效率）<br>为什么会出现这种情况？<br>  这种情况可能是因为map删除的特性导致的。当我们不断向哈希表中插入数据，并且将他们又全部删除时，其内存占用并不会减少，因为删除只是将桶对应位置的tophash置nil而已。<br>  这种情况下，就会不断的积累溢出桶造成内存泄露，为了解决这种情况，采用了等量扩容的机制，一旦哈希表中出现了过多的溢出桶，会创建新桶保存数据，gc会清理掉老的溢出桶，从而避免内存泄露。</p><p>如何定义溢出桶是否太多需要等量扩容呢？两种情况：</p><p>当B小于15时，溢出桶的数量超过2^B，属于溢出桶数量太多，需要等量扩容；<br>当B大于等于15时，溢出桶数量超过2^15，属于溢出桶数量太多，需要等量扩容。</p><h4 id="3、扩容策略（怎么扩容？）"><a href="#3、扩容策略（怎么扩容？）" class="headerlink" title="3、扩容策略（怎么扩容？）"></a>3、扩容策略（怎么扩容？）</h4><p>  Go 会创建一个新的 buckets 数组，新的 buckets 数组的容量是旧buckets数组的两倍（或者和旧桶容量相同），将原始桶数组中的所有元素重新散列到新的桶数组中。这样做的目的是为了使每个桶中的元素数量尽可能平均分布，以提高查询效率。旧的buckets数组不会被直接删除，而是会把原来对旧数组的引用去掉，让GC来清除内存。</p><p>  在map进行扩容迁移的期间，不会触发第二次扩容。只有在前一个扩容迁移工作完成后，map才能进行下一次扩容操作。</p><h4 id="4、搬迁策略"><a href="#4、搬迁策略" class="headerlink" title="4、搬迁策略"></a>4、搬迁策略</h4><p>  由于map扩容需要将原有的kv键值对搬迁到新的内存地址，如果一下子全部搬完，会非常的影响性能。go 中 map 的扩容采用渐进式的搬迁策略，原有的 key 并不会一次性搬迁完毕，一次性搬迁会造成比较大的延时，每次最多只会搬迁 2 个 bucket，将搬迁的O(N)开销均摊到O(1)的赋值和删除操作上。</p><p>  上面说的 hashGrow() 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets 挂到了 oldbuckets 字段上。真正搬迁 buckets 的动作在 growWork() 函数中，而调用 growWork() 函数的动作是在 mapassign 和 mapdelete 函数中。也就是插入或修改、删除 key 的时候，都会尝试进行搬迁 buckets 的工作。先检查 oldbuckets 是否搬迁完毕，具体来说就是检查 oldbuckets 是否为 nil。</p><h3 id="五、解决哈希冲突"><a href="#五、解决哈希冲突" class="headerlink" title="五、解决哈希冲突"></a>五、解决哈希冲突</h3><h4 id="1、开放寻址法"><a href="#1、开放寻址法" class="headerlink" title="1、开放寻址法"></a>1、开放寻址法</h4><p>  如果发生哈希冲突，从发生冲突的那个单元起，按一定的次序，不断重复，从哈希表中寻找一个空闲的单元，将该键值对存储在该单元中。具体的实现方式包括线性探测法、平方探测法、随机探测法和双重哈希法等。开放寻址法需要的表长度要大于等于所需要存放的元素数量。</p><h4 id="2、链地址法"><a href="#2、链地址法" class="headerlink" title="2、链地址法"></a>2、链地址法</h4><p>  基于数组 + 链表 实现哈希表，数组中每个元素都是一个链表，将每个桶都指向一个链表，当哈希冲突发生时，新的键值对会按顺序添加到该桶对应的链表的尾部。在查找特定键值对时，可以遍历该链表以查找与之匹配的键值对。</p><h4 id="3、两种方案的比较"><a href="#3、两种方案的比较" class="headerlink" title="3、两种方案的比较"></a>3、两种方案的比较</h4><p>内存利用率<br>  对于链地址法，基于 数组 + 链表 进行存储，链表节点可以在需要时再创建，开放寻址法需要事先申请好足够内存，因此链地址法对内存的利用率高。<br>适用场景<br>  链地址法对装载因子的容忍度会更高，适合存储大对象、大数据量的哈希表，而且相较于开放寻址法，它更加灵活，支持更多的优化策略，比如可采用红黑树代替链表。但是链地址法需要额外的空间来存储指针。<br>  对于开放寻址法，它只有数组一种数据结构就可完成存储，继承了数组的优点，对CPU缓存友好，易于序列化操作，但是它对内存的利用率不高，且发生冲突时代价更高。当数据量明确、装载因子小，适合采用开放寻址法。</p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 进阶教程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 必看必会 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式16-职责链模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-act/16-chain/"/>
      <url>/library/Golang/go-design-pattern/gdp-act/16-chain/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式15-策略模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-act/15-strategy/"/>
      <url>/library/Golang/go-design-pattern/gdp-act/15-strategy/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式14-模板模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-act/14-template/"/>
      <url>/library/Golang/go-design-pattern/gdp-act/14-template/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式13-观察者模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-act/13-observer/"/>
      <url>/library/Golang/go-design-pattern/gdp-act/13-observer/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式12-享元模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-struct/12-flyweight/"/>
      <url>/library/Golang/go-design-pattern/gdp-struct/12-flyweight/</url>
      
        <content type="html"><![CDATA[<p>按照课程中的例子来理解，就是象棋棋子作为享元，可以被所有的对局共享，以达到减少内存的目的</p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式11-组合模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-struct/11-composite/"/>
      <url>/library/Golang/go-design-pattern/gdp-struct/11-composite/</url>
      
        <content type="html"><![CDATA[<p>比较简单的例子是 人员架构中 部门和人员的关系，二者可以形成简单的树形接口，部门中规定了一些功能；而人员又有自己的基本属性功能</p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式10-门面模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-struct/10-facade/"/>
      <url>/library/Golang/go-design-pattern/gdp-struct/10-facade/</url>
      
        <content type="html"><![CDATA[<p>简单来理解就是 有登录和注册两个基础功能，对外统一封装成 登录&amp;注册，上层调用无需知道具体调用的逻辑，只通过一个接口获取登录状态即可</p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式09-适配器模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-struct/09-adapter/"/>
      <url>/library/Golang/go-design-pattern/gdp-struct/09-adapter/</url>
      
        <content type="html"><![CDATA[<p>简单理解是有两个不同的业务系统，需要同时完成同一种业务动作，可以封装后统一提供给上层调用</p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式08-装饰器模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-struct/08-decorator/"/>
      <url>/library/Golang/go-design-pattern/gdp-struct/08-decorator/</url>
      
        <content type="html"><![CDATA[<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>下面是一个简单的画画的例子，默认的 <code>Line</code>  只有基础的画画功能， <code>ColorLine</code>  为他加上了颜色，本质上是对现有功能类进行包装，增加新功能点</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> decorator  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// IDraw IDraw  </span></span><br><span class="line"><span class="keyword">type</span> IDraw <span class="keyword">interface</span> &#123;  </span><br><span class="line">   Draw() <span class="type">string</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Line 划线  </span></span><br><span class="line"><span class="keyword">type</span> Line <span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Draw Draw  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Line)</span></span> Draw() <span class="type">string</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;Drawing a line here&quot;</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ColorLine 有颜色的线  </span></span><br><span class="line"><span class="keyword">type</span> ColorLine <span class="keyword">struct</span> &#123;  </span><br><span class="line">   line IDraw  </span><br><span class="line">   color  <span class="type">string</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// NewColorLine NewColorLine  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewColorLine</span><span class="params">(line IDraw, color <span class="type">string</span>)</span></span> ColorLine &#123;  </span><br><span class="line">   <span class="keyword">return</span> ColorLine&#123;color: color, line: line&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Draw Draw  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ColorLine)</span></span> Draw() <span class="type">string</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> c.line.Draw() + <span class="string">&quot;, color is &quot;</span> + c.color  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestColorLine_Draw</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">   l := Line&#123;&#125;  </span><br><span class="line">   ncl := NewColorLine(sq, <span class="string">&quot;red&quot;</span>)  </span><br><span class="line">   got := ncl.Draw()  </span><br><span class="line">   assert.Equal(t, <span class="string">&quot;Drawing a line here, color is red&quot;</span>, got)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式07-桥接模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-struct/07-bridge/"/>
      <url>/library/Golang/go-design-pattern/gdp-struct/07-bridge/</url>
      
        <content type="html"><![CDATA[<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bridge  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// IMsgSender IMsgSender  </span></span><br><span class="line"><span class="keyword">type</span> IMsgSender <span class="keyword">interface</span> &#123;  </span><br><span class="line">   Send(msg <span class="type">string</span>) <span class="type">error</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// EmailMsgSender 发送邮件  </span></span><br><span class="line"><span class="comment">// 可能还有 电话、短信等各种实现  </span></span><br><span class="line"><span class="keyword">type</span> EmailMsgSender <span class="keyword">struct</span> &#123;  </span><br><span class="line">   emails []<span class="type">string</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// NewEmailMsgSender NewEmailMsgSender  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEmailMsgSender</span><span class="params">(emails []<span class="type">string</span>)</span></span> *EmailMsgSender &#123;  </span><br><span class="line">   <span class="keyword">return</span> &amp;EmailMsgSender&#123;emails: emails&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Send Send  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EmailMsgSender)</span></span> Send(msg <span class="type">string</span>) <span class="type">error</span> &#123;  </span><br><span class="line">   <span class="comment">// 这里去发送消息  </span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// INotification 通知接口  </span></span><br><span class="line"><span class="keyword">type</span> INotification <span class="keyword">interface</span> &#123;  </span><br><span class="line">   Notify(msg <span class="type">string</span>) <span class="type">error</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ErrorNotification 错误通知  </span></span><br><span class="line"><span class="comment">// 后面可能还有 warning 各种级别  </span></span><br><span class="line"><span class="keyword">type</span> ErrorNotification <span class="keyword">struct</span> &#123;  </span><br><span class="line">   sender IMsgSender  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// NewErrorNotification NewErrorNotification  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewErrorNotification</span><span class="params">(sender IMsgSender)</span></span> *ErrorNotification &#123;  </span><br><span class="line">   <span class="keyword">return</span> &amp;ErrorNotification&#123;sender: sender&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Notify 发送通知  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *ErrorNotification)</span></span> Notify(msg <span class="type">string</span>) <span class="type">error</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> n.sender.Send(msg)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestErrorNotification_Notify</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">   sender := NewEmailMsgSender([]<span class="type">string</span>&#123;<span class="string">&quot;test@test.com&quot;</span>&#125;)  </span><br><span class="line">   n := NewErrorNotification(sender)  </span><br><span class="line">   err := n.Notify(<span class="string">&quot;test msg&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">   assert.Nil(t, err)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式06-代理模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-struct/06-proxy/"/>
      <url>/library/Golang/go-design-pattern/gdp-struct/06-proxy/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式05-创造者模式总结</title>
      <link href="/library/Golang/go-design-pattern/gdp-create/05-create-summarize/"/>
      <url>/library/Golang/go-design-pattern/gdp-create/05-create-summarize/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 创建型模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式04-原型模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-create/04-prototype/"/>
      <url>/library/Golang/go-design-pattern/gdp-create/04-prototype/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 创建型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式03-构造模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-create/03-builder/"/>
      <url>/library/Golang/go-design-pattern/gdp-create/03-builder/</url>
      
        <content type="html"><![CDATA[<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>其实在 Golang 中对于创建类参数比较多的对象的时候，我们常见的做法是必填参数直接传递，可选参数通过传递可变的方法进行创建。<br>本文会先实现课程中的建造者模式，然后再实现我们常用的方式。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>通过下面可以看到，使用 Go 编写建造者模式的代码其实会很长，这些是它的一个缺点，所以如果不是参数的校验逻辑很复杂的情况下一般我们在 Go 中不会采用这种方式，而会采用后面的另外一种方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> (  </span><br><span class="line">   defaultMaxTotal = <span class="number">10</span>  </span><br><span class="line">   defaultMaxIdle  = <span class="number">9</span>  </span><br><span class="line">   defaultMinIdle  = <span class="number">1</span>  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ResourcePoolConfig resource pooltype ResourcePoolConfig struct &#123;  </span></span><br><span class="line">   name     <span class="type">string</span>  </span><br><span class="line">   maxTotal <span class="type">int</span>  </span><br><span class="line">   maxIdle  <span class="type">int</span>  </span><br><span class="line">   minIdle  <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ResourcePoolConfigBuilder 用于构建 ResourcePoolConfig  </span></span><br><span class="line"><span class="keyword">type</span> ResourcePoolConfigBuilder <span class="keyword">struct</span> &#123;  </span><br><span class="line">   name     <span class="type">string</span>  </span><br><span class="line">   maxTotal <span class="type">int</span>  </span><br><span class="line">   maxIdle  <span class="type">int</span>  </span><br><span class="line">   minIdle  <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// SetName SetName  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span></span> SetName(name <span class="type">string</span>) <span class="type">error</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;name can not be empty&quot;</span>)  </span><br><span class="line">   &#125;  </span><br><span class="line">   b.name = name  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// SetMinIdle SetMinIdle  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span></span> SetMinIdle(minIdle <span class="type">int</span>) <span class="type">error</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> minIdle &lt; <span class="number">0</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;max tatal cannot &lt; 0, input: %d&quot;</span>, minIdle)  </span><br><span class="line">   &#125;  </span><br><span class="line">   b.minIdle = minIdle  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// SetMaxIdle SetMaxIdle  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span></span> SetMaxIdle(maxIdle <span class="type">int</span>) <span class="type">error</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> maxIdle &lt; <span class="number">0</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;max tatal cannot &lt; 0, input: %d&quot;</span>, maxIdle)  </span><br><span class="line">   &#125;  </span><br><span class="line">   b.maxIdle = maxIdle  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// SetMaxTotal SetMaxTotal  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span></span> SetMaxTotal(maxTotal <span class="type">int</span>) <span class="type">error</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> maxTotal &lt;= <span class="number">0</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;max tatal cannot &lt;= 0, input: %d&quot;</span>, maxTotal)  </span><br><span class="line">   &#125;  </span><br><span class="line">   b.maxTotal = maxTotal  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Build Build  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ResourcePoolConfigBuilder)</span></span> Build() (*ResourcePoolConfig, <span class="type">error</span>) &#123;  </span><br><span class="line">   <span class="keyword">if</span> b.name == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;name can not be empty&quot;</span>)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 设置默认值  </span></span><br><span class="line">   <span class="keyword">if</span> b.minIdle == <span class="number">0</span> &#123;  </span><br><span class="line">      b.minIdle = defaultMinIdle  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> b.maxIdle == <span class="number">0</span> &#123;  </span><br><span class="line">      b.maxIdle = defaultMaxIdle  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> b.maxTotal == <span class="number">0</span> &#123;  </span><br><span class="line">      b.maxTotal = defaultMaxTotal  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> b.maxTotal &lt; b.maxIdle &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;max total(%d) cannot &lt; max idle(%d)&quot;</span>, b.maxTotal, b.maxIdle)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> b.minIdle &gt; b.maxIdle &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;max idle(%d) cannot &lt; min idle(%d)&quot;</span>, b.maxIdle, b.minIdle)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> &amp;ResourcePoolConfig&#123;  </span><br><span class="line">      name:     b.name,  </span><br><span class="line">      maxTotal: b.maxTotal,  </span><br><span class="line">      maxIdle:  b.maxIdle,  </span><br><span class="line">      minIdle:  b.minIdle,  </span><br><span class="line">   &#125;, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;testing&quot;</span>  </span><br><span class="line">   <span class="string">&quot;github.com/stretchr/testify/assert&quot;</span>   </span><br><span class="line">   <span class="string">&quot;github.com/stretchr/testify/require&quot;</span></span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestResourcePoolConfigBuilder_Build</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">   tests := []<span class="keyword">struct</span> &#123;  </span><br><span class="line">      name    <span class="type">string</span>  </span><br><span class="line">      builder *ResourcePoolConfigBuilder  </span><br><span class="line">      want    *ResourcePoolConfig  </span><br><span class="line">      wantErr <span class="type">bool</span>  </span><br><span class="line">   &#125;&#123;  </span><br><span class="line">      &#123;  </span><br><span class="line">         name: <span class="string">&quot;name empty&quot;</span>,  </span><br><span class="line">         builder: &amp;ResourcePoolConfigBuilder&#123;  </span><br><span class="line">            name:     <span class="string">&quot;&quot;</span>,  </span><br><span class="line">            maxTotal: <span class="number">0</span>,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         want:    <span class="literal">nil</span>,  </span><br><span class="line">         wantErr: <span class="literal">true</span>,  </span><br><span class="line">      &#125;,  </span><br><span class="line">      &#123;  </span><br><span class="line">         name: <span class="string">&quot;maxIdle &lt; minIdle&quot;</span>,  </span><br><span class="line">         builder: &amp;ResourcePoolConfigBuilder&#123;  </span><br><span class="line">            name:     <span class="string">&quot;test&quot;</span>,  </span><br><span class="line">            maxTotal: <span class="number">0</span>,  </span><br><span class="line">            maxIdle:  <span class="number">10</span>,  </span><br><span class="line">            minIdle:  <span class="number">20</span>,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         want:    <span class="literal">nil</span>,  </span><br><span class="line">         wantErr: <span class="literal">true</span>,  </span><br><span class="line">      &#125;,  </span><br><span class="line">      &#123;  </span><br><span class="line">         name: <span class="string">&quot;success&quot;</span>,  </span><br><span class="line">         builder: &amp;ResourcePoolConfigBuilder&#123;  </span><br><span class="line">            name: <span class="string">&quot;test&quot;</span>,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         want: &amp;ResourcePoolConfig&#123;  </span><br><span class="line">            name:     <span class="string">&quot;test&quot;</span>,  </span><br><span class="line">            maxTotal: defaultMaxTotal,  </span><br><span class="line">            maxIdle:  defaultMaxIdle,  </span><br><span class="line">            minIdle:  defaultMinIdle,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         wantErr: <span class="literal">false</span>,  </span><br><span class="line">      &#125;,  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;  </span><br><span class="line">      t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">         got, err := tt.builder.Build()  </span><br><span class="line">         require.Equalf(t, tt.wantErr, err != <span class="literal">nil</span>, <span class="string">&quot;Build() error = %v, wantErr %v&quot;</span>, err, tt.wantErr)  </span><br><span class="line">         assert.Equal(t, tt.want, got)  </span><br><span class="line">      &#125;)  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go-常用的参数传递方法"><a href="#Go-常用的参数传递方法" class="headerlink" title="Go 常用的参数传递方法"></a>Go 常用的参数传递方法</h3><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ResourcePoolConfigOption option</span></span><br><span class="line"><span class="keyword">type</span> ResourcePoolConfigOption <span class="keyword">struct</span> &#123;  </span><br><span class="line">   maxTotal <span class="type">int</span>  </span><br><span class="line">   maxIdle  <span class="type">int</span>  </span><br><span class="line">   minIdle  <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ResourcePoolConfigOptFunc to set option</span></span><br><span class="line"><span class="keyword">type</span> ResourcePoolConfigOptFunc <span class="function"><span class="keyword">func</span><span class="params">(option *ResourcePoolConfigOption)</span></span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// NewResourcePoolConfig NewResourcePoolConfig  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewResourcePoolConfig</span><span class="params">(name <span class="type">string</span>, opts ...ResourcePoolConfigOptFunc)</span></span> (*ResourcePoolConfig, <span class="type">error</span>) &#123;  </span><br><span class="line">   <span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;name can not be empty&quot;</span>)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   option := &amp;ResourcePoolConfigOption&#123;  </span><br><span class="line">      maxTotal: <span class="number">10</span>,  </span><br><span class="line">      maxIdle:  <span class="number">9</span>,  </span><br><span class="line">      minIdle:  <span class="number">1</span>,  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;  </span><br><span class="line">      opt(option)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> option.maxTotal &lt; <span class="number">0</span> || option.maxIdle &lt; <span class="number">0</span> || option.minIdle &lt; <span class="number">0</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;args err, option: %v&quot;</span>, option)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> option.maxTotal &lt; option.maxIdle || option.minIdle &gt; option.maxIdle &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;args err, option: %v&quot;</span>, option)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> &amp;ResourcePoolConfig&#123;  </span><br><span class="line">      name:     name,  </span><br><span class="line">      maxTotal: option.maxTotal,  </span><br><span class="line">      maxIdle:  option.maxIdle,  </span><br><span class="line">      minIdle:  option.minIdle,  </span><br><span class="line">   &#125;, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;testing&quot;</span>  </span><br><span class="line">   <span class="string">&quot;github.com/stretchr/testify/assert&quot;</span>   </span><br><span class="line">   <span class="string">&quot;github.com/stretchr/testify/require&quot;</span></span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNewResourcePoolConfig</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">type</span> args <span class="keyword">struct</span> &#123;  </span><br><span class="line">      name <span class="type">string</span>  </span><br><span class="line">      opts []ResourcePoolConfigOptFunc  </span><br><span class="line">   &#125;  </span><br><span class="line">   tests := []<span class="keyword">struct</span> &#123;  </span><br><span class="line">      name    <span class="type">string</span>  </span><br><span class="line">      args    args  </span><br><span class="line">      want    *ResourcePoolConfig  </span><br><span class="line">      wantErr <span class="type">bool</span>  </span><br><span class="line">   &#125;&#123;  </span><br><span class="line">      &#123;  </span><br><span class="line">         name: <span class="string">&quot;name empty&quot;</span>,  </span><br><span class="line">         args: args&#123;  </span><br><span class="line">            name: <span class="string">&quot;&quot;</span>,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         want:    <span class="literal">nil</span>,  </span><br><span class="line">         wantErr: <span class="literal">true</span>,  </span><br><span class="line">      &#125;,  </span><br><span class="line">      &#123;  </span><br><span class="line">         name: <span class="string">&quot;success&quot;</span>,  </span><br><span class="line">         args: args&#123;  </span><br><span class="line">            name: <span class="string">&quot;test&quot;</span>,  </span><br><span class="line">            opts: []ResourcePoolConfigOptFunc&#123;  </span><br><span class="line">               <span class="function"><span class="keyword">func</span><span class="params">(option *ResourcePoolConfigOption)</span></span> &#123;  </span><br><span class="line">                  option.minIdle = <span class="number">2</span>  </span><br><span class="line">               &#125;,  </span><br><span class="line">            &#125;,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         want: &amp;ResourcePoolConfig&#123;  </span><br><span class="line">            name:     <span class="string">&quot;test&quot;</span>,  </span><br><span class="line">            maxTotal: <span class="number">10</span>,  </span><br><span class="line">            maxIdle:  <span class="number">9</span>,  </span><br><span class="line">            minIdle:  <span class="number">2</span>,  </span><br><span class="line">         &#125;,  </span><br><span class="line">         wantErr: <span class="literal">false</span>,  </span><br><span class="line">      &#125;,  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;  </span><br><span class="line">      t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">         got, err := NewResourcePoolConfig(tt.args.name, tt.args.opts...)  </span><br><span class="line">         require.Equalf(t, tt.wantErr, err != <span class="literal">nil</span>, <span class="string">&quot;error = %v, wantErr %v&quot;</span>, err, tt.wantErr)  </span><br><span class="line">         assert.Equal(t, tt.want, got)  </span><br><span class="line">      &#125;)  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发一些公共库的时候，对于入口参数的传递推荐后面一种方法，可以一定程度上避免参数变化破坏式更新的情况</p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 创建型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-连续固定区间最大值</title>
      <link href="/interview/interviewer/maximum-of-segments/"/>
      <url>/interview/interviewer/maximum-of-segments/</url>
      
        <content type="html"><![CDATA[<h1 id="连续固定区间最大值"><a href="#连续固定区间最大值" class="headerlink" title="连续固定区间最大值"></a>连续固定区间最大值</h1><ul><li>涉及知识点：堆，栈、双指针、滑动窗口，双向队列、线段树，树状数组, dp 等。</li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>nums</code> 和一个大小为 <code>k</code>的区间。这个区间可以从数组的最左侧不断移动到数组的最右侧。每个移动区间固定有 <code>k</code> 个数字。这个区间每次只向右移动一位。</p><p>让你返回移动过程中，这些固定区间中的最大值。</p><p>样例输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br></pre></td></tr></table></figure><p>样例输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,3,5,5,6,7]</span><br></pre></td></tr></table></figure><p>样例解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">          移动情况              最大值</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果候选人询问到数据范围，可提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.size() &lt;= 10^5</span><br><span class="line">-10^4 &lt;= nums[i] &lt;= 10^4</span><br><span class="line">1 &lt;= k &lt;= nums.size()</span><br></pre></td></tr></table></figure><h2 id="思路描述"><a href="#思路描述" class="headerlink" title="思路描述"></a>思路描述</h2><h3 id="思路-1：暴力滑动-O-n-2"><a href="#思路-1：暴力滑动-O-n-2" class="headerlink" title="思路 1：暴力滑动 O(n^2)"></a>思路 1：暴力滑动 O(n^2)</h3><p>暴力进行滑动窗口， 每次遍历当前窗口内的元素取最大值。</p><p>参考代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">find_maximum_of_sgements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + k &lt;= nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(*<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>() + i, nums.<span class="built_in">begin</span>() + i + k));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度 <code>O(n * k)～O(n^2)</code></li><li>空间复杂度 <code>O(n - k + 1)</code></li></ul><p><strong>这个是暴力解，非正确解，只能给 2 分，可提示次优解和最优解</strong></p><blockquote><p>优化提示 1：可以优化到低于 O(n^2) 的吗？比如 O(nlogn)，O(nlogk), 甚至是线性 O(n) 的做法。</p></blockquote><blockquote><p>优化提示 2：可以想到用一些可以维护极值的数据结构做吗？</p></blockquote><blockquote><p>优化提示 3：那如果拆分成子问题，快速求连续区间的最大值，你怎么做才会有带 log 的时间复杂度？</p></blockquote><p><strong>提示后，候选人还是不会。可换题。</strong></p><h3 id="思路-2：堆-O-nlogk"><a href="#思路-2：堆-O-nlogk" class="headerlink" title="思路 2：堆 O(nlogk)"></a>思路 2：堆 O(nlogk)</h3><p>维护一个大小为 <code>k</code> 的堆，向堆中插入一个元素(单个操作时间复杂度 <code>O(logk)</code>), 将数据不断 <code>push</code> 进堆，每次取结果都将 <code>top</code> 的数取出来就是序列答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">find_maximum_of_segments</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  priority_queue&lt; pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; pq;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">      pq.<span class="built_in">push</span>(&#123;nums[i],i&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = k;i &lt; nums.<span class="built_in">size</span>(); i++) &#123; </span><br><span class="line">      <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>() &amp;&amp; pq.<span class="built_in">top</span>().second &lt;= (i - k)) &#123;</span><br><span class="line">          pq.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      pq.<span class="built_in">push</span>(&#123;nums[i],i&#125;);</span><br><span class="line">      res.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().first);   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<code>O(nlogk)</code>, 候选人有可能写成<code>O(nlogn)</code>, 但问题不大。</li><li>空间复杂度：<code>O(k)</code>。</li></ul><p><strong>这个是正确解，但非最优解，可给 3 分，通过。</strong></p><h3 id="思路-3：双向队列-O-n"><a href="#思路-3：双向队列-O-n" class="headerlink" title="思路 3：双向队列 O(n)"></a>思路 3：双向队列 O(n)</h3><p>可以维护一个双向队列，这个队列是递减的。队列用来保存可能是最大值的数字的 <code>index</code>。<br>当前窗口最大值的 <code>index</code> 在队首，当窗口滑动时，会进入一个新值，出去一个旧值，不断更新给出当前窗口的最大值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">find_maximum_of_segments</span>(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> k) &#123;</span><br><span class="line">  deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">      <span class="comment">// 新元素入队时, 比队尾元素大的话则替代队尾元素</span></span><br><span class="line">      <span class="keyword">while</span>(!que.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[que.<span class="built_in">back</span>()])&#123;</span><br><span class="line">          que.<span class="built_in">pop_back</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 检查队首的 index 是否在窗口内，不在则出队</span></span><br><span class="line">      <span class="keyword">if</span>(!que.<span class="built_in">empty</span>() &amp;&amp; que.<span class="built_in">front</span>() &lt; i - k + <span class="number">1</span>) &#123;</span><br><span class="line">          que.<span class="built_in">pop_front</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      que.<span class="built_in">push_back</span>(i);</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= k <span class="number">-1</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(nums[que.<span class="built_in">front</span>()]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<code>O(n)</code>。</li><li>空间复杂度：<code>O(k)</code>。</li></ul><p><strong>这个是正确解，最优解，可给 4 分，通过。</strong></p><h3 id="思路-4：dynamic-programming"><a href="#思路-4：dynamic-programming" class="headerlink" title="思路 4：dynamic programming"></a>思路 4：dynamic programming</h3><p>先将数组分割成有 <code>k</code> 个元素的块。<br>建立数组 <code>left</code>,其中 <code>left[j]</code> 是从块的开始到下标 <code>j</code> 最大的元素，方向： <code>左-&gt;右</code>。<br>数组 <code>right</code>，其中 <code>right[j]</code> 是从块的结尾到下标 <code>j</code> 最大的元素，方向： <code>右-&gt;左</code>。</p><p>从左到右遍历数组，建立数组 <code>left</code>。</p><p>从右到左遍历数组，建立数组 <code>right</code>。</p><p>因为一个窗口 <code>[i, i + k - 1]</code> 最多跨越两个块，所以求窗口中的最大值就是求这个窗口跨越的块中的最大值，<br>可以知道，无论是跨越 1 个块也好，2 个块也好，计算处于边界的 <code>i</code> 和 <code>i + k - 1</code> 对应的值即可。</p><p><code>right[i]</code> 表示从块的结尾到下标 <code>j</code> 的最大的元素。</p><p><code>left[i + k - 1]</code> 表示从块的开始到下标 <code>i + k - 1</code> 的最大的元素。</p><p>这两个范围刚好是整个窗口。</p><p>所以窗口的最大值是 <code>max(right[i], left[i + k - 1])</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">find_maximum_of_segments</span>(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> k) &#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">right</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="type">int</span> max_num;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i % k == <span class="number">0</span>)&#123;</span><br><span class="line">          max_num = nums[i];</span><br><span class="line">      &#125;</span><br><span class="line">      max_num = <span class="built_in">max</span>(max_num, nums[i]);</span><br><span class="line">      left[i] = max_num;</span><br><span class="line">  &#125;</span><br><span class="line">  max_num = nums[n - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i % k == k - <span class="number">1</span>)&#123;</span><br><span class="line">          max_num = nums[i];</span><br><span class="line">      &#125;</span><br><span class="line">      max_num = <span class="built_in">max</span>(max_num, nums[i]);</span><br><span class="line">      right[i] = max_num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - k; i ++)&#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(<span class="built_in">max</span>(right[i], left[i + k - <span class="number">1</span>]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个是正确解，最优解，但比较难想到。可给 5 分，通过。</strong></p><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<code>O(n)</code>。</li><li>空间复杂度：<code>O(n)</code>。</li></ul><h2 id="其他思路参考"><a href="#其他思路参考" class="headerlink" title="其他思路参考"></a>其他思路参考</h2><p>以下解法比较特殊，而且编码比较复杂，如果真的有候选人在面试中写了，可以考虑给 5 分。</p><h3 id="思路-4-线段树-segment-tree"><a href="#思路-4-线段树-segment-tree" class="headerlink" title="思路 4: 线段树 (segment tree)"></a>思路 4: 线段树 (segment tree)</h3><p>比较裸的线段树维护极值的做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;tree;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushUp</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">  tree[rt] = <span class="built_in">max</span>(tree[<span class="number">1</span> &lt;&lt; rt], tree[<span class="number">1</span> &lt;&lt; rt | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l,<span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">    tree[rt] = nums[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span> &lt;&lt; rt, l, mid, nums);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span> &lt;&lt; rt | <span class="number">1</span>, mid + <span class="number">1</span>, r, nums);</span><br><span class="line">  <span class="built_in">pushUp</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l &gt; r) &#123;</span><br><span class="line">    <span class="keyword">return</span> INT_MIN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(l &gt; qr || r &lt; ql) &#123;</span><br><span class="line">    <span class="keyword">return</span> INT_MIN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// [ql [l, r] qr]</span></span><br><span class="line">  <span class="keyword">if</span>(l &gt;= ql &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">      <span class="keyword">return</span> tree[rt];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> left_val = <span class="built_in">query</span>(<span class="number">1</span> &lt;&lt; rt, l, mid, ql, qr);</span><br><span class="line">  <span class="type">int</span> right_val = <span class="built_in">query</span>(<span class="number">1</span> &lt;&lt; rt | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(left_val, right_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">find_maximum_of_segments</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">0</span> || n &lt; k) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  tree.<span class="built_in">resize</span>(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, nums);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + k - <span class="number">1</span> &lt; n; i++) &#123;</span><br><span class="line">      <span class="type">int</span> val = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, i, i + k - <span class="number">1</span>);</span><br><span class="line">      res.<span class="built_in">push_back</span>(val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<ul><li>建树：<code>O(n)</code>。</li><li>查询：<code>O(logn)</code></li></ul></li><li>空间复杂度：<code>O(3 * n)</code>。</li></ul><h3 id="思路-5：树状数组-fenwick-tree"><a href="#思路-5：树状数组-fenwick-tree" class="headerlink" title="思路 5：树状数组 (fenwick tree)"></a>思路 5：树状数组 (fenwick tree)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;val;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;tmp;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_VAL = <span class="number">1e5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">    val[x] = v;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">    <span class="type">int</span> lx = <span class="built_in">lowbit</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; lx; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      val[x] = <span class="built_in">max</span>(val[x], val[x - i]);</span><br><span class="line">    &#125;</span><br><span class="line">    x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(r &gt;= l) &#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;r = &quot; &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">    ans = <span class="built_in">max</span>(tmp[r - <span class="number">1</span>], ans);</span><br><span class="line">    r--;</span><br><span class="line">    <span class="keyword">while</span>(r &gt;= l + <span class="built_in">lowbit</span>(r))&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(val[r], ans);</span><br><span class="line">        r -= <span class="built_in">lowbit</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">find_maximum_of_segments</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  n = nums.<span class="built_in">size</span>();</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">0</span> || n &lt; k) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  val.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> num = nums[i] + MAX_VAL;</span><br><span class="line">    tmp.<span class="built_in">push_back</span>(num);</span><br><span class="line">    <span class="built_in">update</span>(i + <span class="number">1</span>, num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + k - <span class="number">1</span> &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> max_val = <span class="built_in">query</span>(i + <span class="number">1</span>, i + k);</span><br><span class="line">    res.<span class="built_in">push_back</span>(max_val - MAX_VAL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的时空复杂度分析如下：</p><ul><li>时间复杂度：<ul><li>建树：<code>O(n)</code>。</li><li>查询：<code>O(logn)</code></li></ul></li><li>空间复杂度：<code>O(3 * n)</code>。</li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>如果遇到水平比较高的候选人，比如具有 OI 或者 ACM 经历且实力比较强的候选人。</p><p>候选人只需要口述解法即可。</p><p>可将上面题目改编成：</p><p>题意不变，同样是给你一个数组 <code>nums = [1,3,-1,-3,5,3,6,7]</code> 和 一个 <code>t</code>, <code>t</code> 代表查询次数。<br>即存在多组查询，每次查询给你不一样的 <code>k</code>, 让你输出每个查询区间为 <code>k</code> 的区间的答案序列。</p><p>数据范围：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.size() &lt;= 10^5</span><br><span class="line">-10^4 &lt;= nums[i] &lt;= 10^4</span><br><span class="line">1 &lt;= k &lt;= nums.size()</span><br><span class="line">1 &lt;= t &lt;= 10^3</span><br></pre></td></tr></table></figure><p>样例输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,5,3,6,7], t = 5</span><br><span class="line">k = 2</span><br><span class="line">k = 3</span><br><span class="line">k = 4</span><br><span class="line">k = 5</span><br><span class="line">k = 6</span><br></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 3 -1 5 5 6 7</span><br><span class="line">3 3 5 5 6 7 </span><br><span class="line">3 5 5 6 7 </span><br><span class="line">5 5 6 7 </span><br><span class="line">5 6 7</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h3><p>这种属于比较经典的 RMQ (Range Minimum&#x2F;Maximum Query) 问题。</p><p>可以使用一种数据结构 <code>Sparse Tables</code> 来解决。</p><p>该数据结构可在 <code>O(nlogn)</code> 内完成数据预处理， 在 <code>O(1)</code> 内完成查询。</p><ul><li>时间复杂度：<ul><li>预处理：<code>O(nlogn)</code>。</li><li>查询：<code>O(1)</code></li></ul></li><li>空间复杂度：<code>O(nlogn)</code>。</li></ul><p>代码参考：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> M;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">(vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;&amp;dp, vector&lt;<span class="type">int</span>&gt;&amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">          dp[i][j] = <span class="built_in">max</span>(dp[i][j<span class="number">-1</span>], dp[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;&amp;dp, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> k = (<span class="type">int</span>) (<span class="built_in">log</span>(r - l + <span class="number">1</span>) / <span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(dp[l][k], dp[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_maximum_of_segments</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  M = (<span class="type">int</span>) (<span class="built_in">log</span>(n) / <span class="built_in">log</span>(<span class="number">2</span>)) + <span class="number">1</span>; </span><br><span class="line">  vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(M + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">  <span class="built_in">prepare</span>(dp, nums);</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + k - <span class="number">1</span> &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(<span class="built_in">query</span>(dp, i, i + k - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: res) &#123;</span><br><span class="line">      cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试官 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-移掉K位数字</title>
      <link href="/interview/interviewer/remove-the-k-digit/"/>
      <url>/interview/interviewer/remove-the-k-digit/</url>
      
        <content type="html"><![CDATA[<h1 id="移掉K位数字-leetcode-402"><a href="#移掉K位数字-leetcode-402" class="headerlink" title="移掉K位数字-leetcode-402"></a>移掉K位数字-leetcode-402</h1><ul><li>涉及知识点：贪心,栈</li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。  </p><p>注意:  </p><ul><li>num 的长度小于 10002 且 ≥ k。  </li><li>num 不会包含任何前导零。</li></ul><p>输入&#x2F;输出示例：  </p><p>Example 1:  </p><p>Input:   </p><pre><code>num = &quot;1432219&quot;, k = 3  </code></pre><p>Output:   </p><pre><code>&quot;1219&quot;  </code></pre><p>Explanation: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。  </p><p>Example 2:  </p><p>Input:   </p><pre><code>num = &quot;10200&quot;, k = 1  </code></pre><p>Output:   </p><pre><code>&quot;200&quot;  </code></pre><p>Explanation: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。  </p><p>Example 3:  </p><p>Input:   </p><pre><code>num = &quot;10&quot;, k = 2  </code></pre><p>Output:   </p><pre><code>&quot;0&quot;  </code></pre><p>Explanation: 从原数字移除所有的数字，剩余为空就是0。  </p><h2 id="思路描述"><a href="#思路描述" class="headerlink" title="思路描述"></a>思路描述</h2><h2 id="思路-0"><a href="#思路-0" class="headerlink" title="思路 0"></a>思路 0</h2><p>详细描述：思路，从左到右，找第一个比后面大的字符，删除，清零，k次扫描。  </p><ul><li>时间复杂度：o(n*k)  </li><li>空间复杂度：o(1)</li></ul><p>代码：  </p><pre><code class="java">class Solution &#123;      public String removeKdigits(String num, int k) &#123;        if (num.length() == k) return &quot;0&quot;;        StringBuilder s = new StringBuilder(num);        for (int i = 0; i &lt; k; i++) &#123;            int idx = 0;            for (int j = 1; j &lt; s.length() &amp;&amp; s.charAt(j) &gt;= s.charAt(j - 1); j++) idx = j;            s.delete(idx, idx + 1);            while (s.length() &gt; 1 &amp;&amp; s.charAt(0) == &#39;0&#39;) s.delete(0, 1);        &#125;        return s.toString();    &#125;&#125;  </code></pre><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h3><p>详细描述：在一定的范围内逐步选取最小的数字。<br>  </p><ol><li>在第一次循环中，num &#x3D; 1432219, k&#x3D;3，此时我们要删去k&#x3D;3个数字，保留n-k&#x3D;7-3&#x3D;4个数字。  </li><li>最终要挑选4个字符，那么我们先来挑选 千位 的字符，，由于挑选完千位后还需要挑选百位，十位，个位这三个位置的字符，所以千位能选择的范围只能在1432之间,因为要留出末尾的219这三个字符供百位、十位、个位 去挑选。  </li><li>1432中最小的值是1，所以千位的值选好了，就是1，接下来就是从千位后面的432219中去挑选百位值，可以发现挑选每一位的值是一个递归的过程。  </li><li>start &#x3D; 0, end &#x3D; k。也就是要在[start,end]中选取一个最小的进行保留，返回最小数字的下标minIndex。而在下次循环中，start &#x3D; minIndex+1, end++ ，也就是在[start,end]中选择下一个最小的数字。以此类推，直至所有数字都选取完毕。</li></ol><p>注意：当返回的下标minIndex及后面的字符串的长度 &#x3D; 还需要保留的字符串的长度的时候，直接返回  </p><ul><li>时间复杂度：o(n*k)  </li><li>空间复杂度：o(1)</li></ul><p>代码：  </p><pre><code class="go">func removeKdigits(num string, k int) string &#123;      if 0 == k &#123;        return num    &#125;    if k == len(num) &#123;        return &quot;0&quot;    &#125;    result := &quot;&quot;    i := len(num)-k    for &#123;        if i == 0 &#123;            break        &#125;        minIndex := 0        for  j := 0; j &lt; len(num)-(i-1); j++ &#123;            if num[j] &lt; num[minIndex] &#123;                minIndex = j            &#125;        &#125;        // 优化        if len(num)- minIndex == i &#123;            result = result + num[minIndex:]            break        &#125;        result += num[minIndex:minIndex+1]        num = num[minIndex+1:]        i--    &#125;    // 前导0    ans := strings.TrimLeft(result, &quot;0&quot;)    if ans == &quot;&quot; &#123;        ans = &quot;0&quot;    &#125;    return ans&#125;    </code></pre><h3 id="思路2-贪心-单调栈（一般可用-栈、队列、双端队列、双指针-实现）"><a href="#思路2-贪心-单调栈（一般可用-栈、队列、双端队列、双指针-实现）" class="headerlink" title="思路2: 贪心 + 单调栈（一般可用 栈、队列、双端队列、双指针 实现）"></a>思路2: 贪心 + 单调栈（一般可用 栈、队列、双端队列、双指针 实现）</h3><p>详细描述：  </p><ul><li><p>遍历字符串，逐个入栈,若新来的比栈顶小，则栈顶出栈 ,出栈相当于移除动作，需次数并与 k 比较，别删多了  </p></li><li><p>移除头部零有 ‘0’,全空，return “0”,构建字符串，顺序返回整个单调栈元素.  </p></li><li><p>时间复杂度：o(n+k)  </p></li><li><p>空间复杂度：o(n)</p></li></ul><p>代码：  </p><pre><code class="go">func removeKdigits(num string, k int) string &#123;      stack := []byte&#123;&#125;        for i := range num &#123;        digit := num[i]        for k &gt; 0 &amp;&amp; len(stack) &gt; 0 &amp;&amp; digit &lt; stack[len(stack)-1] &#123;            stack = stack[:len(stack)-1]            k--                &#125;        stack = append(stack, digit)     &#125;    stack = stack[:len(stack)-k]    ans := strings.TrimLeft(string(stack), &quot;0&quot;)    if ans == &quot;&quot; &#123;        ans = &quot;0&quot;        &#125;    return ans&#125;  </code></pre><h4 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h4><ul><li>提出思路0，能正确分析时空复杂度(2分)  </li><li>提出思路1，能正确分析时空复杂度(3分)  </li><li>提出思路2，能正确分析时空复杂度(4分)  </li><li>bugfree且代码简洁(5分)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试官 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试官101</title>
      <link href="/interview/interviewer/interviewer101/"/>
      <url>/interview/interviewer/interviewer101/</url>
      
        <content type="html"><![CDATA[<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a><strong>面试</strong></h3><h4 id="算法能力-一题5-10min"><a href="#算法能力-一题5-10min" class="headerlink" title="算法能力 一题5-10min :"></a>算法能力 一题5-10min :</h4><ol><li>题目：仅出现一次的数</li><li>题目：连续固定区间最大值<br>给你一个数组 nums 和一个大小为 k的区间。这个区间可以从数组的最左侧不断移动到数组的最右侧。每个移动区间固定有 k 个数字。这个区间每次只向右移动一位。<br>让你返回移动过程中，这些固定区间中的最大值。</li></ol><p>样例输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br></pre></td></tr></table></figure><p>样例输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,3,5,5,6,7]</span><br></pre></td></tr></table></figure><p>样例解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">移动情况 最大值</span><br><span class="line"></span><br><span class="line">[1 3 -1] -3 5 3 6 7 3</span><br><span class="line"></span><br><span class="line">1 [3 -1 -3] 5 3 6 7 3</span><br><span class="line"></span><br><span class="line">1 3 [-1 -3 5] 3 6 7 5</span><br><span class="line"></span><br><span class="line">1 3 -1 [-3 5 3] 6 7 5</span><br><span class="line"></span><br><span class="line">1 3 -1 -3 [5 3 6] 7 6</span><br><span class="line"></span><br><span class="line">1 3 -1 -3 5 [3 6 7] 7</span><br></pre></td></tr></table></figure><ol start="3"><li>拓展</li></ol><p>样例输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,5,3,6,7], t = 5</span><br><span class="line">k = 2</span><br><span class="line">k = 3</span><br><span class="line">k = 4</span><br><span class="line">k = 5</span><br><span class="line">k = 6</span><br></pre></td></tr></table></figure><p>样例输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 3 -1 5 5 6 7</span><br><span class="line">3 3 5 5 6 7</span><br><span class="line">3 5 5 6 7</span><br><span class="line">5 5 6 7</span><br><span class="line">5 6 7</span><br></pre></td></tr></table></figure><h4 id="基础能力"><a href="#基础能力" class="headerlink" title="基础能力"></a>基础能力</h4><h6 id="Go八股"><a href="#Go八股" class="headerlink" title="Go八股"></a>Go八股</h6><p><a href="https://www.topgoer.cn/docs/gomianshiti/gomianshiti-1dd225t6esqld">https://www.topgoer.cn/docs/gomianshiti/gomianshiti-1dd225t6esqld</a></p><h6 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h6><ol><li><p>Redis是单线程的，但Redis为什么这么快？</p><ul><li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</li><li>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li><li>使用多路I&#x2F;O复用模型，非阻塞IO；这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程</li><li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</li></ul></li><li><p>缓存穿透和雪崩的解决方案</p></li><li><p>请简述Reids的删除策略</p><ul><li>定时删除：在设置键的过期时间的同时，创建一个定时任务，当键达到过期时间时，立即执行对键的删除操作</li><li>惰性删除：放任键过期不管，但在每次从键空间获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，如果没有过期，就返回该键</li><li>定期删除：每隔一点时间，程序就对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li></ul><ol start="3"><li>索引的构建流程？</li><li>b树，b+树区别，MongoDB为什么选用b树</li></ol></li></ol><h6 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h6><ol><li>CPU三级缓存</li><li>进程与线程<ul><li>进程: 进程是具有一定独立功能的程序，进程是系统资源分配和调度的最小单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</li><li>线程: 线程是进程的一个实体,线程是内核态,而且是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</li><li>协程: 协程是一种用户态的轻量级线程，协程的调度完全是由用户来控制的。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</li></ul></li></ol><h6 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h6><ol><li><p>创建索引的规则：最左匹配，区分度等</p></li><li><p>索引失效的情况</p><ul><li>未遵循最佳左前缀规则导致索引失效</li><li>计算、函数、类型转换(自动或手动)导致索引失效</li><li>范围条件右边列索引失效</li><li>不等于(!&#x3D;)会导致索引失效</li><li>is null可以用到索引，is not null不能用到索引</li><li>like以通配符%开头索引失效</li><li>or 前的列建立了索引 or后面的列没有建立索引 会导致索引失效</li><li>不同字符集进行比较前需要进行转换，会导致索引失效</li></ul></li><li><p>数据的存储方式： B+树</p><ul><li>非叶子节点不存储数据，只存索引（冗余），这样可以保证存放更多的索引</li><li>叶子节点存储所有索引字段</li><li>叶子节点用指针连接，提高区间访问性能<br> ![[Pasted image 20221201183525.png]]</li></ul></li><li><p>大数据量级的mysql，如何分库分表？解决方案？</p></li><li><p>网络这些可以挑一两个主题聊。</p></li><li><p>自我介绍，告知规则与流程：两个部分：算法题 &amp; 聊一聊基础问题</p></li><li><p>先介绍下自己；主要技能，常用语言，工作经历简单叙述</p></li><li><p>项目：支付相关，幂等？</p></li><li><p>发过去在线文档</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试官 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试官 </tag>
            
            <tag> 初学者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-仅出现一次的元素</title>
      <link href="/interview/interviewer/single-numbers/"/>
      <url>/interview/interviewer/single-numbers/</url>
      
        <content type="html"><![CDATA[<h1 id="仅出现一次的元素"><a href="#仅出现一次的元素" class="headerlink" title="仅出现一次的元素"></a>仅出现一次的元素</h1><ul><li>涉及知识点：散列表、位运算</li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>（英文）<br>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.  </p><p>For example:  </p><p>Given nums &#x3D; [1, 2, 1, 3, 2, 5], return [3, 5].  </p><p>Note:  </p><ol><li>The order of the result is not important. So in the above example, [5, 3] is also correct.</li></ol><p>（中文）<br>给定一个整数数组，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出仅出现一次的那两个元素。要求时间复杂度在O(N)内。  </p><p>示例输入:  </p><pre><code>[1, 2, 1, 3, 2, 5]  </code></pre><p>示例输出：  </p><pre><code>[3, 5]  </code></pre><h2 id="思路描述"><a href="#思路描述" class="headerlink" title="思路描述"></a>思路描述</h2><h3 id="思路1：排序-遍历"><a href="#思路1：排序-遍历" class="headerlink" title="思路1：排序+遍历"></a>思路1：排序+遍历</h3><p>对序列排序，后遍历所有元素，通过相邻元素是否有相同值来判断是否满足条件，输出。  </p><p>常规排序方案的时空复杂度如下：  </p><ul><li>时间复杂度 <code>O(N*log(N))</code>  </li><li>空间复杂度 <code>O(1)</code></li></ul><p>此时解法不满足要求，可给到2分，若能给出计数排序（时间复杂度O(N)）法，可给到3分。  </p><h3 id="思路2：散列表-遍历"><a href="#思路2：散列表-遍历" class="headerlink" title="思路2：散列表+遍历"></a>思路2：散列表+遍历</h3><p>遍历每个元素，使用散列表存储元素值到数量的映射关系，再遍历散列表找出其中value为1的key，输出。  </p><p>该方案的时空复杂度分析如下：  </p><ul><li>时间复杂度 <code>O(N)</code>  </li><li>空间复杂度 <code>O(N)</code></li></ul><p>此时为次优解，可延伸提问对散列表的理解（如遍历结果是否有序，两个元素输出顺序是否确定），回答正确可给到4分  </p><h3 id="思路3：位运算"><a href="#思路3：位运算" class="headerlink" title="思路3：位运算"></a>思路3：位运算</h3><p>遍历元素，使用异或运算可消除相同的元素，得到所求两个元素的异或结果，从中找出二进制为1的最低位数字，再遍历一次，求出其中一个元素，再与前面结果异或得到另一个元素，输出。  </p><p>该方案的时空复杂度分析如下：  </p><ul><li>时间复杂度 <code>O(N)</code>  </li><li>空间复杂度 <code>O(1)</code></li></ul><p>此为最优解，可给到5分  </p><h2 id="解法示例"><a href="#解法示例" class="headerlink" title="解法示例"></a>解法示例</h2><p><a href="./single-numbers/sortSolution.go">排序+遍历</a>  </p><p><a href="./single-numbers/hashSolution.go">hash+遍历</a>  </p><p><a href="./single-numbers/bitSolution.go">位运算</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试官 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/%E8%BD%AF%E5%AE%9E%E5%8A%9B/1/"/>
      <url>/%E8%BD%AF%E5%AE%9E%E5%8A%9B/1/</url>
      
        <content type="html"><![CDATA[<h1 id="软实力"><a href="#软实力" class="headerlink" title="软实力"></a>软实力</h1><h2 id="主动性，责任心"><a href="#主动性，责任心" class="headerlink" title="主动性，责任心"></a>主动性，责任心</h2><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>主动推进自己参与的每一个项目，将自己看作是每一个项目的负责人，以项目负责人的角度去看待事情，一方面能够让自己更好的做事情，另一方面也能培养自己的项目推动能力</p><h3 id="个人事务"><a href="#个人事务" class="headerlink" title="个人事务"></a>个人事务</h3><p>转介绍相关链路很长，用户从看到第三方广告开始，到最终成为忠实用户</p><h2 id="抗压能力–》有所进步，还需加强"><a href="#抗压能力–》有所进步，还需加强" class="headerlink" title="抗压能力–》有所进步，还需加强"></a>抗压能力–》有所进步，还需加强</h2><p>这一点我最初做的不够好，现在相对而言已经做的不错，总体经验如下</p><p><strong>学会区分事情的轻重缓急，不那么紧急的事情就先放着，不去理会，集中精神解决掉紧急的事情，然后以平和的心态去解决那些不紧急的</strong></p><p>可能说起来简单，但是具体如何实施，还是要自己多经历</p><h2 id="沟通能力–》在沟通中的谦逊没有问题，一向是自己错了就是错了不找接口，但是有时候事情多了，语气会急躁，有所注意和改进，还需要继续努力"><a href="#沟通能力–》在沟通中的谦逊没有问题，一向是自己错了就是错了不找接口，但是有时候事情多了，语气会急躁，有所注意和改进，还需要继续努力" class="headerlink" title="沟通能力–》在沟通中的谦逊没有问题，一向是自己错了就是错了不找接口，但是有时候事情多了，语气会急躁，有所注意和改进，还需要继续努力"></a>沟通能力–》在沟通中的谦逊没有问题，一向是自己错了就是错了不找接口，但是有时候事情多了，语气会急躁，有所注意和改进，还需要继续努力</h2><h3 id="保证沟通的高效性"><a href="#保证沟通的高效性" class="headerlink" title="保证沟通的高效性"></a>保证沟通的高效性</h3><p>低效的沟通不仅会让你烦，也会让沟通对象感到烦，当发现打字已经说不清楚事情的时候可以考虑直接语音，或者直接当面对接。</p><h3 id="沟通过程保持谦逊和平和"><a href="#沟通过程保持谦逊和平和" class="headerlink" title="沟通过程保持谦逊和平和"></a>沟通过程保持谦逊和平和</h3><h4 id="方案沟通"><a href="#方案沟通" class="headerlink" title="方案沟通"></a>方案沟通</h4><p>与他人沟通过程中难免有所争执，要能明确的从对方的角度思考，对方说的一些解决方案你可能一开始不认可，但是别人既然这么说了就一定有他这么说的原因，可以先问清楚，是不是有什么历史遗留问题或者业务场景，导致他要采用你不认可的方案，如果发现确实是对方思考不周，然后可以提供自己的想法，互相沟通，总会达成一致。</p><h4 id="接受自己不足"><a href="#接受自己不足" class="headerlink" title="接受自己不足"></a>接受自己不足</h4><p>不要有自己绝对不能犯错的思想，有时候明明是你的问题或者就是你能力不足没有思考到一些东西，被同事当面指出，这时候要保持谦逊的心，不要硬抗，这没有任何意义，错了就是错了，没有想到就是没有想到，接受别人的指责，然后反省进步即可，硬抗对他人对自己都不是一个好的方式。</p><h1 id="一些好的工作习惯和建议"><a href="#一些好的工作习惯和建议" class="headerlink" title="一些好的工作习惯和建议"></a>一些好的工作习惯和建议</h1><p><strong>1.事事有回音</strong></p><p>这一点很多鸡汤文都有写，但是真的很重要，所以在此放在第一个强调。</p><p>交给你的任务，你做到哪一步，一定要让给你布置的人心里有数，或者说你打算什么时候做完，也一定要给一个deadline，若是长久没有回音，或者最后出了岔子，难免就会留下不靠谱的印象。</p><p><strong>2.跟事情要跟到底</strong></p><p>让你跟一件事情，就要跟到底，中间如果遇到阻碍发现事情没有进展，就要想办法去解决，如果实在解决不了，就要跟向你布置任务的人主动沟通，最起码我们组内达成共识得出一个结论。</p><p><strong>3.不只是完成任务</strong></p><p> 以高标准要求自己，在完成任务的同时能否做的更好，或者说给我的方案是这样，我能否想出更好的方案，在这样的思考中自己的能力也会有所提升。</p><p><strong>4.高效</strong></p><p>一个任务，他花费多少时间，大家心里一般都有数，如果这个任务一般只花费一天，结果你做了两天，三天还没有做好，那一定是你的问题，还有的情况是因为其他事情多，所以设置了deadline，但是出现一拖再拖，到了deadline还继续往下拖的情况，那最起码也是你对自己时间规划不清楚所造成的问题，哪怕自己加班也不能出现因为自己导致项目block的情况，这是我对我自己的要求。</p><p><strong>5.团队配合</strong></p><p>不要怕问问题，但是要问对的问题。</p><p>当出现了问题，一定要先判定问题的范畴，是技术问题，还是非技术问题。</p><p>技术问题当然要靠自己搜资料和想办法解决，但是可以分情况给自己一个时间限制，比如我手上还有很多事情，我已经花了一个小时，还是解决不了这个问题，但是我这边该做的都做了，实在找不到问题了，问了避免浪费时间可以考虑求助一下资深同事或者自己组内的leader。</p><p>非技术问题，可能是我们公司的组件，或者相关的技术规范导致，是一种你知道了就知道了，不知道就无法解决的问题，完全没有下手思路，这种问题可以给自己的时间限制少一些，比如10分钟，当然在提问之前也要确定自己把该做的排查都做了，然后去问一下知道的人。</p><p>于我们组而言，大家都是比较平和的人，所以不要怕问问题，但是也不要问浪费大家时间的低级问题。</p><p><strong>6.不当传话筒</strong></p><p>组内负责的服务很多，有的业务不了解每个人负责的范畴会出现问错人的情况，如果这个问题你恰好也知道可以协助做答，不过作答后也要跟业务明确负责这问题的人其实是谁，不让以后所有这些问题都可能会先问你，如果你不清楚，就不要做传话筒，可以直接拉群或者直接告诉业务方应该问谁，不要转发问题，这样业务方跟问题负责人的沟通中就多加了一层你，有时候业务方对服务了解不清楚，问的问题本身就不正确，你还协助传达，那就是在浪费所有人的时间。</p>]]></content>
      
      
      <categories>
          
          <category> 软实力 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>序</title>
      <link href="/library/Golang/go-design-pattern/startup/"/>
      <url>/library/Golang/go-design-pattern/startup/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Go 设计模式实现，包含 23 种常见的设计模式实现，同时这也是 <a href="https://time.geekbang.org/column/intro/250">极客时间-设计模式之美</a> 的笔记</li><li>一些基础原则和思想</li></ul><h3 id="“好”代码的几个标准"><a href="#“好”代码的几个标准" class="headerlink" title="“好”代码的几个标准"></a>“好”代码的几个标准</h3><ol><li>如何评价代码质量的高低？<br>代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁等，这些词汇是从不同的维度去评价代码质量的。它们之间有互相作用，并不是独立的，比如，代码的可读性好、可扩展性好就意味着代码的可维护性好。代码质量高低是一个综合各种因素得到的结论。我们并不能通过单一的维度去评价一段代码的好坏。</li><li>最常用的评价标准有哪几个？<br>最常用到几个评判代码质量的标准是：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。</li><li>如何才能写出高质量的代码？<br>要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等等</li></ol>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper 面试必备 100 题</title>
      <link href="/interview/100prob/zookeeper-interview-100/"/>
      <url>/interview/100prob/zookeeper-interview-100/</url>
      
        <content type="html"><![CDATA[<h1 id="1-ZooKeeper是什么？"><a href="#1-ZooKeeper是什么？" class="headerlink" title="1. ZooKeeper是什么？"></a>1. ZooKeeper是什么？</h1><p>ZooKeeper是一个开放源码的分布式协调服务，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p><p>分布式应用程序可以基于Zookeeper实现诸如数据发布&#x2F;订阅、负载均衡、命名服务、分布式协调&#x2F;通知、集群管理、Master选举、分布式锁和分布式队列等功能。</p><p>Zookeeper保证了如下分布式一致性特性：</p><ul><li>顺序一致性</li><li>原子性</li><li>单一视图</li><li>可靠性</li><li>实时性（最终一致性）</li></ul><p>客户端的读请求可以被集群中的任意一台机器处理，<strong>如果读请求在节点上注册了监听器，这个监听器也是由所连接的 zookeeper 机器来处理</strong>。对于写请求，这些请求会同时发给其他 zookeeper 机器并且达成一致后，请求才会返回成功。因此，随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。</p><p>有序性是 zookeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为 zxid（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个 zookeeper 最新的 zxid。</p><h1 id="2-ZooKeeper提供了什么？"><a href="#2-ZooKeeper提供了什么？" class="headerlink" title="2. ZooKeeper提供了什么？"></a>2. ZooKeeper提供了什么？</h1><p>1、文件系统 2、通知机制</p><h1 id="3-Zookeeper文件系统"><a href="#3-Zookeeper文件系统" class="headerlink" title="3. Zookeeper文件系统"></a>3. Zookeeper文件系统</h1><p>Zookeeper 提供一个多层级的节点命名空间（节点称为znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。 Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，<strong>这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为1M</strong>。</p><h1 id="4-ZAB协议？"><a href="#4-ZAB协议？" class="headerlink" title="4. ZAB协议？"></a>4. ZAB协议？</h1><p>ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。</p><p>ZAB 协议包括两种基本的模式：崩溃恢复和消息广播。</p><p>当整个 zookeeper 集群刚刚启动或者 Leader 服务器宕机、重启或者网络故障导致不存在过半的服务器与 Leader 服务器保持正常通信时，所有进程（服务器）进入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步，当集群中超过半数机器与该 Leader 服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。</p><h1 id="5-四种类型的数据节点-Znode"><a href="#5-四种类型的数据节点-Znode" class="headerlink" title="5. 四种类型的数据节点 Znode"></a>5. 四种类型的数据节点 Znode</h1><ul><li>PERSISTENT-持久节点 除非手动删除，否则节点一直存在于 Zookeeper 上</li><li>EPHEMERAL-临时节点 临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与 zookeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。</li><li>PERSISTENT_SEQUENTIAL-持久顺序节点 基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</li><li>EPHEMERAL_SEQUENTIAL-临时顺序节点 基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</li></ul><h1 id="6-Zookeeper-Watcher-机制-–-数据变更通知"><a href="#6-Zookeeper-Watcher-机制-–-数据变更通知" class="headerlink" title="6. Zookeeper Watcher 机制 – 数据变更通知"></a>6. Zookeeper Watcher 机制 – 数据变更通知</h1><p>Zookeeper 允许客户端向服务端的某个 Znode 注册一个 Watcher 监听，当服务端的一些指定事件触发了这个 Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据 Watcher 通知状态和事件类型做出业务上的改变。</p><h3 id="工作机制："><a href="#工作机制：" class="headerlink" title="工作机制："></a>工作机制：</h3><ul><li>客户端注册 watcher</li><li>服务端处理 watcher</li><li>客户端回调 watcher</li></ul><h3 id="Watcher-特性总结："><a href="#Watcher-特性总结：" class="headerlink" title="Watcher 特性总结："></a>Watcher 特性总结：</h3><ol><li>一次性 无论是服务端还是客户端，一旦一个 Watcher 被触发，Zookeeper 都会将其从相应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的压力都非常大。</li><li>客户端串行执行 客户端 Watcher 回调的过程是一个串行同步的过程。</li><li>轻量<ul><li>Watcher 通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。</li><li>客户端向服务端注册 Watcher 的时候，并不会把客户端真实的 Watcher 对象实体传递到服务端，仅仅是在客户端请求中使用 boolean 类型属性进行了标记。</li></ul></li><li>watcher event 异步发送 watcher 的通知事件从 server 发送到 client 是异步的，这就存在一个问题，不同的客户端和服务器之间通过 socket 进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于 Zookeeper 本身提供了ordering guarantee，即客户端监听事件后，才会感知它所监视 znode 发生了变化。所以我们使用 Zookeeper 不能期望能够监控到节点每次的变化。Zookeeper 只能保证最终的一致性，而无法保证强一致性。</li><li>注册 watcher getData、exists、getChildren</li><li>触发 watcher create、delete、setData</li><li>当一个客户端连接到一个新的服务器上时，watch 将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到 watch 的。而当 client 重新连接时，如果需要的话，所有先前注册过的 watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch 可能会丢失：对于一个未创建的 znode 的 exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个 watch 事件可能会被丢失。</li></ol><h1 id="7-客户端注册Watcher实现"><a href="#7-客户端注册Watcher实现" class="headerlink" title="7. 客户端注册Watcher实现"></a>7. 客户端注册Watcher实现</h1><ol><li>调用 getData() &#x2F; getChildren() &#x2F; exist() 三个 API ，传入 Watcher 对象</li><li>标记请求 request，封装 Watcher 到 WatchRegistration</li><li>封装成 Packet 对象，发服务端发送 request</li><li>收到服务端响应后，将 Watcher 注册到 ZKWatcherManager 中进行管理</li><li>请求返回，完成注册。</li></ol><h1 id="8-服务端处理Watcher实现"><a href="#8-服务端处理Watcher实现" class="headerlink" title="8. 服务端处理Watcher实现"></a>8. 服务端处理Watcher实现</h1><ol><li>服务端接收 Watcher 并存储 接收到客户端请求，处理请求判断是否需要注册 Watcher ，需要的话将数据节点的节点路径和 ServerCnxn（ServerCnxn 代表一个客户端和服务端的连接，实现了 Watcher 的 process 接口，此时可以看成一个 Watcher 对象）存储在 WatcherManager 的 WatchTable 和 watch2Paths 中去。</li><li>Watcher 触发 以服务端接收到 setData() 事务请求触发 NodeDataChanged 事件为例：<ul><li>封装 WatchedEvent 将通知状态（SyncConnected）、事件类型（NodeDataChanged）以及节点路径封装成一个 WatchedEvent 对象</li><li>查询 Watcher 从 WatchTable 中根据节点路径查找 Watcher</li><li>没找到；说明没有客户端在该数据节点上注册过 Watcher</li><li>找到；提取并从 WatchTable 和 Watch2Paths 中删除对应 Watcher（<strong>从这里可以看出Watcher在服务端是一次性的，触发一次就失效了</strong>）</li></ul></li><li>调用 process 方法来触发 Watcher 这里 process 主要就是通过 ServerCnxn 对应的 TCP 连接发送 Watcher 事件通知。</li></ol><h1 id="9-客户端回调Watcher"><a href="#9-客户端回调Watcher" class="headerlink" title="9. 客户端回调Watcher"></a>9. 客户端回调Watcher</h1><p>客户端 SendThread 线程接收事件通知，交由 EventThread 线程回调 Watcher。客户端的 Watcher 机制同样是一次性的，一旦被触发后，该 Watcher 就失效了。</p><h1 id="10-ACL权限控制机制"><a href="#10-ACL权限控制机制" class="headerlink" title="10. ACL权限控制机制"></a>10. ACL权限控制机制</h1><h3 id="UGO（User-x2F-Group-x2F-Others）"><a href="#UGO（User-x2F-Group-x2F-Others）" class="headerlink" title="UGO（User&#x2F;Group&#x2F;Others）"></a>UGO（User&#x2F;Group&#x2F;Others）</h3><p>目前在 Linux&#x2F;Unix 文件系统中使用，也是使用最广泛的权限控制方式。是一种粗粒度的文件系统权限控制模式。</p><h3 id="ACL（Access-Control-List）访问控制列表"><a href="#ACL（Access-Control-List）访问控制列表" class="headerlink" title="ACL（Access Control List）访问控制列表"></a>ACL（Access Control List）访问控制列表</h3><p>包括三个方面：</p><ul><li>权限模式（Scheme）<ul><li>IP：从IP地址粒度进行权限控制</li><li>Digest：最常用，用类似于 username:password 的权限标识来进行权限配置，便于区分不同应用来进行权限控制</li><li>World：最开放的权限控制方式，是一种特殊的 digest 模式，只有一个权限标识 “world:anyone”</li><li>Super：超级用户</li></ul></li><li>授权对象 授权对象指的是权限赋予的用户或一个指定实体，例如IP地址或是机器灯。</li><li>权限 Permission<ul><li>CREATE：数据节点创建权限，允许授权对象在该 Znode 下创建子节点</li><li>DELETE：子节点删除权限，允许授权对象删除该数据节点的子节点</li><li>READ：数据节点的读取权限，允许授权对象访问该数据节点并读取其数据内容或子节点列表等</li><li>WRITE：数据节点更新权限，允许授权对象对该数据节点进行更新操作</li><li>ADMIN：数据节点管理权限，允许授权对象对该数据节点进行 ACL 相关设置操作</li></ul></li></ul><h1 id="11-Chroot特性"><a href="#11-Chroot特性" class="headerlink" title="11. Chroot特性"></a>11. Chroot特性</h1><p>3.2.0版本后，添加了 Chroot 特性，该特性允许每个客户端为自己设置一个命名空间。如果一个客户端设置了 Chroot，那么该客户端对服务器的任何操作，都将会被限制在其自己的命名空间下。</p><p>通过设置 Chroot，能够将一个客户端应用于 Zookeeper 服务端的一颗子树相对应，在那些多个应用公用一个 Zookeeper 进群的场景下，对实现不同应用间的相互隔离非常有帮助。</p><h1 id="12-会话管理"><a href="#12-会话管理" class="headerlink" title="12. 会话管理"></a>12. 会话管理</h1><p>分桶策略：将类似的会话放在同一区块中进行管理，以便于 Zookeeper 对会话进行不同区块的隔离处理以及同一区块的统一处理。</p><p>分配原则：每个会话的“下次超时时间点”（ExpirationTime）</p><p>计算公式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ExpirationTime</span>_ = currentTime + sessionTimeout</span><br><span class="line"><span class="title class_">ExpirationTime</span> = (<span class="title class_">ExpirationTime</span>_ / <span class="title class_">ExpirationInrerval</span> + <span class="number">1</span>) * <span class="title class_">ExpirationInterval</span> , <span class="title class_">ExpirationInterval</span> 是指 <span class="title class_">Zookeeper</span> 会话超时检查时间间隔，默认 tickTime</span><br></pre></td></tr></table></figure><h1 id="13-服务器角色"><a href="#13-服务器角色" class="headerlink" title="13. 服务器角色"></a>13. 服务器角色</h1><h3 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h3><ul><li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性</li><li>集群内部各服务的调度者</li></ul><h3 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h3><ul><li>处理客户端的非事务请求，转发事务请求给Leader服务器</li><li>参与事务请求Proposal的投票</li><li>参与Leader选举投票</li></ul><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>3.3.0版本以后引入的一个服务器角色，在不影响集群事务处理能力的基础上提升集群的非事务处理能力</p><ul><li>处理客户端的非事务请求，转发事务请求给Leader服务器</li><li>不参与任何形式的投票</li></ul><h1 id="14-Zookeeper-下-Server工作状态"><a href="#14-Zookeeper-下-Server工作状态" class="headerlink" title="14. Zookeeper 下 Server工作状态"></a>14. Zookeeper 下 Server工作状态</h1><p>服务器具有四种状态，分别是 LOOKING、FOLLOWING、LEADING、OBSERVING。</p><ul><li>LOOKING：寻找 Leader 状态。当服务器处于该状态时，它会认为当前集群中没有 Leader，因此需要进入 Leader 选举状态。</li><li>FOLLOWING：跟随者状态。表明当前服务器角色是 Follower。</li><li>LEADING：领导者状态。表明当前服务器角色是 Leader。</li><li>OBSERVING：观察者状态。表明当前服务器角色是 Observer。</li></ul><h1 id="15-Leader-选举"><a href="#15-Leader-选举" class="headerlink" title="15. Leader 选举"></a>15. Leader 选举</h1><p>Leader选举是保证分布式数据一致性的关键所在。当 Zookeeper 集群中的一台服务器出现以下两种情况之一时，需要进入 Leader 选举。</p><ol><li>服务器初始化启动。</li><li>服务器运行期间无法和Leader保持连接。</li></ol><p>下面就两种情况进行分析讲解。</p><h3 id="服务器启动时期的Leader选举"><a href="#服务器启动时期的Leader选举" class="headerlink" title="服务器启动时期的Leader选举"></a>服务器启动时期的Leader选举</h3><p>若进行 Leader 选举，则至少需要两台机器，这里选取3台机器组成的服务器集群为例。在集群初始化阶段，当有一台服务器 Server1 启动时，其单独无法进行和完成 Leader 选举，当第二台服务器 Server2 启动时，此时两台机器可以相互通信，每台机器都试图找到 Leader ，于是进入 Leader 选举过程。选举过程如下</p><ol><li>每个 Server 发出一个投票。由于是初始情况，Server1 和 Server2 都会将自己作为 Leader 服务器来进行投票，每次投票会包含所推举的服务器的 myid 和 ZXID ，使用 (myid, ZXID) 来表示，此时 Server1 的投票为 (1, 0)，Server2 的投票为 (2, 0)，然后各自将这个投票发给集群中其他机器。</li><li>接受来自各个服务器的投票。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票、是否来自 LOOKING 状态的服务器。</li><li>处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行 PK ，PK 规则如下<ul><li>优先检查 ZXID 。ZXID 比较大的服务器优先作为 Leader。</li><li>如果 ZXID 相同，那么就比较 myid。myid 较大的服务器作为 Leader 服务器。</li><li>对于 Server1 而言，它的投票是 (1, 0)，接收 Server2 的投票为 (2, 0)，首先会比较两者的 ZXID，均为 0，再比较 myid，此时 Server2 的 myid 最大，于是更新自己的投票为 (2, 0)，然后重新投票，对于 Server2 而言，其无须更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可。</li></ul></li><li>统计投票。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于 Server1、Server2 而言，都统计出集群中已经有两台机器接受了 (2, 0) 的投票信息，此时便认为已经选出了 Leader。</li><li>改变服务器状态。一旦确定了 Leader ，每个服务器就会更新自己的状态，如果是 Follower，那么就变更为 FOLLOWING，如果是 Leader，就变更为 LEADING。</li></ol><h3 id="服务器运行时期的-Leader-选举"><a href="#服务器运行时期的-Leader-选举" class="headerlink" title="服务器运行时期的 Leader 选举"></a>服务器运行时期的 Leader 选举</h3><p>在 Zookeeper 运行期间，Leader 与非 Leader 服务器各司其职，即便当有非 Leader 服务器宕机或新加入，此时也不会影响 Leader ，但是一旦 Leader 服务器挂了，那么整个集群将暂停对外服务，进入新一轮 Leader 选举，其过程和启动时期的 Leader 选举过程基本一致。假设正在运行的有 Server1、Server2、Server3 三台服务器，当前 Leader 是 Server2，若某一时刻 Leader 挂了，此时便开始 Leader 选举。选举过程如下</p><ol><li>变更状态。Leader 挂后，余下的非 Observer 服务器都会讲自己的服务器状态变更为 LOOKING，然后开始进入 Leader 选举过程。</li><li>每个 Server 会发出一个投票。在运行期间，每个服务器上的 ZXID 可能不同，此时假定 Server1 的 ZXID 为 123，Server3 的 ZXID 为 122；在第一轮投票中，Server1 和 Server3 都会投自己，产生投票 (1, 123)，(3, 122)，然后各自将投票发送给集群中所有机器。</li><li>接收来自各个服务器的投票。与启动时过程相同。</li><li>处理投票。与启动时过程相同，此时，Server1 将会成为 Leader。</li><li>统计投票。与启动时过程相同。</li><li>改变服务器的状态。与启动时过程相同。</li></ol><h3 id="Leader选举算法分析"><a href="#Leader选举算法分析" class="headerlink" title="Leader选举算法分析"></a>Leader选举算法分析</h3><p>在 3.4.0 后的 Zookeeper 的版本只保留了 TCP 版本的 FastLeaderElection 选举算法。当一台机器进入 Leader 选举时，当前集群可能会处于以下两种状态</p><ul><li>集群中已经存在 Leader。</li><li>集群中不存在 Leader。</li></ul><p>对于集群中已经存在 Leader 而言，此种情况一般都是某台机器启动得较晚，在其启动之前，集群已经在正常工作，对这种情况，该机器试图去选举 Leader 时，会被告知当前服务器的 Leader 信息，对于该机器而言，仅仅需要和 Leader 机器建立起连接，并进行状态同步即可。而在集群中不存在 Leader 情况下则会相对复杂，其步骤如下：</p><ol><li>第一次投票。无论哪种导致进行 Leader 选举，集群的所有机器都处于试图选举出一个 Leader 的状态，即 LOOKING 状态，LOOKING 机器会向所有其他机器发送消息，该消息称为投票。投票中包含了 SID（服务器的唯一标识）和 ZXID（事务ID），(SID, ZXID) 形式来标识一次投票信息。假定 Zookeeper  由5台机器组成，SID 分别为 1、2、3、4、5，ZXID 分别为 9、9、9、8、8，并且此时 SID 为 2 的机器是 Leader 机器，某一时刻，1、2所在机器出现故障，因此集群开始进行 Leader 选举。在第一次投票时，每台机器都会将自己作为投票对象，于是 SID 为 3、4、5 的机器投票情况分别为 (3, 9)，(4, 8)， (5, 8)。</li><li>变更投票。每台机器发出投票后，也会收到其他机器的投票，每台机器会根据一定规则来处理收到的其他机器的投票，并以此来决定是否需要变更自己的投票，这个规则也是整个 Leader 选举算法的核心所在，其中术语描述如下：<ol><li>vote_sid：接收到的投票中所推举 Leader 服务器的 SID。</li><li>vote_zxid：接收到的投票中所推举 Leader 服务器的 ZXID。</li><li>self_sid：当前服务器自己的 SID。</li><li>self_zxid：当前服务器自己的 ZXID。<br>每次对收到的投票的处理，都是对（vote_sid, vote_zxid）和（self_sid, self_zxid）对比的过程。</li></ol></li></ol><ul><li>规则一：如果 vote_zxid 大于 self_zxid，就认可当前收到的投票，并再次将该投票发送出去。</li><li>规则二：如果 vote_zxid 小于 self_zxid，那么坚持自己的投票，不做任何变更。</li><li>规则三：如果 vote_zxid 等于 self_zxid，那么就对比两者的 SID，如果 vote_sid 大于 self_sid，那么就认可当前收到的投票，并再次将该投票发送出去。</li><li>规则四：如果 vote_zxid 等于 self_zxid，并且 vote_sid 小于 self_sid，那么坚持自己的投票，不做任何变更。</li></ul><p>结合上面规则，给出下面的集群变更过程。</p><ol><li>确定 Leader。经过第二轮投票后，集群中的每台机器都会再次接收到其他机器的投票，然后开始统计投票，如果一台机器收到了超过半数的相同投票，那么这个投票对应的 SID 机器即为 Leader。此时 Server3 将成为 Leader。由上面规则可知，通常那台服务器上的数据越新（ZXID 会越大），其成为 Leader 的可能性越大，也就越能够保证数据的恢复。如果 ZXID 相同，则 SID 越大机会越大。</li></ol><h3 id="Leader选举实现细节"><a href="#Leader选举实现细节" class="headerlink" title="Leader选举实现细节"></a>Leader选举实现细节</h3><ol><li>服务器状态<ol><li>LOOKING：寻找 Leader 状态。当服务器处于该状态时，它会认为当前集群中没有 Leader，因此需要进入 Leader 选举状态。</li><li>FOLLOWING：跟随者状态。表明当前服务器角色是 Follower。</li><li>LEADING：领导者状态。表明当前服务器角色是 Leader。</li><li>OBSERVING：观察者状态。表明当前服务器角色是 Observer。</li></ol></li><li>投票数据结构<ol><li>id：被推举的 Leader 的 SID。</li><li>zxid：被推举的 Leader 事务 ID。</li><li>electionEpoch：逻辑时钟，用来判断多个投票是否在同一轮选举周期中，该值在服务端是一个自增序列，每次进入新一轮的投票后，都会对该值进行加1操作。</li><li>peerEpoch：被推举的 Leader 的 epoch。</li><li>state：当前服务器的状态。</li></ol></li><li>QuorumCnxManager：网络I&#x2F;O<ol><li>每台服务器在启动的过程中，会启动一个 QuorumPeerManager，负责各台服务器之间的底层 Leader 选举过程中的网络通信。</li><li><strong>消息队列</strong>。QuorumCnxManager 内部维护了一系列的队列，用来保存接收到的、待发送的消息以及消息的发送器，除接收队列以外，其他队列都按照 SID 分组形成队列集合，如一个集群中除了自身还有 3 台机器，那么就会为这3台机器分别创建一个发送队列，互不干扰。<ol><li>recvQueue：消息接收队列，用于存放那些从其他服务器接收到的消息。</li><li>queueSendMap：消息发送队列，用于保存那些待发送的消息，按照 SID 进行分组。</li><li>senderWorkerMap：发送器集合，每个 SenderWorker 消息发送器，都对应一台远程 Zookeeper 服务器，负责消息的发送，也按照SID进行分组。</li><li>lastMessageSent：最近发送过的消息，为每个 SID 保留最近发送过的一个消息。</li></ol></li><li><strong>建立连接</strong>。为了能够相互投票，Zookeeper 集群中的所有机器都需要两两建立起网络连接。QuorumCnxManager 在启动时会创建一个 ServerSocket 来监听 Leader 选举的通信端口（默认为 3888 ）。开启监听后，Zookeeper 能够不断地接收到来自其他服务器的创建连接请求，在接收到其他服务器的 TCP 连接请求时，会进行处理。为了避免两台机器之间重复地创建 TCP 连接，Zookeeper 只允许 SID 大的服务器主动和其他机器建立连接，否则断开连接。在接收到创建连接请求后，服务器通过对比自己和远程服务器的 SID 值来判断是否接收连接请求，如果当前服务器发现自己的 SID 更大，那么会断开当前连接，然后自己主动和远程服务器建立连接。一旦连接建立，就会根据远程服务器的 SID 来创建相应的消息发送器 SendWorker 和消息接收器 RecvWorker，并启动。</li><li><strong>消息接收与发送</strong>。消息接收：由消息接收器 RecvWorker 负责，由于 Zookeeper 为每个远程服务器都分配一个单独的 RecvWorker，因此，每个 RecvWorker 只需要不断地从这个 TCP 连接中读取消息，并将其保存到 recvQueue 队列中。消息发送：由于 Zookeeper 为每个远程服务器都分配一个单独的 SendWorker，因此，每个 SendWorker 只需要不断地从对应的消息发送队列中获取出一个消息发送即可，同时将这个消息放入 lastMessageSent中。在 SendWorker 中，一旦 Zookeeper 发现针对当前服务器的消息发送队列为空，那么此时需要从 lastMessageSent 中取出一个最近发送过的消息来进行再次发送，这是为了解决接收方在消息接收前或者接收到消息后服务器挂了，导致消息尚未被正确处理。同时，Zookeeper 能够保证接收方在处理消息时，会对重复消息进行正确的处理。</li></ol></li><li>FastLeaderElection：选举算法核心<ul><li>外部投票：特指其他服务器发来的投票。</li><li>内部投票：服务器自身当前的投票。</li><li>选举轮次：Zookeeper 服务器 Leader 选举的轮次，即 logicalclock。</li><li>PK：对内部投票和外部投票进行对比来确定是否需要变更内部投票。</li></ul><ol><li>选票管理<ol><li>sendqueue：选票发送队列，用于保存待发送的选票。</li><li>recvqueue：选票接收队列，用于保存接收到的外部投票。</li><li>WorkerReceiver：选票接收器。其会不断地从 QuorumCnxManager 中获取其他服务器发来的选举消息，并将其转换成一个选票，然后保存到recvqueue中，在选票接收过程中，如果发现该外部选票的选举轮次小于当前服务器的，那么忽略该外部投票，同时立即发送自己的内部投票。</li><li>WorkerSender：选票发送器，不断地从 sendqueue 中获取待发送的选票，并将其传递到底层 QuorumCnxManager 中。</li></ol></li><li>算法核心：Leader 选举的基本流程如下：<ol><li>自增选举轮次。Zookeeper 规定所有有效的投票都必须在同一轮次中，在开始新一轮投票时，会首先对 logicalclock 进行自增操作。</li><li>初始化选票。在开始进行新一轮投票之前，每个服务器都会初始化自身的选票，并且在初始化阶段，每台服务器都会将自己推举为 Leader。</li><li>发送初始化选票。完成选票的初始化后，服务器就会发起第一次投票。Zookeeper 会将刚刚初始化好的选票放入 sendqueue 中，由发送器 WorkerSender 负责发送出去。</li><li>接收外部投票。每台服务器会不断地从 recvqueue 队列中获取外部选票。如果服务器发现无法获取到任何外部投票，那么就会立即确认自己是否和集群中其他服务器保持着有效的连接，如果没有连接，则马上建立连接，如果已经建立了连接，则再次发送自己当前的内部投票。</li><li>判断选举轮次。在发送完初始化选票之后，接着开始处理外部投票。在处理外部投票时，会根据选举轮次来进行不同的处理。<ol><li>外部投票的选举轮次大于内部投票。若服务器自身的选举轮次落后于该外部投票对应服务器的选举轮次，那么就会立即更新自己的选举轮次（logicalclock），并且清空所有已经收到的投票，然后使用初始化的投票来进行PK以确定是否变更内部投票。最终再将内部投票发送出去。</li><li>外部投票的选举轮次小于内部投票。若服务器接收的外选票的选举轮次落后于自身的选举轮次，那么 Zookeeper 就会直接忽略该外部投票，不做任何处理，并返回步骤 4。</li><li>外部投票的选举轮次等于内部投票。此时可以开始进行选票PK。</li></ol></li><li>选票 PK。在进行选票 PK 时，符合任意一个条件就需要变更投票。<ol><li>若外部投票中推举的 Leader 服务器的选举轮次大于内部投票，那么需要变更投票。</li><li>若选举轮次一致，那么就对比两者的 ZXID，若外部投票的 ZXID 大，那么需要变更投票。</li><li>若两者的 ZXID 一致，那么就对比两者的 SID，若外部投票的 SID 大，那么就需要变更投票。</li></ol></li><li>变更投票。经过 PK 后，若确定了外部投票优于内部投票，那么就变更投票，即使用外部投票的选票信息来覆盖内部投票，变更完成后，再次将这个变更后的内部投票发送出去。</li><li>选票归档。无论是否变更了投票，都会将刚刚收到的那份外部投票放入选票集合 recvset 中进行归档。recvset 用于记录当前服务器在本轮次的 Leader 选举中收到的所有外部投票（按照服务队的 SID 区别，如{(1, vote1), (2, vote2)…}）。</li><li>统计投票。完成选票归档后，就可以开始统计投票，统计投票是为了统计集群中是否已经有过半的服务器认可了当前的内部投票，如果确定已经有过半服务器认可了该投票，则终止投票。否则返回步骤4。</li><li>更新服务器状态。若已经确定可以终止投票，那么就开始更新服务器状态，服务器首选判断当前被过半服务器认可的投票所对应的 Leader 服务器是否是自己，若是自己，则将自己的服务器状态更新为 LEADING ，若不是，则根据具体情况来确定自己是 FOLLOWING 或是 OBSERVING。</li></ol></li><li>以上10个步骤就是 FastLeaderElection 的核心，其中步骤 4-9 会经过几轮循环，直到有 Leader 选举产生。</li></ol></li></ol><h1 id="16-数据同步"><a href="#16-数据同步" class="headerlink" title="16. 数据同步"></a>16. 数据同步</h1><p>整个集群完成 Leader 选举之后，Learner（Follower 和 Observer 的统称）会向 Leader 服务器进行注册。当 Learner 服务器向 Leader 服务器完成注册后，进入数据同步环节。<br>数据同步流程：（均以消息传递的方式进行） i. Learner 向 Learder 注册 ii. 数据同步 iii. 同步确认</p><p><strong>Zookeeper的数据同步通常分为四类：</strong></p><ul><li>直接差异化同步（DIFF 同步）</li><li>先回滚再差异化同步（TRUNC + DIFF 同步）</li><li>仅回滚同步（TRUNC 同步）</li><li>全量同步（SNAP 同步）</li></ul><p>在进行数据同步前，Leader 服务器会完成数据同步初始化：</p><ul><li>peerLastZxid：从 learner 服务器注册时发送的 ACKEPOCH 消息中提取 lastZxid（该 Learner 服务器最后处理的 ZXID）</li><li>minCommittedLog：Leader 服务器 Proposal 缓存队列 committedLog 中最小 ZXID</li><li>maxCommittedLog：Leader 服务器 Proposal 缓存队列 committedLog 中最大 ZXID</li></ul><h3 id="直接差异化同步（DIFF同步）"><a href="#直接差异化同步（DIFF同步）" class="headerlink" title="直接差异化同步（DIFF同步）"></a>直接差异化同步（DIFF同步）</h3><p><strong>场景</strong>：peerLastZxid 介于 minCommittedLog 和 maxCommittedLog 之间</p><h3 id="先回滚再差异化同步（TRUNC-DIFF同步）"><a href="#先回滚再差异化同步（TRUNC-DIFF同步）" class="headerlink" title="先回滚再差异化同步（TRUNC+DIFF同步）"></a>先回滚再差异化同步（TRUNC+DIFF同步）</h3><p><strong>场景</strong>：当新的 Leader 服务器发现某个 Learner 服务器包含了一条自己没有的事务记录，那么就需要让该 Learner 服务器进行事务回滚–回滚到 Leader 服务器上存在的，同时也是最接近于 peerLastZxid 的 ZXID</p><h3 id="仅回滚同步（TRUNC同步）"><a href="#仅回滚同步（TRUNC同步）" class="headerlink" title="仅回滚同步（TRUNC同步）"></a>仅回滚同步（TRUNC同步）</h3><p><strong>场景</strong>：peerLastZxid 大于 maxCommittedLog</p><h3 id="全量同步（SNAP同步）"><a href="#全量同步（SNAP同步）" class="headerlink" title="全量同步（SNAP同步）"></a>全量同步（SNAP同步）</h3><p><strong>场景一</strong>：peerLastZxid 小于 minCommittedLog<br><strong>场景二</strong>：Leader 服务器上没有 Proposal 缓存队列且 peerLastZxid 不等于 lastProcessZxid</p><h1 id="17-zookeeper是如何保证事务的顺序一致性的？"><a href="#17-zookeeper是如何保证事务的顺序一致性的？" class="headerlink" title="17. zookeeper是如何保证事务的顺序一致性的？"></a>17. zookeeper是如何保证事务的顺序一致性的？</h1><p>zookeeper 采用了全局递增的事务 Id 来标识，所有的 proposal（提议）都在被提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（时期; 纪元; 世; 新时代）用来标识 leader 周期，如果有新的 leader 产生出来，epoch 会自增，低 32 位用来递增计数。当新产生 proposal 的时候，会依据数据库的两阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。</p><h1 id="18-分布式集群中为什么会有Master？"><a href="#18-分布式集群中为什么会有Master？" class="headerlink" title="18. 分布式集群中为什么会有Master？"></a>18. 分布式集群中为什么会有Master？</h1><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行 leader 选举。</p><h1 id="19-zk节点宕机如何处理？"><a href="#19-zk节点宕机如何处理？" class="headerlink" title="19. zk节点宕机如何处理？"></a>19. zk节点宕机如何处理？</h1><p>Zookeeper 本身也是集群，推荐配置不少于3个服务器。Zookeeper 自身也要保证当一个节点宕机时，其他节点会继续提供服务。 如果是一个 Follower 宕机，还有2台服务器提供访问，因为 Zookeeper 上的数据是有多个副本的，数据并不会丢失； 如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。 ZK 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZK 节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。 所以 3 个节点的 cluster 可以挂掉 1 个节点（leader可以得到2票 &gt; 1.5） 2 个节点的 cluster 就不能挂掉任何一个节点了（leader 可以得到 1 票 &lt;&#x3D; 1）</p><h1 id="20-zookeeper负载均衡和nginx负载均衡区别"><a href="#20-zookeeper负载均衡和nginx负载均衡区别" class="headerlink" title="20. zookeeper负载均衡和nginx负载均衡区别"></a>20. zookeeper负载均衡和nginx负载均衡区别</h1><p>zk 的负载均衡是可以调控，nginx 只是能调权重，其他需要可控的都需要自己写插件；但是 nginx 的吞吐量比zk大很多，应该说按业务选择用哪种方式。</p><h1 id="21-Zookeeper有哪几种几种部署模式？"><a href="#21-Zookeeper有哪几种几种部署模式？" class="headerlink" title="21. Zookeeper有哪几种几种部署模式？"></a>21. Zookeeper有哪几种几种部署模式？</h1><p>部署模式：单机模式、伪集群模式、集群模式。</p><h1 id="22-集群最少要几台机器，集群规则是怎样的"><a href="#22-集群最少要几台机器，集群规则是怎样的" class="headerlink" title="22. 集群最少要几台机器，集群规则是怎样的?"></a>22. 集群最少要几台机器，集群规则是怎样的?</h1><p>集群规则为 2N+1 台，N&gt;0，即 3 台。</p><h1 id="23-集群支持动态添加机器吗？"><a href="#23-集群支持动态添加机器吗？" class="headerlink" title="23. 集群支持动态添加机器吗？"></a>23. 集群支持动态添加机器吗？</h1><p>其实就是水平扩容了，Zookeeper 在这方面不太好。两种方式：</p><ul><li>全部重启：关闭所有 Zookeeper 服务，修改配置之后启动。不影响之前客户端的会话。</li><li>逐个重启：在过半存活即可用的原则下，一台机器重启不影响整个集群对外提供服务。这是比较常用的方式。</li></ul><p>3.5版本开始支持动态扩容。</p><h1 id="24-Zookeeper对节点的watch监听通知是永久的吗？为什么不是永久的"><a href="#24-Zookeeper对节点的watch监听通知是永久的吗？为什么不是永久的" class="headerlink" title="24. Zookeeper对节点的watch监听通知是永久的吗？为什么不是永久的?"></a>24. Zookeeper对节点的watch监听通知是永久的吗？为什么不是永久的?</h1><p>不是。官方声明：一个 Watch 事件是一个一次性的触发器，当被设置了 Watch 的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端，以便通知它们。</p><p>为什么不是永久的，举个例子，如果服务端变动频繁，而监听的客户端很多情况下，每次变动都要通知到所有的客户端，给网络和服务器造成很大压力。 一般是客户端执行 getData(“&#x2F;节点A”,true)，如果节点 A 发生了变更或删除，客户端会得到它的 watch 事件，但是在之后节点 A 又发生了变更，而客户端又没有设置 watch 事件，就不再给客户端发送。 在实际应用中，很多情况下，我们的客户端不需要知道服务端的每一次变动，我只要最新的数据即可。</p><h1 id="25-chubby是什么，和zookeeper比你怎么看？"><a href="#25-chubby是什么，和zookeeper比你怎么看？" class="headerlink" title="25. chubby是什么，和zookeeper比你怎么看？"></a>25. chubby是什么，和zookeeper比你怎么看？</h1><p>chubby 是 google 的，完全实现 paxos 算法，不开源。zookeeper 是 chubby 的开源实现，使用zab协议，paxos 算法的变种。</p><h1 id="26-说几个zookeeper常用的命令。"><a href="#26-说几个zookeeper常用的命令。" class="headerlink" title="26. 说几个zookeeper常用的命令。"></a>26. 说几个zookeeper常用的命令。</h1><p>常用命令：ls get set create delete等。</p><h1 id="27-ZAB和Paxos算法的联系与区别？"><a href="#27-ZAB和Paxos算法的联系与区别？" class="headerlink" title="27. ZAB和Paxos算法的联系与区别？"></a>27. ZAB和Paxos算法的联系与区别？</h1><ul><li>相同点：<ul><li>两者都存在一个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程的运行</li><li>Leader 进程都会等待超过半数的 Follower 做出正确的反馈后，才会将一个提案进行提交</li><li>ZAB 协议中，每个 Proposal 中都包含一个 epoch 值来代表当前的 Leader 周期，Paxos 中名字为 Ballot</li></ul></li><li>不同点： ZAB 用来构建高可用的分布式数据主备系统（Zookeeper），Paxos 是用来构建分布式一致性状态机系统。</li></ul><h1 id="28-Zookeeper的典型应用场景"><a href="#28-Zookeeper的典型应用场景" class="headerlink" title="28. Zookeeper的典型应用场景"></a>28. Zookeeper的典型应用场景</h1><p>Zookeeper 是一个典型的发布&#x2F;订阅模式的分布式数据管理与协调框架，开发人员可以使用它来进行分布式数据的发布和订阅。</p><p>通过对 Zookeeper 中丰富的数据节点进行交叉使用，配合 Watcher 事件通知机制，可以非常方便的构建一系列分布式应用中年都会涉及的核心功能，如：</p><ul><li>数据发布&#x2F;订阅</li><li>负载均衡</li><li>命名服务</li><li>分布式协调&#x2F;通知</li><li>集群管理</li><li>Master选举</li><li>分布式锁</li><li>分布式队列</li></ul><h3 id="数据发布-x2F-订阅"><a href="#数据发布-x2F-订阅" class="headerlink" title="数据发布&#x2F;订阅"></a>数据发布&#x2F;订阅</h3><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h5><p>数据发布&#x2F;订阅系统，即所谓的配置中心，顾名思义就是发布者发布数据供订阅者进行数据订阅。</p><h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a><strong>目的</strong></h5><ul><li>动态获取数据（配置信息）</li><li>实现数据（配置信息）的集中式管理和数据的动态更新</li></ul><h5 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><strong>设计模式</strong></h5><ul><li>Push 模式</li><li>Pull 模式</li></ul><h5 id="数据（配置信息）特性："><a href="#数据（配置信息）特性：" class="headerlink" title="数据（配置信息）特性："></a><strong>数据（配置信息）特性：</strong></h5><ul><li>数据量通常比较小</li><li>数据内容在运行时会发生动态更新</li><li>集群中各机器共享，配置一致</li><li>机器列表信息、运行时开关配置、数据库配置信息等</li></ul><h5 id="基于Zookeeper的实现方式"><a href="#基于Zookeeper的实现方式" class="headerlink" title="基于Zookeeper的实现方式"></a><strong>基于Zookeeper的实现方式</strong></h5><ol><li>数据存储：将数据（配置信息）存储到 Zookeeper 上的一个数据节点</li><li>数据获取：应用在启动初始化节点从 Zookeeper 数据节点读取数据，并在该节点上注册一个数据变更 Watcher</li><li>数据变更：当变更数据时，更新 Zookeeper 对应节点数据，Zookeeper 会将数据变更通知发到各客户端，客户端接到通知后重新读取变更后的数据即可。</li></ol><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试100题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GMP 原理与调度</title>
      <link href="/library/Golang/concurrency/go-gmp/"/>
      <url>/library/Golang/concurrency/go-gmp/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>M(machine): 代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。<br>P(processor): 表示逻辑processor，是线程M的执行的上下文。<br>G(goroutine): 调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。</p><h1 id="1-GMP-原理与调度"><a href="#1-GMP-原理与调度" class="headerlink" title="1. GMP 原理与调度"></a>1. GMP 原理与调度</h1><h3 id="1-1-1-一、Golang-“调度器”-的由来？"><a href="#1-1-1-一、Golang-“调度器”-的由来？" class="headerlink" title="1.1.1 一、Golang “调度器” 的由来？"></a>1.1.1 一、Golang “调度器” 的由来？</h3><h4 id="1-单进程时代不需要调度器"><a href="#1-单进程时代不需要调度器" class="headerlink" title="(1) 单进程时代不需要调度器"></a>(1) 单进程时代不需要调度器</h4><p>我们知道，一切的软件都是跑在操作系统上，真正用来干活 (计算) 的是 CPU。早期的操作系统每个程序就是一个进程，知道一个程序运行完，才能进行下一个进程，就是 “单进程时代”<br>一切的程序只能串行发生。<br>早期的单进程操作系统，面临 2 个问题：</p><ol><li><p>单一的执行流程，计算机只能一个任务一个任务处理。</p></li><li><p>进程阻塞所带来的 CPU 时间浪费。</p></li></ol><p>那么能不能有多个进程来宏观一起来执行多个任务呢？</p><p>后来操作系统就具有了最早的并发能力：多进程并发，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把 CPU 利用起来，CPU 就不浪费了。</p><h4 id="2-多进程-x2F-线程时代有了调度器需求"><a href="#2-多进程-x2F-线程时代有了调度器需求" class="headerlink" title="(2) 多进程 &#x2F; 线程时代有了调度器需求"></a>(2) 多进程 &#x2F; 线程时代有了调度器需求</h4><p><img src="https://s3.bmp.ovh/imgs/2022/02/921c521bed752387.jpg" alt="image"><br>在多进程 &#x2F; 多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞 cpu 可以立刻切换到其他进程中去执行，而且调度 cpu 的算法可以保证在运行的进程都可以被分配到 cpu 的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。</p><p>但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU 虽然利用起来了，但如果进程过多，CPU 有很大的一部分都被用来进行进程调度了。</p><p>怎么才能提高 CPU 的利用率呢？</p><p>但是对于 Linux 操作系统来讲，cpu 对进程的态度和线程的态度是一样的。<br><img src="https://s3.bmp.ovh/imgs/2022/02/bad5998d362c5be9.jpg" alt="image"></p><p>所有应用程序都是运行在操作系统上，真正用来干活(计算)的是<code>CPU</code>。所以谈到<code>Go</code>语言调度器，我们也绕不开操作系统、进程与线程这些概念。线程是操作系统调度时的最基本单元，而 Linux 在调度器并不区分进程和线程的调度，它们在不同操作系统上也有不同的实现，但是在大多数的实现中线程都属于进程。</p><p>多个线程可以属于同一个进程并共享内存空间。因为多线程不需要创建新的虚拟内存空间，所以它们也不需要内存管理单元处理上下文的切换，线程之间的通信也正是基于共享的内存进行的，与重量级的进程相比，线程显得比较轻量。</p><p>虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1 兆以上的内存空间，在对线程进行切换时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁对应的资源。</p><p>大量的线程出现了新的问题</p><ul><li><p>高内存占用</p></li><li><p>调度的CPU高消耗</p></li></ul><p>然后工程师们就发现，其实一个线程分为”内核态”线程和”用户态”线程。</p><p>一个<code>用户态线程</code>必须要绑定一个<code>内核态线程</code>，但是CPU并不知道有<code>用户态线程</code>的存在，它只知道它运行的是一个<code>内核态线程</code>(Linux的PCB进程控制块)。这样，我们再去细化分类，内核线程依然叫线程(thread)，用户线程叫协程(co-routine)。既然一个协程可以绑定一个线程，那么也可以通过实现协程调度器把多个协程与一个或者多个线程进行绑定。</p><p><code>Go</code>语言的<code>goroutine</code>来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被<code>runtime</code>调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。</p><p><code>Go</code>中，协程被称为<code>goroutine</code>，它非常轻量，一个<code>goroutine</code>只占几KB，并且这几KB就足够<code>goroutine</code>运行完，这就能在有限的内存空间内支持大量<code>goroutine</code>，支持了更多的并发。虽然一个<code>goroutine</code>的栈只占几KB，但实际是可伸缩的，如果需要更多内存，<code>runtime</code>会自动为<code>goroutine</code>分配。</p><p>既然我们知道了<code>goroutine</code>和系统线程的关系，那么最关键的一点就是实现协程调度器了。</p><p><code>Go</code>目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了。重新设计的调度器使用<code>G-M-P</code>模型并一直沿用至今。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f68Yc2PzBpdRSf4iaE1bicpADBkw9ITic8G4yctoweOep4Yc0fQKlkHeWkUIsUatove0g7AFsIAw22tA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="调度器G-M-P模型"></p><p>调度器G-M-P模型</p><ul><li><p>G — 表示 goroutine，它是一个待执行的任务；</p></li><li><p>M — 表示操作系统的线程，它由操作系统的调度器调度和管理；</p></li><li><p>P — 表示处理器，它可以被看做运行在线程上的本地调度器；</p></li></ul><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p><code>gorotuine</code> 就是<code>Go</code>语言调度器中待执行的任务，它在运行时调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销。</p><p><code>goroutine</code>只存在于<code>Go</code>语言的运行时，它是<code>Go</code>语言在用户态提供的线程，作为一种粒度更细的资源调度单元，如果使用得当能够在高并发的场景下更高效地利用机器的<code>CPU</code>。</p><h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p><code>Go</code>语言并发模型中的<code>M</code>是操作系统线程。调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有 <code>GOMAXPROCS</code> 个活跃线程能够正常运行。</p><p>在默认情况下，运行时会将 <code>GOMAXPROCS</code> 设置成当前机器的核数，我们也可以使用 <code>runtime.GOMAXPROCS</code> 来改变程序中最大的线程数。一个四核机器上会创建四个活跃的操作系统线程，每一个线程都对应一个运行时中的 <code>runtime.m</code> 结构体。</p><p>在大多数情况下，我们都会使用<code>Go</code>的默认设置，也就是活跃线程数等于<code>CPU</code>个数，在这种情况下不会触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由<code>Go</code>语言调度器触发，能够减少非常多的额外开销。</p><p>操作系统线程在<code>Go</code>语言中会使用私有结构体 <code>runtime.m</code> 来表示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type m struct &#123;    g0   *g     curg *g    ...&#125;</span><br></pre></td></tr></table></figure><p>其中<code>g0</code>是持有调度栈的<code>goroutine</code>，<code>curg</code> 是在当前线程上运行的用户<code>goroutine</code>，用户<code>goroutine</code>执行完后，线程切换回<code>g0</code>上，<code>g0</code>会从线程<code>M</code>绑定的<code>P</code>上的等待队列中获取<code>goroutine</code>交给线程。</p><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>调度器中的处理器<code>P</code>是线程和<code>goroutine</code> 的中间层，它能提供线程需要的上下文环境，也会负责调度线程上的等待队列，通过处理器<code>P</code>的调度，每一个内核线程都能够执行多个 <code>goroutine</code>，它能在<code>goroutine</code> 进行一些 <code>I/O</code> 操作时及时切换，提高线程的利用率。因为调度器在启动时就会创建 <code>GOMAXPROCS</code> 个处理器，所以<code>Go</code>语言程序的处理器数量一定会等于 <code>GOMAXPROCS</code>，这些处理器会绑定到不同的内核线程上并利用线程的计算资源运行<code>goroutine</code>。</p><p>此外在调度器里还有一个全局等待队列，当所有P本地的等待队列被占满后，新创建的<code>goroutine</code>会进入全局等待队列。<code>P</code>的本地队列为空后，<code>M</code>也会从全局队列中拿一批待执行的<code>goroutine</code>放到<code>P</code>本地的等待队列中。</p><h3 id="GMP模型图示"><a href="#GMP模型图示" class="headerlink" title="GMP模型图示"></a>GMP模型图示</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f68Yc2PzBpdRSf4iaE1bicpADicd9ka0ILRcZEob1gRNjuXgu6ic2dBysv5VeibYUUTru76UmRiaFrOmdtg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" title="GMP模型图示"></p><p>GMP模型图示</p><ul><li><p>全局队列：存放等待运行的G。</p></li><li><p>P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G时，G优先加入到P的本地队列，如果队列已满，则会把本地队列中一半的G移动到全局队列。</p></li><li><p>P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。</p></li><li><p>M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</p></li><li><p><code>goroutine</code>调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU上执行。</p></li></ul><h3 id="调度器的策略"><a href="#调度器的策略" class="headerlink" title="调度器的策略"></a>调度器的策略</h3><p>调度器的一个策略是尽可能的复用现有的活跃线程，通过以下两个机制提高线程的复用：</p><ol><li><p>work stealing机制，当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。</p></li><li><p>hand off机制，当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</p></li></ol><p><code>Go</code>的运行时并不具备操作系统内核级的硬件中断能力，基于工作窃取的调度器实现，本质上属于先来先服务的协作式调度，为了解决响应时间可能较高的问题，目前运行时实现了协作式调度和抢占式调度两种不同的调度策略，保证在大部分情况下，不同的 G 能够获得均匀的<code>CPU</code>时间片。</p><p>协作式调度依靠被调度方主动弃权，系统监控到一个<code>goroutine</code>运行超过10ms会通过 <code>runtime.Gosched</code> 调用主动让出执行机会。抢占式调度则依靠调度器强制将被调度方被动中断。</p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 并发 </tag>
            
            <tag> go </tag>
            
            <tag> GMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang Sync.Mutex 详解</title>
      <link href="/library/Golang/concurrency/go-sync-mutex/"/>
      <url>/library/Golang/concurrency/go-sync-mutex/</url>
      
        <content type="html"><![CDATA[<h3 id="lock逻辑："><a href="#lock逻辑：" class="headerlink" title="lock逻辑："></a>lock逻辑：</h3><ol><li>第一次上锁的时候，直接走第一步<strong>CAS</strong>上锁，成功返回</li><li><strong>Mutex</strong>已经被另一个<strong>g</strong>上锁，那么<strong>state</strong>的<strong>g</strong>等待数+1，更新当前的锁状态，然后就进入队列，等待被唤醒，等到另个<strong>g</strong>调用了<strong>Unlock</strong>方法之后，当前<strong>g</strong>被唤醒，然后设置<strong>awoken&#x3D;true</strong>，再执行一遍<strong>for</strong>循环，此时<strong>locked</strong>位就是未上锁状态（0），<strong>new</strong>就是代表上锁，然后清除<strong>woken</strong>位，然后再<strong>CAS</strong>更新<strong>new</strong>到<strong>state</strong>上，因为之前的锁是未上锁状态，那么就代表抢锁成功，<strong>break</strong>，返回</li><li>和第二种一样，只不过，在<strong>CAS</strong>更新<strong>new</strong>到<strong>state</strong>上时，有其他<strong>g</strong>先改掉了<strong>state</strong>的值，那么就继续for循环，然后重复到第二种情况。</li></ol><h3 id="自旋锁："><a href="#自旋锁：" class="headerlink" title="自旋锁："></a>自旋锁：</h3><p>简单概括一下，就是为了解决锁粒度非常小的时候，给系统带来的不必要的调度开销<br>不过自旋要先满足几个条件<br>首先程序要跑在多核的机器上，然后GOMAXPROCS要大于1，并且此时有至少一个P的local runq是空的，才能进入到自旋的状态</p><p>自旋是一种多线程同步机制，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真。在多核的 CPU 上，自旋可以避免 Goroutine 的切换，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 Goroutine 进入自旋的条件非常苛刻</p><p>当<strong>Mutex</strong>已经上锁的时候，当前<strong>G</strong>在满足自旋条件下，进入自旋状态，在自旋中，其他<strong>G</strong>解锁了<strong>Mutex</strong>，那么当前<strong>G</strong>就设置了<strong>woken</strong>标记位，这样其他<strong>G</strong>在<strong>Unlock</strong>的时候就不会去等待队列里面唤醒<strong>G</strong>了，然后当前<strong>G</strong>就顺理成章的抢到了锁</p><p>这样自旋锁在锁粒度非常小的场景下的能对其性能带来一定的优化。</p><p>引入自旋锁之后，又带来了一个问题。就是<strong>G</strong>等待队列的<strong>长尾问题</strong>。因为从等待队列里面被唤醒，然后再去抢锁，对本身就在执行的<strong>G</strong>来说，被唤醒的<strong>G</strong>其实是很难抢过当前执行的<strong>G</strong>的，这样的话，等待队列里面的<strong>G</strong>，就会被饿死(长时间获取不到锁)，这样对等待队列的<strong>G</strong>来说其实是不公平的。</p><h3 id="饥饿模式"><a href="#饥饿模式" class="headerlink" title="饥饿模式"></a>饥饿模式</h3><p>简单概括一下，就是解决了等待G队列的长尾问题<br>饥饿模式下，直接由unlock把锁交给等待队列中排在第一位的G，同时，饥饿模式下，新进来的G不会参与抢锁也不会进入自旋状态，会直接进入等待队列的尾部。<br>饥饿模式的触发条件，当一个G等待锁时间超过1毫秒时，Mutex切换到饥饿模式<br>饥饿模式的取消条件，当一个G获取到锁且在等待队列的末尾，或者这个G获取锁的等待时间在1ms内，那么Mutex切换回正常模式</p><p>带来的改变</p><p>Mutex.state的倒数第三位，变成了mutexStarving标记位，0表示正常模式，1表示饥饿模式，与此同时，支持的最大等待G数量从230个 变成了229个</p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 并发 </tag>
            
            <tag> go </tag>
            
            <tag> mutex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang模拟面试题01</title>
      <link href="/interview/simulation/simulation01/"/>
      <url>/interview/simulation/simulation01/</url>
      
        <content type="html"><![CDATA[<ol><li><p>channel实现原理</p></li><li><p>Mutex 是悲观还是乐观锁（什么是乐观锁）</p></li><li><p>Mutex 有几种模式（饥饿和互斥）</p></li><li><p>Mutex 自旋锁？</p></li><li><p>goroutine 模型 和抢占时机</p><p><a href="https://www.bilibili.com/video/BV19r4y1w7Nx/?spm_id_from=333.788.recommend_more_video.6">https://www.bilibili.com/video/BV19r4y1w7Nx/?spm_id_from&#x3D;333.788.recommend_more_video.6</a></p></li><li><p>GC 原理</p></li><li><p>go内存分配，哪些对象分配在堆上，哪些分配在栈上（大对象小对象）</p></li><li><p>OOM out of MEMERY 内存泄漏</p></li><li><p>signal信号（64种）</p></li><li><p>Go Micro</p></li><li><p>CPU三级缓存，加载固定长度到cache，连续的地址空间</p></li><li><p>多核CPU如何保持cache不冲突（MESI）</p></li><li><p>rune 和 uint 超出位数后计算</p></li></ol><p>小厂01</p><ol><li>mutex有几种锁？<ol><li>互斥锁mutex</li><li>读写互斥锁rwmutex</li></ol></li><li>协程和线程？见golang101-1 .4</li><li>channel的作用？用法？<ol><li>控制并发数，一般结合 waitgroup</li><li>控制协程退出等</li></ol></li><li>tidb基础</li><li>gc流程 原理 golang101-2.4</li><li>线程与进程</li><li>slice 和 map 线程安全否</li><li>使用go遇到的挑战？</li><li>postgre？分布式缓存？</li><li>框架grpc相关</li><li>统计协程数量<ol><li>runtime.NumGoroutine()</li></ol></li><li>为什么转go<ol><li>微服务，上云</li><li>k8s</li><li>大量，分布式</li></ol></li></ol><p>ihandy</p><ol><li>项目</li><li>gc</li><li>redis 持久化</li><li>channel，context</li><li>mutex使用</li><li>gmp</li><li>进程线程协程</li></ol><p>数獨科技：多业务或者多方数据不出库，怎样模型化使用这些数据 tob</p><ol><li>项目<ol><li>最拿手的哪个？</li><li>技术点不是特别突出</li><li>任务系统要讲明白对用户和运营的两套接口模式，以及相关的缓存实现方案和刷新机制</li><li>广告系统要讲明白具体提升了哪些效率</li><li>什么维度的缓存key，等</li></ol></li><li>管理<ol><li>时间分配</li><li>需求评审大概流程和内容</li></ol></li><li>字符串相加</li><li>kafka ：topic， partition和consumer的关系， replica<ol><li>consumer的负载分配等</li><li>组内每个消费者对应一个partition，partition多的话由consumer承接，其中一个或几个接受的量会多；消费者多的话，多出partition的会处于空闲状态</li></ol></li></ol><p>中物联讯</p><ol><li>项目</li></ol><p>字节国际支付</p><ol><li>项目</li><li>redis 持久化</li><li>求根号2<ol><li>卡算法题了你敢信，菜逼</li><li>去把课程中的题每个至少来两遍才够的！！！！！！</li></ol></li></ol><p>循环调度：银行 or 销售的提效工具，通话质量模型 tob</p><ol><li>http + 协程，怎么调度的？是否涉及用户态和核心态的切换？</li><li>索引的构建流程？</li><li>b树，b+树区别，MongoDB为什么选用b树</li><li>gmp调度流程</li><li>redis 哪些命令? 时间复杂度是 o(n)</li><li>kafka 持久化？</li><li>kafka partition数量根据哪些信息确定的？<ol><li>回答：consumer的数量</li><li>答案：？</li></ol></li></ol><p>umu</p><ol><li>mysql 聚合索引和XX索引</li><li>redis 各种数据类型的底层结构</li></ol><p>自己总结：<br>并发，缓存，高可用，grpc，gc，gmp，mutex，channel，context等<br>http，redis，mysql，zookeeper，raft<br>乐观锁悲观锁？<br>cas？</p><p>集度基础服务开发</p><ol><li>grpc通信问题</li><li>grpc限流，熔断相关</li><li>golang 底层，写了就会问，channel实现方式，slice实现方式</li><li>如何做限流，redis请求锁的过期时间为什么，如果有人一直持有锁怎么办？</li><li>延时队列的实现方案</li><li>golang的gc</li><li>redis 锁的实现方案？</li><li>算法：判断二叉树是否对称</li><li>逃逸分析</li></ol><p>刷题：<br>剑指offer<br>算法训练营<br>简单题*3<br>中等题*4</p><p>Tik Tok二面<br>1.介绍数据库索引？<br>    数据库索引是一种数据结构，用于提高数据库查询效率。它通过创建特定的数据结构（如B树、B+树）来存储数据的有序副本，以便更快地定位和检索数据。<br>2.为什么把二叉查找树变成多路平衡查找树就能减少磁盘IO？为什么树的高度决定了磁盘的IO次数？如果查找某一个数据，用二叉查找树和用B+树的时间复杂度分别是多少?<br>3.B+树的叶子结点的默认大小是多少？如果把B树的非叶子结点只存放指针,那B树是不是就和B+树一样了呢？<br>4.除了二叉树，B+树，B树这些索引，还有什么常见的存储数据结构适合做索引呢？<br>    哈希索引和全文索引也常用于数据库索引。<br>5.为什么InnoDB不用哈希做索引，用哈希和用B+树有什么区别？<br>    哈希索引适用于等值查询，而B+树索引支持范围查询和排序。InnoDB使用B+树索引，因为它支持更多的查询类型。<br>6.Redis里面有序集合用的索引？介绍一下跳跃表，与哈希的区别？<br>    跳跃表是一种有序数据结构，用于实现有序集合。与哈希表相比，跳跃表支持有序性和范围查询。<br>7.MySQL事务隔离级别有哪些，会产生哪些问题，MySQL默认的隔离级别是什么<br>    MySQL的事务隔离级别包括读未提交、读已提交、可重复读和串行化。不同的隔离级别可能导致脏读、不可重复读和幻读等问题。MySQL默认的隔离级别是可重复读。<br>8.MySQL如何实现可重复读？MVCC的底层原理？<br>9.看你用过palsuar，也用过Kafka，那你说一下这两者不一样的地方？或者设计上有哪些不一样？<br>    Pulsar和Kafka都是消息中间件，但它们的架构和设计有所不同。例如，Pulsar支持多租户、多数据中心复制和动态消息路由等特性，而Kafka则更加专注于高吞吐量和低延迟。<br>14.说说两者底层存储消息方式的区别？<br>15.为什么这两者要这么设计？<br>17.Redis如何实现高可用和高可靠的？<br>    Redis实现高可用通常通过主从复制和哨兵或集群模式。哨兵负责监控节点健康，并在主节点失败时自动切换到从节点。集群模式支持数据分片和节点自动发现，提高了可用性和可扩展性。<br>18.Redis的主从复制是同步的还是异步的？异步和同步的优缺点？<br>    Redis的主从复制是异步的。异步复制提高了性能，但可能导致数据不一致性和数据丢失。<br>19.了解go吗，说说协程，为什么要用协程？<br>    协程是一种轻量级的线程，由Go语言原生支持。协程的优点包括低开销、高并发和简单易用，使得编写并发程序变得更加简单和高效。<br>20.为什么多线程访问共享资源需要加锁处理？<br>    多线程并发访问共享资源可能导致数据竞态和不一致性。加锁能够保证数据的原子性和一致性，从而确保线程安全。<br>21.说说可见性，为什么一个线程看不到另外一个线程的修改？<br>    线程的可见性指的是一个线程对共享变量的修改能够被其他线程立即看到。在多线程编程中，由于CPU的优化、缓存以及编译器的优化，可能导致线程之间的数据不一致。为了确保线程安全和正确性，我们需要解决这个问题。多线程对同一共享变量做修改时，某个线程修改后的新值可能不会立即更新到主内存，其他线程可能仍旧读到该变量旧值。<br>    使用锁保证同一时刻只有一个线程访问共享变量；<br>    对变量访问使用原子操作<br>23.让你设计一个任务调度器的类，add一个task，指定这个task的执行时间，可以add很多任务，但每个task执行的时间又各不相同，你如何实现，用什么数据结构？<br>    可以使用优先队列（如最小堆）来存储任务，并按照执行时间进行排序。每次调度器检查时，都会选择最早的任务执行。<br>24.优先队列的实现原理？</p><h2 id="定义与概念"><a href="#定义与概念" class="headerlink" title="定义与概念"></a><strong>定义与概念</strong></h2><p>优先队列是一种数据结构，用于存储具有不同优先级的任务或元素</p><p>包括FIFO（先进先出）和LIFO（后进先出）两种基本类型</p><h2 id="实现技术"><a href="#实现技术" class="headerlink" title="实现技术"></a><strong>实现技术</strong></h2><p>数据结构</p><p>堆式队列：高效的数据组织结构</p><p>K叉树：基于K叉树的优先队列算法，运算效率高</p><p>双输入通道优先网络：用于通信网络设计</p><p>算法设计</p><p>PQDSA算法：基于DAG任务集的入口节点数量确定优先队列数</p><p>MP-SAQM算法：基于优先级区分的调度及主动队列管理</p><p>硬件支持</p><p>SP-PIFO: 使用严格优先级队列逼近PIFO行为</p><p>光学优先队列：通过反馈系统实现，提高了缓冲容量的利用率</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h2><p>操作系统</p><p>调度算法优化：提高处理器调度效率</p><p>网络传输</p><p>数据包调度：实现可编程的数据包调度</p><p>人工智能</p><p>异构计算环境下的任务调度问题解决</p><p>中间件技术</p><p>处理多个任务时按轻重顺序执行，缩短用户平均等待时间</p><h2 id="性能分析与优化"><a href="#性能分析与优化" class="headerlink" title="性能分析与优化"></a><strong>性能分析与优化</strong></h2><p>并行操作性能</p><p>并行插入和删除方法：保证并行度和串行存取算法的优先顺序一致</p><p>高效合并优先队列的技术：减少存储开销，提高操作效率</p><p>实验验证与比较</p><p>实验结果验证了不同算法的有效性，如SP-PIFO、PQDSA等</p><p>对比经典堆算法和新颖堆变体在不同输入下的表现</p><h2 id="挑战与未来方向"><a href="#挑战与未来方向" class="headerlink" title="挑战与未来方向"></a><strong>挑战与未来方向</strong></h2><p>技术挑战</p><p>实现大规模并行操作的存储空间自适应性</p><p>提高硬件支持下的实时性和准确性</p><p>发展趋势</p><p>探索新的数据结构和算法以适应更复杂的应用场景</p><p>加强对异构计算环境下的优化和支持能力</p><p>25.算法题：二叉树的完全性检验？</p><h2 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h2><p>1.介绍一下业务表的字段</p><p>2.定时任务刷新字段, 是怎么实现的?</p><p>3.分布式锁? 分布式死锁如何解决? 看门狗机制? 如何避免当前线程加的锁, 被其它线程解锁?</p><p>4.乐观锁和悲观锁的区别? 写多读少的情况, 应该使用乐观锁还是悲观锁?</p><p>5.分布式场景下, 如何实现乐观锁?</p><p>6.kafka的幂等性? 如何避免消息被重复消费?</p><p>7.两个线程, 同时向mysql中插入一条数据?</p><p>8.kafka如何保证消息不丢失</p><p>9.sql优化场景:</p><p>select id,name,balance from account where update_time &gt; ‘2020-09-19’ limit 100000, 10</p><p>该语句为什么查询慢? 有什么优化思路?</p><ol start="10"><li>算法题: 子集</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 实录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go设计模式01-单例模式</title>
      <link href="/library/Golang/go-design-pattern/gdp-create/01-singleton/"/>
      <url>/library/Golang/go-design-pattern/gdp-create/01-singleton/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>单例模式采用了 饿汉式 和 懒汉式 两种实现，个人其实更倾向于饿汉式的实现，简单，并且可以将问题及早暴露，懒汉式虽然支持延迟加载，但是这只是把冷启动时间放到了第一次使用的时候，并没有本质上解决问题，并且为了实现懒汉式还不可避免的需要加锁。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><strong>代码实现:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="comment">// Singleton 饿汉式单例</span></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> singleton *Singletonfunc init() &#123;</span><br><span class="line">singleton = &amp;Singleton&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetInstance 获取实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line"><span class="keyword">return</span> singleton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单元测试:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton_test</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">singleton </span><br><span class="line"><span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetInstance</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">assert.Equal(t, singleton.GetInstance(), singleton.GetInstance())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkGetInstanceParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line"><span class="keyword">if</span> singleton.GetInstance() != singleton.GetInstance() &#123;</span><br><span class="line">b.Errorf(<span class="string">&quot;test fail&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式（双重检测）"><a href="#懒汉式（双重检测）" class="headerlink" title="懒汉式（双重检测）"></a>懒汉式（双重检测）</h3><p><strong>代码实现:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">lazySingleton *Singleton</span><br><span class="line">once          = &amp;sync.Once&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetLazyInstance 懒汉式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetLazyInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line"><span class="keyword">if</span> lazySingleton == <span class="literal">nil</span> &#123;</span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">lazySingleton = &amp;Singleton&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lazySingleton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单元测试:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton_test</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">singleton </span><br><span class="line"><span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetInstance</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">assert.Equal(t, singleton.GetInstance(), singleton.GetInstance())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkGetInstanceParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line"><span class="keyword">if</span> singleton.GetInstance() != singleton.GetInstance() &#123;</span><br><span class="line">b.Errorf(<span class="string">&quot;test fail&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 设计模式之美 </category>
          
          <category> 创建型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang201</title>
      <link href="/library/Golang/advanced-tutorial/golang201/"/>
      <url>/library/Golang/advanced-tutorial/golang201/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 进阶教程笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang Channel 详解</title>
      <link href="/library/Golang/concurrency/go-channel/"/>
      <url>/library/Golang/concurrency/go-channel/</url>
      
        <content type="html"><![CDATA[<h2 id="channel-101"><a href="#channel-101" class="headerlink" title="channel 101"></a>channel 101</h2><h3 id="1-引子"><a href="#1-引子" class="headerlink" title="1. 引子"></a>1. 引子</h3><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。</p><p>如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h4><h2 id="channel-底层原理"><a href="#channel-底层原理" class="headerlink" title="channel 底层原理"></a>channel 底层原理</h2><ul><li><code>buf</code>是有缓冲的channel所特有的结构，用来存储缓存数据。是个循环链表 （为啥是循环链表？普通数组不行吗，普通数组地址和容量固定更适合指定的空间。需要pop 掉元素，普通数组需要全部都前移）</li><li><code>sendx</code>和<code>recvx</code>用于记录<code>buf</code>这个循环链表中的<del>发送或者接收的</del>index</li><li><code>lock</code>是个互斥锁。</li><li><code>recvq</code>和<code>sendq</code>分别是接收(&lt;-channel)或者发送(channel &lt;- xxx)的goroutine抽象出来的结构体(sudog)的队列。是个双向链表</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="type">uint</span>  <span class="comment">// 队列中的总元素个数 </span></span><br><span class="line">dataqsiz <span class="type">uint</span>  <span class="comment">// 环形队列大小，即可存放元素的个数 </span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// 环形队列指针 </span></span><br><span class="line">elemsize <span class="type">uint16</span>  <span class="comment">//每个元素的大小 </span></span><br><span class="line">closed   <span class="type">uint32</span>  <span class="comment">//标识关闭状态 </span></span><br><span class="line">elemtype *_type <span class="comment">// 元素类型 </span></span><br><span class="line">sendx    <span class="type">uint</span>   <span class="comment">// 发送索引，元素写入时存放到队列中的位置</span></span><br><span class="line">recvx    <span class="type">uint</span>   <span class="comment">// 接收索引，元素从队列的该位置读出</span></span><br><span class="line">recvq    waitq  <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">sendq    waitq <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex <span class="comment">//互斥锁，chan不允许并发读写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-读写流程"><a href="#1-读写流程" class="headerlink" title="1. 读写流程"></a>1. 读写流程</h4><blockquote><p>向 channel 写数据:</p><ol><li><p>若等待接收队列 recvq 不为空，则缓冲区中无数据或无缓冲区，将直接从 recvq 取出 G ，并把数据写入，最后把该 G 唤醒，结束发送过程。</p></li><li><p>若缓冲区中有空余位置，则将数据写入缓冲区，结束发送过程。</p></li><li><p>若缓冲区中没有空余位置，则将发送数据写入 G，将当前 G 加入 sendq ，进入睡眠，等待被读 goroutine 唤醒。</p></li></ol></blockquote><blockquote><p>从 channel 读数据</p><ol><li><p>若等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G ，把 G 中数据读出，最后把 G 唤醒，结束读取过程。</p></li><li><p>如果等待发送队列 sendq 不为空，说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程。</p></li><li><p>如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程。</p></li><li><p>将当前 goroutine 加入 recvq ，进入睡眠，等待被写 goroutine 唤醒。</p></li></ol></blockquote><blockquote><p>关闭 channel</p><p>1.关闭 channel 时会将 recvq 中的 G 全部唤醒，本该写入 G 的数据位置为 nil。将 sendq 中的 G 全部唤醒，但是这些 G 会 panic。</p><p>panic 出现的场景还有：</p><ul><li>关闭值为 nil 的 channel</li><li>关闭已经关闭的 channel</li><li>向已经关闭的 channel 中写数据</li></ul></blockquote><h4 id="2-创建channel"><a href="#2-创建channel" class="headerlink" title="2. 创建channel"></a>2. 创建channel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无缓冲的channel由于没有缓冲发送和接收需要同步</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)   </span><br><span class="line"><span class="comment">//有缓冲channel不要求发送和接收操作同步</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>实例化了 chan 的结构体，返回ch指针</p><h4 id="channel中发送send-ch-lt-xxx-和recv-lt-ch-接收"><a href="#channel中发送send-ch-lt-xxx-和recv-lt-ch-接收" class="headerlink" title="channel中发送send(ch &lt;- xxx)和recv(&lt;- ch)接收"></a>channel中发送send(ch &lt;- xxx)和recv(&lt;- ch)接收</h4><p>使用 mutex 加锁操作，新进先出的队列</p><h4 id="当channel缓存满后"><a href="#当channel缓存满后" class="headerlink" title="当channel缓存满后"></a>当channel缓存满后</h4><h5 id="发送满的时候"><a href="#发送满的时候" class="headerlink" title="发送满的时候"></a>发送满的时候</h5><p>当队列已满的时候，G1正在运行，当再次send操作时，会主动调用GO的调度器，让G1等待，并让出M，同时G1也会被抽象成含有G1指针和send元素的sudog结构体保存到hchan的<code>sendq</code>中等待被唤醒。</p><p>当G2 recv操作的时候，G2从缓存队列中取出数据，channel会将等待队列中的G1推出，将G1当时send的数据推到缓存中，然后调用Go的scheduler，唤醒G1，并把G1放到可运行的Goroutine队列中。</p><h5 id="接收满的时候"><a href="#接收满的时候" class="headerlink" title="接收满的时候"></a>接收满的时候</h5><p>这个时候G2会主动调用Go的调度器,让G2等待，并从让出M，让其他G去使用。 G2还会被抽象成含有G2指针和recv空元素的<code>sudog</code>结构体保存到hchan的<code>recvq</code>中等待被唤醒。此时恰好有个goroutine G1开始向channel中推送数据 <code>ch &lt;- 1</code>。 此时，非常有意思的事情发生了：G1并没有锁住channel，然后将数据放到缓存中，而是直接把数据从G1直接copy到了G2的栈中。 这种方式非常的赞！在唤醒过程中，G2无需再获得channel的锁，然后从缓存中取数据。减少了内存的copy，提高了效率。</p><h4 id="4-channel-的状态和操作方式"><a href="#4-channel-的状态和操作方式" class="headerlink" title="4. channel 的状态和操作方式"></a>4. channel 的状态和操作方式</h4><p>如下：</p><table><thead><tr><th align="left">操作</th><th align="left">nil 的 channel</th><th align="left">已关闭的 channel</th><th align="left">正常 channel</th></tr></thead><tbody><tr><td align="left">close 关闭</td><td align="left">panic</td><td align="left">panic</td><td align="left">成功</td></tr><tr><td align="left">ch &lt;- 写</td><td align="left">死锁</td><td align="left">panic</td><td align="left">阻塞或成功</td></tr><tr><td align="left">&lt;-ch 读</td><td align="left">死锁</td><td align="left">零值</td><td align="left">阻塞或成功</td></tr></tbody></table><p>channel一个类型管道，通过它可以在goroutine之间发送和接收消息。它是Golang在语言层面提供的goroutine间的通信方式。</p><p>众所周知，Go依赖于称为CSP（Communicating Sequential Processes）的并发模型，通过Channel实现这种同步模式。Go并发的核心哲学是不要通过共享内存进行通信; 相反，通过沟通分享记忆。</p><h2 id="channel-常见用法"><a href="#channel-常见用法" class="headerlink" title="channel 常见用法"></a>channel 常见用法</h2><h4 id="循环读取"><a href="#循环读取" class="headerlink" title="循环读取"></a>循环读取</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x := <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 并发 </tag>
            
            <tag> go </tag>
            
            <tag> channel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http 网络面试必备</title>
      <link href="/interview/http-interview/"/>
      <url>/interview/http-interview/</url>
      
        <content type="html"><![CDATA[<h1 id="△-46次-从输入-URL-到展现页面的全过程-困难"><a href="#△-46次-从输入-URL-到展现页面的全过程-困难" class="headerlink" title="△ 46次 从输入 URL 到展现页面的全过程  困难"></a><em>△ 46次</em> 从输入 URL 到展现页面的全过程  困难</h1><p>当你在浏览器中输入一个 URL 并按下回车键，直到页面展现，这个过程中涉及多个步骤，包括 DNS 解析、TCP 连接、HTTP 请求和响应、以及页面渲染等。以下是这个全过程的详细描述：</p><h3 id="1-输入-URL"><a href="#1-输入-URL" class="headerlink" title="1. 输入 URL"></a>1. 输入 URL</h3><p>用户在浏览器的地址栏输入一个 URL 并按下回车键。</p><h3 id="2-URL-解析"><a href="#2-URL-解析" class="headerlink" title="2. URL 解析"></a>2. URL 解析</h3><p>浏览器解析输入的 URL，提取协议（如 HTTP、HTTPS）、主机名（如 \<a href="http://www.example.com)、端口号(如果指定)、路径(如/">www.example.com）、端口号（如果指定）、路径（如</a> &#x2F;index.html）和查询参数。</p><h3 id="3-检查缓存"><a href="#3-检查缓存" class="headerlink" title="3. 检查缓存"></a>3. 检查缓存</h3><p>浏览器会首先检查浏览器缓存、操作系统缓存、路由器缓存以及 ISP 缓存中是否有该 URL 对应的资源。如果缓存命中并且资源未过期，则直接从缓存中加载资源。</p><h3 id="4-DNS-解析"><a href="#4-DNS-解析" class="headerlink" title="4. DNS 解析"></a>4. DNS 解析</h3><p>如果缓存未命中，浏览器需要将主机名转换为 IP 地址。这个过程称为 DNS 解析。步骤如下：</p><ol><li><strong>浏览器缓存</strong>：检查浏览器的 DNS 缓存是否有该域名的 IP 地址。</li><li><strong>操作系统缓存</strong>：如果浏览器缓存没有命中，检查操作系统的 DNS 缓存。</li><li><strong>本地 HOSTS 文件</strong>：操作系统会查找本地的 HOSTS 文件，看是否有手动配置的域名-IP 映射。</li><li><strong>DNS 服务器查询</strong>：如果以上步骤都没有命中，操作系统会向配置的 DNS 服务器（通常是 ISP 提供的或手动配置的 DNS 服务器）发起 DNS 查询。DNS 服务器会递归查询其他 DNS 服务器，直到找到对应的 IP 地址。</li></ol><h3 id="5-建立-TCP-连接"><a href="#5-建立-TCP-连接" class="headerlink" title="5. 建立 TCP 连接"></a>5. 建立 TCP 连接</h3><p>DNS 解析得到 IP 地址后，浏览器与服务器建立 TCP 连接。具体步骤如下：</p><ol><li><strong>三次握手</strong>：TCP 使用三次握手来建立连接：<ul><li>客户端发送一个 SYN 数据包给服务器，表示请求建立连接。</li><li>服务器收到后，发送一个 SYN-ACK 数据包给客户端，表示同意连接。</li><li>客户端收到 SYN-ACK 数据包后，发送一个 ACK 数据包给服务器，连接建立成功。</li></ul></li></ol><h3 id="6-发送-HTTP-请求"><a href="#6-发送-HTTP-请求" class="headerlink" title="6. 发送 HTTP 请求"></a>6. 发送 HTTP 请求</h3><p>TCP 连接建立后，浏览器构建并发送 HTTP 请求。包括以下内容：</p><ol><li><strong>请求行</strong>：包括请求方法（如 GET、POST）、URL 和 HTTP 版本。</li><li><strong>请求头</strong>：包括主机名、用户代理、接受的内容类型、接受的语言、Cookie 等信息。</li><li><strong>请求体</strong>（可选）：主要用于 POST 请求，包含提交的数据。</li></ol><h3 id="7-服务器处理请求"><a href="#7-服务器处理请求" class="headerlink" title="7. 服务器处理请求"></a>7. 服务器处理请求</h3><p>服务器收到请求后，处理请求并生成响应。服务器的处理过程包括：</p><ol><li><strong>请求解析</strong>：解析请求行和请求头，提取必要的信息。</li><li><strong>身份验证</strong>（可选）：验证用户身份，如检查 Cookie 或 Token。</li><li><strong>路由处理</strong>：根据请求的路径和方法，将请求路由到相应的处理程序。</li><li><strong>业务逻辑</strong>：执行具体的业务逻辑，如查询数据库、调用外部 API、执行计算等。</li><li><strong>生成响应</strong>：生成响应头和响应体。响应体可以是 HTML、JSON、XML、图像、文件等。</li></ol><h3 id="8-发送-HTTP-响应"><a href="#8-发送-HTTP-响应" class="headerlink" title="8. 发送 HTTP 响应"></a>8. 发送 HTTP 响应</h3><p>服务器将生成的 HTTP 响应通过已建立的 TCP 连接发送给客户端。响应包括：</p><ol><li><strong>状态行</strong>：包括 HTTP 版本、状态码（如 200、404、500）和状态描述。</li><li><strong>响应头</strong>：包括内容类型、内容长度、日期、服务器信息、Cookie 等。</li><li><strong>响应体</strong>：包含实际的响应数据，如 HTML 内容、图像数据等。</li></ol><h3 id="9-浏览器接收响应"><a href="#9-浏览器接收响应" class="headerlink" title="9. 浏览器接收响应"></a>9. 浏览器接收响应</h3><p>浏览器接收到服务器的响应后，开始处理响应数据：</p><ol><li><strong>解析 HTML</strong>：浏览器解析 HTML 文档，构建 DOM 树。</li><li><strong>加载资源</strong>：解析 HTML 时，发现外部资源（如 CSS、JavaScript、图像等），会发起新的 HTTP 请求加载这些资源。</li><li><strong>解析 CSS</strong>：浏览器解析 CSS，构建 CSSOM 树。</li><li><strong>执行 JavaScript</strong>：浏览器解析并执行 JavaScript，可能会进一步修改 DOM 树和 CSSOM 树。</li><li><strong>构建渲染树</strong>：根据 DOM 树和 CSSOM 树构建渲染树。</li></ol><h3 id="10-页面渲染"><a href="#10-页面渲染" class="headerlink" title="10. 页面渲染"></a>10. 页面渲染</h3><p>浏览器根据渲染树，计算每个元素的位置和样式，进行页面布局（Layout）。接着，浏览器将渲染树绘制到屏幕上，展示完整的页面。</p><h3 id="11-持续加载和交互"><a href="#11-持续加载和交互" class="headerlink" title="11. 持续加载和交互"></a>11. 持续加载和交互</h3><p>页面加载完成后，用户可以与页面进行交互。JavaScript 可以继续执行，响应用户操作，发起异步请求（如 AJAX 或 Fetch），动态更新页面内容。</p><h3 id="过程中的优化"><a href="#过程中的优化" class="headerlink" title="过程中的优化"></a>过程中的优化</h3><p>在这个过程中，可以通过多种优化手段来提升页面加载速度和用户体验，例如：</p><ul><li><strong>DNS 预解析</strong>：在 HTML 中使用 <code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//example.com&quot;&gt;</code> 提前解析 DNS。</li><li><strong>TCP 连接复用</strong>：使用 HTTP&#x2F;2 或保持 TCP 连接来复用连接，减少握手延迟。</li><li><strong>缓存优化</strong>：合理使用缓存控制头（如 <code>Cache-Control</code>、<code>Expires</code>）和浏览器缓存。</li><li><strong>压缩和缩小资源</strong>：使用 Gzip 或 Brotli 压缩传输内容，缩小 CSS、JavaScript 和图像资源的大小。</li><li><strong>异步加载资源</strong>：使用 <code>async</code> 或 <code>defer</code> 属性异步加载 JavaScript，减少阻塞渲染。</li></ul><p>通过以上过程和优化手段，浏览器能够高效地将用户输入的 URL 展现为完整的网页。</p><h1 id="△-42次-TCP-怎么保证可靠传输？-中等"><a href="#△-42次-TCP-怎么保证可靠传输？-中等" class="headerlink" title="△ 42次 TCP 怎么保证可靠传输？  中等"></a><strong>△ 42次</strong> TCP 怎么保证可靠传输？  中等</h1><p>TCP（Transmission Control Protocol，传输控制协议）通过以下几个机制来保证数据的可靠传输：</p><ol><li><p><strong>三次握手（Three-Way Handshake）</strong>：</p><ul><li><strong>目的</strong>：建立连接并同步双方的序列号和确认号，确保通信双方准备好进行数据传输。</li><li><strong>过程</strong>：<ol><li>客户端发送一个带有 SYN 标志的数据包给服务器，表示请求建立连接。</li><li>服务器收到后，回应一个带有 SYN 和 ACK 标志的数据包，表示同意连接并确认收到的序列号。</li><li>客户端收到服务器的 SYN-ACK 包后，发送一个带有 ACK 标志的数据包给服务器，表示连接建立成功。</li></ol></li></ul></li><li><p><strong>四次挥手（Four-Way Handshake）</strong>：</p><ul><li><strong>目的</strong>：安全地终止连接，确保双方都已经完成数据传输。</li><li><strong>过程</strong>：<ol><li>客户端发送一个带有 FIN 标志的数据包，表示请求终止连接。</li><li>服务器收到后，回应一个带有 ACK 标志的数据包，确认收到请求。</li><li>服务器发送一个带有 FIN 标志的数据包，表示同意终止连接。</li><li>客户端收到后，回应一个带有 ACK 标志的数据包，确认连接终止。</li></ol></li></ul></li><li><p><strong>序列号和确认号（Sequence Number and Acknowledgment Number）</strong>：</p><ul><li><strong>序列号</strong>：每个字节的数据都有一个序列号，用于确保数据按照正确的顺序接收。</li><li><strong>确认号</strong>：接收方会发回确认号，告知发送方已收到数据的序列号范围。这样可以确认数据的接收情况。</li></ul></li><li><p><strong>流量控制（Flow Control）</strong>：</p><ul><li><strong>滑动窗口机制</strong>：TCP 使用滑动窗口机制来控制数据的发送速率，防止发送方发送的数据超出接收方的处理能力。</li><li><strong>窗口大小</strong>：接收方会通知发送方当前可以接收的数据量（窗口大小），发送方根据这个值调整发送速率。</li></ul></li><li><p><strong>拥塞控制（Congestion Control）</strong>：</p><ul><li><strong>慢启动（Slow Start）</strong>：初始阶段，发送方以较慢的速度发送数据，然后逐步增加发送速率。</li><li><strong>拥塞避免（Congestion Avoidance）</strong>：当发送速率达到一定阈值后，逐步增加发送窗口，以避免拥塞。</li><li><strong>快速重传和快速恢复（Fast Retransmit and Fast Recovery）</strong>：检测到数据丢失后，发送方会快速重传丢失的数据包，并采取措施快速恢复发送速率。</li></ul></li><li><p><strong>重传机制（Retransmission Mechanism）</strong>：</p><ul><li><strong>超时重传</strong>：发送方在发送数据包后启动定时器，如果在规定时间内没有收到确认，重新发送数据包。</li><li><strong>快速重传</strong>：当发送方连续收到三个重复的确认号（ACK）时，立即重传丢失的数据包，不必等待超时。</li></ul></li><li><p><strong>校验和（Checksum）</strong>：</p><ul><li><strong>数据完整性</strong>：每个 TCP 数据包都包含一个校验和，用于检测数据在传输过程中是否发生错误。接收方计算数据的校验和，并与包中的校验和进行比较，如果不匹配，则丢弃该数据包。</li></ul></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>TCP 通过上述机制实现可靠的数据传输，确保数据在不可靠的网络环境中能够准确、有序地传输到目标端。具体而言，TCP 的三次握手和四次挥手确保了连接的建立和关闭，序列号和确认号确保了数据的有序传输，流量控制和拥塞控制机制避免了网络拥塞，重传机制确保了数据包丢失时的重传，而校验和则确保了数据的完整性。通过这些机制，TCP 提供了一个可靠的端到端的数据传输服务。</p><h1 id="△-42次-TCP-中常见的拥塞控制算法有哪些？-中等"><a href="#△-42次-TCP-中常见的拥塞控制算法有哪些？-中等" class="headerlink" title="△ 42次 TCP 中常见的拥塞控制算法有哪些？  中等"></a><strong>△ 42次</strong> TCP 中常见的拥塞控制算法有哪些？  中等</h1><ul><li>慢启动</li><li>拥塞避免</li><li>快重传</li><li>快恢复</li></ul><h1 id="△-40次-HTTP-与-HTTPS-有哪些区别？-中等"><a href="#△-40次-HTTP-与-HTTPS-有哪些区别？-中等" class="headerlink" title="△ 40次 HTTP 与 HTTPS 有哪些区别？  中等"></a><em>△ 40次</em> HTTP 与 HTTPS 有哪些区别？  中等</h1><ul><li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL&#x2F;TLS之上，SSL&#x2F;TLS运行在TCP之上，所有传输的内容都经过加密的。    </li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li></ul><h1 id="△-38次-简述常见的-HTTP-状态码的含义（301，304，401，403）-简单"><a href="#△-38次-简述常见的-HTTP-状态码的含义（301，304，401，403）-简单" class="headerlink" title="△ 38次 简述常见的 HTTP 状态码的含义（301，304，401，403）  简单"></a><em>△ 38次</em> 简述常见的 HTTP 状态码的含义（301，304，401，403）  简单</h1><h4 id="200-ok"><a href="#200-ok" class="headerlink" title="200 ok"></a>200 ok</h4><p>请求成功。成功的含义取决于 HTTP 方法：</p><ul><li><code>GET</code>: 资源已被提取并在消息正文中传输。</li><li><code>HEAD</code>: 实体标头位于消息正文中。</li><li><code>PUT</code> or <code>POST</code>: 描述动作结果的资源在消息体中传输。</li><li><code>TRACE</code>: 消息正文包含服务器收到的请求消息。<h4 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h4>请求资源的 URL 已永久更改。在响应中给出了新的 URL。<h4 id="302"><a href="#302" class="headerlink" title="302"></a>302</h4>临时重定向<h4 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h4>这是用于缓存的目的。它告诉客户端响应还没有被修改，因此客户端可以继续使用相同的缓存版本的响应。</li></ul><h4 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h4><p>由于被认为是客户端错误（例如，错误的请求语法、无效的请求消息帧或欺骗性的请求路由），服务器无法或不会处理请求。</p><h4 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h4><p>虽然 HTTP 标准指定了”unauthorized”，但从语义上来说，这个响应意味着”unauthenticated”。也就是说，客户端必须对自身进行身份验证才能获得请求的响应。</p><h4 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h4><p>客户端没有访问内容的权限；也就是说，它是未经授权的，因此服务器拒绝提供请求的资源。与 <code>401 Unauthorized</code> 不同，服务器知道客户端的身份。</p><h4 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h4><p>服务器找不到请求的资源。在浏览器中，这意味着无法识别 URL。在 API 中，这也可能意味着端点有效，但资源本身不存在。服务器也可以发送此响应，而不是 <code>403 Forbidden</code>，以向未经授权的客户端隐藏资源的存在。这个响应代码可能是最广为人知的，因为它经常出现在网络上。</p><h4 id="405-Method-Not-Allowed"><a href="#405-Method-Not-Allowed" class="headerlink" title="405 Method Not Allowed"></a>405 Method Not Allowed</h4><p>服务器知道请求方法，但目标资源不支持该方法。例如，API 可能不允许调用<code>DELETE</code>来删除资源。</p><h4 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h4><p>服务器遇到了不知道如何处理的情况。</p><h4 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h4><p>此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。</p><h4 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h4><p>服务器没有准备好处理请求。常见原因是服务器因维护或重载而停机。请注意，与此响应一起，应发送解释问题的用户友好页面。这个响应应该用于临时条件和如果可能的话，HTTP 标头 <code>Retry-After</code> 字段应该包含恢复服务之前的估计时间。网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。</p><h4 id="504-Gateway-Timeout"><a href="#504-Gateway-Timeout" class="headerlink" title="504 Gateway Timeout"></a>504 Gateway Timeout</h4><p>当服务器充当网关且无法及时获得响应时，会给出此错误响应。</p><h1 id="△-38次-简述-TCP-三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？-中等"><a href="#△-38次-简述-TCP-三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？-中等" class="headerlink" title="△ 38次 简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？  中等"></a><em>△ 38次</em> 简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？  中等</h1><h3 id="TCP-的特性"><a href="#TCP-的特性" class="headerlink" title="TCP 的特性"></a>TCP 的特性</h3><ul><li>TCP 提供一种<strong>面向连接的、可靠的</strong>字节流服务</li><li>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP</li><li>TCP 使用校验和，确认和重传机制来保证可靠传输</li><li>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li><li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li></ul><p><strong>注意</strong>：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。<br>TCP（Transmission Control Protocol，传输控制协议）使用三次握手（Three-Way Handshake）和四次挥手（Four-Way Handshake）来建立和终止连接。每个过程都有其特定的目的，以确保数据传输的可靠性和连接管理的正确性。</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><strong>目的</strong>：三次握手的主要目的是确保双方都准备好开始通信，并同步初始序列号。这为可靠的数据传输提供了基础。</p><ol><li><p><strong>第一次握手（SYN）</strong>：</p><ul><li>客户端发送一个带有 SYN（同步）标志的数据包给服务器。这个数据包包含一个初始序列号 <code>seq=x</code>。</li><li>目的：客户端告诉服务器它想建立连接，并发送一个初始序列号。</li></ul></li><li><p><strong>第二次握手（SYN-ACK）</strong>：</p><ul><li>服务器收到 SYN 数据包后，回应一个带有 SYN 和 ACK（确认）标志的数据包。这个数据包包含服务器的初始序列号 <code>seq=y</code>，并对客户端的序列号进行确认 <code>ack=x+1</code>。</li><li>目的：服务器同意建立连接，并确认收到客户端的初始序列号。</li></ul></li><li><p><strong>第三次握手（ACK）</strong>：</p><ul><li>客户端收到 SYN-ACK 数据包后，发送一个带有 ACK 标志的数据包给服务器，确认收到服务器的初始序列号 <code>ack=y+1</code>。</li><li>目的：客户端确认连接已经建立，并告知服务器自己也准备好了。</li></ul></li></ol><h4 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h4><ul><li><strong>双向确认</strong>：三次握手确保了客户端和服务器双方都知道对方准备好了，并且初始序列号已经同步。这避免了因为过期的 SYN 数据包导致的错误连接。</li><li><strong>防止重复连接</strong>：在网络延迟或其他原因导致的重复数据包情况下，三次握手能够防止重复连接的产生。</li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><strong>目的</strong>：四次挥手的主要目的是确保双方都安全地终止连接，并且所有的数据传输都已经完成。</p><ol><li><p><strong>第一次挥手（FIN）</strong>：</p><ul><li>客户端发送一个带有 FIN（终止）标志的数据包，表示不再发送数据了。这个数据包包含一个序列号 <code>seq=u</code>。</li><li>目的：客户端告知服务器它已经发送完数据，请求终止连接。</li></ul></li><li><p><strong>第二次挥手（ACK）</strong>：</p><ul><li>服务器收到 FIN 数据包后，回应一个带有 ACK 标志的数据包，确认收到客户端的终止请求 <code>ack=u+1</code>。</li><li>目的：服务器确认收到客户端的终止请求，但可能仍有数据要发送。</li></ul></li><li><p><strong>第三次挥手（FIN）</strong>：</p><ul><li>服务器发送一个带有 FIN 标志的数据包，表示它也准备好终止连接。这个数据包包含一个序列号 <code>seq=v</code>。</li><li>目的：服务器告知客户端它也已经发送完数据，请求终止连接。</li></ul></li><li><p><strong>第四次挥手（ACK）</strong>：</p><ul><li>客户端收到 FIN 数据包后，发送一个带有 ACK 标志的数据包，确认收到服务器的终止请求 <code>ack=v+1</code>。</li><li>目的：客户端确认连接已经终止。</li></ul></li></ol><h4 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h4><ul><li><strong>双向独立关闭</strong>：TCP 连接是全双工的，即双方都可以独立地关闭各自的发送和接收通道。四次挥手确保了每一方向的连接都能安全关闭。</li><li><strong>数据完整性</strong>：通过四次挥手，确保所有未发送的数据都能被正确接收，防止数据丢失。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>三次握手</strong>：用于建立连接，确保双方都准备好开始通信，并同步初始序列号。三次握手提供了双向确认，防止重复连接，确保连接的可靠性。</li><li><strong>四次挥手</strong>：用于安全地终止连接，确保双方都完成数据传输，并独立地关闭各自的连接。四次挥手确保了数据的完整性和连接的正确关闭。</li></ul><p>这两个过程共同确保了 TCP 连接的可靠性、数据的完整性和连接管理的正确性。</p><h1 id="△-34次-简述-HTTPS-的加密与认证过程-中等"><a href="#△-34次-简述-HTTPS-的加密与认证过程-中等" class="headerlink" title="△ 34次 简述 HTTPS 的加密与认证过程  中等"></a><em>△ 34次</em> 简述 HTTPS 的加密与认证过程  中等</h1><h3 id="SSL-握手"><a href="#SSL-握手" class="headerlink" title="SSL 握手"></a>SSL 握手</h3><ol><li>客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。</li><li>服务端确认双方使用的加密方法，并给出数字证书、一个服务端生成的随机数（Server random）。</li><li>客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用证书中的公钥，对其进行加密后发给客户端。</li><li>客户端使用自己的私钥，换算出服务端的新随机数（Premaster secret）。</li><li>双方根据约定好的加密方法，使用前面三个随机数，生成“对话秘钥”（session key），用来加密接下来的整个对话过程。</li></ol><h1 id="△-34次-什么是跨域，什么情况下会发生跨域请求？-中等"><a href="#△-34次-什么是跨域，什么情况下会发生跨域请求？-中等" class="headerlink" title="△ 34次 什么是跨域，什么情况下会发生跨域请求？  中等"></a><strong>△ 34次</strong> 什么是跨域，什么情况下会发生跨域请求？  中等</h1><p>跨域（Cross-Origin）是指从一个域向另一个域发出请求的行为。浏览器的同源策略（Same-Origin Policy）限制了这种行为，以保护用户的安全和隐私。同源策略规定，只有当请求的源（协议、域名、端口）与当前页面的源相同时，才能共享资源。</p><h3 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h3><p>同源策略是一种安全机制，限制一个源的文档或脚本与来自另一个源的资源进行交互。具体来说，同源策略要求以下三者必须完全相同：</p><ol><li>协议（如 <code>http</code>、<code>https</code>）</li><li>域名（如 <code>example.com</code>）</li><li>端口（如 <code>80</code>、<code>443</code>）</li></ol><h3 id="什么是跨域请求"><a href="#什么是跨域请求" class="headerlink" title="什么是跨域请求"></a>什么是跨域请求</h3><p>跨域请求是指当前页面向不同源的服务器发出 HTTP 请求。以下情况都会触发跨域请求：</p><ul><li><strong>不同的协议</strong>（例如，从 <code>https://example.com</code> 请求 <code>http://example.com</code> 的资源）</li><li><strong>不同的域名</strong>（例如，从 <code>example.com</code> 请求 <code>api.example.com</code> 的资源）</li><li><strong>不同的端口</strong>（例如，从 <code>example.com:80</code> 请求 <code>example.com:8080</code> 的资源）</li></ul><h3 id="常见的跨域请求场景"><a href="#常见的跨域请求场景" class="headerlink" title="常见的跨域请求场景"></a>常见的跨域请求场景</h3><ol><li><p><strong>Ajax 请求</strong>：</p><ul><li>通过 JavaScript 发出的 <code>XMLHttpRequest</code> 或 <code>Fetch</code> 请求，目标服务器与当前页面的源不同。</li></ul></li><li><p><strong>图片、脚本、样式</strong>：</p><ul><li>在 HTML 中引入的 <code>&lt;img&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;link&gt;</code> 等标签的 <code>src</code> 或 <code>href</code> 属性指向不同源。</li></ul></li><li><p><strong>Web 字体</strong>：</p><ul><li>使用 <code>@font-face</code> 在 CSS 中加载不同源的字体文件。</li></ul></li><li><p><strong>嵌入框架</strong>：</p><ul><li>使用 <code>&lt;iframe&gt;</code> 加载不同源的页面内容。</li></ul></li><li><p><strong>表单提交</strong>：</p><ul><li>HTML 表单的 <code>action</code> 属性指向不同源。</li></ul></li><li><p><strong>WebSockets</strong>：</p><ul><li>使用 WebSocket 连接到不同源的服务器。</li></ul></li></ol><h3 id="解决跨域问题的方法"><a href="#解决跨域问题的方法" class="headerlink" title="解决跨域问题的方法"></a>解决跨域问题的方法</h3><p>浏览器默认会阻止不符合同源策略的跨域请求，但可以通过以下几种方式来解决跨域问题：</p><ol><li><p><strong>JSONP（JSON with Padding）</strong>：</p><ul><li>利用 <code>&lt;script&gt;</code> 标签不受同源策略限制的特点，通过动态插入 <code>&lt;script&gt;</code> 标签来实现跨域请求。JSONP 只能用于 GET 请求。</li></ul></li><li><p><strong>CORS（跨域资源共享）</strong>：</p><ul><li>服务器在响应头中设置适当的 CORS 头信息，例如 <code>Access-Control-Allow-Origin</code>，来指示浏览器允许跨域请求。CORS 是最常用、最灵活的跨域解决方案。</li></ul></li><li><p><strong>代理服务器</strong>：</p><ul><li>使用服务器端的代理，将跨域请求发送到自己的服务器，然后由服务器向目标服务器发出请求，并将结果返回给客户端。这种方式可以完全绕过浏览器的同源策略。</li></ul></li><li><p><strong>跨域资源嵌入</strong>：</p><ul><li>某些标签（如 <code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;iframe&gt;</code> 等）可以直接嵌入跨域资源。这种方式虽然简单，但不适用于需要进行复杂数据交互的情况。</li></ul></li></ol><h3 id="CORS-详细说明"><a href="#CORS-详细说明" class="headerlink" title="CORS 详细说明"></a>CORS 详细说明</h3><p>CORS（Cross-Origin Resource Sharing）是目前最常用的跨域解决方案，通过在 HTTP 头中设置适当的 CORS 头信息来实现。以下是一些常见的 CORS 头信息及其含义：</p><ul><li><p>**<code>Access-Control-Allow-Origin</code>**：</p><ul><li>指定允许哪些域可以访问资源。可以是具体的域名或通配符 <code>*</code>。</li></ul></li><li><p>**<code>Access-Control-Allow-Methods</code>**：</p><ul><li>指定允许的 HTTP 方法（如 GET、POST、PUT、DELETE）。</li></ul></li><li><p>**<code>Access-Control-Allow-Headers</code>**：</p><ul><li>指定允许的请求头字段。</li></ul></li><li><p>**<code>Access-Control-Allow-Credentials</code>**：</p><ul><li>是否允许发送凭据（如 Cookie）。如果设置为 <code>true</code>，<code>Access-Control-Allow-Origin</code> 不能为 <code>*</code>，必须指定具体的域名。</li></ul></li><li><p>**<code>Access-Control-Expose-Headers</code>**：</p><ul><li>指定哪些响应头可以被客户端 JavaScript 访问。</li></ul></li><li><p>**<code>Access-Control-Max-Age</code>**：</p><ul><li>指定预检请求的结果可以缓存多长时间。</li></ul></li></ul><h3 id="示例：使用-CORS-允许跨域请求"><a href="#示例：使用-CORS-允许跨域请求" class="headerlink" title="示例：使用 CORS 允许跨域请求"></a>示例：使用 CORS 允许跨域请求</h3><p>假设有一个服务器的域名为 <code>api.example.com</code>，我们希望允许 <code>www.example.com</code> 访问其资源，可以在 <code>api.example.com</code> 的响应头中设置：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://www.example.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>GET, POST</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>Content-Type</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span><span class="punctuation">: </span>true</span><br></pre></td></tr></table></figure><p>这样，当 <code>www.example.com</code> 发起跨域请求时，浏览器会检查这些 CORS 头信息，确定是否允许跨域请求。如果头信息匹配，则请求成功，否则浏览器会阻止请求。</p><p>通过这些方法，可以在确保安全的前提下，实现跨域请求和数据共享。</p><h1 id="△-28次-DNS-查询服务器的基本流程是什么？DNS-劫持是什么？-中等-参考1-参考2"><a href="#△-28次-DNS-查询服务器的基本流程是什么？DNS-劫持是什么？-中等-参考1-参考2" class="headerlink" title="△ 28次 DNS 查询服务器的基本流程是什么？DNS 劫持是什么？  中等 参考1 参考2"></a><strong>△ 28次</strong> DNS 查询服务器的基本流程是什么？DNS 劫持是什么？  中等 <a href="https://www.cloudflare.com/learning/dns/what-is-dns/">参考1</a> <a href="https://www.ruanyifeng.com/blog/2016/06/dns.html">参考2</a></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主机名.次级域名.顶级域名.根域名</span><br><span class="line"><span class="comment"># 即</span></span><br><span class="line">host.sld.tld.root</span><br></pre></td></tr></table></figure><h4 id="DNS-查找的-8-个步骤："><a href="#DNS-查找的-8-个步骤：" class="headerlink" title="DNS 查找的 8 个步骤："></a>DNS 查找的 8 个步骤：</h4><ol><li>用户在 Web 浏览器中键入 “example.com”，查询传输到 Internet 中，并被 DNS 递归解析器接收。</li><li>接着，解析器查询 DNS 根域名服务器（.）。</li><li>然后，根服务器使用存储其域信息的顶级域（TLD）DNS 服务器（例如 .com 或 .net）的地址响应该解析器。在搜索 example.com 时，我们的请求指向 .com TLD。</li><li>然后，解析器向 .com TLD 发出请求。</li><li>TLD 服务器随后使用该域的域名服务器 example.com 的 IP 地址进行响应。</li><li>最后，递归解析器将查询发送到域的域名服务器。</li><li>example.com 的 IP 地址而后从域名服务器返回解析器。</li><li>然后 DNS 解析器使用最初请求的域的 IP 地址响应 Web 浏览器。<h4 id="DNS-查找的这-8-个步骤返回-example-com-的-IP-地址后，浏览器便能发出对该网页的请求："><a href="#DNS-查找的这-8-个步骤返回-example-com-的-IP-地址后，浏览器便能发出对该网页的请求：" class="headerlink" title="DNS 查找的这 8 个步骤返回 example.com 的 IP 地址后，浏览器便能发出对该网页的请求："></a>DNS 查找的这 8 个步骤返回 example.com 的 IP 地址后，浏览器便能发出对该网页的请求：</h4></li><li>浏览器向该 IP 地址发出 <a href="https://www.cloudflare-cn.com/learning/ddos/glossary/hypertext-transfer-protocol-http/">HTTP</a> 请求。</li><li>位于该 IP 的服务器返回将在浏览器中呈现的网页（第 10 步）。</li></ol><h1 id="△-26次-TCP的拥塞控制具体是怎么实现的？UDP有拥塞控制吗？-中等"><a href="#△-26次-TCP的拥塞控制具体是怎么实现的？UDP有拥塞控制吗？-中等" class="headerlink" title="△ 26次 TCP的拥塞控制具体是怎么实现的？UDP有拥塞控制吗？  中等"></a><strong>△ 26次</strong> TCP的拥塞控制具体是怎么实现的？UDP有拥塞控制吗？  中等</h1><h3 id="慢启动-Slow-start"><a href="#慢启动-Slow-start" class="headerlink" title="慢启动(Slow start)"></a>慢启动(Slow start)</h3><ul><li>拥塞窗口的初始值为1 </li><li>每收到一个对发出的数据段的ACK确认，便将拥塞窗口的值增加1,cwnd++ (呈线性上升) </li><li>每当过了一个RTT(Round Trip Time)，cwnd &#x3D; cwnd*2; 呈指数让升 </li><li>阈值ssthresh（slow start threshold），是一个上限，当cwnd &gt;&#x3D; ssthresh时，就会进入“拥塞避免算法”</li></ul><h3 id="拥塞避免-Congestion-avoidance"><a href="#拥塞避免-Congestion-avoidance" class="headerlink" title="拥塞避免(Congestion avoidance)"></a>拥塞避免(Congestion avoidance)</h3><ul><li>达到阈值（一般是16）开始加法递增</li><li>TCP连接进行初始化的时候，cwnd&#x3D;1,ssthresh&#x3D;16 </li><li>在慢启动算法开始时，cwnd的初始值是1，每次发送方收到一个ACK拥塞窗口就增加1，当ssthresh &#x3D;cwnd时，就启动拥塞控制算法，拥塞窗口按照规律增长 </li><li>当cwnd&#x3D;24时，网络出现超时，发送方收不到确认ACK，此时设置ssthresh&#x3D;12（二分之一cwnd），设置cwnd&#x3D;1，然后重新开始慢启动算法，当cwnd&#x3D;ssthresh&#x3D;12，慢启动算法变为拥塞控制算法，cwnd按照线性的速度进行增长</li></ul><h3 id="快速重传-Fast-retransmit"><a href="#快速重传-Fast-retransmit" class="headerlink" title="快速重传(Fast retransmit)"></a>快速重传(Fast retransmit)</h3><ul><li>3次受到重复 ack 报文，立刻重传该报文</li><li>把ssthresh设置为cwnd的一半 </li><li>把cwnd再设置为ssthresh的值(具体实现有些为ssthresh+3*MSS) </li><li>重新进入拥塞避免阶段（加法递增）</li></ul><h3 id="快速恢复-Fast-Recovery"><a href="#快速恢复-Fast-Recovery" class="headerlink" title="快速恢复(Fast Recovery)"></a>快速恢复(Fast Recovery)</h3><ul><li>当收到3个重复ACK时，把ssthresh设置为cwnd的一半，把cwnd设置为ssthresh的值加3，然后重传丢失的报文段，加3的原因是因为收到3个重复的ACK，表明有3个“老”的数据包离开了网络，(cwnd &#x3D; sshthresh + 3 * MSS (3的意思是确认有3个数据包被收到了)) </li><li>重传Duplicated ACKs指定的数据包 </li><li>如果再收到重复的ACK时，拥塞窗口增加1。 </li><li>当收到新的数据包的ACK时，把cwnd设置为第一步中的ssthresh的值。原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。</li><li>乘法减半 + 加法递增</li></ul><h3 id="选择性应答-selective-acknowledgement-SACK-算法"><a href="#选择性应答-selective-acknowledgement-SACK-算法" class="headerlink" title="选择性应答( selective acknowledgement,SACK)算法"></a>选择性应答( selective acknowledgement,SACK)算法</h3><h1 id="△-26次-TCP-与-UDP-在网络协议中的哪一层，他们之间有什么区别？"><a href="#△-26次-TCP-与-UDP-在网络协议中的哪一层，他们之间有什么区别？" class="headerlink" title="△ 26次 TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？"></a><em>△ 26次</em> TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？</h1><p>传输层协议</p><ul><li>TCP 面向连接（如打电话要先拨号建立连接）提供可靠的服务，UDP 是无连接的，即发送数据之前不需要建立连接，UDP 尽最大努力交付，即不保证可靠交付。</li><li>UDP 具有较好的实时性，工作效率比 TCP 高，适用于对高速传输和实时性有较高的通信或广播通信。</li><li>每一条 TCP 连接只能是一对一的，UDP 支持一对一，一对多，多对一和多对多的交互通信。</li><li>UDP 分组首部开销小，TCP 首部开销 20 字节，UDP 的首部开销小，只有 8 个字节。</li><li>TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流，UDP 是面向报文的一次交付一个完整的报文，报文不可分割，报文是 UDP 数据报处理的最小单位。</li><li>UDP 适合一次性传输较小数据的网络应用，如 DNS，SNMP 等。</li></ul><p>△ 24次</p><p>什么是 TCP 粘包和拆包？  简单</p><h1 id="△-24次-简述-HTTP-1-0，1-1，2-0-的主要区别-简单"><a href="#△-24次-简述-HTTP-1-0，1-1，2-0-的主要区别-简单" class="headerlink" title="△ 24次 简述 HTTP 1.0，1.1，2.0 的主要区别  简单"></a><strong>△ 24次</strong> 简述 HTTP 1.0，1.1，2.0 的主要区别  简单</h1><p>HTTP（HyperText Transfer Protocol）是用于在客户端和服务器之间传输超文本的协议。HTTP 协议从 1.0 发展到 2.0，经历了多次改进，主要体现在连接管理、性能和安全性等方面。</p><h3 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><p><strong>发布时间</strong>：1996年</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ol><li><p><strong>无连接</strong>：</p><ul><li>每个请求&#x2F;响应对使用单独的 TCP 连接。这意味着每次请求都需要建立和关闭 TCP 连接，导致额外的开销。</li></ul></li><li><p><strong>请求&#x2F;响应模型</strong>：</p><ul><li>客户端发送请求，服务器处理后返回响应。</li></ul></li><li><p><strong>缺少持久连接</strong>：</p><ul><li>每次请求完成后连接就关闭，不能复用连接。</li></ul></li><li><p><strong>有限的缓存控制</strong>：</p><ul><li>使用 <code>Expires</code> 头部来控制缓存，功能有限。</li></ul></li></ol><h3 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h3><p><strong>发布时间</strong>：1997年</p><h4 id="主要改进："><a href="#主要改进：" class="headerlink" title="主要改进："></a>主要改进：</h4><ol><li><p><strong>持久连接</strong>：</p><ul><li>默认使用持久连接（连接复用），通过 <code>Connection: keep-alive</code> 头部保持连接，使得多个请求可以复用同一个 TCP 连接，减少连接建立和关闭的开销。</li></ul></li><li><p><strong>管道化</strong>：</p><ul><li>支持请求管道化，即在收到前一个请求的响应之前，客户端可以继续发送后续请求，虽然服务器仍然是按顺序处理请求。</li></ul></li><li><p><strong>分块传输编码</strong>：</p><ul><li>使用 <code>Transfer-Encoding: chunked</code>，允许服务器逐步发送响应数据，而无需事先知道内容的总长度。</li></ul></li><li><p><strong>缓存控制</strong>：</p><ul><li>增加了更复杂的缓存机制，使用 <code>Cache-Control</code> 头部提供更精确的缓存指令（如 <code>max-age</code>、<code>no-cache</code>、<code>no-store</code> 等）。</li></ul></li><li><p><strong>范围请求</strong>：</p><ul><li>支持部分内容请求，通过 <code>Range</code> 头部，客户端可以请求资源的特定部分（用于断点续传、视频流等）。</li></ul></li><li><p><strong>更多的请求&#x2F;响应头</strong>：</p><ul><li>增加了许多新的请求和响应头（如 <code>Host</code> 头部），使得请求可以包含更多的信息。</li></ul></li></ol><h3 id="HTTP-x2F-2-0"><a href="#HTTP-x2F-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h3><p><strong>发布时间</strong>：2015年</p><h4 id="主要改进：-1"><a href="#主要改进：-1" class="headerlink" title="主要改进："></a>主要改进：</h4><ol><li><p><strong>二进制分帧</strong>：</p><ul><li>HTTP&#x2F;2 引入了二进制分帧层，所有数据在传输时都被分成更小的二进制帧。这种方式更高效且易于解析，取代了 HTTP&#x2F;1.1 的纯文本格式。</li></ul></li><li><p><strong>多路复用</strong>：</p><ul><li>在一个 TCP 连接中允许同时发送多个请求和响应，不再按顺序排队。这解决了 HTTP&#x2F;1.x 中存在的队头阻塞（Head-of-Line Blocking）问题，大大提升了性能。</li></ul></li><li><p><strong>头部压缩</strong>：</p><ul><li>使用 HPACK 算法对 HTTP 头部进行压缩，减少传输的数据量，提升性能。</li></ul></li><li><p><strong>服务器推送</strong>：</p><ul><li>服务器可以主动向客户端推送资源，而无需客户端明确请求。这对于提升页面加载速度非常有利，例如预加载样式表和脚本。</li></ul></li><li><p><strong>优先级和依赖性</strong>：</p><ul><li>客户端可以指定请求的优先级和依赖关系，服务器可以根据优先级来决定响应的顺序和速度。</li></ul></li></ol><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><ul><li><p><strong>HTTP&#x2F;1.0 vs HTTP&#x2F;1.1</strong>：</p><ul><li>HTTP&#x2F;1.0 使用无连接的请求&#x2F;响应模型，每个请求都需要新的连接，缺少持久连接和先进的缓存机制。</li><li>HTTP&#x2F;1.1 引入了持久连接、管道化、分块传输编码、更复杂的缓存控制、范围请求等，提升了效率和灵活性。</li></ul></li><li><p><strong>HTTP&#x2F;1.1 vs HTTP&#x2F;2.0</strong>：</p><ul><li>HTTP&#x2F;1.1 使用纯文本格式，尽管支持持久连接和管道化，但仍存在队头阻塞的问题，性能受限。</li><li>HTTP&#x2F;2.0 引入二进制分帧、多路复用、头部压缩、服务器推送等，显著提升了传输效率和性能，解决了 HTTP&#x2F;1.x 的一些固有问题。</li></ul></li></ul><p>总体来说，HTTP 从 1.0 到 2.0 的发展，主要是为了提高传输效率、降低延迟、减少开销以及提升安全性。HTTP&#x2F;2.0 尤其通过多路复用和头部压缩，显著提高了网络性能，改善了用户体验。</p><h1 id="△-22次-简述对称与非对称加密的概念-简单"><a href="#△-22次-简述对称与非对称加密的概念-简单" class="headerlink" title="△ 22次 简述对称与非对称加密的概念  简单"></a><strong>△ 22次</strong> 简述对称与非对称加密的概念  简单</h1><p>对称加密和非对称加密是两种主要的加密技术，分别用于保护数据的安全性。它们在密钥管理和使用上存在显著差异。</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p><strong>概念</strong>：<br>对称加密（Symmetric Encryption）使用相同的密钥进行数据的加密和解密。也就是说，加密和解密使用的是同一个密钥。</p><p><strong>特点</strong>：</p><ol><li><p><strong>单一密钥</strong>：</p><ul><li>加密和解密使用同一个密钥，必须确保密钥的保密性。</li></ul></li><li><p><strong>速度快</strong>：</p><ul><li>对称加密算法相对简单，处理速度快，适合对大量数据进行加密。</li></ul></li><li><p><strong>密钥分发问题</strong>：</p><ul><li>密钥需要在通信双方之间安全传输，确保不被第三方截获。</li></ul></li></ol><p><strong>常见算法</strong>：</p><ul><li>DES（Data Encryption Standard）</li><li>3DES（Triple DES）</li><li>AES（Advanced Encryption Standard）</li><li>RC4</li><li>Blowfish</li></ul><p><strong>应用场景</strong>：</p><ul><li>数据库加密</li><li>文件加密</li><li>网络通信中的数据加密（如 TLS 会话中的对称加密部分）</li></ul><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p><strong>概念</strong>：<br>非对称加密（Asymmetric Encryption）使用一对密钥进行加密和解密：公钥（public key）和私钥（private key）。公钥用于加密数据，私钥用于解密数据。</p><p><strong>特点</strong>：</p><ol><li><p><strong>密钥对</strong>：</p><ul><li>由一对密钥组成，公钥公开分发，私钥保密。</li></ul></li><li><p><strong>加密解密过程</strong>：</p><ul><li>公钥加密的数据只能由对应的私钥解密，私钥加密的数据只能由对应的公钥解密。</li></ul></li><li><p><strong>速度较慢</strong>：</p><ul><li>非对称加密算法相对复杂，处理速度较慢，不适合对大量数据进行加密。</li></ul></li><li><p><strong>无需共享私钥</strong>：</p><ul><li>公钥可以公开分发，无需安全传输私钥，解决了对称加密中的密钥分发问题。</li></ul></li></ol><p><strong>常见算法</strong>：</p><ul><li>RSA</li><li>ECC（Elliptic Curve Cryptography）</li><li>DSA（Digital Signature Algorithm）</li></ul><p><strong>应用场景</strong>：</p><ul><li>数字签名</li><li>数字证书</li><li>安全电子邮件（如 PGP）</li><li>密钥交换（如 TLS 中的密钥协商）</li></ul><h3 id="对比总结-1"><a href="#对比总结-1" class="headerlink" title="对比总结"></a>对比总结</h3><ul><li><p><strong>密钥管理</strong>：</p><ul><li>对称加密使用单一密钥，需要安全传输和存储。</li><li>非对称加密使用公钥和私钥对，公钥公开，私钥保密，简化了密钥分发。</li></ul></li><li><p><strong>速度</strong>：</p><ul><li>对称加密速度快，适合加密大数据量。</li><li>非对称加密速度慢，适合加密小数据量和密钥交换。</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li>对称加密的安全性依赖于密钥的保密性。</li><li>非对称加密通过私钥的保密和数学难题（如大整数分解）确保安全。</li></ul></li></ul><h3 id="结合使用"><a href="#结合使用" class="headerlink" title="结合使用"></a>结合使用</h3><p>在实际应用中，对称加密和非对称加密常常结合使用。非对称加密用于安全地交换对称加密密钥，而对称加密用于加密实际的数据内容。这样既能确保密钥的安全传输，又能利用对称加密的高效性。一个典型的例子是 HTTPS 协议，其中使用非对称加密进行密钥交换，然后使用对称加密保护数据传输。</p><p>△ 22次</p><p>简述 OSI 七层模型，TCP，IP 属于哪一层？  简单 <a href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">参考1</a></p><h1 id="△-20次-HTTP-的方法有哪些？-简单"><a href="#△-20次-HTTP-的方法有哪些？-简单" class="headerlink" title="△ 20次 HTTP 的方法有哪些？  简单"></a><strong>△ 20次</strong> HTTP 的方法有哪些？  简单</h1><p>Get<br>Post<br>Head<br>Delete<br>Patch等</p><p>△ 18次</p><p>简述 TCP 滑动窗口以及重传机制  简单 <a href="https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C?id=%e5%9b%9b-tcp-%e5%8d%8f%e8%ae%ae%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93">参考1</a></p><p>△ 16次</p><p>简述 JWT 的原理和校验机制  中等</p><p>△ 16次</p><p>Cookie 和 Session 的关系和区别是什么？  简单</p><h1 id="△-16次-简述-RPC-的调用过程-简单"><a href="#△-16次-简述-RPC-的调用过程-简单" class="headerlink" title="△ 16次 简述 RPC 的调用过程  简单"></a><strong>△ 16次</strong> 简述 RPC 的调用过程  简单</h1><p>客户端调用<br>序列化<br>发送请求<br>服务端接收请求<br>反序列化<br>执行调用逻辑<br>序列化响应<br>客户端接收响应<br>反序列化响应<br>返回结果</p><p>△ 15次</p><p>TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？  简单 <a href="https://superuser.com/questions/173535/what-are-close-wait-and-time-wait-states">参考1</a> <a href="https://zhuanlan.zhihu.com/p/60382685">参考2</a></p><p>△ 14次</p><p>为什么需要序列化？有什么序列化的方式？  中等</p><h1 id="△-12次-HTTP-中-GET-和-POST-区别-简单"><a href="#△-12次-HTTP-中-GET-和-POST-区别-简单" class="headerlink" title="△ 12次 HTTP 中 GET 和 POST 区别  简单"></a><strong>△ 12次</strong> HTTP 中 GET 和 POST 区别  简单</h1><p>HTTP 协议中的 GET 和 POST 是最常见的两种请求方法，它们在使用场景、参数传递、安全性等方面有显著区别。</p><h3 id="对比总结-2"><a href="#对比总结-2" class="headerlink" title="对比总结"></a>对比总结</h3><ol><li><p><strong>传递方式</strong>：</p><ul><li><strong>GET</strong>：参数在 URL 中传递，适合少量数据。</li><li><strong>POST</strong>：参数在请求体中传递，适合大量数据和文件上传。</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li><strong>GET</strong>：参数暴露在 URL 中，不适合传递敏感信息。</li><li><strong>POST</strong>：参数在请求体中，稍微安全，但仍需 HTTPS。</li></ul></li><li><p><strong>幂等性</strong>：</p><ul><li><strong>GET</strong>：幂等，多次请求不会改变服务器状态。</li><li><strong>POST</strong>：非幂等，多次请求可能会改变服务器状态。</li></ul></li><li><p><strong>缓存</strong>：</p><ul><li><strong>GET</strong>：响应可以被缓存。</li><li><strong>POST</strong>：响应通常不被缓存。</li></ul></li><li><p><strong>长度限制</strong>：</p><ul><li><strong>GET</strong>：受 URL 长度限制，适合少量参数。</li><li><strong>POST</strong>：无明显长度限制，适合大量参数和数据。</li></ul></li></ol><h3 id="选择使用"><a href="#选择使用" class="headerlink" title="选择使用"></a>选择使用</h3><ul><li><p><strong>GET</strong>：</p><ul><li>用于获取资源或数据，不会改变服务器状态的请求。</li><li>数据量小，参数无需隐藏。</li></ul></li><li><p><strong>POST</strong>：</p><ul><li>用于提交数据、上传文件或任何会改变服务器状态的请求。</li><li>数据量大，参数包含敏感信息或需要隐藏。</li></ul></li></ul><p>△ 12次</p><p>什么是中间人攻击？如何防止攻击？  中等</p><p>△ 2次</p><p>简述 iPv4 和 iPv6 的区别  简单</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 面试 </tag>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程</title>
      <link href="/library/Golang/concurrency/concurrent%20programming/"/>
      <url>/library/Golang/concurrency/concurrent%20programming/</url>
      
        <content type="html"><![CDATA[<h3 id="goroutine超时处理"><a href="#goroutine超时处理" class="headerlink" title="goroutine超时处理"></a>goroutine超时处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        c1 &lt;- <span class="string">&quot;result 1&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c1:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout 1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        c2 &lt;- <span class="string">&quot;result 2&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c2:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无阻塞"><a href="#无阻塞" class="headerlink" title="无阻塞"></a>无阻塞</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c2:</span><br><span class="line">    fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">    fmt.Println(<span class="string">&quot;timeout 2&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通道关闭"><a href="#通道关闭" class="headerlink" title="通道关闭"></a>通道关闭</h3><ol><li>close(channel) 关闭通道</li><li>j，more :&#x3D; &lt;- channel 如果已关闭，则more为 false</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            j, more := &lt;-jobs</span><br><span class="line">            <span class="keyword">if</span> more &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;received job&quot;</span>, j)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;received all jobs&quot;</span>)</span><br><span class="line">                done &lt;- <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++ &#123;</span><br><span class="line">        jobs &lt;- j</span><br><span class="line">        fmt.Println(<span class="string">&quot;sent job&quot;</span>, j)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(jobs)</span><br><span class="line">    fmt.Println(<span class="string">&quot;sent all jobs&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管道遍历"><a href="#管道遍历" class="headerlink" title="管道遍历"></a>管道遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    queue := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    queue &lt;- <span class="string">&quot;one&quot;</span></span><br><span class="line">    queue &lt;- <span class="string">&quot;two&quot;</span></span><br><span class="line">    <span class="built_in">close</span>(queue)</span><br><span class="line">    <span class="keyword">for</span> elem := <span class="keyword">range</span> queue &#123;</span><br><span class="line">        fmt.Println(elem)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="只读和只写管道"><a href="#只读和只写管道" class="headerlink" title="只读和只写管道"></a>只读和只写管道</h3><ul><li><code>&lt;-chan string</code> 只读</li><li><code>chan&lt;- string</code> 只写</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(jobs <span class="keyword">chan</span> <span class="type">int</span>, done <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">j, more := &lt;-jobs</span><br><span class="line"><span class="keyword">if</span> more &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;received job&quot;</span>, j)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;received all jobs&quot;</span>)</span><br><span class="line">done &lt;- <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMsg</span><span class="params">(jobs <span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++ &#123;</span><br><span class="line">jobs &lt;- j</span><br><span class="line">fmt.Println(<span class="string">&quot;sent job&quot;</span>, j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(jobs)</span><br><span class="line">fmt.Println(<span class="string">&quot;sent all jobs&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> test(jobs, done)</span><br><span class="line"><span class="keyword">go</span> sendMsg(jobs)</span><br><span class="line"></span><br><span class="line">&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制并发数"><a href="#控制并发数" class="headerlink" title="控制并发数"></a>控制并发数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">choice1()</span><br><span class="line">choice2()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">choice1</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span> ,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">time.Sleep( time.Second)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&lt;- ch</span><br><span class="line">&#125;(ch)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">choice2</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span> ,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">time.Sleep( time.Second)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&lt;- ch</span><br><span class="line">&#125;(ch)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 并发 </tag>
            
            <tag> go </tag>
            
            <tag> channel </tag>
            
            <tag> goroutine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 反射</title>
      <link href="/library/Golang/reflect/"/>
      <url>/library/Golang/reflect/</url>
      
        <content type="html"><![CDATA[<h3 id="Name-and-Kind"><a href="#Name-and-Kind" class="headerlink" title="Name and Kind"></a>Name and Kind</h3><p>可调用函数和含义，以及结果一览</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typeOfCat := reflect.TypeOf(cat&#123;&#125;)</span><br><span class="line">typeOfCat.Name() <span class="comment">// cat</span></span><br><span class="line">typeOfCat.Kind()  <span class="comment">// struct</span></span><br><span class="line">typeOfCat.NumField() <span class="comment">// 2 几个字段</span></span><br><span class="line">typeOfCat.Field(i) <span class="comment">//第几个字段</span></span><br><span class="line">typeOfCat.FieldByName(<span class="string">&quot;Type&quot;</span>) <span class="comment">// 找名为Type的字段</span></span><br><span class="line">typeOfCat.MethodByName(<span class="string">&quot;Start&quot;</span>) <span class="comment">// 找名为Start的方法</span></span><br><span class="line"><span class="keyword">if</span> typeofCat.Kind() == <span class="string">&quot;ptr&quot;</span>&#123;</span><br><span class="line">  res := typeOfCat.Elem()  <span class="comment">// 等价于*ptr</span></span><br><span class="line">  res.Name()</span><br><span class="line">  res.Kind()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reflect-ValueOf-和reflect-Value"><a href="#reflect-ValueOf-和reflect-Value" class="headerlink" title="reflect.ValueOf()和reflect.Value"></a>reflect.ValueOf()和reflect.Value</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">valueOfA := reflect.ValueOf(a)</span><br><span class="line"><span class="keyword">var</span> getA <span class="type">int</span> = valueOfA.Interface().(<span class="type">int</span>)</span><br><span class="line"><span class="keyword">var</span> getA2 <span class="type">int</span> = <span class="type">int</span>(valueOfA.Int())</span><br></pre></td></tr></table></figure><h3 id="通过反射获取值信息"><a href="#通过反射获取值信息" class="headerlink" title="通过反射获取值信息"></a>通过反射获取值信息</h3><h4 id="使用反射值对象包装任意值"><a href="#使用反射值对象包装任意值" class="headerlink" title="使用反射值对象包装任意值"></a>使用反射值对象包装任意值</h4><p>Go语言中，使用 reflect.ValueOf() 函数获得值的反射值对象（reflect.Value）。书写格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value := reflect.ValueOf(rawValue)</span><br></pre></td></tr></table></figure><p>reflect.ValueOf 返回 reflect.Value 类型，包含有 rawValue 的值信息。reflect.Value 与原值间可以通过值包装和值获取互相转化。reflect.Value 是一些反射操作的重要类型，如反射调用函数。</p><h4 id="从反射值对象获取被包装的值"><a href="#从反射值对象获取被包装的值" class="headerlink" title="从反射值对象获取被包装的值"></a>从反射值对象获取被包装的值</h4><p>Go语言中可以通过 reflect.Value 重新获得原始值。</p><h5 id="1-从反射值对象（reflect-Value）中获取值的方法"><a href="#1-从反射值对象（reflect-Value）中获取值的方法" class="headerlink" title="1) 从反射值对象（reflect.Value）中获取值的方法"></a>1) 从反射值对象（reflect.Value）中获取值的方法</h5><p>可以通过下面几种方法从反射值对象 reflect.Value 中获取原值，如下表所示。</p><table><thead><tr><th align="left">方法名</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="left">Interface() interface {}</td><td align="left">将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td></tr><tr><td align="left">Int() int64</td><td align="left">将值以 int 类型返回，所有有符号整型均可以此方式返回</td></tr><tr><td align="left">Uint() uint64</td><td align="left">将值以 uint 类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td align="left">Float() float64</td><td align="left">将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td align="left">Bool() bool</td><td align="left">将值以 bool 类型返回</td></tr><tr><td align="left">Bytes() []bytes</td><td align="left">将值以字节数组 []bytes 类型返回</td></tr><tr><td align="left">String() string</td><td align="left">将值以字符串类型返回</td></tr></tbody></table><h5 id="2-从反射值对象（reflect-Value）中获取值的例子"><a href="#2-从反射值对象（reflect-Value）中获取值的例子" class="headerlink" title="2) 从反射值对象（reflect.Value）中获取值的例子"></a>2) 从反射值对象（reflect.Value）中获取值的例子</h5><p>下面代码中，将整型变量中的值使用 reflect.Value 获取反射值对象（reflect.Value）。再通过 reflect.Value 的 Interface() 方法获得 interface{} 类型的原值，通过 int 类型对应的 reflect.Value 的 Int() 方法获得整型值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明整型变量a并赋初值</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">1024</span></span><br><span class="line">    <span class="comment">// 获取变量a的反射值对象</span></span><br><span class="line">    valueOfA := reflect.ValueOf(a)</span><br><span class="line">    <span class="comment">// 获取interface&#123;&#125;类型的值, 通过类型断言转换</span></span><br><span class="line">    <span class="keyword">var</span> getA <span class="type">int</span> = valueOfA.Interface().(<span class="type">int</span>)</span><br><span class="line">    <span class="comment">// 获取64位的值, 强制类型转换为int类型</span></span><br><span class="line">    <span class="keyword">var</span> getA2 <span class="type">int</span> = <span class="type">int</span>(valueOfA.Int())</span><br><span class="line">    fmt.Println(getA, getA2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代码输出如下：</span></span><br><span class="line"><span class="comment">// 1024 1024</span></span><br></pre></td></tr></table></figure><h3 id="通过reflect反射修改值"><a href="#通过reflect反射修改值" class="headerlink" title="通过reflect反射修改值"></a>通过reflect反射修改值</h3><p>判断反射值是否可以修改？CanSet()，是否能被取址CanAddr()</p><p>结构体成员中，如果字段没有被导出，即便不使用反射也可以被访问，但不能通过反射修改</p><ol><li><p>指针指向的具体元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">v := reflect.ValueOf(&amp;x)</span><br><span class="line">v = v.Elem()</span><br></pre></td></tr></table></figure></li><li><p>slice的元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">1</span>&#125;</span><br><span class="line">v := reflect.ValueOf(s)</span><br><span class="line">e := v.Index(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p>可寻址的结构体的字段(指向结构体的指针)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Orange <span class="keyword">struct</span>&#123;</span><br><span class="line">  Size <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line">a := Orange&#123;<span class="number">99</span>&#125;</span><br><span class="line">v := reflect.ValueOf(&amp;a)</span><br><span class="line">v = v.Elem()</span><br><span class="line">field = v.FieldByName(<span class="string">&quot;field&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>可寻址的数组的元素(指向数组的指针)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">1</span>&#125;</span><br><span class="line">v := reflect.ValueOf(&amp;a)</span><br><span class="line">v = v.Elem()</span><br><span class="line">vIndex = v.Index(<span class="number">0</span>)</span><br><span class="line">vIndex.SetInt(<span class="number">1</span>)</span><br><span class="line">vIndex.SetInt(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ol><table><thead><tr><th align="left">-</th><th align="left">-</th></tr></thead><tbody><tr><td align="left">Set(x Value)</td><td align="left">将值设置为传入的反射值对象的值</td></tr><tr><td align="left">Setlnt(x int64)</td><td align="left">使用 int64 设置值。当值的类型不是 int、int8、int16、 int32、int64 时会发生宕机</td></tr><tr><td align="left">SetUint(x uint64)</td><td align="left">使用 uint64 设置值。当值的类型不是 uint、uint8、uint16、uint32、uint64 时会发生宕机</td></tr><tr><td align="left">SetFloat(x float64)</td><td align="left">使用 float64 设置值。当值的类型不是 float32、float64 时会发生宕机</td></tr><tr><td align="left">SetBool(x bool)</td><td align="left">使用 bool 设置值。当值的类型不是 bod 时会发生宕机</td></tr><tr><td align="left">SetBytes(x []byte)</td><td align="left">设置字节数组 []bytes值。当值的类型不是 []byte 时会发生宕机</td></tr><tr><td align="left">SetString(x string)</td><td align="left">设置字符串值。当值的类型不是 string 时会发生宕机</td></tr></tbody></table><h3 id="通过类型信息创建实例"><a href="#通过类型信息创建实例" class="headerlink" title="通过类型信息创建实例"></a>通过类型信息创建实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">typeOfA := reflect.TypeOf(a)</span><br><span class="line">aIns := reflect.New(typeOfA) <span class="comment">// 等价于 new(int)</span></span><br><span class="line">fmt.Println(aIns.Type(), aIns.Kind())</span><br></pre></td></tr></table></figure><h3 id="Go语言结构体标签（Struct-Tag）"><a href="#Go语言结构体标签（Struct-Tag）" class="headerlink" title="Go语言结构体标签（Struct Tag）"></a>Go语言结构体标签（Struct Tag）</h3><h4 id="结构体标签的格式"><a href="#结构体标签的格式" class="headerlink" title="结构体标签的格式"></a>结构体标签的格式</h4><p>tag 格式：<code>json:&quot;type&quot; id:&quot;100&quot;</code></p><p>注意：</p><ol><li>key:“value” 冒号后没有空格</li><li>两个key之间，一个空格，多一个都不行</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Type <span class="type">int</span> <span class="string">`json:&quot;type&quot; id:&quot;100&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从结构体标签中获取值"><a href="#从结构体标签中获取值" class="headerlink" title="从结构体标签中获取值"></a>从结构体标签中获取值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeOfCat := reflect.TypeOf(cat&#123;&#125;)</span><br><span class="line">catType = typeOfCat.FieldByName(<span class="string">&quot;Type&quot;</span>)</span><br><span class="line">catType.Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><h4 id="动态调用函数（无参数）"><a href="#动态调用函数（无参数）" class="headerlink" title="动态调用函数（无参数）"></a>动态调用函数（无参数）</h4><ol><li>直接<code>reflect.Valueof</code></li><li><code>MethodByName</code></li><li>调用<code>Call</code>方法</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Do&quot;</span></span><br><span class="line">    t := &amp;T&#123;&#125;</span><br><span class="line">    reflect.ValueOf(t).MethodByName(name).Call(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Do() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态调用函数（有参数）"><a href="#动态调用函数（有参数）" class="headerlink" title="动态调用函数（有参数）"></a>动态调用函数（有参数）</h4><ol><li>创建<code>reflect.Value</code>切片</li><li><code>reflect.Valueof(t).MethodByName(string)</code> 调用Call方法传入参数</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Do&quot;</span></span><br><span class="line">    t := &amp;T&#123;&#125;</span><br><span class="line">    a := reflect.ValueOf(<span class="number">1111</span>)</span><br><span class="line">    b := reflect.ValueOf(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    in := []reflect.Value&#123;a, b&#125;</span><br><span class="line">    reflect.ValueOf(t).MethodByName(name).Call(in)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Do(a <span class="type">int</span>, b <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span> + b, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接收返回值"><a href="#接收返回值" class="headerlink" title="接收返回值"></a>接收返回值</h4><ol><li>返回<code>[]reflect.Value</code></li><li>调用<code>Interface()</code>方法，转为<code>interface&#123;&#125;</code>类型</li><li>断言类型</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Do&quot;</span></span><br><span class="line">    t := &amp;T&#123;&#125;</span><br><span class="line">    ret := reflect.ValueOf(t).MethodByName(name).Call(<span class="literal">nil</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;strValue: %[1]v\nerrValue: %[2]v\nstrType: %[1]T\nerrType: %[2]T&quot;</span>, ret[<span class="number">0</span>], ret[<span class="number">1</span>].Interface().(<span class="type">error</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Do() (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>, errors.New(<span class="string">&quot;new error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Tag解析"><a href="#Tag解析" class="headerlink" title="Tag解析"></a>Tag解析</h4><ol><li><code>reflect.Typeof</code>有<code>NumField</code>，Field根据序号索取，取其中的tag</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;</span><br><span class="line">Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Age <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := T&#123;&#125;</span><br><span class="line">tt := reflect.TypeOf(a)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;tt.NumField();i++&#123;</span><br><span class="line">fmt.Println(tt.Field(i).Name)</span><br><span class="line">fmt.Println(tt.Field(i).Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">fmt.Println(tt.Field(i).Tag.Lookup(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">fmt.Println(tt.Field(i).Type)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过kind（）处理不同分支"><a href="#通过kind（）处理不同分支" class="headerlink" title="通过kind（）处理不同分支"></a>通过kind（）处理不同分支</h4><ol><li><code>reflect.Typeof().Kind()</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := <span class="number">1</span></span><br><span class="line">a := reflect.TypeOf(t)</span><br><span class="line"><span class="keyword">switch</span> a.Kind() &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.String:</span><br><span class="line">fmt.Println(<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> reflect.Int:</span><br><span class="line">fmt.Println(<span class="string">&quot;int&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断结构体是否实现接口"><a href="#判断结构体是否实现接口" class="headerlink" title="判断结构体是否实现接口"></a>判断结构体是否实现接口</h4><ol><li>将<code>nil</code>强转为接口指针类型，通过<code>reflect.Typeof().Elem</code>获取其接口类型</li><li><code>reflect.Typeof</code>调用方法<code>Implements</code>来判断</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IT <span class="keyword">interface</span> &#123;</span><br><span class="line">test1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">A <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> test1() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := &amp;T&#123;&#125;</span><br><span class="line">elem := reflect.TypeOf((*IT)(<span class="literal">nil</span>)).Elem()</span><br><span class="line"><span class="keyword">if</span> reflect.TypeOf(t).Implements(elem) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接通过接口强转判断</p><ol><li>将类型转换为 <code>reflect.Value</code></li><li>将<code>reflect.Value</code>调用Interface()方法转为接口类型</li><li>类型断言</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ITester <span class="keyword">interface</span> &#123;</span><br><span class="line">test1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">A <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u := &amp;User&#123;&#125;</span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line">val, ok := v.Interface().(ITester)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Support Interface&quot;</span>, val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> reflect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础 面试必备</title>
      <link href="/interview/elementary-interview/"/>
      <url>/interview/elementary-interview/</url>
      
        <content type="html"><![CDATA[<p>△ 70次</p><p>进程间有哪些通信方式？  困难 <a href="https://www.guru99.com/inter-process-communication-ipc.html">参考1</a> <a href="https://www.coursera.org/lecture/os-pku/jin-cheng-jian-tong-xin-ipc-wbxs5">参考2</a></p><p>△ 44次</p><p>进程和线程之间有什么区别？  简单 <a href="https://www.guru99.com/difference-between-process-and-thread.html">参考1</a> <a href="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Phyduck/c%2B%2B/concurrent/1.%20Linux%20%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%B0%83%E5%BA%A6.pdf">参考2</a></p><p>△ 40次</p><p>简述操作系统如何进行内存管理  中等 <a href="https://www.guru99.com/os-memory-management.html">参考1</a> <a href="https://zhuanlan.zhihu.com/p/143273007">参考2</a></p><p>△ 40次</p><p>操作系统中，虚拟地址与物理地址之间如何映射？  中等</p><p>△ 26次</p><p>简述操作系统中的缺页中断  中等 <a href="https://www.oreilly.com/library/view/understanding-the-linux/0596005652/ch04s02.html">参考1</a></p><p>△ 24次</p><p>什么时候会由用户态陷入内核态？  简单</p><p>△ 22次</p><p>简述自旋锁与互斥锁的使用场景  中等</p><p>△ 20次</p><p>简述 mmap 的使用场景以及原理  中等</p><p>△ 20次</p><p>线程间有哪些通信方式？  中等</p><p>△ 20次</p><p>Linux 下如何查看端口被哪个进程占用？  简单</p><p>△ 18次</p><p>两个线程交替打印一个共享变量  中等</p><p>△ 16次</p><p>简述 Linux 进程调度的算法  困难 <a href="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/Phyduck/c%2B%2B/concurrent/1.%20Linux%20%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%B0%83%E5%BA%A6.pdf">参考1</a></p><p>△ 12次</p><p>简述 Linux 零拷贝的原理  中等</p><p>△ 12次</p><p>什么情况下，进程会进行切换？  简单</p><p>△ 12次</p><p>Linux 中虚拟内存和物理内存有什么区别？有什么优点？  中等</p><p>△ 10次</p><p>简述 traceroute 命令的原理  简单</p><p>△ 40次</p><p>简述 CAP 理论  简单</p><p>△ 22次</p><p>简述常见的负载均衡算法  简单 <a href="https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/">参考1</a></p><p>△ 18次</p><p>设计一个阻塞队列  中等</p><p>△ 16次</p><p>简述生产者消费者模型  简单</p><p>△ 12次</p><p>简述 MapReduce 的原理  中等</p><p>△ 12次</p><p>kafka 如何保证消息一致性？  中等</p><p>△ 12次</p><p>设计 Tiny URL 系统  中等</p><p>△ 10次</p><p>停车场有有限个车位，有多个车来抢车位，设计一个系统需要根据车辆进入和离开停车场的时间进行计费  困难</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试算法题总结</title>
      <link href="/interview/juan/inter-alg101/"/>
      <url>/interview/juan/inter-alg101/</url>
      
        <content type="html"><![CDATA[<p><a href="https://neetcode.io/roadmap">NeetCode.RoadMap</a></p><h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><p>更多加分点： 加权等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> LoadBalancer <span class="keyword">struct</span> &#123;</span><br><span class="line">    client []*Client</span><br><span class="line">    size <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLB</span><span class="params">(size <span class="type">int32</span>)</span></span> *LoadBalalcer &#123;</span><br><span class="line">    lb := &amp;LoadBalancer&#123;client: <span class="built_in">make</span>([]*Client, size), size: size&#125;</span><br><span class="line">    lb.client = <span class="built_in">append</span>(lb.client, &amp;Client&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> lb</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LoadBalancer)</span></span> getClient() *Client &#123;</span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">    x := rand.Int31n(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">return</span> m.client[x &amp; m.size]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Client)</span></span> Do &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Do&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    lb := NewLB(<span class="number">4</span>)</span><br><span class="line">    lb.getClient().Do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用反射调用函数"><a href="#利用反射调用函数" class="headerlink" title="利用反射调用函数"></a>利用反射调用函数</h3><p>实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span></span> Drive &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Driving&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    car := Car&#123;&#125;</span><br><span class="line">    val := reflect.ValueOf(&amp;car)</span><br><span class="line">    f := value.MethodByName(<span class="string">&quot;Drive&quot;</span>)</span><br><span class="line">    f.Call([]reflect.Value&#123;&#125;)  <span class="comment">// Drive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给定三个函数-cat-dog-fish-，每个函数启动一个-goroutine-，要求按照顺序打印100次"><a href="#给定三个函数-cat-dog-fish-，每个函数启动一个-goroutine-，要求按照顺序打印100次" class="headerlink" title="给定三个函数 cat dog fish ，每个函数启动一个 goroutine ，要求按照顺序打印100次"></a>给定三个函数 cat dog fish ，每个函数启动一个 goroutine ，要求按照顺序打印100次</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintCat</span><span class="params">(fishCH,catCH <span class="keyword">chan</span> <span class="type">bool</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> waitgroup.Done()</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(catCH)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt;<span class="number">100</span>;i++&#123;</span><br><span class="line">&lt;-fishCH</span><br><span class="line">fmt.Println(<span class="string">&quot;cat ...&quot;</span>)</span><br><span class="line">catCH &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintDog</span><span class="params">(catCH,dogCH <span class="keyword">chan</span> <span class="type">bool</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> waitgroup.Done()</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(dogCH)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt;<span class="number">100</span>;i++&#123;</span><br><span class="line">&lt;-catCH</span><br><span class="line">fmt.Println(<span class="string">&quot;dog ...&quot;</span>)</span><br><span class="line">dogCH&lt;-<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintFish</span><span class="params">(dogCH,fishCH <span class="keyword">chan</span> <span class="type">bool</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> waitgroup.Done()</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(fishCH)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt;<span class="number">100</span>;i++&#123;</span><br><span class="line">&lt;-dogCH</span><br><span class="line">fmt.Println(<span class="string">&quot;fish ...&quot;</span>)</span><br><span class="line">fishCH&lt;-<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> waitgroup sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">catCH := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>,<span class="number">1</span>)</span><br><span class="line">dogCH := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>,<span class="number">1</span>)</span><br><span class="line">fishCH := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>,<span class="number">1</span>)</span><br><span class="line">fishCH &lt;- <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> PrintFish(dogCH,fishCH)</span><br><span class="line"><span class="keyword">go</span> PrintDog(catCH,dogCH)</span><br><span class="line"><span class="keyword">go</span> PrintCat(fishCH,catCH)</span><br><span class="line"></span><br><span class="line">waitgroup.Add(<span class="number">3</span>)</span><br><span class="line">waitgroup.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽奖问题"><a href="#抽奖问题" class="headerlink" title="抽奖问题"></a>抽奖问题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定如下结构</span></span><br><span class="line"><span class="comment">// map中，key代表名称，value代表成交单数</span></span><br><span class="line"><span class="keyword">var</span> users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span> = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>&#123;</span><br><span class="line">  <span class="string">&quot;a&quot;</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="string">&quot;b&quot;</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="string">&quot;c&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&quot;d&quot;</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="string">&quot;f&quot;</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-随机抽奖"><a href="#1-随机抽奖" class="headerlink" title="1. 随机抽奖"></a>1. 随机抽奖</h5><p>从 map 中随机选取用户中奖<br>思路：将用户理解为一个个格子，从中选取一个格子中奖</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAwardUserName</span><span class="params">(users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>)</span></span> (name <span class="type">string</span>) &#123;</span><br><span class="line">  sizeOfUsers := <span class="built_in">len</span>(users)</span><br><span class="line">  award_index := rand.Intn(sizeOfUsers)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> index <span class="type">int</span></span><br><span class="line">  <span class="keyword">for</span> u_name, _ := <span class="keyword">range</span> users &#123;</span><br><span class="line">    <span class="keyword">if</span> index == award_index &#123;</span><br><span class="line">      name = u_name</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span> = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>&#123;</span><br><span class="line">    <span class="string">&quot;a&quot;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="string">&quot;b&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">&quot;c&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;d&quot;</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="string">&quot;e&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&quot;f&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rand.Seed(time.Now().Unix())</span><br><span class="line">  <span class="comment">// 抽奖1次</span></span><br><span class="line">  name := GetAwardUserName(users)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;user: %s jack point&quot;</span>, name)</span><br><span class="line">  <span class="comment">// 抽奖1000次</span></span><br><span class="line">  award_stat := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i += <span class="number">1</span> &#123;</span><br><span class="line">    name := GetAwardUserName(users)</span><br><span class="line">    <span class="keyword">if</span> count, ok := award_stat[name]; ok &#123;</span><br><span class="line">      award_stat[name] = count + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      award_stat[name] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> name, count := <span class="keyword">range</span> award_stat &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;user: %s, award count: %d\n&quot;</span>, name, count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方抽奖代码复杂度为 O(n) ，可以结合二分查找优化为 O(logN)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAwardGenerator</span><span class="params">(users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>)</span></span> (generator <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sum_num <span class="type">int64</span></span><br><span class="line">  name_arr := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(users))</span><br><span class="line">  offset_arr := <span class="built_in">make</span>([]<span class="type">int64</span>, <span class="built_in">len</span>(users))</span><br><span class="line">  <span class="keyword">var</span> index <span class="type">int</span></span><br><span class="line">  <span class="keyword">for</span> u_name, num := <span class="keyword">range</span> users &#123;</span><br><span class="line">    name_arr[index] = u_name</span><br><span class="line">    offset_arr[index] = sum_num</span><br><span class="line">    sum_num += num</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  generator = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    award_num := rand.Int63n(sum_num)</span><br><span class="line">    <span class="keyword">return</span> name_arr[binary_search(offset_arr, award_num)]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binary_search</span><span class="params">(nums []<span class="type">int64</span>, target <span class="type">int64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  start, end := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">  <span class="keyword">for</span> start &lt;= end &#123;</span><br><span class="line">    mid := start + (end-start)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">      end = mid - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">      <span class="keyword">if</span> mid+<span class="number">1</span> == <span class="built_in">len</span>(nums) &#123; <span class="comment">// 最后一名中奖</span></span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> nums[mid+<span class="number">1</span>] &gt; target &#123;</span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line">      &#125;</span><br><span class="line">      start = mid + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mid</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-加权抽奖"><a href="#2-加权抽奖" class="headerlink" title="2. 加权抽奖"></a>2. 加权抽奖</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个也是我们常规概率抽奖的实现方案</span></span><br><span class="line"><span class="comment">// 前置逻辑需要做好并发相关的处理，包括异常状态处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAwardGenerator</span><span class="params">(users <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> sum_num <span class="type">int64</span></span><br><span class="line">  name_arr := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(users))</span><br><span class="line">  <span class="keyword">for</span> u_name, num := <span class="keyword">range</span> users &#123;</span><br><span class="line">    sum_num += num</span><br><span class="line">    name_arr = <span class="built_in">append</span>(name_arr, u_name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> generator <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span></span><br><span class="line">  generator = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    award_num := rand.Int63n(sum_num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> offset_num <span class="type">int64</span></span><br><span class="line">    <span class="keyword">for</span> _, u_name := <span class="keyword">range</span> name_arr &#123;</span><br><span class="line">      offset_num += users[u_name]</span><br><span class="line">      <span class="keyword">if</span> award_num &lt; offset_num &#123;</span><br><span class="line">        <span class="keyword">return</span> u_name</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缺省返回，正常情况下，不会运行到此处</span></span><br><span class="line">    <span class="keyword">return</span> name_arr[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个消息队列"><a href="#实现一个消息队列" class="headerlink" title="实现一个消息队列"></a>实现一个消息队列</h3><p>核心：切片 + 锁</p><h3 id="字符串相加-https-leetcode-cn-com-problems-add-s"><a href="#字符串相加-https-leetcode-cn-com-problems-add-s" class="headerlink" title="[字符串相加](https://leetcode-cn.com/problems/add-s"></a>[字符串相加](<a href="https://leetcode-cn.com/problems/add-s">https://leetcode-cn.com/problems/add-s</a></h3><p>trings&#x2F;)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStrings</span><span class="params">(num1 <span class="type">string</span>, num2 <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">add := <span class="number">0</span></span><br><span class="line">ans := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i, j := <span class="built_in">len</span>(num1) - <span class="number">1</span>, <span class="built_in">len</span>(num2) - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>; i, j = i - <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">x = <span class="type">int</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> j &gt;= <span class="number">0</span> &#123;</span><br><span class="line">y = <span class="type">int</span>(num2[j] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">result := x + y + add</span><br><span class="line">ans = strconv.Itoa(result%<span class="number">10</span>) + ans</span><br><span class="line">add = result / <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求根号2的值"><a href="#求根号2的值" class="headerlink" title="求根号2的值"></a>求根号2的值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找法求近似值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;  </span><br><span class="line">    l, r := <span class="type">float64</span>(<span class="number">0</span>), <span class="type">float64</span>(x)  </span><br><span class="line">    <span class="keyword">for</span> r-l &gt; <span class="number">1e-7</span> &#123;  </span><br><span class="line">        mid := l + (r - l) / <span class="number">2</span>  </span><br><span class="line"><span class="keyword">if</span> mid * mid &lt;= <span class="type">float64</span>(x) &#123;  </span><br><span class="line">            l = mid  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            r = mid  </span><br><span class="line">&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> r  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 牛顿迭代</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">&#125;  </span><br><span class="line">    C, x0 := <span class="type">float64</span>(x), <span class="type">float64</span>(x)  </span><br><span class="line">    <span class="keyword">for</span> &#123;  </span><br><span class="line">        xi := <span class="number">0.5</span> * (x0 + C/x0)  </span><br><span class="line">        <span class="keyword">if</span> math.Abs(x0 - xi) &lt; <span class="number">1e-7</span> &#123;  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">&#125;  </span><br><span class="line">        x0 = xi  </span><br><span class="line">&#125;  </span><br><span class="line">    <span class="keyword">return</span> x0  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> go </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>paxos 论文翻译</title>
      <link href="/research/paxos-original/"/>
      <url>/research/paxos-original/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 研究所 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mongodb 面试必备</title>
      <link href="/interview/mongodb-interview/"/>
      <url>/interview/mongodb-interview/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 面试 </tag>
            
            <tag> mongo </tag>
            
            <tag> nosql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis 面试必备 100 题</title>
      <link href="/interview/100prob/redis-interview-100/"/>
      <url>/interview/100prob/redis-interview-100/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-数据库经典面试题解析"><a href="#Redis-数据库经典面试题解析" class="headerlink" title="Redis 数据库经典面试题解析"></a>Redis 数据库经典面试题解析</h1><h3 id="1-Redis-是一个基于内存的高性能key-value数据库。"><a href="#1-Redis-是一个基于内存的高性能key-value数据库。" class="headerlink" title="1.Redis 是一个基于内存的高性能key-value数据库。"></a>1.Redis 是一个基于内存的高性能key-value数据库。</h3><h3 id="2-Redis相比memcached有哪些优势："><a href="#2-Redis相比memcached有哪些优势：" class="headerlink" title="2.Redis相比memcached有哪些优势："></a>2.Redis相比memcached有哪些优势：</h3><ul><li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</li><li>redis的速度比memcached快很多</li><li>redis可以持久化其数据</li></ul><h3 id="3-Redis是单线程"><a href="#3-Redis是单线程" class="headerlink" title="3.Redis是单线程"></a>3.Redis是单线程</h3><ul><li>redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销</li></ul><h3 id="4-Reids常用5种数据类型"><a href="#4-Reids常用5种数据类型" class="headerlink" title="4.Reids常用5种数据类型"></a>4.Reids常用5种数据类型</h3><ul><li>string，list，set，sorted set，hash</li></ul><h3 id="6-Reids6种淘汰策略："><a href="#6-Reids6种淘汰策略：" class="headerlink" title="6.Reids6种淘汰策略："></a>6.Reids6种淘汰策略：</h3><ul><li>noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。大多数写命令都会导致占用更多的内存(有极少数会例外。</li><li>**allkeys-lru:**所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。</li><li>**volatile-lru:**只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。</li><li>**allkeys-random:**所有key通用; 随机删除一部分 key。</li><li>volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key。</li><li>volatile-ttl: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。</li></ul><h3 id="7-Redis的并发竞争问题如何解决"><a href="#7-Redis的并发竞争问题如何解决" class="headerlink" title="7.Redis的并发竞争问题如何解决?"></a>7.Redis的并发竞争问题如何解决?</h3><p>单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，利用setnx实现锁。</p><h3 id="8-Redis是使用c语言开发的。"><a href="#8-Redis是使用c语言开发的。" class="headerlink" title="8.Redis是使用c语言开发的。"></a>8.Redis是使用c语言开发的。</h3><h3 id="9-Redis前端启动命令"><a href="#9-Redis前端启动命令" class="headerlink" title="9.Redis前端启动命令"></a>9.Redis前端启动命令</h3><p>.&#x2F;redis-server</p><h3 id="10-Reids支持的语言："><a href="#10-Reids支持的语言：" class="headerlink" title="10.Reids支持的语言："></a>10.Reids支持的语言：</h3><p>java、C、C#、C++、php、Node.js、Go等。</p><h3 id="11-Redis-持久化方案："><a href="#11-Redis-持久化方案：" class="headerlink" title="11.Redis 持久化方案："></a>11.Redis 持久化方案：</h3><p>Rdb 和 Aof</p><h3 id="12-Redis-的主从复制"><a href="#12-Redis-的主从复制" class="headerlink" title="12.Redis 的主从复制"></a>12.Redis 的主从复制</h3><p>持久化保证了即使redis服务重启也不会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，如果通过redis的主从复制机制就可以避免这种单点故障，</p><h3 id="13-Redis是单线程的，但Redis为什么这么快？"><a href="#13-Redis是单线程的，但Redis为什么这么快？" class="headerlink" title="13.Redis是单线程的，但Redis为什么这么快？"></a>13.Redis是单线程的，但Redis为什么这么快？</h3><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p><p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p><p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p><p>4、使用多路I&#x2F;O复用模型，非阻塞IO；这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程</p><p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p><h3 id="14-为什么Redis是单线程的？"><a href="#14-为什么Redis是单线程的？" class="headerlink" title="14.为什么Redis是单线程的？"></a>14.为什么Redis是单线程的？</h3><p>Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</p><h3 id="15-Redis-info查看命令：info-memory"><a href="#15-Redis-info查看命令：info-memory" class="headerlink" title="15.Redis info查看命令：info memory"></a>15.Redis info查看命令：info memory</h3><h3 id="16-Redis内存模型"><a href="#16-Redis内存模型" class="headerlink" title="16.Redis内存模型"></a>16.Redis内存模型</h3><ul><li><p>used_memory：Redis分配器分配的内存总量（单位是字节），包括使用的虚拟内存（即swap）；Redis分配器后面会介绍。used_memory_human只是显示更友好。</p></li><li><p>used_memory_rss<strong>：</strong>Redis进程占据操作系统的内存（单位是字节），与top及ps命令看到的值是一致的；除了分配器分配的内存之外，used_memory_rss还包括进程运行本身需要的内存、内存碎片等，但是不包括虚拟内存。</p></li><li><p>mem_fragmentation_ratio<strong>：</strong>内存碎片比率，该值是used_memory_rss &#x2F; used_memory的比值。</p></li><li><p>mem_allocator<strong>：</strong>Redis使用的内存分配器，在编译时指定；可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc；截图中使用的便是默认的jemalloc。</p></li></ul><h3 id="17-Redis内存划分"><a href="#17-Redis内存划分" class="headerlink" title="17.Redis内存划分"></a>17.Redis内存划分</h3><ul><li>数据</li></ul><p>作为数据库，数据是最主要的部分；这部分占用的内存会统计在used_memory中。</p><ul><li>进程本身运行需要的内存</li></ul><p>Redis主进程本身运行肯定需要占用内存，如代码、常量池等等；这部分内存大约几兆，在大多数生产环境中与Redis数据占用的内存相比可以忽略。这部分内存不是由jemalloc分配，因此不会统计在used_memory中。</p><ul><li>缓冲内存</li></ul><p>缓冲内存包括客户端缓冲区、复制积压缓冲区、AOF缓冲区等；其中，客户端缓冲存储客户端连接的输入输出缓冲；复制积压缓冲用于部分复制功能；AOF缓冲区用于在进行AOF重写时，保存最近的写入命令。在了解相应功能之前，不需要知道这些缓冲的细节；这部分内存由jemalloc分配，因此会统计在used_memory中。</p><ul><li>内存碎片</li></ul><p>内存碎片是Redis在分配、回收物理内存过程中产生的。例如，如果对数据的更改频繁，而且数据之间的大小相差很大，可能导致redis释放的空间在物理内存中并没有释放，但redis又无法有效利用，这就形成了内存碎片。内存碎片不会统计在used_memory中。</p><h3 id="18-Redis对象有5种类型"><a href="#18-Redis对象有5种类型" class="headerlink" title="18.Redis对象有5种类型"></a>18.Redis对象有5种类型</h3><p>无论是哪种类型，Redis都不会直接存储，而是通过redisObject对象进行存储。</p><h3 id="19-Redis没有直接使用C字符串"><a href="#19-Redis没有直接使用C字符串" class="headerlink" title="19.Redis没有直接使用C字符串"></a>19.Redis没有直接使用C字符串</h3><p>(即以空字符’\0’结尾的字符数组)作为默认的字符串表示，而是使用了SDS。SDS是简单动态字符串(Simple Dynamic String)的缩写。</p><h3 id="20-Reidis的SDS在C字符串的基础上加入了free和len字段"><a href="#20-Reidis的SDS在C字符串的基础上加入了free和len字段" class="headerlink" title="20.Reidis的SDS在C字符串的基础上加入了free和len字段"></a>20.Reidis的SDS在C字符串的基础上加入了free和len字段</h3><h3 id="21-Reids主从复制"><a href="#21-Reids主从复制" class="headerlink" title="21.Reids主从复制"></a>21.Reids主从复制</h3><p>复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。</p><h3 id="22-Redis哨兵"><a href="#22-Redis哨兵" class="headerlink" title="22.Redis哨兵"></a>22.Redis哨兵</h3><p>在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。</p><h3 id="23-Reids持久化触发条件"><a href="#23-Reids持久化触发条件" class="headerlink" title="23.Reids持久化触发条件"></a>23.Reids持久化触发条件</h3><p>RDB持久化的触发分为手动触发和自动触发两种。</p><h3 id="24-Redis-开启AOF"><a href="#24-Redis-开启AOF" class="headerlink" title="24.Redis 开启AOF"></a>24.Redis 开启AOF</h3><p>Redis服务器默认开启RDB，关闭AOF；要开启AOF，需要在配置文件中配置：</p><p>appendonly yes</p><h3 id="25-AOF常用配置总结"><a href="#25-AOF常用配置总结" class="headerlink" title="25.AOF常用配置总结"></a>25.AOF常用配置总结</h3><p>下面是AOF常用的配置项，以及默认值；前面介绍过的这里不再详细介绍。</p><ul><li>appendonly no：是否开启AOF</li><li>appendfilename “appendonly.aof”：AOF文件名</li><li>dir .&#x2F;：RDB文件和AOF文件所在目录</li><li>appendfsync everysec：fsync持久化策略</li><li>no-appendfsync-on-rewrite no：AOF重写期间是否禁止fsync；如果开启该选项，可以减轻文件重写时CPU和硬盘的负载（尤其是硬盘），但是可能会丢失AOF重写期间的数据；需要在负载和安全性之间进行平衡</li><li>auto-aof-rewrite-percentage 100：文件重写触发条件之一</li><li>auto-aof-rewrite-min-size 64mb：文件重写触发提交之一</li><li>aof-load-truncated yes：如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件</li></ul><h3 id="26-RDB和AOF的优缺点"><a href="#26-RDB和AOF的优缺点" class="headerlink" title="26.RDB和AOF的优缺点"></a>26.RDB和AOF的优缺点</h3><p>RDB持久化</p><p>优点：RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多。当然，与AOF相比，RDB最重要的优点之一是对性能的影响相对较小。</p><p>缺点：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。</p><p>AOF持久化</p><p>与RDB持久化相对应，AOF的优点在于支持秒级持久化、兼容性好，缺点是文件大、恢复速度慢、对性能影响大。</p><h3 id="27-持久化策略选择"><a href="#27-持久化策略选择" class="headerlink" title="27.持久化策略选择"></a>27.持久化策略选择</h3><p>（1）如果Redis中的数据完全丢弃也没有关系（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化。</p><p>（2）在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF。</p><p>（3）但在多数情况下，我们都会配置主从环境，slave的存在既可以实现数据的热备，也可以进行读写分离分担Redis读请求，以及在master宕掉后继续提供服务。</p><h3 id="28-redis缓存被击穿处理机制"><a href="#28-redis缓存被击穿处理机制" class="headerlink" title="28.redis缓存被击穿处理机制"></a>28.redis缓存被击穿处理机制</h3><p>使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法</p><h3 id="29-Redis还提供的高级工具"><a href="#29-Redis还提供的高级工具" class="headerlink" title="29.Redis还提供的高级工具"></a>29.Redis还提供的高级工具</h3><p>像慢查询分析、性能测试、Pipeline、事务、Lua自定义命令、Bitmaps、HyperLogLog、发布&#x2F;订阅、Geo等个性化功能。</p><h3 id="30-Redis常用管理命令"><a href="#30-Redis常用管理命令" class="headerlink" title="30.Redis常用管理命令"></a>30.Redis常用管理命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># dbsize 返回当前数据库 key 的数量。</span><br><span class="line"># info 返回当前 redis 服务器状态和一些统计信息。</span><br><span class="line"># monitor 实时监听并返回redis服务器接收到的所有请求信息。</span><br><span class="line"># shutdown 把数据同步保存到磁盘上，并关闭redis服务。</span><br><span class="line"># config get parameter 获取一个 redis 配置参数信息。（个别参数可能无法获取）</span><br><span class="line"># config set parameter value 设置一个 redis 配置参数信息。（个别参数可能无法获取）</span><br><span class="line"># config resetstat 重置 info 命令的统计信息。（重置包括：keyspace 命中数、</span><br><span class="line"># keyspace 错误数、 处理命令数，接收连接数、过期 key 数）</span><br><span class="line"># debug object key 获取一个 key 的调试信息。</span><br><span class="line"># debug segfault 制造一次服务器当机。</span><br><span class="line"># flushdb 删除当前数据库中所有 key,此方法不会失败。小心慎用</span><br><span class="line"># flushall 删除全部数据库中所有 key，此方法不会失败。小心慎用</span><br></pre></td></tr></table></figure><h3 id="31-Reids工具命令"><a href="#31-Reids工具命令" class="headerlink" title="31.Reids工具命令"></a>31.Reids工具命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#redis-server：Redis 服务器的 daemon 启动程序</span><br><span class="line">#redis-cli：Redis 命令行操作工具。当然，你也可以用 telnet 根据其纯文本协议来操作</span><br><span class="line">#redis-benchmark：Redis 性能测试工具，测试 Redis 在你的系统及你的配置下的读写性能</span><br><span class="line">$redis-benchmark -n 100000 –c 50</span><br><span class="line">#模拟同时由 50 个客户端发送 100000 个 SETs/GETs 查询</span><br><span class="line">#redis-check-aof：更新日志检查</span><br><span class="line">#redis-check-dump：本地数据库检查</span><br></pre></td></tr></table></figure><h3 id="32-为什么需要持久化？"><a href="#32-为什么需要持久化？" class="headerlink" title="32.为什么需要持久化？"></a>32.为什么需要持久化？</h3><p>由于Redis是一种内存型数据库，即服务器在运行时，系统为其分配了一部分内存存储数据，一旦服务器挂了，或者突然宕机了，那么数据库里面的数据将会丢失，为了使服务器即使突然关机也能保存数据，必须通过持久化的方式将数据从内存保存到磁盘中。</p><h3 id="33-判断key是否存在"><a href="#33-判断key是否存在" class="headerlink" title="33.判断key是否存在"></a>33.判断key是否存在</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key +key名字</span><br></pre></td></tr></table></figure><h3 id="34-删除key"><a href="#34-删除key" class="headerlink" title="34.删除key"></a>34.删除key</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key1 key2 ...</span><br></pre></td></tr></table></figure><h3 id="35-缓存和数据库间数据一致性问题"><a href="#35-缓存和数据库间数据一致性问题" class="headerlink" title="35.缓存和数据库间数据一致性问题"></a>35.缓存和数据库间数据一致性问题</h3><p>分布式环境下（单机就不用说了）非常容易出现缓存和数据库间的数据一致性问题，针对这一点的话，只能说，如果你的项目对缓存的要求是强一致性的，那么请不要使用缓存。我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。合适的策略包括 合适的缓存更新策略，更新数据库后要及时更新缓存、缓存失败时增加重试机制，例如MQ模式的消息队列。</p><h3 id="36-布隆过滤器"><a href="#36-布隆过滤器" class="headerlink" title="36.布隆过滤器"></a>36.布隆过滤器</h3><p>bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小</p><h3 id="37-缓存雪崩问题"><a href="#37-缓存雪崩问题" class="headerlink" title="37.缓存雪崩问题"></a>37.缓存雪崩问题</h3><p>存在同一时间内大量键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。</p><p>解决方案：</p><p>1、也是像解决缓存穿透一样加锁排队。</p><p>2、建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;</p><h3 id="38-缓存并发问题"><a href="#38-缓存并发问题" class="headerlink" title="38.缓存并发问题"></a>38.缓存并发问题</h3><p>这里的并发指的是多个redis的client同时set key引起的并发问题。比较有效的解决方案就是把redis.set操作放在队列中使其串行化，必须的一个一个执行，具体的代码就不上了，当然加锁也是可以的，至于为什么不用redis中的事务，留给各位看官自己思考探究。</p><h3 id="39-Redis分布式"><a href="#39-Redis分布式" class="headerlink" title="39.Redis分布式"></a>39.Redis分布式</h3><p>redis支持主从的模式。原则：Master会将数据同步到slave，而slave不会将数据同步到master。Slave启动时会连接master来同步数据。</p><p>这是一个典型的分布式读写分离模型。我们可以利用master来插入数据，slave提供检索服务。这样可以有效减少单个机器的并发访问数量</p><h3 id="40-读写分离模型"><a href="#40-读写分离模型" class="headerlink" title="40.读写分离模型"></a>40.读写分离模型</h3><p>通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。读写分离架构的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离架构并不适合。</p><h3 id="41-数据分片模型"><a href="#41-数据分片模型" class="headerlink" title="41.数据分片模型"></a>41.数据分片模型</h3><p>为了解决读写分离模型的缺陷，可以将数据分片模型应用进来。</p><p>可以将每个节点看成都是独立的master，然后通过业务实现数据分片。</p><p>结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。</p><h3 id="42-redis常见性能问题和解决方案："><a href="#42-redis常见性能问题和解决方案：" class="headerlink" title="42. redis常见性能问题和解决方案："></a>42. redis常见性能问题和解决方案：</h3><p>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</p><p>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</p><p>为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</p><p>尽量避免在压力很大的主库上增加从库</p><h3 id="43-redis通讯协议"><a href="#43-redis通讯协议" class="headerlink" title="43.redis通讯协议"></a>43.redis通讯协议</h3><p>RESP 是redis客户端和服务端之前使用的一种通讯协议；RESP 的特点：实现简单、快速解析、可读性好</p><h3 id="44-Redis分布式锁实现"><a href="#44-Redis分布式锁实现" class="headerlink" title="44.Redis分布式锁实现"></a>44.Redis分布式锁实现</h3><p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。<strong>如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</strong>set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！</p><h3 id="45-Redis做异步队列"><a href="#45-Redis做异步队列" class="headerlink" title="45.Redis做异步队列"></a>45.Redis做异步队列</h3><p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。缺点：在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。<strong>能不能生产一次消费多次呢？</strong>使用pub&#x2F;sub主题订阅者模式，可以实现1:N的消息队列。</p><h3 id="46-Redis中海量数据的正确操作方式"><a href="#46-Redis中海量数据的正确操作方式" class="headerlink" title="46.Redis中海量数据的正确操作方式"></a>46.Redis中海量数据的正确操作方式</h3><p>利用SCAN系列命令（SCAN、SSCAN、HSCAN、ZSCAN）完成数据迭代。</p><h3 id="47-SCAN系列命令注意事项"><a href="#47-SCAN系列命令注意事项" class="headerlink" title="47.SCAN系列命令注意事项"></a>47.SCAN系列命令注意事项</h3><ul><li>SCAN的参数没有key，因为其迭代对象是DB内数据；</li><li>返回值都是数组，第一个值都是下一次迭代游标；</li><li>时间复杂度：每次请求都是O(1)，完成所有迭代需要O(N)，N是元素数量；</li><li>可用版本：version &gt;&#x3D; 2.8.0；</li></ul><h3 id="48-Redis-管道-Pipeline"><a href="#48-Redis-管道-Pipeline" class="headerlink" title="48.Redis 管道 Pipeline"></a>48.Redis 管道 Pipeline</h3><p>在某些场景下我们在一次操作中可能需要执行多个命令，而如果我们只是一个命令一个命令去执行则会浪费很多网络消耗时间，如果将命令一次性传输到 Redis中去再执行，则会减少很多开销时间。但是需要注意的是 pipeline中的命令并不是原子性执行的，也就是说管道中的命令到达 Redis服务器的时候可能会被其他的命令穿插</p><h3 id="49-事务不支持回滚"><a href="#49-事务不支持回滚" class="headerlink" title="49.事务不支持回滚"></a>49.事务不支持回滚</h3><h3 id="50-手写一个-LRU-算法"><a href="#50-手写一个-LRU-算法" class="headerlink" title="50.手写一个 LRU 算法"></a>50.手写一个 LRU 算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;</span><br><span class="line">    private final int CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 传递进来最多能缓存多少数据</span><br><span class="line">     *</span><br><span class="line">     * @param cacheSize 缓存大小</span><br><span class="line">     */</span><br><span class="line">    public LRUCache(int cacheSize) &#123;</span><br><span class="line">        // true 表示让 linkedHashMap 按照访问顺序来进行排序，最近访问的放在头部，最老访问的放在尾部。</span><br><span class="line">        super((int) Math.ceil(cacheSize / 0.75) + 1, 0.75f, true);</span><br><span class="line">        CACHE_SIZE = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;</span><br><span class="line">        // 当 map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。</span><br><span class="line">        return size() &gt; CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="51-多节点-Redis-分布式锁：Redlock-算法"><a href="#51-多节点-Redis-分布式锁：Redlock-算法" class="headerlink" title="51.多节点 Redis 分布式锁：Redlock 算法"></a>51.多节点 Redis 分布式锁：Redlock 算法</h3><p>获取当前时间（start）。</p><p>依次向 N 个 Redis节点请求锁。请求锁的方式与从单节点 Redis获取锁的方式一致。为了保证在某个 Redis节点不可用时该算法能够继续运行，获取锁的操作都需要设置超时时间，需要保证该超时时间远小于锁的有效时间。这样才能保证客户端在向某个 Redis节点获取锁失败之后，可以立刻尝试下一个节点。</p><p>计算获取锁的过程总共消耗多长时间（consumeTime &#x3D; end - start）。如果客户端从大多数 Redis节点（&gt;&#x3D; N&#x2F;2 + 1) 成功获取锁，并且获取锁总时长没有超过锁的有效时间，这种情况下，客户端会认为获取锁成功，否则，获取锁失败。</p><p>如果最终获取锁成功，锁的有效时间应该重新设置为锁最初的有效时间减去 consumeTime。</p><p>如果最终获取锁失败，客户端应该立刻向所有 Redis节点发起释放锁的请求。</p><h3 id="52-Redis-中设置过期时间主要通过以下四种方式"><a href="#52-Redis-中设置过期时间主要通过以下四种方式" class="headerlink" title="52.Redis 中设置过期时间主要通过以下四种方式"></a>52.Redis 中设置过期时间主要通过以下四种方式</h3><p>expire key seconds：设置 key 在 n 秒后过期；<br>pexpire key milliseconds：设置 key 在 n 毫秒后过期；<br>expireat key timestamp：设置 key 在某个时间戳（精确到秒）之后过期；<br>pexpireat key millisecondsTimestamp：设置 key 在某个时间戳（精确到毫秒）之后过期；</p><h3 id="53-Reids三种不同删除策略"><a href="#53-Reids三种不同删除策略" class="headerlink" title="53.Reids三种不同删除策略"></a>53.Reids三种不同删除策略</h3><p>定时删除：在设置键的过期时间的同时，创建一个定时任务，当键达到过期时间时，立即执行对键的删除操作</p><p>惰性删除：放任键过期不管，但在每次从键空间获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，如果没有过期，就返回该键</p><p>定期删除：每隔一点时间，程序就对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</p><h3 id="54-定时删除"><a href="#54-定时删除" class="headerlink" title="54.定时删除"></a>54.定时删除</h3><p><strong>优点：</strong>对内存友好，定时删除策略可以保证过期键会尽可能快地被删除，并释放国期间所占用的内存<br><strong>缺点：</strong>对cpu时间不友好，在过期键比较多时，删除任务会占用很大一部分cpu时间，在内存不紧张但cpu时间紧张的情况下，将cpu时间用在删除和当前任务无关的过期键上，影响服务器的响应时间和吞吐量</p><h3 id="55-定期删除"><a href="#55-定期删除" class="headerlink" title="55.定期删除"></a>55.定期删除</h3><p>由于定时删除会占用太多cpu时间，影响服务器的响应时间和吞吐量以及惰性删除浪费太多内存，有内存泄露的危险，所以出现一种整合和折中这两种策略的定期删除策略。</p><p>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。<br>定时删除策略有效地减少了因为过期键带来的内存浪费。</p><h3 id="56-惰性删除"><a href="#56-惰性删除" class="headerlink" title="56.惰性删除"></a>56.惰性删除</h3><p><strong>优点：</strong>对cpu时间友好，在每次从键空间获取键时进行过期键检查并是否删除，删除目标也仅限当前处理的键，这个策略不会在其他无关的删除任务上花费任何cpu时间。<br><strong>缺点：</strong>对内存不友好，过期键过期也可能不会被删除，导致所占的内存也不会释放。甚至可能会出现内存泄露的现象，当存在很多过期键，而这些过期键又没有被访问到，这会可能导致它们会一直保存在内存中，造成内存泄露。</p><h3 id="57-Reids-管理工具：Redis-Manager-2-0"><a href="#57-Reids-管理工具：Redis-Manager-2-0" class="headerlink" title="57.Reids 管理工具：Redis Manager 2.0"></a>57.Reids 管理工具：Redis Manager 2.0</h3><p>github地址</p><h3 id="58-Redis常见的几种缓存策略"><a href="#58-Redis常见的几种缓存策略" class="headerlink" title="58.Redis常见的几种缓存策略"></a>58.Redis常见的几种缓存策略</h3><ul><li>Cache-Aside</li><li>Read-Through</li><li>Write-Through</li><li>Write-Behind</li></ul><h3 id="59-Redis-Module-实现布隆过滤器"><a href="#59-Redis-Module-实现布隆过滤器" class="headerlink" title="59.Redis Module 实现布隆过滤器"></a>59.Redis Module 实现布隆过滤器</h3><p>Redis module 是Redis 4.0 以后支持的新的特性，这里很多国外牛逼的大学和机构提供了很多牛逼的Module 只要编译引入到Redis 中就能轻松的实现我们某些需求的功能。在Redis 官方Module 中有一些我们常见的一些模块，我们在这里就做一个简单的使用。</p><ul><li>neural-redis 主要是神经网络的机器学，集成到redis 可以做一些机器训练感兴趣的可以尝试</li><li>RedisSearch 主要支持一些富文本的的搜索</li><li>RedisBloom 支持分布式环境下的Bloom 过滤器</li></ul><h3 id="60-Redis-到底是怎么实现“附近的人”"><a href="#60-Redis-到底是怎么实现“附近的人”" class="headerlink" title="60.Redis 到底是怎么实现“附近的人”"></a>60.Redis 到底是怎么实现“附近的人”</h3><p>使用方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOADD key longitude latitude member [longitude latitude member ...]</span><br></pre></td></tr></table></figure><p>将给定的位置对象（纬度、经度、名字）添加到指定的key。其中，key为集合名称，member为该经纬度所对应的对象。在实际运用中，当所需存储的对象数量过多时，可通过设置多key(如一个省一个key)的方式对对象集合变相做sharding，避免单集合数量过多。</p><p>成功插入后的返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(integer) N</span><br></pre></td></tr></table></figure><p>其中N为成功插入的个数。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试100题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 面试 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql 面试必备 100 题</title>
      <link href="/interview/100prob/mysql-interview-100/"/>
      <url>/interview/100prob/mysql-interview-100/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL数据库经典面试题解析"><a href="#MySQL数据库经典面试题解析" class="headerlink" title="MySQL数据库经典面试题解析"></a>MySQL数据库经典面试题解析</h1><h2 id="1-MySQL-索引使用有哪些注意事项呢？"><a href="#1-MySQL-索引使用有哪些注意事项呢？" class="headerlink" title="1. MySQL 索引使用有哪些注意事项呢？"></a>1. MySQL 索引使用有哪些注意事项呢？</h2><p>可以从三个维度回答这个问题：索引哪些情况会失效，索引不适合哪些场景，索引规则</p><h3 id="索引哪些情况会失效"><a href="#索引哪些情况会失效" class="headerlink" title="索引哪些情况会失效"></a>索引哪些情况会失效</h3><ul><li>查询条件包含or，可能导致索引失效</li><li>如何字段类型是字符串，where时一定用引号括起来，否则索引失效</li><li>like通配符可能导致索引失效。</li><li>联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。</li><li>在索引列上使用mysql的内置函数，索引失效。</li><li>对索引列运算（如，+、-、*、&#x2F;），索引失效。</li><li>索引字段上使用（！&#x3D; 或者 &lt; &gt;，not in）时，可能会导致索引失效。</li><li>索引字段上使用is null， is not null，可能导致索引失效。</li><li>左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。</li><li>mysql估计使用全表扫描要比使用索引快,则不使用索引。</li></ul><h3 id="索引不适合哪些场景"><a href="#索引不适合哪些场景" class="headerlink" title="索引不适合哪些场景"></a>索引不适合哪些场景</h3><ul><li>数据量少的不适合加索引</li><li>更新比较频繁的也不适合加索引</li><li>区分度低的字段不适合加索引（如性别）</li></ul><h3 id="索引的一些潜规则"><a href="#索引的一些潜规则" class="headerlink" title="索引的一些潜规则"></a>索引的一些潜规则</h3><ul><li>覆盖索引</li><li>回表</li><li>索引数据结构（B+树）</li><li>最左前缀原则</li><li>索引下推</li></ul><h2 id="2-MySQL-遇到过死锁问题吗，你是如何解决的？"><a href="#2-MySQL-遇到过死锁问题吗，你是如何解决的？" class="headerlink" title="2. MySQL 遇到过死锁问题吗，你是如何解决的？"></a>2. MySQL 遇到过死锁问题吗，你是如何解决的？</h2><p>我排查死锁的一般步骤是酱紫的：</p><ul><li>查看死锁日志show engine innodb status;</li><li>找出死锁Sql</li><li>分析sql加锁情况</li><li>模拟死锁案发</li><li>分析死锁日志</li><li>分析死锁结果</li></ul><h2 id="3-日常工作中你是怎么优化SQL的？"><a href="#3-日常工作中你是怎么优化SQL的？" class="headerlink" title="3. 日常工作中你是怎么优化SQL的？"></a>3. 日常工作中你是怎么优化SQL的？</h2><p>可以从这几个维度回答这个问题：</p><ul><li>加索引</li><li>避免返回不必要的数据</li><li>适当分批量进行</li><li>优化sql结构</li><li>分库分表</li><li>读写分离</li></ul><h2 id="4-说说分库与分表的设计"><a href="#4-说说分库与分表的设计" class="headerlink" title="4. 说说分库与分表的设计"></a>4. 说说分库与分表的设计</h2><p>分库分表方案，分库分表中间件，分库分表可能遇到的问题</p><h3 id="分库分表方案"><a href="#分库分表方案" class="headerlink" title="分库分表方案:"></a>分库分表方案:</h3><ul><li>水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。</li><li>水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。</li><li>垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。</li><li>垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。</li></ul><h3 id="常用的分库分表中间件："><a href="#常用的分库分表中间件：" class="headerlink" title="常用的分库分表中间件："></a>常用的分库分表中间件：</h3><ul><li>sharding-jdbc（当当）</li><li>Mycat</li><li>TDDL（淘宝）</li><li>Oceanus(58同城数据库中间件)</li><li>vitess（谷歌开发的数据库中间件）</li><li>Atlas(Qihoo 360)</li></ul><h3 id="分库分表可能遇到的问题"><a href="#分库分表可能遇到的问题" class="headerlink" title="分库分表可能遇到的问题"></a>分库分表可能遇到的问题</h3><ul><li>事务问题：需要用分布式事务啦</li><li>跨节点Join的问题：解决这一问题可以分两次查询实现</li><li>跨节点的count,order by,group by以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并。</li><li>数据迁移，容量规划，扩容等问题</li><li>ID问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑UUID</li><li>跨分片的排序分页问题（后台加大pagesize处理？）</li></ul><h2 id="5-InnoDB与MyISAM的区别"><a href="#5-InnoDB与MyISAM的区别" class="headerlink" title="5. InnoDB与MyISAM的区别"></a>5. InnoDB与MyISAM的区别</h2><ul><li>InnoDB支持事务，MyISAM不支持事务</li><li>InnoDB支持外键，MyISAM不支持外键</li><li>InnoDB 支持 MVCC(多版本并发控制)，MyISAM 不支持</li><li><code>select count(*) from table</code>时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB就需要全表扫描。</li><li>Innodb不支持全文索引，而MyISAM支持全文索引（5.7以后的InnoDB也支持全文索引）</li><li>InnoDB支持表、行级锁，而MyISAM支持表级锁。</li><li>InnoDB表必须有主键，而MyISAM可以没有主键</li><li>Innodb表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小，。</li><li>Innodb按主键大小有序插入，MyISAM记录插入顺序是，按记录插入顺序保存。</li><li>InnoDB 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 MyISAM 比 InnoDB 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引</li><li>InnoDB 属于索引组织表，使用共享表空间和多表空间储存数据。MyISAM用<code>.frm</code>、<code>.MYD</code>、<code>.MTI</code>来储存表定义，数据和索引。</li></ul><h2 id="6-数据库索引的原理，为什么要用-B-树，为什么不用二叉树？"><a href="#6-数据库索引的原理，为什么要用-B-树，为什么不用二叉树？" class="headerlink" title="6. 数据库索引的原理，为什么要用 B+树，为什么不用二叉树？"></a>6. 数据库索引的原理，为什么要用 B+树，为什么不用二叉树？</h2><p>可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是B+树呢？</p><h3 id="为什么不是一般二叉树？"><a href="#为什么不是一般二叉树？" class="headerlink" title="为什么不是一般二叉树？"></a>为什么不是一般二叉树？</h3><p>如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。</p><h3 id="为什么不是平衡二叉树呢？"><a href="#为什么不是平衡二叉树呢？" class="headerlink" title="为什么不是平衡二叉树呢？"></a>为什么不是平衡二叉树呢？</h3><p>我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。</p><h3 id="那为什么不是B树而是B-树呢？"><a href="#那为什么不是B树而是B-树呢？" class="headerlink" title="那为什么不是B树而是B+树呢？"></a>那为什么不是B树而是B+树呢？</h3><ul><li>1）B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。</li><li>2）B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。</li></ul><h2 id="7-聚集索引与非聚集索引的区别"><a href="#7-聚集索引与非聚集索引的区别" class="headerlink" title="7. 聚集索引与非聚集索引的区别"></a>7. 聚集索引与非聚集索引的区别</h2><ul><li>一个表中只能拥有一个聚集索引，而非聚集索引一个表可以存在多个。</li><li>聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。</li><li>索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</li><li>聚集索引：物理存储按照索引排序；非聚集索引：物理存储不按照索引排序；</li></ul><p>何时使用聚集索引或非聚集索引？</p><h2 id="8-limit-1000000-加载很慢的话，你是怎么解决的呢？"><a href="#8-limit-1000000-加载很慢的话，你是怎么解决的呢？" class="headerlink" title="8. limit 1000000 加载很慢的话，你是怎么解决的呢？"></a>8. limit 1000000 加载很慢的话，你是怎么解决的呢？</h2><p>方案一：如果id是连续的，可以这样，返回上次查询的最大记录(偏移量)，再往下limit</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id，name <span class="keyword">from</span> employee <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">1000000</span> limit <span class="number">10.</span></span><br></pre></td></tr></table></figure><p>方案二：在业务允许的情况下限制页数：</p><p>建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。</p><p>方案三：order by + 索引（id为索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id，name <span class="keyword">from</span> employee <span class="keyword">order</span> <span class="keyword">by</span> id  limit <span class="number">1000000</span>，<span class="number">10</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.<span class="operator">*</span> <span class="keyword">FROM</span> employee a, (<span class="keyword">select</span> id <span class="keyword">from</span> employee <span class="keyword">where</span> 条件 LIMIT <span class="number">1000000</span>,<span class="number">10</span> ) b <span class="keyword">where</span> a.id<span class="operator">=</span>b.id</span><br></pre></td></tr></table></figure><p>方案四：利用延迟关联或者子查询优化超多分页场景。（先快速定位需要获取的id段，然后再关联）</p><h2 id="9-如何选择合适的分布式主键方案呢？"><a href="#9-如何选择合适的分布式主键方案呢？" class="headerlink" title="9. 如何选择合适的分布式主键方案呢？"></a>9. 如何选择合适的分布式主键方案呢？</h2><ul><li>数据库自增长序列或字段。</li><li>UUID。</li><li>Redis生成ID</li><li>Twitter的snowflake算法</li><li>利用zookeeper生成唯一ID</li><li>MongoDB的ObjectId</li></ul><h2 id="10-事务的隔离级别有哪些？MySQL的默认隔离级别是什么？"><a href="#10-事务的隔离级别有哪些？MySQL的默认隔离级别是什么？" class="headerlink" title="10. 事务的隔离级别有哪些？MySQL的默认隔离级别是什么？"></a>10. 事务的隔离级别有哪些？MySQL的默认隔离级别是什么？</h2><ul><li>读未提交（Read Uncommitted）</li><li>读已提交（Read Committed）</li><li>可重复读（Repeatable Read）</li><li>串行化（Serializable）</li></ul><p>Mysql默认的事务隔离级别是可重复读(Repeatable Read)</p><h2 id="11-什么是幻读，脏读，不可重复读呢？"><a href="#11-什么是幻读，脏读，不可重复读呢？" class="headerlink" title="11. 什么是幻读，脏读，不可重复读呢？"></a>11. 什么是幻读，脏读，不可重复读呢？</h2><ul><li>事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据,这就是脏读</li><li>在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是不可重复读。</li><li>事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入&#x2F;删除了数据，并静悄悄地提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了，这就是幻读。</li></ul><h2 id="12-在高并发情况下，如何做到安全的修改同一行数据？"><a href="#12-在高并发情况下，如何做到安全的修改同一行数据？" class="headerlink" title="12. 在高并发情况下，如何做到安全的修改同一行数据？"></a>12. 在高并发情况下，如何做到安全的修改同一行数据？</h2><p>要安全的修改同一行数据，就要保证一个线程在修改时其它线程无法更新这行记录。一般有悲观锁和乐观锁两种方案~</p><h3 id="使用悲观锁"><a href="#使用悲观锁" class="headerlink" title="使用悲观锁"></a>使用悲观锁</h3><p>悲观锁思想就是，当前线程要进来修改数据时，别的线程都得拒之门外~<br>比如，可以使用select…for update ~</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">User</span> <span class="keyword">where</span> name<span class="operator">=</span>‘jay’ <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>以上这条sql语句会锁定了User表中所有符合检索条件（name&#x3D;‘jay’）的记录。本次事务提交之前，别的线程都无法修改这些记录。</p><h3 id="使用乐观锁"><a href="#使用乐观锁" class="headerlink" title="使用乐观锁"></a>使用乐观锁</h3><p>乐观锁思想就是，有线程过来，先放过去修改，如果看到别的线程没修改过，就可以修改成功，如果别的线程修改过，就修改失败或者重试。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。</p><h2 id="13-数据库的乐观锁和悲观锁。"><a href="#13-数据库的乐观锁和悲观锁。" class="headerlink" title="13. 数据库的乐观锁和悲观锁。"></a>13. 数据库的乐观锁和悲观锁。</h2><h3 id="悲观锁："><a href="#悲观锁：" class="headerlink" title="悲观锁："></a>悲观锁：</h3><p>悲观锁她专一且缺乏安全感了，她的心只属于当前事务，每时每刻都担心着它心爱的数据可能被别的事务修改，所以一个事务拥有（获得）悲观锁后，其他任何事务都不能对数据进行修改啦，只能等待锁被释放才可以执行。</p><h3 id="乐观锁："><a href="#乐观锁：" class="headerlink" title="乐观锁："></a>乐观锁：</h3><p>乐观锁的“乐观情绪”体现在，它认为数据的变动不会太频繁。因此，它允许多个事务同时对数据进行变动。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。</p><h2 id="14-SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义。"><a href="#14-SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义。" class="headerlink" title="14. SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义。"></a>14. SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义。</h2><ul><li><code>show status</code> 命令了解各种 sql 的执行频率</li><li>通过慢查询日志定位那些执行效率较低的 sql 语句</li><li><code>explain</code> 分析低效 sql 的执行计划（这点非常重要，日常开发中用它分析Sql，会大大降低Sql导致的线上事故）</li></ul><h2 id="15-select-for-update有什么含义，会锁表还是锁行还是其他。"><a href="#15-select-for-update有什么含义，会锁表还是锁行还是其他。" class="headerlink" title="15. select for update有什么含义，会锁表还是锁行还是其他。"></a>15. select for update有什么含义，会锁表还是锁行还是其他。</h2><h3 id="select-for-update-含义"><a href="#select-for-update-含义" class="headerlink" title="select for update 含义"></a>select for update 含义</h3><p>select查询语句是不会加锁的，但是select for update除了有查询的作用外，还会加锁呢，而且它是悲观锁哦。至于加了是行锁还是表锁，这就要看是不是用了索引&#x2F;主键啦。<br>没用索引&#x2F;主键的话就是表锁，否则就是是行锁。</p><h2 id="16-MySQL事务得四大特性以及实现原理"><a href="#16-MySQL事务得四大特性以及实现原理" class="headerlink" title="16. MySQL事务得四大特性以及实现原理"></a>16. MySQL事务得四大特性以及实现原理</h2><ul><li>原子性： 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li><li>一致性： 指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转10块钱，不管成功与否，A和B的总金额是不变的。</li><li>隔离性： 多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。简言之，就是事务之间是进水不犯河水的。</li><li>持久性： 表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。</li></ul><h3 id="事务ACID特性的实现思想"><a href="#事务ACID特性的实现思想" class="headerlink" title="事务ACID特性的实现思想"></a>事务ACID特性的实现思想</h3><ul><li>原子性：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。</li><li>持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。</li><li>隔离性：通过锁以及MVCC,使事务相互隔离开。</li><li>一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。</li></ul><h2 id="17-如果某个表有近千万数据，CRUD比较慢，如何优化。"><a href="#17-如果某个表有近千万数据，CRUD比较慢，如何优化。" class="headerlink" title="17. 如果某个表有近千万数据，CRUD比较慢，如何优化。"></a>17. 如果某个表有近千万数据，CRUD比较慢，如何优化。</h2><h3 id="什么时候进行分库"><a href="#什么时候进行分库" class="headerlink" title="什么时候进行分库"></a>什么时候进行分库</h3><p>MySQL 的高可用架构大多都是一主多从，所有写入操作都发生在 Master 上，随着业务的增长，数据量的增加，很多接口响应时间变得很长，经常出现 Timeout，而且通过升级 MySQL 实例配置已经无法解决问题了，这时候就要分库。</p><h3 id="什么时候进行分表"><a href="#什么时候进行分表" class="headerlink" title="什么时候进行分表"></a>什么时候进行分表</h3><p>分表的应用场景是<strong>单表</strong>数据量增长速度过快，影响了业务接口的响应时间，但是 MySQL 实例的负载并不高，这时候只需要分表，不需要分库（拆分实例）。</p><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>某个表有近千万数据，可以考虑优化表结构，分表（水平分表，垂直分表），当然，你这样回答，需要准备好面试官问你的分库分表相关问题呀，如</p><ul><li>分表方案（水平分表 &#x3D; 拆字段 &#x3D; 需要注意拆分后 join 的问题 &#x3D; 冗余关键字段，垂直分表 &#x3D; 按时间切分 or 按照 uid 切分 &#x3D; 规则 hash &#x2F; mod 等）</li><li>分库分表中间件（Mycat，sharding-jdbc等）</li><li>分库分表一些问题（事务问题？跨节点Join的问题）</li><li>解决方案（分布式事务等）or 分布式数据库 &#x3D;  tidb</li></ul><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><p>除了分库分表，优化表结构，当然还有所以索引优化等方案~</p><h2 id="18-如何写sql能够有效的使用到复合索引。"><a href="#18-如何写sql能够有效的使用到复合索引。" class="headerlink" title="18. 如何写sql能够有效的使用到复合索引。"></a>18. 如何写sql能够有效的使用到复合索引。</h2><p>复合索引，也叫组合索引，用户可以在多个列上建立索引,这种索引叫做复合索引。</p><p>当我们创建一个组合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> k1<span class="operator">=</span>A <span class="keyword">AND</span> k2<span class="operator">=</span>B <span class="keyword">AND</span> k3<span class="operator">=</span>D </span><br></pre></td></tr></table></figure><p>有关于复合索引，我们需要关注查询Sql条件的顺序，确保最左匹配原则有效，同时可以删除不必要的冗余索引。</p><h2 id="19-mysql中in-和exists的区别。"><a href="#19-mysql中in-和exists的区别。" class="headerlink" title="19. mysql中in 和exists的区别。"></a>19. mysql中in 和exists的区别。</h2><p>这个，跟一下demo来看更刺激吧，啊哈哈</p><p>假设表A表示某企业的员工表，表B表示部门表，查询所有部门的所有员工，很容易有以下SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> deptId <span class="keyword">in</span> (<span class="keyword">select</span> deptId <span class="keyword">from</span> B);</span><br></pre></td></tr></table></figure><p>这样写等价于：</p><blockquote><p>先查询部门表B<br>select deptId from B<br>再由部门deptId，查询A的员工<br>select * from A where A.deptId &#x3D; B.deptId</p></blockquote><p>可以抽象成这样的一个循环：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List<span class="operator">&lt;&gt;</span> resultSet ;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i<span class="operator">=</span><span class="number">0</span>;i<span class="operator">&lt;</span>B.length;i<span class="operator">+</span><span class="operator">+</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j<span class="operator">=</span><span class="number">0</span>;j<span class="operator">&lt;</span>A.length;j<span class="operator">+</span><span class="operator">+</span>) &#123;</span><br><span class="line">       if(A[i].id<span class="operator">=</span><span class="operator">=</span>B[j].id) &#123;</span><br><span class="line">          resultSet.add(A[i]);</span><br><span class="line">          break;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>显然，除了使用in，我们也可以用exists实现一样的查询功能，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> A.deptId <span class="operator">=</span> B.deptId); </span><br></pre></td></tr></table></figure><p>因为exists查询的理解就是，先执行主查询，获得数据后，再放到子查询中做条件验证，根据验证结果（true或者false），来决定主查询的数据结果是否得意保留。</p><p>那么，这样写就等价于：</p><blockquote><p>select * from A,先从A表做循环<br>select * from B where A.deptId &#x3D; B.deptId,再从B表做循环.</p></blockquote><p>同理，可以抽象成这样一个循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;&gt; resultSet ;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.length;i++) &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;B.length;j++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(A[i].deptId==B[j].deptId) &#123;</span><br><span class="line">            resultSet.add(A[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>数据库最费劲的就是跟程序链接释放。假设链接了两次，每次做上百万次的数据集查询，查完就走，这样就只做了两次；相反建立了上百万次链接，申请链接释放反复重复，这样系统就受不了了。即mysql优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优。<br>因此，我们要选择最外层循环小的，也就是，如果B的数据量小于A，适合使用in，如果B的数据量大于A，即适合选择exists，这就是in和exists的区别。</p><h2 id="20-数据库自增主键可能遇到什么问题。"><a href="#20-数据库自增主键可能遇到什么问题。" class="headerlink" title="20. 数据库自增主键可能遇到什么问题。"></a>20. 数据库自增主键可能遇到什么问题。</h2><p>使用自增主键对数据库做分库分表，可能出现诸如主键重复等的问题。解决方案的话，简单点的话可以考虑使用UUID哈<br>自增主键会产生表锁，从而引发问题<br>自增主键可能用完问题。</p><h2 id="21-MVCC熟悉吗，它的底层原理？"><a href="#21-MVCC熟悉吗，它的底层原理？" class="headerlink" title="21. MVCC熟悉吗，它的底层原理？"></a>21. MVCC熟悉吗，它的底层原理？</h2><p>MVCC,多版本并发控制,它是通过读取历史版本的数据，来降低并发事务冲突，从而提高并发性能的一种机制。</p><h3 id="MVCC需要关注这几个知识点："><a href="#MVCC需要关注这几个知识点：" class="headerlink" title="MVCC需要关注这几个知识点："></a>MVCC需要关注这几个知识点：</h3><ul><li>事务版本号</li><li>表的隐藏列</li><li>undo log</li><li>read view</li></ul><h2 id="22-数据库中间件了解过吗，sharding-jdbc，mycat？"><a href="#22-数据库中间件了解过吗，sharding-jdbc，mycat？" class="headerlink" title="22. 数据库中间件了解过吗，sharding jdbc，mycat？"></a>22. 数据库中间件了解过吗，sharding jdbc，mycat？</h2><p>sharding-jdbc目前是基于jdbc驱动，无需额外的proxy，因此也无需关注proxy本身的高可用。<br>Mycat 是基于 Proxy，它复写了 MySQL 协议，将 Mycat Server 伪装成一个 MySQL 数据库，而 Sharding-JDBC 是基于 JDBC 接口的扩展，是以 jar 包的形式提供轻量级服务的。</p><h2 id="23-MYSQL的主从延迟，你怎么解决？"><a href="#23-MYSQL的主从延迟，你怎么解决？" class="headerlink" title="23. MYSQL的主从延迟，你怎么解决？"></a>23. MYSQL的主从延迟，你怎么解决？</h2><p>嘻嘻，先复习一下主从复制原理吧，如图：<br>主从复制分了五个步骤进行：</p><ul><li>步骤一：主库的更新事件(update、insert、delete)被写到binlog</li><li>步骤二：从库发起连接，连接到主库。</li><li>步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库。</li><li>步骤四：从库启动之后，创建一个I&#x2F;O线程，读取主库传过来的binlog内容并写入到relay log</li><li>步骤五：还会创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db</li></ul><h3 id="主从同步延迟的原因"><a href="#主从同步延迟的原因" class="headerlink" title="主从同步延迟的原因"></a>主从同步延迟的原因</h3><p>一个服务器开放Ｎ个链接给客户端来连接的，这样有会有大并发的更新操作, 但是从服务器的里面读取binlog的线程仅有一个，当某个SQL在从服务器上执行的时间稍长 或者由于某个SQL要进行锁表就会导致，主服务器的SQL大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。</p><h3 id="主从同步延迟的解决办法"><a href="#主从同步延迟的解决办法" class="headerlink" title="主从同步延迟的解决办法"></a>主从同步延迟的解决办法</h3><ul><li>主服务器要负责更新操作，对安全性的要求比从服务器要高，所以有些设置参数可以修改，比如sync_binlog&#x3D;1，innodb_flush_log_at_trx_commit &#x3D; 1 之类的设置等。</li><li>选择更好的硬件设备作为slave。</li><li>把一台从服务器当度作为备份使用， 而不提供查询， 那边他的负载下来了， 执行relay log 里面的SQL效率自然就高了。</li><li>增加从服务器喽，这个目的还是分散读的压力，从而降低服务器负载。</li></ul><h2 id="24-说一下大表查询的优化方案"><a href="#24-说一下大表查询的优化方案" class="headerlink" title="24. 说一下大表查询的优化方案"></a>24. 说一下大表查询的优化方案</h2><ul><li>优化shema、sql语句+索引；</li><li>可以考虑加缓存，memcached, redis，或者JVM本地缓存；</li><li>主从复制，读写分离；</li><li>分库分表；</li></ul><h2 id="25-什么是数据库连接池-为什么需要数据库连接池呢"><a href="#25-什么是数据库连接池-为什么需要数据库连接池呢" class="headerlink" title="25. 什么是数据库连接池?为什么需要数据库连接池呢?"></a>25. 什么是数据库连接池?为什么需要数据库连接池呢?</h2><h3 id="连接池基本原理："><a href="#连接池基本原理：" class="headerlink" title="连接池基本原理："></a>连接池基本原理：</h3><p>数据库连接池原理：在内部对象池中，维护一定数量的数据库连接，并对外暴露数据库连接的获取和返回方法。</p><h3 id="应用程序和数据库建立连接的过程："><a href="#应用程序和数据库建立连接的过程：" class="headerlink" title="应用程序和数据库建立连接的过程："></a>应用程序和数据库建立连接的过程：</h3><ul><li>通过TCP协议的三次握手和数据库服务器建立连接</li><li>发送数据库用户账号密码，等待数据库验证用户身份</li><li>完成身份验证后，系统可以提交SQL语句到数据库执行</li><li>把连接关闭，TCP四次挥手告别。</li></ul><h3 id="数据库连接池好处："><a href="#数据库连接池好处：" class="headerlink" title="数据库连接池好处："></a>数据库连接池好处：</h3><ul><li>资源重用 (连接复用)</li><li>更快的系统响应速度</li><li>新的资源分配手段<br> 统一的连接管理，避免数据库连接泄漏</li></ul><h2 id="26-一条SQL语句在MySQL中如何执行的？"><a href="#26-一条SQL语句在MySQL中如何执行的？" class="headerlink" title="26. 一条SQL语句在MySQL中如何执行的？"></a>26. 一条SQL语句在MySQL中如何执行的？</h2><p>先看一下Mysql的逻辑架构图吧~</p><h3 id="查询语句："><a href="#查询语句：" class="headerlink" title="查询语句："></a>查询语句：</h3><ul><li>先检查该语句是否有权限</li><li>如果没有权限，直接返回错误信息</li><li>如果有权限，在 MySQL8.0 版本以前，会先查询缓存。</li><li>如果没有缓存，分析器进行词法分析，提取 sql 语句select等的关键元素。然后判断sql 语句是否有语法错误，比如关键词是否正确等等。</li><li>优化器进行确定执行方案</li><li>进行权限校验，如果没有权限就直接返回错误信息，如果有权限就会调用数据库引擎接口，返回执行结果。</li></ul><h2 id="27-InnoDB引擎中的索引策略，了解过吗？"><a href="#27-InnoDB引擎中的索引策略，了解过吗？" class="headerlink" title="27. InnoDB引擎中的索引策略，了解过吗？"></a>27. InnoDB引擎中的索引策略，了解过吗？</h2><ul><li>覆盖索引</li><li>最左前缀原则</li><li>索引下推</li><li>索引下推优化是 MySQL 5.6 引入的， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</li></ul><h2 id="28-数据库存储日期格式时，如何考虑时区转换问题？"><a href="#28-数据库存储日期格式时，如何考虑时区转换问题？" class="headerlink" title="28. 数据库存储日期格式时，如何考虑时区转换问题？"></a>28. 数据库存储日期格式时，如何考虑时区转换问题？</h2><ul><li>datetime类型适合用来记录数据的原始的创建时间，修改记录中其他字段的值，datetime字段的值不会改变，除非手动修改它。</li><li>timestamp类型适合用来记录数据的最后修改时间，只要修改了记录中其他字段的值，timestamp字段的值都会被自动更新。</li></ul><h2 id="29-一条sql执行过长的时间，你如何优化，从哪些方面入手？"><a href="#29-一条sql执行过长的时间，你如何优化，从哪些方面入手？" class="headerlink" title="29. 一条sql执行过长的时间，你如何优化，从哪些方面入手？"></a>29. 一条sql执行过长的时间，你如何优化，从哪些方面入手？</h2><ul><li>查看是否涉及多表和子查询，优化Sql结构，如去除冗余字段，是否可拆表等</li><li>优化索引结构，看是否可以适当添加索引</li><li>数量大的表，可以考虑进行分离&#x2F;分表（如交易流水表）</li><li>数据库主从分离，读写分离</li><li>explain分析sql语句，查看执行计划，优化sql</li><li>查看mysql执行日志，分析是否有其他方面的问题</li></ul><h2 id="30-MYSQL数据库服务器性能分析的方法命令有哪些"><a href="#30-MYSQL数据库服务器性能分析的方法命令有哪些" class="headerlink" title="30. MYSQL数据库服务器性能分析的方法命令有哪些?"></a>30. MYSQL数据库服务器性能分析的方法命令有哪些?</h2><ul><li>Show status, 一些值得监控的变量值：</li></ul><blockquote><p>Bytes_received和Bytes_sent 和服务器之间来往的流量。<br> Com_*服务器正在执行的命令。<br> Created_*在查询执行期限间创建的临时表和文件。<br> Handler_*存储引擎操作。<br> Select_*不同类型的联接执行计划。<br> Sort_*几种排序信息。</p></blockquote><ul><li>Show profiles 是MySql用来分析当前会话SQL语句执行的资源消耗情况</li></ul><h2 id="31-Blob和text有什么区别？"><a href="#31-Blob和text有什么区别？" class="headerlink" title="31. Blob和text有什么区别？"></a>31. Blob和text有什么区别？</h2><ul><li>Blob用于存储二进制数据，而Text用于存储大字符串。</li><li>Blob值被视为二进制字符串（字节字符串）,它们没有字符集，并且排序和比较基于列值中的字节的数值。</li><li>text值被视为非二进制字符串（字符字符串）。它们有一个字符集，并根据字符集的排序规则对值进行排序和比较。</li></ul><h2 id="32-mysql里记录货币用什么字段类型比较好？"><a href="#32-mysql里记录货币用什么字段类型比较好？" class="headerlink" title="32.  mysql里记录货币用什么字段类型比较好？"></a>32.  mysql里记录货币用什么字段类型比较好？</h2><ul><li>货币在数据库中MySQL常用Decimal和Numric类型表示，这两种类型被MySQL实现为同样的类型。他们被用于保存与金钱有关的数据。</li><li>salary DECIMAL(9,2)，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。存储在salary列中的值的范围是从-9999999.99到9999999.99。</li><li>DECIMAL和NUMERIC值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。</li></ul><h2 id="33-Mysql中有哪几种锁，列举一下？"><a href="#33-Mysql中有哪几种锁，列举一下？" class="headerlink" title="33.  Mysql中有哪几种锁，列举一下？"></a>33.  Mysql中有哪几种锁，列举一下？</h2><p>如果按锁粒度划分，有以下3种：</p><ul><li>表锁： 开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现死锁。</li><li>行锁： 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。</li><li>页锁： 开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般</li></ul><h2 id="34-Hash索引和B-树区别是什么？你在设计索引是怎么抉择的？"><a href="#34-Hash索引和B-树区别是什么？你在设计索引是怎么抉择的？" class="headerlink" title="34.  Hash索引和B+树区别是什么？你在设计索引是怎么抉择的？"></a>34.  Hash索引和B+树区别是什么？你在设计索引是怎么抉择的？</h2><ul><li>B+树可以进行范围查询，Hash索引不能。</li><li>B+树支持联合索引的最左侧原则，Hash索引不支持。</li><li>B+树支持order by排序，Hash索引不支持。</li><li>Hash索引在等值查询上比B+树效率更高。</li><li>B+树使用like 进行模糊查询的时候，like后面（比如%开头）的话可以起到优化的作用，Hash索引根本无法进行模糊查询。</li></ul><h2 id="35-mysql-的内连接、左连接、右连接有什么区别？"><a href="#35-mysql-的内连接、左连接、右连接有什么区别？" class="headerlink" title="35.  mysql 的内连接、左连接、右连接有什么区别？"></a>35.  mysql 的内连接、左连接、右连接有什么区别？</h2><ul><li>Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集</li><li>left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</li><li>right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</li></ul><h2 id="36-说说MySQL-的基础架构图"><a href="#36-说说MySQL-的基础架构图" class="headerlink" title="36.  说说MySQL 的基础架构图"></a>36.  说说MySQL 的基础架构图</h2><p>Mysql逻辑架构图主要分三层：</p><ul><li>第一层负责连接处理，授权认证，安全等等</li><li>第二层负责编译并优化SQL</li><li>第三层是存储引擎。</li></ul><h2 id="37-什么是内连接、外连接、交叉连接、笛卡尔积呢？"><a href="#37-什么是内连接、外连接、交叉连接、笛卡尔积呢？" class="headerlink" title="37.  什么是内连接、外连接、交叉连接、笛卡尔积呢？"></a>37.  什么是内连接、外连接、交叉连接、笛卡尔积呢？</h2><ul><li>内连接（inner join）：取得两张表中满足存在连接匹配关系的记录。</li><li>外连接（outer join）：取得两张表中满足存在连接匹配关系的记录，以及某张表（或两张表）中不满足匹配关系的记录。</li><li>交叉连接（cross join）：显示两张表所有记录一一对应，没有匹配关系进行筛选，也被称为：笛卡尔积。</li></ul><h2 id="38-说一下数据库的三大范式"><a href="#38-说一下数据库的三大范式" class="headerlink" title="38.  说一下数据库的三大范式"></a>38.  说一下数据库的三大范式</h2><ul><li>第一范式：数据表中的每一列（每个字段）都不可以再拆分。</li><li>第二范式：在第一范式的基础上，分主键列完全依赖于主键，而不能是依赖于主键的一部分。</li><li>第三范式：在满足第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其他非主键。</li></ul><h2 id="39-mysql有关权限的表有哪几个呢？"><a href="#39-mysql有关权限的表有哪几个呢？" class="headerlink" title="39.  mysql有关权限的表有哪几个呢？"></a>39.  mysql有关权限的表有哪几个呢？</h2><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。</p><ul><li>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li><li>db权限表：记录各个帐号在各个数据库上的操作权限。</li><li>table_priv权限表：记录数据表级的操作权限。</li><li>columns_priv权限表：记录数据列级的操作权限。</li><li>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li></ul><h2 id="40-Mysql的binlog有几种录入格式？分别有什么区别？"><a href="#40-Mysql的binlog有几种录入格式？分别有什么区别？" class="headerlink" title="40.  Mysql的binlog有几种录入格式？分别有什么区别？"></a>40.  Mysql的binlog有几种录入格式？分别有什么区别？</h2><p>有三种格式哈，statement，row和mixed。</p><ul><li>statement，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li><li>row，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li><li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li></ul><h2 id="41-InnoDB引擎的4大特性，了解过吗"><a href="#41-InnoDB引擎的4大特性，了解过吗" class="headerlink" title="41.  InnoDB引擎的4大特性，了解过吗"></a>41.  InnoDB引擎的4大特性，了解过吗</h2><ul><li>插入缓冲（insert buffer)</li><li>二次写(double write)</li><li>自适应哈希索引(ahi)</li><li>预读(read ahead)</li></ul><h2 id="42-索引有哪些优缺点？"><a href="#42-索引有哪些优缺点？" class="headerlink" title="42.  索引有哪些优缺点？"></a>42.  索引有哪些优缺点？</h2><p><strong>优点：</strong></p><ul><li>唯一索引可以保证数据库表中每一行的数据的唯一性</li><li>索引可以加快数据查询速度，减少查询时间</li></ul><p><strong>缺点：</strong></p><ul><li>创建索引和维护索引要耗费时间</li><li>索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间</li><li>以表中的数据进行增、删、改的时候，索引也要动态的维护。</li></ul><h2 id="43-索引有哪几种类型？"><a href="#43-索引有哪几种类型？" class="headerlink" title="43.  索引有哪几种类型？"></a>43.  索引有哪几种类型？</h2><ul><li>主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</li><li>唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</li><li>普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。</li><li>全文索引：是目前搜索引擎使用的一种关键技术，对文本的内容进行分词、搜索。</li><li>覆盖索引：查询列要被所建的索引覆盖，不必读取数据行</li><li>组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并</li></ul><h2 id="44-创建索引有什么原则呢？"><a href="#44-创建索引有什么原则呢？" class="headerlink" title="44.  创建索引有什么原则呢？"></a>44.  创建索引有什么原则呢？</h2><ul><li>最左前缀匹配原则</li><li>频繁作为查询条件的字段才去创建索引</li><li>频繁更新的字段不适合创建索引</li><li>索引列不能参与计算，不能有函数操作</li><li>优先考虑扩展索引，而不是新建索引，避免不必要的索引</li><li>在order by或者group by子句中，创建索引需要注意顺序</li><li>区分度低的数据列不适合做索引列(如性别）</li><li>定义有外键的数据列一定要建立索引。</li><li>对于定义为text、image数据类型的列不要建立索引。</li><li>删除不再使用或者很少使用的索引</li></ul><h2 id="45-创建索引的三种方式"><a href="#45-创建索引的三种方式" class="headerlink" title="45.  创建索引的三种方式"></a>45.  创建索引的三种方式</h2><p>在执行CREATE TABLE时创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `employee` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `<span class="type">date</span>` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `sex` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_name` (`name`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>使用ALTER TABLE命令添加索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name (<span class="keyword">column</span>);</span><br></pre></td></tr></table></figure><p>使用CREATE INDEX命令创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name (<span class="keyword">column</span>);</span><br></pre></td></tr></table></figure><h2 id="46-百万级别或以上的数据，你是如何删除的？"><a href="#46-百万级别或以上的数据，你是如何删除的？" class="headerlink" title="46. 百万级别或以上的数据，你是如何删除的？"></a>46. 百万级别或以上的数据，你是如何删除的？</h2><ul><li>我们想要删除百万数据的时候可以先删除索引</li><li>然后批量删除其中无用数据</li><li>删除完成后重新创建索引。</li></ul><h2 id="47-什么是最左前缀原则？什么是最左匹配原则？"><a href="#47-什么是最左前缀原则？什么是最左匹配原则？" class="headerlink" title="47. 什么是最左前缀原则？什么是最左匹配原则？"></a>47. 什么是最左前缀原则？什么是最左匹配原则？</h2><ul><li>最左前缀原则，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li><li>当我们创建一个组合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。</li><li>原理：B+树叶节点的数据是按照字段 k1， k2， k3 的顺序有序排列的，例：<ul><li>k1 &#x3D; 1, k2 &#x3D; 2, k3 &#x3D; 3</li><li>k1 &#x3D; 1, k2 &#x3D; 4, k3 &#x3D; 6</li><li>k1 &#x3D; 11, k2 &#x3D; 3, k3 &#x3D; 1</li><li>k1 &#x3D; 11, k2 &#x3D; 3, k3 &#x3D; 2</li></ul></li><li>因此要想使用联合索引，必须按照顺序才能找到对应的叶节点</li></ul><h2 id="48-B树和B-树的区别，数据库为什么使用B-树而不是B树？"><a href="#48-B树和B-树的区别，数据库为什么使用B-树而不是B树？" class="headerlink" title="48.  B树和B+树的区别，数据库为什么使用B+树而不是B树？"></a>48.  B树和B+树的区别，数据库为什么使用B+树而不是B树？</h2><ul><li><p>在B树中，键和值即存放在内部节点又存放在叶子节点；在B+树中，内部节点只存键，叶子节点则同时存放键和值。</p></li><li><p>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立的。</p></li><li><p>B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。.</p></li><li><p>B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快.</p></li></ul><h2 id="49-覆盖索引、回表等这些，了解过吗？"><a href="#49-覆盖索引、回表等这些，了解过吗？" class="headerlink" title="49.  覆盖索引、回表等这些，了解过吗？"></a>49.  覆盖索引、回表等这些，了解过吗？</h2><ul><li>覆盖索引： 查询列要被所建的索引覆盖，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。</li><li>回表：二级索引无法直接查询所有列的数据，所以通过二级索引查询到聚簇索引后，再查询到想要的数据，这种通过二级索引查询出来的过程，就叫做回表。</li></ul><h2 id="50-B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？"><a href="#50-B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？" class="headerlink" title="50.  B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？"></a>50.  B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？</h2><ul><li>在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</li><li>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</li></ul><h2 id="51-何时使用聚簇索引与非聚簇索引"><a href="#51-何时使用聚簇索引与非聚簇索引" class="headerlink" title="51. 何时使用聚簇索引与非聚簇索引"></a>51. 何时使用聚簇索引与非聚簇索引</h2><table><thead><tr><th>动作描述</th><th>使用聚集索引</th><th>使用非聚集索引</th></tr></thead><tbody><tr><td>列经常被分组排序</td><td>应</td><td>应</td></tr><tr><td>返回某范围内的数据</td><td>应</td><td>不应</td></tr><tr><td>一个或极少不同值</td><td>不应</td><td>不应</td></tr><tr><td>小数目的不同值</td><td>应</td><td>不应</td></tr><tr><td>大数目的不同值</td><td>不应</td><td>应</td></tr><tr><td>频繁更新的列</td><td>不应</td><td>应</td></tr><tr><td>外键列</td><td>应</td><td>应</td></tr><tr><td>主键列</td><td>应</td><td>应</td></tr><tr><td>频繁修改索引列</td><td>不应</td><td>应</td></tr></tbody></table><h2 id="52-非聚簇索引一定会回表查询吗？"><a href="#52-非聚簇索引一定会回表查询吗？" class="headerlink" title="52.  非聚簇索引一定会回表查询吗？"></a>52.  非聚簇索引一定会回表查询吗？</h2><p>不一定，如果查询语句的字段全部命中了索引，那么就不必再进行回表查询（哈哈，覆盖索引就是这么回事）。</p><p>举个简单的例子，假设我们在学生表的上建立了索引，那么当进行<code>select age from student where age &lt; 20</code>的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p><h2 id="53-组合索引是什么？为什么需要注意组合索引中的顺序？"><a href="#53-组合索引是什么？为什么需要注意组合索引中的顺序？" class="headerlink" title="53. 组合索引是什么？为什么需要注意组合索引中的顺序？"></a>53. 组合索引是什么？为什么需要注意组合索引中的顺序？</h2><p>组合索引，用户可以在多个列上建立索引,这种索引叫做组合索引。<br>因为InnoDB引擎中的索引策略的最左原则，所以需要注意组合索引中的顺序。</p><h2 id="54-什么是数据库事务？"><a href="#54-什么是数据库事务？" class="headerlink" title="54.  什么是数据库事务？"></a>54.  什么是数据库事务？</h2><p>数据库事务（简称：事务），是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。</p><h2 id="55-隔离级别与锁的关系"><a href="#55-隔离级别与锁的关系" class="headerlink" title="55.  隔离级别与锁的关系"></a>55.  隔离级别与锁的关系</h2><p>回答这个问题，可以先阐述四种隔离级别，再阐述它们的实现原理。隔离级别就是依赖锁和MVCC实现的。</p><h2 id="56-按照锁的粒度分，数据库锁有哪些呢？锁机制与InnoDB锁算法"><a href="#56-按照锁的粒度分，数据库锁有哪些呢？锁机制与InnoDB锁算法" class="headerlink" title="56. 按照锁的粒度分，数据库锁有哪些呢？锁机制与InnoDB锁算法"></a>56. 按照锁的粒度分，数据库锁有哪些呢？锁机制与InnoDB锁算法</h2><ul><li>按锁粒度分有：表锁，页锁，行锁</li><li>按锁机制分有：乐观锁，悲观锁</li></ul><h2 id="57-从锁的类别角度讲，MySQL都有哪些锁呢？"><a href="#57-从锁的类别角度讲，MySQL都有哪些锁呢？" class="headerlink" title="57.  从锁的类别角度讲，MySQL都有哪些锁呢？"></a>57.  从锁的类别角度讲，MySQL都有哪些锁呢？</h2><p>从锁的类别上来讲，有共享锁和排他锁。</p><ul><li>共享锁: 又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</li><li>排他锁: 又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</li></ul><h2 id="58-MySQL中InnoDB引擎的行锁是怎么实现的？"><a href="#58-MySQL中InnoDB引擎的行锁是怎么实现的？" class="headerlink" title="58. MySQL中InnoDB引擎的行锁是怎么实现的？"></a>58. MySQL中InnoDB引擎的行锁是怎么实现的？</h2><p>基于索引来完成行锁的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">666</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将实行表锁。</p><h2 id="59-什么是死锁？怎么解决？"><a href="#59-什么是死锁？怎么解决？" class="headerlink" title="59.  什么是死锁？怎么解决？"></a>59.  什么是死锁？怎么解决？</h2><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。看图形象一点，如下：</p><p>死锁有四个必要条件：互斥条件，请求和保持条件，环路等待条件，不剥夺条件。<br>解决死锁思路，一般就是切断环路，尽量避免并发形成环路。</p><ul><li>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li><li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li><li>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li><li>如果业务处理不好可以用分布式事务锁或者使用乐观锁</li><li>死锁与索引密不可分，解决索引问题，需要合理优化你的索引，</li></ul><h2 id="60-为什么要使用视图？什么是视图？"><a href="#60-为什么要使用视图？什么是视图？" class="headerlink" title="60.  为什么要使用视图？什么是视图？"></a>60.  为什么要使用视图？什么是视图？</h2><h3 id="为什么要使用视图？"><a href="#为什么要使用视图？" class="headerlink" title="为什么要使用视图？"></a>为什么要使用视图？</h3><p>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。</p><h3 id="什么是视图？"><a href="#什么是视图？" class="headerlink" title="什么是视图？"></a>什么是视图？</h3><p>视图是一个虚拟的表，是一个表中的数据经过某种筛选后的显示方式，视图由一个预定义的查询select语句组成。</p><h2 id="61-视图有哪些特点？哪些使用场景？"><a href="#61-视图有哪些特点？哪些使用场景？" class="headerlink" title="61.  视图有哪些特点？哪些使用场景？"></a>61.  视图有哪些特点？哪些使用场景？</h2><h3 id="视图特点："><a href="#视图特点：" class="headerlink" title="视图特点："></a>视图特点：</h3><ul><li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li><li>视图是由基本表(实表)产生的表(虚表)。</li><li>视图的建立和删除不影响基本表。</li><li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li><li>当视图来自多个基本表时，不允许添加和删除数据。</li></ul><p><strong>视图用途：</strong> 简化sql查询，提高开发效率，兼容老的表结构。</p><h3 id="视图的常见使用场景："><a href="#视图的常见使用场景：" class="headerlink" title="视图的常见使用场景："></a>视图的常见使用场景：</h3><ul><li>重用SQL语句；</li><li>简化复杂的SQL操作。</li><li>使用表的组成部分而不是整个表；</li><li>保护数据</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ul><h2 id="62-视图的优点，缺点，讲一下？"><a href="#62-视图的优点，缺点，讲一下？" class="headerlink" title="62.  视图的优点，缺点，讲一下？"></a>62.  视图的优点，缺点，讲一下？</h2><ul><li>查询简单化。视图能简化用户的操作</li><li>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li><li>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li></ul><h2 id="63-count-1-、count-与-count-列名-的区别？"><a href="#63-count-1-、count-与-count-列名-的区别？" class="headerlink" title="63.  count(1)、count(*) 与 count(列名) 的区别？"></a>63.  count(1)、count(*) 与 count(列名) 的区别？</h2><ul><li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li><li>count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL</li><li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li></ul><h2 id="64-什么是游标？"><a href="#64-什么是游标？" class="headerlink" title="64.  什么是游标？"></a>64.  什么是游标？</h2><p>游标提供了一种对从表中检索出的数据进行操作的灵活手段，就本质而言，游标实际上是一种能从包括多条数据记录的结果集中每次提取一条记录的机制。</p><h2 id="65-什么是存储过程？有哪些优缺点？"><a href="#65-什么是存储过程？有哪些优缺点？" class="headerlink" title="65.  什么是存储过程？有哪些优缺点？"></a>65.  什么是存储过程？有哪些优缺点？</h2><p>存储过程，就是一些编译好了的SQL语句，这些SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后给这些代码块取一个名字，在用到这个功能的时候调用即可。</p><p><strong>优点：</strong></p><ul><li>存储过程是一个预编译的代码块，执行效率比较高</li><li>存储过程在服务器端运行，减少客户端的压力</li><li>允许模块化程序设计，只需要创建一次过程，以后在程序中就可以调用该过程任意次，类似方法的复用</li></ul><p>-一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率</p><ul><li>可以一定程度上确保数据安全</li></ul><p><strong>缺点：</strong></p><ul><li>调试麻烦</li><li>可移植性不灵活</li><li>重新编译问题</li></ul><h2 id="66-什么是触发器？触发器的使用场景有哪些？"><a href="#66-什么是触发器？触发器的使用场景有哪些？" class="headerlink" title="66.  什么是触发器？触发器的使用场景有哪些？"></a>66.  什么是触发器？触发器的使用场景有哪些？</h2><p>触发器，指一段代码，当触发某个事件时，自动执行这些代码。</p><p><strong>使用场景：</strong></p><ul><li>可以通过数据库中的相关表实现级联更改。</li><li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li><li>例如可以生成某些业务的编号。</li><li>注意不要滥用，否则会造成数据库及应用程序的维护困难。</li></ul><h2 id="67-MySQL中都有哪些触发器？"><a href="#67-MySQL中都有哪些触发器？" class="headerlink" title="67.   MySQL中都有哪些触发器？"></a>67.   MySQL中都有哪些触发器？</h2><p>MySQL 数据库中有六种触发器：</p><ul><li>Before Insert</li><li>After Insert</li><li>Before Update</li><li>After Update</li><li>Before Delete</li><li>After Delete</li></ul><h2 id="68-超键、候选键、主键、外键分别是什么？"><a href="#68-超键、候选键、主键、外键分别是什么？" class="headerlink" title="68.   超键、候选键、主键、外键分别是什么？"></a>68.   超键、候选键、主键、外键分别是什么？</h2><ul><li>超键：在关系模式中，能唯一知标识元组的属性集称为超键。</li><li>候选键：是最小超键，即没有冗余元素的超键。</li><li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li><li>外键：在一个表中存在的另一个表的主键称此表的外键。。</li></ul><h2 id="69-SQL-约束有哪几种呢？"><a href="#69-SQL-约束有哪几种呢？" class="headerlink" title="69.   SQL 约束有哪几种呢？"></a>69.   SQL 约束有哪几种呢？</h2><ul><li>NOT NULL: 约束字段的内容一定不能为NULL。</li><li>UNIQUE: 约束字段唯一性，一个表允许有多个 Unique 约束。</li><li>PRIMARY KEY: 约束字段唯一，不可重复，一个表只允许存在一个。</li><li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键。</li><li>CHECK: 用于控制字段的值范围。</li></ul><h2 id="70-谈谈六种关联查询，使用场景。"><a href="#70-谈谈六种关联查询，使用场景。" class="headerlink" title="70.   谈谈六种关联查询，使用场景。"></a>70.   谈谈六种关联查询，使用场景。</h2><ul><li>交叉连接</li><li>内连接</li><li>外连接</li><li>联合查询</li><li>全连接</li><li>交叉连接</li></ul><h2 id="71-varchar-50-中50的涵义"><a href="#71-varchar-50-中50的涵义" class="headerlink" title="71.  varchar(50)中50的涵义"></a>71.  varchar(50)中50的涵义</h2><p>字段最多存放 50 个字符<br>如 varchar(50) 和 varchar(200) 存储 “jay” 字符串所占空间是一样的，后者在排序时会消耗更多内存</p><h2 id="72-mysql中int-20-和char-20-以及varchar-20-的区别"><a href="#72-mysql中int-20-和char-20-以及varchar-20-的区别" class="headerlink" title="72.   mysql中int(20)和char(20)以及varchar(20)的区别"></a>72.   mysql中int(20)和char(20)以及varchar(20)的区别</h2><ul><li>int(20) 表示字段是int类型，显示长度是 20</li><li>char(20)表示字段是固定长度字符串，长度为 20</li><li>varchar(20) 表示字段是可变长度字符串，长度为 20</li></ul><h2 id="73-drop、delete与truncate的区别"><a href="#73-drop、delete与truncate的区别" class="headerlink" title="73.   drop、delete与truncate的区别"></a>73.   drop、delete与truncate的区别</h2><table><thead><tr><th></th><th>delete</th><th>truncate</th><th>drop</th></tr></thead><tbody><tr><td>类型</td><td>DML</td><td>DDL</td><td>DDL</td></tr><tr><td>回滚</td><td>可回滚</td><td>不可回滚</td><td>不可回滚</td></tr><tr><td>删除内容</td><td>表结构还在，删除表的全部或者一部分数据行</td><td>表结构还在，删除表中的所有数据</td><td>从数据库中删除表，所有的数据行，索引和权限也会被删除</td></tr><tr><td>删除速度</td><td>删除速度慢，逐行删除</td><td>删除速度快</td><td>删除速度最快</td></tr></tbody></table><h2 id="74-UNION与UNION-ALL的区别？"><a href="#74-UNION与UNION-ALL的区别？" class="headerlink" title="74.   UNION与UNION ALL的区别？"></a>74.   UNION与UNION ALL的区别？</h2><ul><li>Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；</li><li>Union All：对两个结果集进行并集操作，包括重复行，不进行排序；</li><li>UNION的效率高于 UNION ALL</li></ul><h2 id="75-SQL的生命周期？"><a href="#75-SQL的生命周期？" class="headerlink" title="75.  SQL的生命周期？"></a>75.  SQL的生命周期？</h2><ul><li>服务器与数据库建立连接</li><li>数据库进程拿到请求sql</li><li>解析并生成执行计划，执行</li><li>读取数据到内存，并进行逻辑处理</li><li>通过步骤一的连接，发送结果到客户端</li><li>关掉连接，释放资源</li></ul><h2 id="76-一条Sql的执行顺序？"><a href="#76-一条Sql的执行顺序？" class="headerlink" title="76.  一条Sql的执行顺序？"></a>76.  一条Sql的执行顺序？</h2><h2 id="77-列值为NULL时，查询是否会用到索引？"><a href="#77-列值为NULL时，查询是否会用到索引？" class="headerlink" title="77.  列值为NULL时，查询是否会用到索引？"></a>77.  列值为NULL时，查询是否会用到索引？</h2><p>列值为NULL也是可以走索引的<br>计划对列进行索引，应尽量避免把它设置为可空，因为这会让 MySQL 难以优化引用了可空列的查询，同时增加了引擎的复杂度</p><h2 id="78-关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"><a href="#78-关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？" class="headerlink" title="78.   关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"></a>78.   关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h2><ul><li>我们平时写Sql时，都要养成用explain分析的习惯。</li><li>慢查询的统计，运维会定期统计给我们</li></ul><p><strong>优化慢查询：</strong></p><ul><li>分析语句，是否加载了不必要的字段&#x2F;数据。</li><li>分析SQl执行句话，是否命中索引等。</li><li>如果SQL很复杂，优化SQL结构</li><li>如果表数据量太大，考虑分表</li></ul><h2 id="79-主键使用自增ID还是UUID，为什么？"><a href="#79-主键使用自增ID还是UUID，为什么？" class="headerlink" title="79.  主键使用自增ID还是UUID，为什么？"></a>79.  主键使用自增ID还是UUID，为什么？</h2><p>如果是单机的话，选择自增ID；如果是分布式系统，优先考虑UUID吧，但还是最好自己公司有一套分布式唯一ID生产方案吧。</p><ul><li>自增ID：数据存储空间小，查询效率高。但是如果数据量过大,会超出自增长的值范围，多库合并，也有可能有问题。</li><li>uuid：适合大量数据的插入和更新操作，但是它无序的，插入数据效率慢，占用空间大。</li></ul><h2 id="80-mysql自增主键用完了怎么办？"><a href="#80-mysql自增主键用完了怎么办？" class="headerlink" title="80. mysql自增主键用完了怎么办？"></a>80. mysql自增主键用完了怎么办？</h2><p>自增主键一般用int类型，一般达不到最大值，可以考虑提前分库分表的。</p><p>自增ID用完后 一直都是最大值 如果标识了主键 则主键冲突</p><h2 id="81-字段为什么要求定义为not-null？"><a href="#81-字段为什么要求定义为not-null？" class="headerlink" title="81. 字段为什么要求定义为not null？"></a>81. 字段为什么要求定义为not null？</h2><p>null值会占用更多的字节，并且null有很多坑的。</p><h2 id="82-如果要存储用户的密码散列，应该使用什么字段进行存储？"><a href="#82-如果要存储用户的密码散列，应该使用什么字段进行存储？" class="headerlink" title="82.  如果要存储用户的密码散列，应该使用什么字段进行存储？"></a>82.  如果要存储用户的密码散列，应该使用什么字段进行存储？</h2><p>密码散列，盐，用户身份证号等固定长度的字符串，应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</p><h2 id="83-Mysql驱动程序是什么？"><a href="#83-Mysql驱动程序是什么？" class="headerlink" title="83. Mysql驱动程序是什么？"></a>83. Mysql驱动程序是什么？</h2><p>这个jar包： mysql-connector-java-5.1.18.jar<br>Mysql驱动程序主要帮助编程语言与 MySQL服务端进行通信，如连接、传输数据、关闭等。</p><h2 id="84-如何优化长难的查询语句？有实战过吗？"><a href="#84-如何优化长难的查询语句？有实战过吗？" class="headerlink" title="84.   如何优化长难的查询语句？有实战过吗？"></a>84.   如何优化长难的查询语句？有实战过吗？</h2><ul><li>将一个大的查询分为多个小的相同的查询</li><li>减少冗余记录的查询。</li><li>一个复杂查询可以考虑拆成多个简单查询</li><li>分解关联查询，让缓存的效率更高。</li></ul><h2 id="85-优化特定类型的查询语句"><a href="#85-优化特定类型的查询语句" class="headerlink" title="85.  优化特定类型的查询语句"></a>85.  优化特定类型的查询语句</h2><p>平时积累吧：</p><ul><li>比如使用select 具体字段代替 select *</li><li>使用count(*) 而不是count(列名)</li><li>在不影响业务的情况，使用缓存</li><li>explain 分析你的SQL</li></ul><h2 id="86-MySQL数据库cpu飙升的话，要怎么处理呢？"><a href="#86-MySQL数据库cpu飙升的话，要怎么处理呢？" class="headerlink" title="86. MySQL数据库cpu飙升的话，要怎么处理呢？"></a>86. MySQL数据库cpu飙升的话，要怎么处理呢？</h2><p><strong>排查过程：</strong></p><ul><li>使用top 命令观察，确定是mysqld导致还是其他原因。</li><li>如果是mysqld导致的，show processlist，查看session情况，确定是不是有消耗资源的sql在运行。</li><li>找出消耗高的 sql，看看执行计划是否准确， 索引是否缺失，数据量是否太大。</li></ul><p><strong>处理：</strong></p><ul><li>kill 掉这些线程(同时观察 cpu 使用率是否下降)，</li><li>进行相应的调整(比如说加索引、改 sql、改内存参数)</li><li>重新跑这些 SQL。</li></ul><p><strong>其他情况：</strong></p><p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</p><h2 id="87-读写分离常见方案？"><a href="#87-读写分离常见方案？" class="headerlink" title="87.   读写分离常见方案？"></a>87.   读写分离常见方案？</h2><ul><li>应用程序根据业务逻辑来判断，增删改等写操作命令发给主库，查询命令发给备库。</li><li>利用中间件来做代理，负责对数据库的请求识别出读还是写，并分发到不同的数据库中。（如：amoeba，mysql-proxy）</li></ul><h2 id="88-MySQL的复制原理以及流程"><a href="#88-MySQL的复制原理以及流程" class="headerlink" title="88. MySQL的复制原理以及流程"></a>88. MySQL的复制原理以及流程</h2><p>主从复制原理，简言之，就三步曲，如下：</p><ul><li>主数据库有个bin-log二进制文件，纪录了所有增删改Sql语句。（binlog线程）</li><li>从数据库把主数据库的bin-log文件的sql语句复制过来。（io线程）</li><li>从数据库的relay-log重做日志文件中再执行一次这些sql语句。（Sql执行线程）</li></ul><p>主从复制分了五个步骤进行：</p><ul><li>步骤一：主库的更新事件(update、insert、delete)被写到binlog</li><li>步骤二：从库发起连接，连接到主库。</li><li>步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库。</li><li>步骤四：从库启动之后，创建一个I&#x2F;O线程，读取主库传过来的binlog内容并写入到relay log</li><li>步骤五：还会创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db</li></ul><h2 id="89-MySQL中DATETIME和TIMESTAMP的区别"><a href="#89-MySQL中DATETIME和TIMESTAMP的区别" class="headerlink" title="89.  MySQL中DATETIME和TIMESTAMP的区别"></a>89.  MySQL中DATETIME和TIMESTAMP的区别</h2><p>存储精度都为秒</p><p><strong>区别：</strong></p><ul><li>DATETIME 的日期范围是 1001——9999 年；TIMESTAMP 的时间范围是 1970——2038 年</li><li>DATETIME 存储时间与时区无关；TIMESTAMP 存储时间与时区有关，显示的值也依赖于时区</li><li>DATETIME 的存储空间为 8 字节；TIMESTAMP 的存储空间为 4 字节</li><li>DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空(not null)，默认值为当前时间(CURRENT_TIMESTAMP)</li></ul><h2 id="90-Innodb的事务实现原理？"><a href="#90-Innodb的事务实现原理？" class="headerlink" title="90.   Innodb的事务实现原理？"></a>90.   Innodb的事务实现原理？</h2><ul><li>原子性：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。</li><li>持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。</li><li>隔离性：通过锁以及MVCC,使事务相互隔离开。</li><li>一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。</li></ul><h2 id="91-谈谈MySQL的Explain"><a href="#91-谈谈MySQL的Explain" class="headerlink" title="91. 谈谈MySQL的Explain"></a>91. 谈谈MySQL的Explain</h2><p>Explain 执行计划包含字段信息如下：分别是 id、select_type、table、partitions、type、possible_keys、key、key_len、ref、rows、filtered、Extra 等12个字段。<br>我们重点关注的是type，它的属性排序如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">system</span>  <span class="operator">&gt;</span> const <span class="operator">&gt;</span> eq_ref <span class="operator">&gt;</span> <span class="keyword">ref</span>  <span class="operator">&gt;</span> ref_or_null <span class="operator">&gt;</span></span><br><span class="line">index_merge <span class="operator">&gt;</span> unique_subquery <span class="operator">&gt;</span> index_subquery <span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">range</span> <span class="operator">&gt;</span> index <span class="operator">&gt;</span> <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure><h2 id="92-Innodb的事务与日志的实现方式"><a href="#92-Innodb的事务与日志的实现方式" class="headerlink" title="92. Innodb的事务与日志的实现方式"></a>92. Innodb的事务与日志的实现方式</h2><h3 id="有多少种日志"><a href="#有多少种日志" class="headerlink" title="有多少种日志"></a>有多少种日志</h3><ul><li>innodb两种日志redo和undo。</li></ul><h3 id="日志的存放形式"><a href="#日志的存放形式" class="headerlink" title="日志的存放形式"></a>日志的存放形式</h3><ul><li>redo：在页修改的时候，先写到 redo log buffer 里面， 然后写到 redo log 的文件系统缓存里面(fwrite)，然后再同步到磁盘文件（ fsync）。</li><li>Undo：在 MySQL5.5 之前， undo 只能存放在 ibdata文件里面， 5.6 之后，可以通过设置 innodb_undo_tablespaces 参数把 undo log 存放在 ibdata之外。</li></ul><h3 id="事务是如何通过日志来实现的"><a href="#事务是如何通过日志来实现的" class="headerlink" title="事务是如何通过日志来实现的"></a>事务是如何通过日志来实现的</h3><ul><li>因为事务在修改页时，要先记 undo，在记 undo 之前要记 undo 的 redo， 然后修改数据页，再记数据页修改的 redo。 Redo（里面包括 undo 的修改） 一定要比数据页先持久化到磁盘。</li><li>当事务需要回滚时，因为有 undo，可以把数据页回滚到前镜像的 状态，崩溃恢复时，如果 redo log 中事务没有对应的 commit 记录，那么需要用 undo把该事务的修改回滚到事务开始之前。</li><li>如果有 commit 记录，就用 redo 前滚到该事务完成时并提交掉。</li></ul><h2 id="93-MySQL中TEXT数据类型的最大长度"><a href="#93-MySQL中TEXT数据类型的最大长度" class="headerlink" title="93.  MySQL中TEXT数据类型的最大长度"></a>93.  MySQL中TEXT数据类型的最大长度</h2><ul><li>TINYTEXT：256 bytes</li><li>TEXT：65,535 bytes(64kb)</li><li>MEDIUMTEXT：16,777,215 bytes(16MB)</li><li>LONGTEXT：4,294,967,295 bytes(4GB)</li></ul><h2 id="94-500台db，在最快时间之内重启。"><a href="#94-500台db，在最快时间之内重启。" class="headerlink" title="94.  500台db，在最快时间之内重启。"></a>94.  500台db，在最快时间之内重启。</h2><ul><li>可以使用批量 ssh 工具 pssh 来对需要重启的机器执行重启命令。</li><li>也可以使用 salt（前提是客户端有安装 salt）或者 ansible（ ansible 只需要 ssh 免登通了就行）等多线程工具同时操作多台服务</li></ul><h2 id="95-你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？"><a href="#95-你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？" class="headerlink" title="95. 你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？"></a>95. 你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？</h2><p>监控的工具有很多，例如zabbix，lepus，我这里用的是lepus</p><h2 id="96-你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"><a href="#96-你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？" class="headerlink" title="96. 你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"></a>96. 你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？</h2><p>主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等</p><h2 id="97-你们数据库是否支持emoji表情存储，如果不支持，如何操作？"><a href="#97-你们数据库是否支持emoji表情存储，如果不支持，如何操作？" class="headerlink" title="97. 你们数据库是否支持emoji表情存储，如果不支持，如何操作？"></a>97. 你们数据库是否支持emoji表情存储，如果不支持，如何操作？</h2><p>更换字符集utf8–&gt;utf8mb4</p><h2 id="98-MySQL如何获取当前日期？"><a href="#98-MySQL如何获取当前日期？" class="headerlink" title="98.  MySQL如何获取当前日期？"></a>98.  MySQL如何获取当前日期？</h2><p>SELECT CURRENT_DATE();</p><h2 id="99-一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。"><a href="#99-一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。" class="headerlink" title="99. 一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。"></a>99. 一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。</h2><p>1、如果A表TID是自增长,并且是连续的,B表的ID为索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a,b <span class="keyword">where</span> a.tid <span class="operator">=</span> b.id <span class="keyword">and</span> a.tid<span class="operator">&gt;</span><span class="number">500000</span> limit <span class="number">200</span>;</span><br></pre></td></tr></table></figure><p>2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> b , (<span class="keyword">select</span> tid <span class="keyword">from</span> a limit <span class="number">50000</span>,<span class="number">200</span>) a <span class="keyword">where</span> b.id <span class="operator">=</span> a .tid;</span><br></pre></td></tr></table></figure><h2 id="100-Mysql一条SQL加锁分析"><a href="#100-Mysql一条SQL加锁分析" class="headerlink" title="100. Mysql一条SQL加锁分析"></a>100. Mysql一条SQL加锁分析</h2><p>一条SQL加锁，可以分9种情况进行：</p><ul><li>组合一：id列是主键，RC隔离级别</li><li>组合二：id列是二级唯一索引，RC隔离级别</li><li>组合三：id列是二级非唯一索引，RC隔离级别</li><li>组合四：id列上没有索引，RC隔离级别</li><li>组合五：id列是主键，RR隔离级别</li><li>组合六：id列是二级唯一索引，RR隔离级别</li><li>组合七：id列是二级非唯一索引，RR隔离级别</li><li>组合八：id列上没有索引，RR隔离级别</li><li>组合九：Serializable隔离级别</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 面试100题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 面试 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 面试必备 X 题</title>
      <link href="/interview/redis-interview/"/>
      <url>/interview/redis-interview/</url>
      
        <content type="html"><![CDATA[<h2 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><h3 id="1-分布式系统中常用的缓存方案有哪些？"><a href="#1-分布式系统中常用的缓存方案有哪些？" class="headerlink" title="1. 分布式系统中常用的缓存方案有哪些？"></a>1. 分布式系统中常用的缓存方案有哪些？</h3><ul><li>客户端缓存：页面和浏览器缓存，app 缓存，h5 缓存，localStorage，sessionStorage</li><li>CDN：内容存储&#x3D;数据存储，内容分发&#x3D;负载均衡</li><li>Nginx 缓存： 静态资源</li><li>服务端缓存：本地缓存，外部缓存</li><li>数据库缓存：持久缓存（mybatis，hibernate 多级缓存），mysql 查询缓存</li><li>操作系统缓存：page cache，buffer cache</li></ul><h3 id="2-常见的缓存淘汰算法"><a href="#2-常见的缓存淘汰算法" class="headerlink" title="2. 常见的缓存淘汰算法"></a>2. 常见的缓存淘汰算法</h3><ul><li>FIFO - 先进先出</li><li>LRU - 最近最少使用</li><li>LFU - 最不经常使用</li></ul><h3 id="3-Redis-如何配置-Key-的过期时间？他的实现原理是什么？"><a href="#3-Redis-如何配置-Key-的过期时间？他的实现原理是什么？" class="headerlink" title="3. Redis 如何配置 Key 的过期时间？他的实现原理是什么？"></a>3. Redis 如何配置 Key 的过期时间？他的实现原理是什么？</h3><ul><li>Expire or SETNX</li><li>原理：<ul><li>定期删除：每隔一段时间，执行一次删除过期 Key 的操作（批量脚本）</li><li>懒汉式删除：每当使用 get，getset 等指令去获取数据时，判断 key 是否过期，过期的话就先删除再操作</li><li>redis 同时使用两者，平衡执行频率和执行时长</li></ul></li></ul><h3 id="4-Redis-线程模型，单线程为什么快？"><a href="#4-Redis-线程模型，单线程为什么快？" class="headerlink" title="4. Redis 线程模型，单线程为什么快？"></a>4. Redis 线程模型，单线程为什么快？</h3><ul><li>基于 Reactor 开发了网络时间处理器 - 文件事件处理器，采用 IO 多路复用监听多个 Socket</li><li>纯内存操作、核心基于非阻塞的 IO 多路复用机制、单线程避免了多线程反复上下文切换的性能问题</li></ul><h3 id="5-redis-的常见结构及应用场景"><a href="#5-redis-的常见结构及应用场景" class="headerlink" title="5. redis 的常见结构及应用场景"></a>5. redis 的常见结构及应用场景</h3><ul><li>string<ul><li>id&#x2F;id_info 缓存  </li><li>计数器  </li><li>setnx 分布式锁 <ul><li>setnx 的时候会传入一个随机值</li><li>解锁：‘if redis.call(‘get’, KEYS[1]) &#x3D;&#x3D; ARGV[1] then return redis.call(‘del’, KEYS[1]) else return 0 end’</li><li>lua脚本</li></ul></li><li>分布式ID </li><li>sds（动态简单字符串）<ul><li>读取时间复杂度为 O(1)</li><li>惰性删除，留待下次使用</li><li>一次分配最大为 128kb</li></ul></li><li></li></ul></li><li>list<ul><li>当队列用，最近100个购买用户信息  </li><li>当栈用  </li><li>非实时分页列表，比如小时榜，日榜，周榜</li><li>存储微博、微信公众号等消息流数据</li><li>等于链表，插入删除 O(1)，查找 O(n)</li></ul></li><li>hash<ul><li>相比string获取单个字段节省 序列化与反序列化操作</li><li>相当于 HashMap ，由数组加链表组合而成，当一维的 hash 数组碰撞时，用链表串起来</li></ul></li><li>set<ul><li>取交、并、差集  </li><li>点赞、收藏、关注等…  </li><li>kv 模式</li></ul></li><li>sorted set<ul><li>排行榜功能，实时分页列表，实时榜单等</li><li>set 基础上增加了分数</li><li>结构上是由一个 dict 和一个跳表组成，dict 保证 key 唯一性</li><li>插入删除都是 O(log n)，查找 O(logn)</li><li>一大优点是可以对分数进行范围查找</li><li>少量数据按照 ziplist 存储，大量数据按照跳表存储</li></ul></li></ul><h4 id="redis-大key-问题是什么？怎么查出来？一般怎么解决？"><a href="#redis-大key-问题是什么？怎么查出来？一般怎么解决？" class="headerlink" title="redis 大key 问题是什么？怎么查出来？一般怎么解决？"></a>redis 大key 问题是什么？怎么查出来？一般怎么解决？</h4><p>大key问题呢是说 redis 的 kv 存储中，value值过大，一般超过10kb，我们就会认为这是一个大 key 了。<br>有执行命令，但是没有专门准备这个内容<br>大 key 的危害主要是：在redis内存中分布不均；操作耗时；取结果的数据量大，容易造成网络io堵塞<br>解决方式呢：可以逻辑上对于大 key 的 value 进行拆分和重组。其中 string 类型的大 key 一般不建议存到redis。另外的可以采用 hash 将大 key 拆分</p><h3 id="6-redis-集群方案"><a href="#6-redis-集群方案" class="headerlink" title="6. redis 集群方案"></a>6. redis 集群方案</h3><ul><li>主从模式</li><li>哨兵模式<ul><li>概念<ul><li>集群监控：监控主从是否正常</li><li>消息通知：故障通知</li><li>故障转移：主挂了，移到从身上</li><li>配置中心：通知 client 新的 master 地址</li></ul></li><li>本身也是分布式的，具体方案：<ul><li>通常3个哨兵实例来保证健壮性</li><li>即使哨兵自己挂了，还是可以正常工作</li><li>不保证数据领丢失，可以说主从结构就不保证</li><li>判断故障需要用<code>分布式选举</code>获得大部分哨兵统一才行</li></ul></li></ul></li><li>Redis cluster：服务端 Sharding 计数。采用槽的概念，一共16384个槽，请求发送至任意节点<ul><li>方案说明<ul><li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽（哈希值）区间的数据</li><li>每份数据分片会存储在多个互为主从的多节点上</li><li>数据先写入主节点，再<code>阻塞</code>同步至从节点</li><li>同一分片之间不保证强一致性</li><li>扩容时需要把旧节点数据也迁移一部分至新节点</li></ul></li><li>gossip 协议，多主多从</li></ul></li></ul><ul><li>sorted set  <ul><li>实时分页列表，如实时榜单</li></ul></li></ul><ul><li>一般就是当缓存用</li><li>单线程模型</li><li>目的是服务无状态：session，token等；分布式锁</li><li>无锁化？</li></ul><h3 id="2-单线程还是多线程？"><a href="#2-单线程还是多线程？" class="headerlink" title="2. 单线程还是多线程？"></a>2. 单线程还是多线程？</h3><ul><li>工作线程都是单线程：<ul><li>操作是原子的单指令 pipeline</li><li>事务 vs pipeline ：事务执行期间是原子的；执行失败就是失败，其他指令继续执行，没有回滚 –&gt; redis 少使用事务 &amp;&amp; 事务内的指令少 + 快</li></ul></li><li>6.x+版本出现了 io 多线程</li></ul><hr><ul><li>详细理解 io 多线程 ：内核，网络通信（懂了再说）</li><li>单线程，满足 redis 的串行原子；io 多线程以后，把输入&#x2F;输出放到线程中并行，好处是：执行时间快；更好的压榨系统及硬件的资源</li></ul><h3 id="3-redis-存在线程安全的问题么？为什么？"><a href="#3-redis-存在线程安全的问题么？为什么？" class="headerlink" title="3. redis 存在线程安全的问题么？为什么？"></a>3. redis 存在线程安全的问题么？为什么？</h3><ul><li>参考问题2，redis核心是单线程串行，业务使用的时候需要自行保障线程安全</li></ul><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><h3 id="6-缓存如何淘汰的？"><a href="#6-缓存如何淘汰的？" class="headerlink" title="6. 缓存如何淘汰的？"></a>6. 缓存如何淘汰的？</h3><p>内存空间不足<br>淘汰机制<br>lru，lfu，random，ttl<br>全空间<br>设置了过期时间的key的集合中</p><h3 id="7-如何进行缓存预热？"><a href="#7-如何进行缓存预热？" class="headerlink" title="7. 如何进行缓存预热？"></a>7. 如何进行缓存预热？</h3><p>提前加载数据（很难判断哪些是真正的热数据，常常会出现缓存失败的情况）<br>开发逻辑上要应对差集数据造成的 击穿，穿透，雪崩</p><h3 id="8-数据库和缓存不一致如何解决？"><a href="#8-数据库和缓存不一致如何解决？" class="headerlink" title="8. 数据库和缓存不一致如何解决？"></a>8. 数据库和缓存不一致如何解决？</h3><p>恶心点的使用事务，但是意义不大，场景多为读多写极少，仅仅在秀肌肉<br>业务写db，然后redis更新缓存<br>业务写到消息队列中，redis和db同时消费数据，同时更新<br>redis缓存，更倾向于允许稍微的时差<br>总思路是减少db操作</p><h3 id="9-redis-主从不一致如何解决？"><a href="#9-redis-主从不一致如何解决？" class="headerlink" title="9. redis 主从不一致如何解决？"></a>9. redis 主从不一致如何解决？</h3><p>redis 默认弱一致性，主从异步同步<br>分布式锁不能用主从，可以用单实例、分片集群、redlock –&gt; redisson<br>配置中可以配置同步因子，总趋向于强一致性</p><h3 id="10-redis-持久化原理"><a href="#10-redis-持久化原理" class="headerlink" title="10. redis 持久化原理"></a>10. redis 持久化原理</h3><p>当前线程阻塞服务<br>后台异步进程完成持久化</p><h3 id="11-并发超量，redis-崩溃后如何处理？"><a href="#11-并发超量，redis-崩溃后如何处理？" class="headerlink" title="11. 并发超量，redis 崩溃后如何处理？"></a>11. 并发超量，redis 崩溃后如何处理？</h3><p>雪崩击穿穿透处理方案</p><h3 id="12-为啥使用setnx"><a href="#12-为啥使用setnx" class="headerlink" title="12. 为啥使用setnx"></a>12. 为啥使用setnx</h3><p>原子，不存在即创建<br>分布式锁，用 set k v nx ex 不存在，过期时间，避免死锁</p><p>设计短链<br>base64加密解密。<br>热url，满了怎么办？对内部？对外部？双方隔离？布隆判存在性？</p><p>qps 十几万？保证库存?<br>分布式事务。看看科科的写法</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 面试 </tag>
            
            <tag> nosql </tag>
            
            <tag> redis </tag>
            
            <tag> 哨兵 </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> raft </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang Context 详解</title>
      <link href="/library/Golang/concurrency/go-context/"/>
      <url>/library/Golang/concurrency/go-context/</url>
      
        <content type="html"><![CDATA[<h3 id="go-并发控制"><a href="#go-并发控制" class="headerlink" title="go 并发控制"></a>go 并发控制</h3><p>实际生产中，WaitGroup 和 Channel 是常见的 2 种并发控制的方式。<br>如果有一系列任务，需要这些任务全部完成以后才能继续执行，WaitGroup 非常适合于这类场景，例如下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doTask</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">  time.Sleep(time.Duration(n))  </span><br><span class="line">  fmt.Printf(<span class="string">&quot;Task %d Done\n&quot;</span>, n)  </span><br><span class="line">  wg.Done()  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;  </span><br><span class="line">    wg.Add(<span class="number">1</span>)  </span><br><span class="line">    <span class="keyword">go</span> doTask(i + <span class="number">1</span>)  </span><br><span class="line">  &#125;  </span><br><span class="line">  wg.Wait()  </span><br><span class="line">  fmt.Println(<span class="string">&quot;All Task Done&quot;</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Task 3 Done  </span></span><br><span class="line"><span class="comment">// Task 1 Done  </span></span><br><span class="line"><span class="comment">// Task 2 Done  </span></span><br><span class="line"><span class="comment">// All Task Done  </span></span><br></pre></td></tr></table></figure><p><code>wg.Wait()</code> 会等待所有的子任务全部完成，所有子协程结束后，才会执行 <code>wg.Wait()</code> 后面的代码。<br>WaitGroup 只能等待子任务全部完成才能执行下一步，那么如果我们想要在主进程中通知子协程退出呢？这种场景下，可以使用 <code>select + chan</code> 机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stop <span class="keyword">chan</span> <span class="type">bool</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reqTask</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;  </span><br><span class="line">  <span class="keyword">for</span> &#123;  </span><br><span class="line">    <span class="keyword">select</span> &#123;  </span><br><span class="line">      <span class="keyword">case</span> &lt;-stop:  </span><br><span class="line">      fmt.Println(<span class="string">&quot;stop&quot;</span>, name)  </span><br><span class="line">      <span class="keyword">return</span>  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">      fmt.Println(name, <span class="string">&quot;send request&quot;</span>)  </span><br><span class="line">      time.Sleep(<span class="number">1</span> * time.Second)  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  stop = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)  </span><br><span class="line">  <span class="keyword">go</span> reqTask(<span class="string">&quot;worker&quot;</span>)  </span><br><span class="line">  time.Sleep(<span class="number">3</span> * time.Second)  </span><br><span class="line">  stop &lt;- <span class="literal">true</span>  </span><br><span class="line">  time.Sleep(<span class="number">3</span> * time.Second)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// worker send request  </span></span><br><span class="line"><span class="comment">// worker send request  </span></span><br><span class="line"><span class="comment">// worker send request  </span></span><br><span class="line"><span class="comment">// stop worker  </span></span><br></pre></td></tr></table></figure><p>更复杂的场景如何做并发控制呢？Go 语言提供了 Context 标准库可以解决这类场景的问题，Context 的作用和它的名字很像，上下文，即子协程的下上文。Context 有两个主要的功能：</p><ul><li>通知子协程退出（正常退出，超时退出等）；</li><li>传递必要的参数。</li></ul><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p><code>context.WithCancel()</code> 创建可取消的 Context 对象，即可以主动通知子协程退出。</p><h3 id="2-1-控制单个协程"><a href="#2-1-控制单个协程" class="headerlink" title="2.1 控制单个协程"></a><a href="https://geektutu.com/post/quick-go-context.html#2-1-%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AA%E5%8D%8F%E7%A8%8B" title="2.1 控制单个协程"></a>2.1 控制单个协程</h3><p>使用 Context 改写上述的例子，效果与 <code>select+chan</code> 相同。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20  </p><p>func reqTask(ctx context.Context, name string) {<br> for {<br> select {<br> case &lt;-ctx.Done():<br> fmt.Println(“stop”, name)<br> return<br> default:<br> fmt.Println(name, “send request”)<br> time.Sleep(1 * time.Second)<br> }<br> }<br>}  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithCancel(context.Background())<br> go reqTask(ctx, “worker1”)<br> time.Sleep(3 * time.Second)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><ul><li><code>context.Backgroud()</code> 创建根 Context，通常在 main 函数、初始化和测试代码中创建，作为顶层 Context。</li><li><code>context.WithCancel(parent)</code> 创建可取消的子 Context，同时返回函数 <code>cancel</code>。</li><li>在子协程中，使用 select 调用 <code>&lt;-ctx.Done()</code> 判断是否需要退出。</li><li>主协程中，调用 <code>cancel()</code> 函数通知子协程退出。</li></ul><h3 id="2-2-控制多个协程"><a href="#2-2-控制多个协程" class="headerlink" title="2.2 控制多个协程"></a><a href="https://geektutu.com/post/quick-go-context.html#2-2-%E6%8E%A7%E5%88%B6%E5%A4%9A%E4%B8%AA%E5%8D%8F%E7%A8%8B" title="2.2 控制多个协程"></a>2.2 控制多个协程</h3><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithCancel(context.Background())  </p><p> go reqTask(ctx, “worker1”)<br> go reqTask(ctx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><p>为每个子协程传递相同的上下文 <code>ctx</code> 即可，调用 <code>cancel()</code> 函数后该 Context 控制的所有子协程都会退出。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8  </p><p>worker1 send request<br>worker2 send request<br>worker1 send request<br>worker2 send request<br>worker1 send request<br>worker2 send request<br>stop worker1<br>stop worker2  </p><h2 id="3-context-WithValue"><a href="#3-context-WithValue" class="headerlink" title="3 context.WithValue"></a><a href="https://geektutu.com/post/quick-go-context.html#3-context-WithValue" title="3 context.WithValue"></a>3 context.WithValue</h2><p>如果需要往子协程中传递参数，可以使用 <code>context.WithValue()</code>。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27  </p><p>type Options struct{ Interval time.Duration }  </p><p>func reqTask(ctx context.Context, name string) {<br> for {<br> select {<br> case &lt;-ctx.Done():<br> fmt.Println(“stop”, name)<br> return<br> default:<br> fmt.Println(name, “send request”)<br> op :&#x3D; ctx.Value(“options”).(*Options)<br> time.Sleep(op.Interval * time.Second)<br> }<br> }<br>}  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithCancel(context.Background())<br> vCtx :&#x3D; context.WithValue(ctx, “options”, &amp;Options{1})  </p><p> go reqTask(vCtx, “worker1”)<br> go reqTask(vCtx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><ul><li><code>context.WithValue()</code> 创建了一个基于 <code>ctx</code> 的子 Context，并携带了值 <code>options</code>。</li><li>在子协程中，使用 <code>ctx.Value(&quot;options&quot;)</code> 获取到传递的值，读取&#x2F;修改该值。</li></ul><h2 id="4-context-WithTimeout"><a href="#4-context-WithTimeout" class="headerlink" title="4 context.WithTimeout"></a><a href="https://geektutu.com/post/quick-go-context.html#4-context-WithTimeout" title="4 context.WithTimeout"></a>4 context.WithTimeout</h2><p>如果需要控制子协程的执行时间，可以使用 <code>context.WithTimeout</code> 创建具有超时通知机制的 Context 对象。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithTimeout(context.Background(), 2*time.Second)<br> go reqTask(ctx, “worker1”)<br> go reqTask(ctx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> fmt.Println(“before cancel”)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><p><code>WithTimeout()</code>的使用与 <code>WithCancel()</code> 类似，多了一个参数，用于设置超时时间。执行结果如下：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7  </p><p>worker2 send request<br>worker1 send request<br>worker1 send request<br>worker2 send request<br>stop worker2<br>stop worker1<br>before cancel  </p><p>因为超时时间设置为 2s，但是 main 函数中，3s 后才会调用 <code>cancel()</code>，因此，在调用 <code>cancel()</code> 函数前，子协程因为超时已经退出了。</p><h2 id="5-context-WithDeadline"><a href="#5-context-WithDeadline" class="headerlink" title="5 context.WithDeadline"></a><a href="https://geektutu.com/post/quick-go-context.html#5-context-WithDeadline" title="5 context.WithDeadline"></a>5 context.WithDeadline</h2><p>超时退出可以控制子协程的最长执行时间，那 <code>context.WithDeadline()</code> 则可以控制子协程的最迟退出时间。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23  </p><p>func reqTask(ctx context.Context, name string) {<br> for {<br> select {<br> case &lt;-ctx.Done():<br> fmt.Println(“stop”, name, ctx.Err())<br> return<br> default:<br> fmt.Println(name, “send request”)<br> time.Sleep(1 * time.Second)<br> }<br> }<br>}  </p><p>func main() {<br> ctx, cancel :&#x3D; context.WithDeadline(context.Background(), time.Now().Add(1*time.Second))<br> go reqTask(ctx, “worker1”)<br> go reqTask(ctx, “worker2”)  </p><p> time.Sleep(3 * time.Second)<br> fmt.Println(“before cancel”)<br> cancel()<br> time.Sleep(3 * time.Second)<br>}  </p><ul><li><code>WithDeadline</code> 用于设置截止时间。在这个例子中，将截止时间设置为1s后，<code>cancel()</code> 函数在 3s 后调用，因此子协程将在调用 <code>cancel()</code> 函数前结束。</li><li>在子协程中，可以通过 <code>ctx.Err()</code> 获取到子协程退出的错误原因。</li></ul><p>运行结果如下：</p><p>1<br>2<br>3<br>4<br>5  </p><p>worker2 send request<br>worker1 send request<br>stop worker2 context deadline exceeded<br>stop worker1 context deadline exceeded<br>before cancel  </p><p>可以看到，子协程 <code>worker1</code> 和 <code>worker2</code> 均是因为截止时间到了而退出。</p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
          <category> Golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看必会 </tag>
            
            <tag> 并发 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang语言面试题 - 基本原理</title>
      <link href="/interview/go/golang101-2/"/>
      <url>/interview/go/golang101-2/</url>
      
        <content type="html"><![CDATA[<h4 id="1-golang-文件初始化的顺序"><a href="#1-golang-文件初始化的顺序" class="headerlink" title="1. golang 文件初始化的顺序"></a>1. golang 文件初始化的顺序</h4><p>init() 函数是 Go 程序初始化的一部分。由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。<br>总结顺序如下：<br><strong>import –&gt; const –&gt; var –&gt; init() &#x2F; init2() –&gt; main()</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  &#123;  </span><br><span class="line"> fmt.Println(<span class="string">&quot;init1:&quot;</span>, a)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  &#123;  </span><br><span class="line"> fmt.Println(<span class="string">&quot;init2:&quot;</span>, a)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>  </span><br><span class="line"><span class="keyword">const</span> b = <span class="number">100</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"> fmt.Println(<span class="string">&quot;main:&quot;</span>, a)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 执行结果  </span></span><br><span class="line"><span class="comment">// init1: 10  </span></span><br><span class="line"><span class="comment">// init2: 10  </span></span><br><span class="line"><span class="comment">// main: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// init2: 10  </span></span><br><span class="line"><span class="comment">// init1: 10  </span></span><br><span class="line"><span class="comment">// main: 10</span></span><br></pre></td></tr></table></figure><h4 id="2-interface-如何比较"><a href="#2-interface-如何比较" class="headerlink" title="2. interface 如何比较"></a>2. interface 如何比较</h4><p>Golang 中， interface 内部包含了两个字段，类型 T 和值 V ，interface 之间可以用 &#x3D;&#x3D; 或 !&#x3D; 进行比较。两个 interface 之间可能包含以下两种情况：</p><ol><li>两个都是 nil （对应的 T 和 V 都为 unset 的状态）</li><li>T 相同，且 V 相同</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;  </span><br><span class="line">  UserName <span class="type">string</span>  <span class="string">`json:user_name`</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> UserFace <span class="keyword">interface</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="comment">// 实际比较的是两个结构体的地址</span></span><br><span class="line">  <span class="keyword">var</span> u1, u2 UserFace = &amp;User&#123;<span class="string">&quot;Tom&quot;</span>&#125;, &amp;User&#123;<span class="string">&quot;Tom&quot;</span>&#125;  </span><br><span class="line">  <span class="comment">// 比较两个结构体</span></span><br><span class="line">  <span class="keyword">var</span> u3, u4 UserFace = User&#123;<span class="string">&quot;Tom&quot;</span>&#125;, User&#123;<span class="string">&quot;Tom&quot;</span>&#125;  </span><br><span class="line">  fmt.Println(u1 == u2) <span class="comment">// false  </span></span><br><span class="line">  fmt.Println(u3 == u4) <span class="comment">// true  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-interface-和-nil"><a href="#3-interface-和-nil" class="headerlink" title="3. interface 和 nil"></a>3. interface 和 nil</h4><p>上边讲了 interface 包含两个字段，那么一个 nil 的空结构体和 nil 是否真的相等呢？可以看下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> p *<span class="type">int</span> = <span class="literal">nil</span>  </span><br><span class="line">  <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = p  </span><br><span class="line">  fmt.Println(i == p) <span class="comment">// true  </span></span><br><span class="line">  fmt.Println(p == <span class="literal">nil</span>) <span class="comment">// true  </span></span><br><span class="line">  fmt.Println(i == <span class="literal">nil</span>) <span class="comment">// false  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 nil 非 interface 的值 p 赋给 i 的时候，i 实际上是 (T&#x3D;*int, V&#x3D;nil)。当二者相比较时，Go 会将 p 先转换成 interface 类型的再去比较，此时二者等价。<br>p 与 nil 是直接比较的值，因此二者也等价。<br>i 与 nil  比较时，会将 nil 转换为接口 (T&#x3D;nil, V&#x3D;nil)，与 i (T&#x3D;*int, V&#x3D;nil) 不相等，因此  i !&#x3D; nil</p><h4 id="4-GC-初步理解"><a href="#4-GC-初步理解" class="headerlink" title="4. GC 初步理解"></a>4. GC 初步理解</h4><h4 id="6-Gin-框架简介"><a href="#6-Gin-框架简介" class="headerlink" title="6. Gin 框架简介"></a>6. Gin 框架简介</h4><h4 id="7-反射的原理"><a href="#7-反射的原理" class="headerlink" title="7. 反射的原理"></a>7. 反射的原理</h4><h4 id="10-oom-？"><a href="#10-oom-？" class="headerlink" title="10. oom ？"></a>10. oom ？</h4><h4 id="11-内存管理方式"><a href="#11-内存管理方式" class="headerlink" title="11. 内存管理方式"></a>11. 内存管理方式</h4><h4 id="13-GRPC-以及-protobuf-协议优化"><a href="#13-GRPC-以及-protobuf-协议优化" class="headerlink" title="13. GRPC 以及 protobuf 协议优化"></a>13. GRPC 以及 protobuf 协议优化</h4><p>gRPC的核心概念包括：</p><p>RPC(Remote Procedure Call，远程过程调用)：gRPC提供了一种简单的RPC机制，允许客户端和服务器之间无缝通信。客户端通过调用本地方法，实际上是在远程服务器上执行方法，并将结果返回给客户端。<br>Protocol Buffers：gRPC使用Protocol Buffers作为数据序列化和传输格式。Protocol Buffers是一种轻量级、高效的数据结构序列化库，可以在多种编程语言之间实现无缝通信。<br>HTTP&#x2F;2：gRPC使用HTTP&#x2F;2作为传输协议，利用HTTP&#x2F;2的多路复用、流控制、压缩等特性，实现低延迟、高吞吐量的通信。</p><p>RPC调用：gRPC的RPC调用过程可以分为以下步骤：</p><p>客户端通过Protocol Buffers序列化请求数据，并使用HTTP&#x2F;2发送请求。<br>服务器接收请求，使用Protocol Buffers反序列化请求数据。<br>服务器执行RPC方法，并将结果序列化为Protocol Buffers格式。<br>服务器使用HTTP&#x2F;2发送响应给客户端。<br>客户端使用Protocol Buffers反序列化响应数据，并处理结果。</p><h4 id="14-golang-压测-pprof，火焰图"><a href="#14-golang-压测-pprof，火焰图" class="headerlink" title="14. golang 压测 pprof，火焰图"></a>14. golang 压测 pprof，火焰图</h4>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang语言面试题 - 常见题</title>
      <link href="/interview/go/golang101-3/"/>
      <url>/interview/go/golang101-3/</url>
      
        <content type="html"><![CDATA[<p>下面会给出网上收集的字节系 Golang 语言常见的面试题，按照热度排序哦</p><h4 id="简述-slice-的底层原理，slice-和数组的区别是什么？"><a href="#简述-slice-的底层原理，slice-和数组的区别是什么？" class="headerlink" title="简述 slice 的底层原理，slice 和数组的区别是什么？"></a>简述 slice 的底层原理，slice 和数组的区别是什么？</h4><p>slice 是数组的引用，额外包括两个字段，长度 len 和容量 cap<br>slice支持扩容，本质上是再申请一块内存，将老数据复制过去，更新引用地址</p><h4 id="简单介绍-GMP-模型以及该模型的优点-困难"><a href="#简单介绍-GMP-模型以及该模型的优点-困难" class="headerlink" title="简单介绍 GMP 模型以及该模型的优点  困难"></a>简单介绍 GMP 模型以及该模型的优点  困难</h4><h4 id="简述-Golang-垃圾回收的机制-中等"><a href="#简述-Golang-垃圾回收的机制-中等" class="headerlink" title="简述 Golang 垃圾回收的机制  中等"></a>简述 Golang 垃圾回收的机制  中等</h4><p>Golang 采用的垃圾回收机制是三色标记法，分为白色（未标记）、灰色（标记中）、黑色（已标记）。<br>回收流程为：<br>    1. STW，从根节点出发，将根节点标记为黑色，将能达到的所有节点标记为灰色，然后将所有能达到的子节点加入队列<br>    2. 并发遍历队列中的节点，标记为黑色，且继续寻找其子节点标记为灰色并加入队列<br>    3. 直到队列中所有可达节点均遍历完毕，那么剩下的白色节点就是不可达的节点，可以回收掉<br>在实际使用过程中，如果在标记过程中，节点指针被用户操作改变，可能会标记失败被错误的清除掉，因此 Go 又引入了写屏障</p><p>一次完整的 GC 分为四个阶段：</p><ul><li>标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)，开启辅助 GC （mutator assist），统计 root 对象的任务数量</li><li>使用三色标记法标记（Marking, 并发）</li><li>标记结束(Mark Termination，需 STW)，关闭写屏障。</li><li>清理(Sweeping, 并发)</li></ul><p>GC 调优</p><ol><li>减少使用string类型中的 ‘+’（此种方式每次拼接都会申请一段新的内存空间），推荐使用 strings.Builder （类似切片的扩容机制）</li><li>小对象复用，尽量减少声明局部变量，小对象可以加入结构体来复用，方便 GC 扫描</li></ol><h4 id="协程与进程，线程的区别是什么？协程有什么优势？"><a href="#协程与进程，线程的区别是什么？协程有什么优势？" class="headerlink" title="协程与进程，线程的区别是什么？协程有什么优势？"></a>协程与进程，线程的区别是什么？协程有什么优势？</h4><p>Goroutines是可以同时运行的函数与方法。Goroutines 可以被认为是轻量级的线程。 与线程相比，创建 Goroutine 的开销很小。 Go应用程序同时运行数千个 Goroutine 是非常常见的做法。</p><ul><li>进程: 进程是具有一定独立功能的程序，进程是系统资源分配和调度的最小单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</li><li>线程: 线程是进程的一个实体,线程是内核态,而且是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</li><li>协程: 协程是一种用户态的轻量级线程，协程的调度完全是由用户来控制的。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</li></ul><h4 id="简述-defer-的执行顺序-中等"><a href="#简述-defer-的执行顺序-中等" class="headerlink" title="简述 defer 的执行顺序  中等"></a>简述 defer 的执行顺序  中等</h4><p>1. </p><h4 id="Golang-有哪些优缺点、错误处理有什么优缺点？"><a href="#Golang-有哪些优缺点、错误处理有什么优缺点？" class="headerlink" title="Golang 有哪些优缺点、错误处理有什么优缺点？"></a>Golang 有哪些优缺点、错误处理有什么优缺点？</h4><p>优点：</p><ol><li>简洁、高效、安全</li><li>并发处理能力强</li><li>静态类型和编译型</li><li>丰富的标准库</li><li>跨平台和可移植性</li><li>强大的性能</li><li>垃圾回收机制<br>劣势:</li><li>泛型编程支持不足</li><li>错误处理方式可能不同</li></ol><p>采用错误返回方式，错误是一种内置类型，可以使用 error 类型来定义。而异常（panic）也可以通过 recover() 函数转换为 error来处理。优点是简单直观，一般与主体程序分离。可能的缺点是，需要在调用链中做好收集和处理，如果漏处理可能会有问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">panic</span> := <span class="built_in">recover</span>(); <span class="built_in">panic</span> != <span class="literal">nil</span> &#123;  </span><br><span class="line">      err = DumpStack(<span class="built_in">panic</span>)  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>两次 GC 周期重叠会引发什么问题，GC 触发机制是什么样的？  简单</p><p>Golang 的协程通信方式有哪些？  中等<br>channel 分为有缓冲和无缓冲，有缓冲的满不能存空不能取，都会阻塞；无缓冲的不存就不能取，阻塞<br>sync.waitgroup 控制协程完成时间，多用于等待一批协程完成<br>context 可以传值 context.withvalue；控制多个协程的生命周期，超时控制，取消信号等</p><p>△ 4次</p><p>简述 Golang 的伪抢占式调度  中等</p><p>△ 4次</p><p>什么是 goroutine 泄漏  简单</p><p>△ 4次</p><p>groutinue 什么时候会被挂起？  简单</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang语言面试题 - 基础语法</title>
      <link href="/interview/go/golang101-1/"/>
      <url>/interview/go/golang101-1/</url>
      
        <content type="html"><![CDATA[<h4 id="1-和-的区别？"><a href="#1-和-的区别？" class="headerlink" title="1.  = 和 := 的区别？"></a>1.  <code>=</code> 和 <code>:=</code> 的区别？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo <span class="type">int</span>  </span><br><span class="line">foo = <span class="number">10</span> </span><br><span class="line"><span class="comment">// 等价于  </span></span><br><span class="line">foo := <span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="2-指针的作用"><a href="#2-指针的作用" class="headerlink" title="2. 指针的作用"></a>2. 指针的作用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x =  <span class="number">5</span>  </span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> = &amp;x  </span><br><span class="line">fmt.Printf(<span class="string">&quot;x = %d&quot;</span>,  *p) <span class="comment">// x 可以用 *p 访问</span></span><br><span class="line"><span class="comment">//  `*` 运算符，也称为解引用运算符，用于访问地址中的值。</span></span><br><span class="line"><span class="comment">//  `＆`运算符，也称为地址运算符，用于返回变量的地址。</span></span><br></pre></td></tr></table></figure><h4 id="3-Go-有异常类型么？"><a href="#3-Go-有异常类型么？" class="headerlink" title="3. Go 有异常类型么？"></a>3. Go 有异常类型么？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go 只有错误类型</span></span><br><span class="line">f, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">  log.Fatal(err)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-协程和线程和进程的区别？"><a href="#4-协程和线程和进程的区别？" class="headerlink" title="4. 协程和线程和进程的区别？"></a>4. 协程和线程和进程的区别？</h4><p>Goroutines是可以同时运行的函数与方法。Goroutines 可以被认为是轻量级的线程。 与线程相比，创建 Goroutine 的开销很小。 Go应用程序同时运行数千个 Goroutine 是非常常见的做法。<br>并发掌握，goroutine和channel声明与使用！</p><h4 id="5-拼接字符串"><a href="#5-拼接字符串" class="headerlink" title="5. 拼接字符串"></a>5. 拼接字符串</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串是只读的，也就意味着每次修改操作都会创建一个新的字符串</span></span><br><span class="line">a := <span class="string">&quot;a&quot;</span></span><br><span class="line">b := <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="keyword">var</span> str1 <span class="type">string</span></span><br><span class="line">str1 += a</span><br><span class="line">str1 += b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用 `strings.Builder`，最小化内存拷贝次数。</span></span><br><span class="line"><span class="keyword">var</span> str strings.Builder  </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;  </span><br><span class="line">  str.WriteString(<span class="string">&quot;a&quot;</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">fmt.Println(str.String())</span><br></pre></td></tr></table></figure><h4 id="6-什么是-rune-类型"><a href="#6-什么是-rune-类型" class="headerlink" title="6. 什么是 rune 类型"></a>6. 什么是 rune 类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Go 语言中，字符串的底层表示是 byte (8 bit) 序列，而非 rune (32 bit) 序列。例如下面的例子中 `语` 和 `言` 使用 UTF-8 编码后各占 3 个 byte，因此 `len(&quot;Go语言&quot;)` 等于 8，当然我们也可以将字符串转换为 rune 序列。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(<span class="string">&quot;Go语言&quot;</span>)) <span class="comment">// 8  </span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>([]<span class="type">rune</span>(<span class="string">&quot;Go语言&quot;</span>))) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h4 id="7-判断-map-结构中是否包含某个-key-的方法"><a href="#7-判断-map-结构中是否包含某个-key-的方法" class="headerlink" title="7. 判断 map 结构中是否包含某个 key 的方法"></a>7. 判断 map 结构中是否包含某个 key 的方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok 为 true 代表有这个 key，且 val 是这个 key 的值</span></span><br><span class="line"><span class="keyword">if</span> val, ok := map_[<span class="string">&quot;key&quot;</span>]; ok &#123;  </span><br><span class="line">  <span class="comment">//do something  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-defer-的执行顺序"><a href="#8-defer-的执行顺序" class="headerlink" title="8. defer 的执行顺序"></a>8. defer 的执行顺序</h4><p>多个 defer 语句，遵从后进先出(Last In First Out，LIFO)的原则，最后声明的 defer 语句，最先得到执行。<br>panic 需要等defer 结束后才会向上传递。出现panic恐慌时候，会先按照defer的后入先出的顺序执行，最后才会执行panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">  i := <span class="number">0</span>  </span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;defer1&quot;</span>)  </span><br><span class="line">  &#125;()  </span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    i += <span class="number">1</span>  </span><br><span class="line">    fmt.Println(<span class="string">&quot;defer2&quot;</span>)  </span><br><span class="line">  &#125;()  </span><br><span class="line">  <span class="keyword">return</span> i  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  fmt.Println(<span class="string">&quot;return&quot;</span>, test())  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// defer2  </span></span><br><span class="line"><span class="comment">// defer1  </span></span><br><span class="line"><span class="comment">// return 0</span></span><br></pre></td></tr></table></figure><p>defer 在 return 语句之后执行，但在函数真正退出之前，defer 可以修改返回值。我们可以注意到前一个例子的返回值并没有被修改（注意：只有被预先定义的返回值才能被 defer 语句修改）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> (i <span class="type">int</span>) &#123;  </span><br><span class="line">  i = <span class="number">0</span>  </span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    i += <span class="number">1</span>  </span><br><span class="line">    fmt.Println(<span class="string">&quot;defer2&quot;</span>)  </span><br><span class="line">  &#125;()  </span><br><span class="line">  <span class="keyword">return</span> i  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  fmt.Println(<span class="string">&quot;return&quot;</span>, test())  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// defer2  </span></span><br><span class="line"><span class="comment">// return 1</span></span><br></pre></td></tr></table></figure><h4 id="9-tag的用法？"><a href="#9-tag的用法？" class="headerlink" title="9. tag的用法？"></a>9. tag的用法？</h4><p>tag 是 struct 结构的注解，不同的框架或者工具可以通过反射获取到某个字段的属性，增加语义<br>例如下方例子定义了 struct 结构字段和 json 结构的映射关系</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;encoding/json&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;  </span><br><span class="line">  Name <span class="type">string</span> <span class="string">`json:&quot;user_name&quot;`</span>  </span><br><span class="line">  Id   <span class="type">string</span> <span class="string">`json:&quot;user_id&quot;`</span>  </span><br><span class="line">  Age  <span class="type">int</span>    <span class="string">`json:&quot;-&quot;`</span>  <span class="comment">// json 忽略</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  buf, _ := json.Marshal(Stu&#123;<span class="string">&quot;Bishop&quot;</span>, <span class="string">&quot;1001&quot;</span>, <span class="number">18</span>&#125;)  </span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, buf)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-Golang-如何判断两个列表（slice）结构等价"><a href="#10-Golang-如何判断两个列表（slice）结构等价" class="headerlink" title="10. Golang 如何判断两个列表（slice）结构等价"></a>10. Golang 如何判断两个列表（slice）结构等价</h4><p>可以使用反射 reflect.DeepEqual(a, b) 来判断，但是此种方法比较影响性能，我们这里还是通过基础遍历的方法来完成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceAEqurlSliceB</span><span class="params">(a, b []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">  <span class="comment">// 等长</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b) &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判空</span></span><br><span class="line">  <span class="keyword">if</span> (a == <span class="literal">nil</span>) != (b == <span class="literal">nil</span>) &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  b = b[:<span class="built_in">len</span>(a)]  </span><br><span class="line">  <span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;  </span><br><span class="line"><span class="keyword">if</span> v != b[i] &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-如何标识枚举值（enums）"><a href="#11-如何标识枚举值（enums）" class="headerlink" title="11. 如何标识枚举值（enums）"></a>11. 如何标识枚举值（enums）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Level <span class="type">int32</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> (  </span><br><span class="line">  Level1 Level = <span class="literal">iota</span>  </span><br><span class="line">  Level2  </span><br><span class="line">  Level3 </span><br><span class="line">  Level4 </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  fmt.Println(Level1, Level2, Level3, Level4) <span class="comment">// 0, 1, 2, 3  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-空-struct-结构的一些用法"><a href="#12-空-struct-结构的一些用法" class="headerlink" title="12. 空 struct{} 结构的一些用法"></a>12. 空 struct{} 结构的一些用法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本体是一个空结构体</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(<span class="keyword">struct</span>&#123;&#125;&#123;&#125;)) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用作占位符使用</span></span><br><span class="line"><span class="keyword">type</span> Set <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  set := <span class="built_in">make</span>(Set)  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, item := <span class="keyword">range</span> []<span class="type">string</span>&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125; &#123;  </span><br><span class="line">set[item] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  fmt.Println(<span class="built_in">len</span>(set)) <span class="comment">// 3  </span></span><br><span class="line">  <span class="keyword">if</span> _, ok := set[<span class="string">&quot;A&quot;</span>]; ok &#123;  </span><br><span class="line">fmt.Println(<span class="string">&quot;A exists&quot;</span>) <span class="comment">// A exists  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用作传递信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)  </span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    &lt;-ch  </span><br><span class="line">    <span class="comment">// do something  </span></span><br><span class="line">  &#125;()  </span><br><span class="line">  ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;  </span><br><span class="line">  <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="13-声明结构体方法"><a href="#13-声明结构体方法" class="headerlink" title="13. 声明结构体方法"></a>13. 声明结构体方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Lamp <span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Lamp)</span></span> On() &#123;  </span><br><span class="line"> <span class="built_in">println</span>(<span class="string">&quot;On&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Lamp)</span></span> Off() &#123;  </span><br><span class="line"> <span class="built_in">println</span>(<span class="string">&quot;Off&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-make-和-new"><a href="#14-make-和-new" class="headerlink" title="14. make 和 new"></a>14. make 和 new</h4><ol><li>make 仅用来分配及初始化类型为 slice、map、chan 的数据。new 可分配任意类型的数据.</li><li>new 分配返回的是指针，即类型 *Type。make 返回引用，即 Type.</li><li>new 分配的空间被清零, make 分配空间后，会进行初始化.<br>一个例子<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i *<span class="type">int</span></span><br><span class="line">i = <span class="built_in">new</span>(<span class="type">int</span>) <span class="comment">// 分配内存地址并返回指向改地址的指针，同时置为类型的0值</span></span><br><span class="line">*i = <span class="number">10</span></span><br><span class="line">fmt.Println(*i) <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="15-代码输出啥相关题"><a href="#15-代码输出啥相关题" class="headerlink" title="15. 代码输出啥相关题"></a>15. 代码输出啥相关题</h4><h5 id="1"><a href="#1" class="headerlink" title="(1)"></a>(1)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">uint</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">uint</span> = <span class="number">2</span></span><br><span class="line">    fmt.Println(a-b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2^32-1 or 2^64-1 根据操作系统位数有不同结果</span></span><br></pre></td></tr></table></figure><p>强类型语言，计算结果也是 uint 类型，1-2 可以转换为 0-1 ，计算机中按照 0 + -1 来计算，-1 通常表示为补码，即所有位数都是1的一个数，即当前系统可表示的最大数</p><h5 id="2"><a href="#2" class="headerlink" title="(2)"></a>(2)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;A: &quot;</span>, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;B: &quot;</span>, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考点：<strong>go执行的随机性和闭包</strong><br>解答：谁也不知道执行后打印的顺序是什么样的，所以只能说是随机数字。但是<code>A:</code>均为输出10，<code>B:</code>从0~9输出(顺序不定)。第一个go func中i是外部for的一个变量，地址不变化。遍历完成后，最终i&#x3D;10。故go func执行时，i的值始终是10。<br>第二个go func中i是函数参数，与外部for中的i完全是两个变量。尾部(i)将发生值拷贝，go func内部指向值拷贝地址。</p><h5 id="3"><a href="#3" class="headerlink" title="(3)"></a>(3)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span></span> ShowA() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;showA&quot;</span>)</span><br><span class="line">    p.ShowB()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span></span> ShowB() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;showB&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">    People</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Teacher)</span></span> ShowB() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;teacher showB&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := Teacher&#123;&#125;</span><br><span class="line">    t.ShowA()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shwoA</span></span><br><span class="line"><span class="comment">// showB</span></span><br></pre></td></tr></table></figure><p>考点：<strong>go的组合继承</strong><br>解答：这是Golang的组合模式，可以实现OOP的继承。被组合的类型People所包含的方法虽然升级成了外部类型Teacher这个组合类型的方法（一定要是匿名字段），但它们的方法(ShowA())调用时接受者并没有发生变化。此时People类型并不知道自己会被什么类型组合，当然也就无法调用方法时去使用未知的组合者Teacher类型的功能。</p><h5 id="4"><a href="#4" class="headerlink" title="(4)"></a>(4)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    int_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">    string_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">    int_chan &lt;- <span class="number">1</span></span><br><span class="line">    string_chan &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> value := &lt;-int_chan:</span><br><span class="line">        fmt.Println(value)</span><br><span class="line">    <span class="keyword">case</span> value := &lt;-string_chan:</span><br><span class="line">        <span class="built_in">panic</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考点：<strong>select随机性</strong><br>解答： select会随机选择一个可用通用做收发操作。所以代码是有肯触发异常，也有可能不会。单个chan如果无缓冲时，将会阻塞。但结合 select可以在多个chan间等待执行。有三点原则： </p><ul><li>select 中只要有一个case能return，则立刻执行。 </li><li>当如果同一时间有多个case均能return则伪随机方式抽取任意一个执行。</li><li>如果没有一个case能return则可以执行”default”块。<h5 id="5"><a href="#5" class="headerlink" title="(5)"></a>(5)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)  </span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  </span><br><span class="line">    fmt.Println(s) <span class="comment">// [0,0,0,0,0,1,2,3] </span></span><br><span class="line">  </span><br><span class="line">    s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)  </span><br><span class="line">    s2 = <span class="built_in">append</span>(s2, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  </span><br><span class="line">    fmt.Println(s2)  <span class="comment">// [1,2,3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意 make 会给定义的长度分配初值<h5 id="6"><a href="#6" class="headerlink" title="(6)"></a>(6)</h5>map线程安全</li></ul><h4 id="16-如何理解go语言中的interface"><a href="#16-如何理解go语言中的interface" class="headerlink" title="16. 如何理解go语言中的interface?"></a>16. 如何理解go语言中的interface?</h4><ol><li>interface是方法申明的集合</li><li>任何类型的对象实现了在interface接口中声明的全部方法，则表明该类型实现了该接口</li><li>interface可以作为一种数据类型，实现了该接口的任何对象都可以给对应的接口类型变量赋值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义一个数据写入器</span></span><br><span class="line"><span class="keyword">type</span> DataWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">WriteData(data <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义文件结构，用于实现DataWriter</span></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现DataWriter接口的WriteData方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *file)</span></span> WriteData(data <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// 模拟写入数据</span></span><br><span class="line">fmt.Println(<span class="string">&quot;WriteData:&quot;</span>, data)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口可以作为数据类型传递，体现2，3</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cprint</span><span class="params">(writer DataWriter)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Cprint&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 实例化file</span></span><br><span class="line">f := <span class="built_in">new</span>(file)</span><br><span class="line"><span class="comment">// 声明一个DataWriter的接口</span></span><br><span class="line"><span class="keyword">var</span> writer DataWriter</span><br><span class="line"><span class="comment">// 将接口赋值f，也就是*file类型</span></span><br><span class="line">writer = f</span><br><span class="line"><span class="comment">// 使用DataWriter接口进行数据写入</span></span><br><span class="line">err := writer.WriteData(<span class="string">&quot;data&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;writeData err!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">Cprint(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="17-Go-语言是如何实现切片扩容的？"><a href="#17-Go-语言是如何实现切片扩容的？" class="headerlink" title="17. Go 语言是如何实现切片扩容的？"></a>17. Go 语言是如何实现切片扩容的？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  arr := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>) </span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++ &#123; </span><br><span class="line">    fmt.Println(<span class="string">&quot;len为&quot;</span>, <span class="built_in">len</span>(arr), <span class="string">&quot;cap为&quot;</span>, <span class="built_in">cap</span>(arr)) </span><br><span class="line">    arr = <span class="built_in">append</span>(arr, i) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看下结果<br>依次是 0,1,2,4,8,16,32,64,128,256,512,1024<br>但到了1024之后,就变成了 1024,1280,1696,2304<br>每次都是扩容了四分之一左右</p><h4 id="18-数组和切片"><a href="#18-数组和切片" class="headerlink" title="18. 数组和切片"></a>18. 数组和切片</h4><p>golang 中存在两种函数传入方式：值类型和引用类型<br>值类型只改变当前作用域的值，在该作用域外部不会生效；引用类型改变当前地址对应的值，在作用域外部生效。可以参考下边的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组 值类型</span></span><br><span class="line"><span class="comment">// 切片 引用类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeArray</span><span class="params">(x [3]<span class="type">int</span>)</span></span> &#123;x[<span class="number">0</span>] = <span class="number">123</span>&#125; <span class="comment">// 定义为数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(x []<span class="type">int</span>)</span></span> &#123;x[<span class="number">0</span>] = <span class="number">123</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  x1 := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;x1 original-&gt;&quot;</span>, x1)</span><br><span class="line">  changeArray(x)</span><br><span class="line">  fmt.Println(<span class="string">&quot;x1 current-&gt;&quot;</span>. x1)</span><br><span class="line"></span><br><span class="line">  x := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;x2 -&gt;&quot;</span>, x)</span><br><span class="line">  changeSlice(x)</span><br><span class="line">  fmt.Println(<span class="string">&quot;x2 -&gt;&quot;</span>. x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x1 -&gt; [1,2,3]</span></span><br><span class="line"><span class="comment">// x2 -&gt; [1,2,3]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="19-go-通过切片模拟栈和队列"><a href="#19-go-通过切片模拟栈和队列" class="headerlink" title="19. go 通过切片模拟栈和队列"></a>19. go 通过切片模拟栈和队列</h4><p>栈</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建栈</span></span><br><span class="line">stack:=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">// push压入</span></span><br><span class="line">stack=<span class="built_in">append</span>(stack,<span class="number">10</span>)</span><br><span class="line"><span class="comment">// pop弹出</span></span><br><span class="line">v:=stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">stack=stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"><span class="comment">// 检查栈空</span></span><br><span class="line"><span class="built_in">len</span>(stack)==<span class="number">0</span></span><br></pre></td></tr></table></figure><p>队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建队列</span></span><br><span class="line">queue:=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">// enqueue入队</span></span><br><span class="line">queue=<span class="built_in">append</span>(queue,<span class="number">10</span>)</span><br><span class="line"><span class="comment">// dequeue出队</span></span><br><span class="line">v:=queue[<span class="number">0</span>]</span><br><span class="line">queue=queue[<span class="number">1</span>:]</span><br><span class="line"><span class="comment">// 长度0为空</span></span><br><span class="line"><span class="built_in">len</span>(queue)==<span class="number">0</span></span><br></pre></td></tr></table></figure><p>注意点</p><ul><li>参数传递，只能修改，不能新增或者删除原始数据</li><li>默认 s&#x3D;s[0:len(s)]，取下限不取上限，数学表示为：[</li></ul><h4 id="20-字典"><a href="#20-字典" class="headerlink" title="20.字典"></a>20.字典</h4><p>基本用法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line">m:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">// 设置kv</span></span><br><span class="line">m[<span class="string">&quot;hello&quot;</span>]=<span class="number">1</span></span><br><span class="line"><span class="comment">// 删除k</span></span><br><span class="line"><span class="built_in">delete</span>(m,<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> k,v:=<span class="keyword">range</span> m&#123;</span><br><span class="line">    <span class="built_in">println</span>(k,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点</p><ul><li>map 键需要可比较，不能为 slice、map、function</li><li>map 值都有默认值，可以直接操作默认值，如：m[age]++ 值由 0 变为 1</li><li>比较两个 map 需要遍历，其中的 kv 是否相同，因为有默认值关系，所以需要检查 val 和 ok 两个值</li></ul><h4 id="21-标准库"><a href="#21-标准库" class="headerlink" title="21.标准库"></a>21.标准库</h4><p>sort</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int排序</span></span><br><span class="line">sort.Ints([]<span class="type">int</span>&#123;&#125;)</span><br><span class="line"><span class="comment">// 字符串排序</span></span><br><span class="line">sort.Strings([]<span class="type">string</span>&#123;&#125;)</span><br><span class="line"><span class="comment">// 自定义排序</span></span><br><span class="line">sort.Slice(s,<span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="type">int</span>)</span></span><span class="type">bool</span>&#123;<span class="keyword">return</span> s[i]&lt;s[j]&#125;)</span><br></pre></td></tr></table></figure><p>math</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int32 最大最小值</span></span><br><span class="line">math.MaxInt32 <span class="comment">// 实际值：1&lt;&lt;31-1</span></span><br><span class="line">math.MinInt32 <span class="comment">// 实际值：-1&lt;&lt;31</span></span><br><span class="line"><span class="comment">// int64 最大最小值（int默认是int64）</span></span><br><span class="line">math.MaxInt64</span><br><span class="line">math.MinInt64</span><br></pre></td></tr></table></figure><p>copy</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除a[i]，可以用 copy 将i+1到末尾的值覆盖到i,然后末尾-1</span></span><br><span class="line"><span class="built_in">copy</span>(a[i:],a[i+<span class="number">1</span>:])</span><br><span class="line">a=a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// make创建长度，则通过索引赋值</span></span><br><span class="line">a:=<span class="built_in">make</span>([]<span class="type">int</span>,n)</span><br><span class="line">a[n]=x</span><br><span class="line"><span class="comment">// make长度为0，则通过append()赋值</span></span><br><span class="line">a:=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">a=<span class="built_in">append</span>(a,x)</span><br></pre></td></tr></table></figure><h4 id="22-常用技巧"><a href="#22-常用技巧" class="headerlink" title="22.常用技巧"></a>22.常用技巧</h4><p>类型转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// byte转数字</span></span><br><span class="line">s=<span class="string">&quot;12345&quot;</span>  <span class="comment">// s[0] 类型是byte</span></span><br><span class="line">num:=<span class="type">int</span>(s[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line">str:=<span class="type">string</span>(s[<span class="number">0</span>]) <span class="comment">// &quot;1&quot;</span></span><br><span class="line">b:=<span class="type">byte</span>(num+<span class="string">&#x27;0&#x27;</span>) <span class="comment">// &#x27;1&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d%s%c\n&quot;</span>, num, str, b) <span class="comment">// 111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转数字</span></span><br><span class="line">num,_:=strconv.Atoi()</span><br><span class="line">str:=strconv.Itoa()</span><br></pre></td></tr></table></figure><p>读取标准输入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>断言</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> f, ok := w.(*os.File); ok &#123;</span><br><span class="line">    <span class="comment">// ...use f...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥锁常用语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mu      sync.Mutex <span class="comment">// guards balance</span></span><br><span class="line">    balance <span class="type">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    balance = balance + amount</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    b := balance</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读写锁 “多读单写”锁（multiple readers, single writer lock）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line"><span class="keyword">var</span> balance <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mu.RLock() <span class="comment">// readers lock</span></span><br><span class="line">    <span class="keyword">defer</span> mu.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync.Once 惰性初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br><span class="line"><span class="comment">// Concurrency-safe.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line">    loadIconsOnce.Do(loadIcons)</span><br><span class="line">    <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo建站（三）GitHub</title>
      <link href="/blog/build-blog/hexo101-3/"/>
      <url>/blog/build-blog/hexo101-3/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到建站记录的第二部分：部署到 github page</p><h2 id="GitHub页面"><a href="#GitHub页面" class="headerlink" title="GitHub页面"></a>GitHub页面</h2><p>这里假设已经注册过了Github帐户，如果没有，可以去<a href="https://github.com/">Github</a>注册。</p><p>注册好了后，登录Github,创建仓库：点击右上角的+号，选择new repository:<br><img src="https://t2.picb.cc/2022/02/21/fpUdSF.jpg" alt="git"></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo建站（二）butterfly</title>
      <link href="/blog/build-blog/hexo101-2/"/>
      <url>/blog/build-blog/hexo101-2/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到建站记录的第二部分：butterfly 主题的安装与初始化</p><h2 id="主题安装与使用"><a href="#主题安装与使用" class="headerlink" title="主题安装与使用"></a>主题安装与使用</h2><p>下载主题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">git <span class="built_in">clone</span> -b master https://gitee.com/immyw/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>修改站点配置文件 _config.yml ,把主题修改为 Butterfly</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">Butterfly</span></span><br></pre></td></tr></table></figure><p>为了后续方便配置，需要在当前目录 blog&#x2F; 创建 _config.butterfly.yml 文件，并将根目录下的 _config.yml 文件内容复制进去。更多的主题配置信息可以等待之后的文章~</p><p>尝试执行以下指令,以查看应用主题后的效果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">#清除旧的内容</span></span><br><span class="line">hexo g <span class="comment">#生成发布用的静态页面</span></span><br></pre></td></tr></table></figure><p>本地查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s <span class="comment"># hexo server</span></span><br></pre></td></tr></table></figure><p>执行完该命令可以去 <a href="localhost:4000">localhost:4000</a> 查看效果</p><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><h4 id="case1-："><a href="#case1-：" class="headerlink" title="case1 ："></a>case1 ：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ERROR TypeError: /data/blog/themes/butterfly/layout/includes/head.pug:40  </span><br><span class="line">38|  </span><br><span class="line">39| !=favicon_tag(theme.favicon || config.favicon)</span><br><span class="line"></span><br><span class="line">&gt; 40| <span class="built_in">link</span>(rel=<span class="string">&quot;canonical&quot;</span> href=urlNoIndex())  </span><br><span class="line">&gt; 41|  </span><br><span class="line">&gt; 42| //- 預解析  </span><br><span class="line">&gt; 43| !=partial(<span class="string">&#x27;includes/head/preconnect&#x27;</span>, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span><br><span class="line"></span><br><span class="line">prettyUrls is not a <span class="keyword">function</span>  </span><br><span class="line">at Object. (/data/blog/themes/butterfly/scripts/helpers/page.js:58:10)  </span><br><span class="line">at <span class="built_in">eval</span> (<span class="built_in">eval</span> at wrap (/data/blog/node_modules/pug-runtime/wrap.js:6:10), :89:77)  </span><br><span class="line">at template (<span class="built_in">eval</span> at wrap (/data/blog/node_modules/pug-runtime/wrap.js:6:10), :4603:215)  </span><br><span class="line">at _View._compiled (/data/blog/node_modules/hexo/lib/theme/view.js:136:50)  </span><br><span class="line">at _View.render (/data/blog/node_modules/hexo/lib/theme/view.js:39:17)  </span><br><span class="line">at /data/blog/node_modules/hexo/lib/hexo/index.js:64:21  </span><br><span class="line">at tryCatcher (/data/blog/node_modules/bluebird/js/release/util.js:16:23)  </span><br><span class="line">at /data/blog/node_modules/bluebird/js/release/method.js:15:34  </span><br><span class="line">at RouteStream._read (/data/blog/node_modules/hexo/lib/hexo/router.js:47:5)  </span><br><span class="line">at RouteStream.Readable.<span class="built_in">read</span> (_stream_readable.js:479:10)  </span><br><span class="line">at resume_ (_stream_readable.js:966:12)  </span><br><span class="line">at processTicksAndRejections (internal/process/task_queues.js:80:21) &#123;  </span><br><span class="line">path: <span class="string">&#x27;/data/blog/themes/butterfly/layout/includes/head.pug&#x27;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>解决方案</p><ol><li>优先确认 themes&#x2F;butterfly 中有相关的文件内容</li><li>尝试执行如下命令： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br><span class="line"><span class="built_in">rm</span> -rf node_modules</span><br><span class="line"><span class="built_in">rm</span> -rf package-lock.json</span><br><span class="line">npm install</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure></li></ol><h4 id="case2："><a href="#case2：" class="headerlink" title="case2："></a>case2：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TypeError: /Users/blog/themes/butterfly/layout/includes/widget/index.pug:33</span><br><span class="line">    31|       !=partial(<span class="string">&#x27;includes/widget/card_tags&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line">    32|       !=partial(<span class="string">&#x27;includes/widget/card_archives&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line">  &gt; 33|       !=partial(<span class="string">&#x27;includes/widget/card_webinfo&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line">    34|       !=partial(<span class="string">&#x27;includes/widget/card_bottom_self&#x27;</span>, &#123;&#125;, &#123;cache: <span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line">/Users/blog/themes/butterfly/layout/includes/widget/card_webinfo.pug:18</span><br><span class="line">    16|         .webinfo-item</span><br><span class="line">    17|           .item-name=_p(<span class="string">&#x27;aside.card_webinfo.site_wordcount&#x27;</span>) + <span class="string">&quot; :&quot;</span></span><br><span class="line">  &gt; 18|           .item-count=totalcount(site)</span><br><span class="line">    19|       <span class="keyword">if</span> theme.busuanzi.site_uv</span><br><span class="line">    20|         .webinfo-item</span><br><span class="line">    21|           .item-name= _p(<span class="string">&#x27;aside.card_webinfo.site_uv_name&#x27;</span>) + <span class="string">&quot; :&quot;</span></span><br><span class="line"></span><br><span class="line">totalcount is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p>请检查是否安裝了wordcount插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><h4 id="case3："><a href="#case3：" class="headerlink" title="case3："></a>case3：</h4><p>如果你沒有 pug 以及 stylus 的渲染器会报错</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extends includes/layout.pug block content include ./includes/mixins/post-ui</span><br><span class="line">.pug <span class="comment">#recent-posts.recent-posts +postUI include includes/pagination.pug</span></span><br></pre></td></tr></table></figure><p>解决方案</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h4 id="case4："><a href="#case4：" class="headerlink" title="case4："></a>case4：</h4><p>hexo本地测试运行重启后页面空白，且提示 : </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN No layout: index.html</span><br></pre></td></tr></table></figure><p>可以参考 case1 &amp; case2 ，即 hexo generate 没有成功</p><h4 id="case5："><a href="#case5：" class="headerlink" title="case5："></a>case5：</h4><p>尝试 hexo deploy 发布的时候失败，显示如下，没有反应</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INFO  Validating config</span><br><span class="line">INFO</span><br><span class="line">  ===================================================================</span><br><span class="line"></span><br><span class="line">      <span class="comment">#####  #    # ##### ##### ###### #####  ###### #      #   #</span></span><br><span class="line">      <span class="comment">#    # #    #   #     #   #      #    # #      #       # #</span></span><br><span class="line">      <span class="comment">#####  #    #   #     #   #####  #    # #####  #        #</span></span><br><span class="line">      <span class="comment">#    # #    #   #     #   #      #####  #      #        #</span></span><br><span class="line">      <span class="comment">#    # #    #   #     #   #      #   #  #      #        #</span></span><br><span class="line">      <span class="comment">#####   ####    #     #   ###### #    # #      ######   #</span></span><br><span class="line"></span><br><span class="line">                            4.1.0</span><br><span class="line">  ===================================================================</span><br></pre></td></tr></table></figure><p>解决方案：deploy 参数需要配置到 _config.yml 文件中。<br><strong>注意：冒号后面需要一个空格</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repo:</span> <span class="string">git@github.com:yourname/yourname.github.io.git</span></span><br><span class="line"><span class="comment"># 推荐使用Git链接，使用http模式还会存在需要填写 用户名和邮箱的情况</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>更多问题请参考 <a href="https://butterfly.js.org/posts/98d20436/">butterfly</a> 官方文档中的解答</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo建站（一）hexo</title>
      <link href="/blog/build-blog/hexo101-1/"/>
      <url>/blog/build-blog/hexo101-1/</url>
      
        <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>终于俺也有自己的 blog 了，下面就整个 hexo 建站和主题 butterfly 的配置分几个部分给大家做个小小的总结</p><p>欢迎来到建站记录的第一部分：hexo 的安装</p><h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><p>官网地址：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p><h4 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h4><p>1.node<br>    首先去 <a href="http://nodejs.cn/download/">node.js</a> 的官网下载最新的稳定版本，我这里选择的是 mac 版本的<br>2.npm<br>    包管理工具</p><h4 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> npm install hexo</span><br></pre></td></tr></table></figure><p>记得这里需要使用管理员权限安装</p><p>初始化 hexo 至某个文件夹</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>这个文件夹就是自己将来管理文章的地方</p><p>工程配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>进入刚才初始化的 blog 文件夹</p><p>浏览器调试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generage</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>也可以如下简写</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>必备插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save <span class="comment"># hexo 渲染必备</span></span><br><span class="line">npm install hexo-server --save <span class="comment"># hexo 本地启动</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install --save hexo-wordcount <span class="comment"># wordcount 插件</span></span><br><span class="line">npm install hexo-butterfly-artitalk --save <span class="comment"># artitalk 插件</span></span><br><span class="line">npm install hexo-generator-feed --save <span class="comment"># RSS 插件</span></span><br><span class="line">npm install hexo-auto-category --save <span class="comment"># 自动根据目录生成categories</span></span><br></pre></td></tr></table></figure><p>自动生成 categories 详情和配置方法具体可以参考 <a href="https://github.com/xu-song/hexo-auto-category">auto-category</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/uncategorized/hello-world/"/>
      <url>/uncategorized/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
